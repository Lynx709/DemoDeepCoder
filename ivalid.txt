#include<bits/stdc++.h>
using namespace std;

int T,ans;
bool k[10][6],jw[10][6];
long long n,a[20],len;

long long read(){
long long a=0,x=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')x=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){a=(a<<1)+(a<<3)+(ch^48);ch=getchar();}
return a*x;
}

void pre(){
k[0][4]=k[0][5]=k[0][0]=1;
k[1][1]=k[1][4]=k[1][5]=1;
k[2][1]=k[2][2]=k[2][4]=k[2][5]=1;
k[3][1]=k[3][2]=k[3][5]=k[3][3]=1;
k[4][2]=k[4][4]=k[4][3]=k[4][5]=1;
k[5][2]=k[5][4]=k[5][3]=k[5][5]=1;
k[6][2]=k[6][3]=k[6][4]=k[6][5]=1;
k[7][3]=k[7][4]=k[7][5]=1;
k[8][3]=k[8][4]=k[8][5]=1;
k[9][3]=k[9][4]=k[9][5]=1;
jw[1][4]=jw[1][5]=jw[2][4]=jw[2][5]=jw[3][5]=jw[4][5]=jw[0][4]=jw[0][5]=1;
jw[5][5]=2;
}

void work(long long x){
len=0;
while(x){
a[++len]=x%10;
x=x/10;
}
}

void dfs(int x,int sum,int b,int sum_now){
int flag=0;
int now=a[x]-b;
if(x==len){
if(now<0)return;
flag=0;
for(int i=0;i<=sum;i++){
if(k[now][i])ans=sum_now;
}
return;
}
if(now<0)now+=10,flag=1;
for(int i=sum;i>=1;i--){
if(k[now][i]){
if(now==5&&sum==5){
dfs(x+1,i,1+flag,sum_now);
dfs(x+1,i,0+flag,sum_now);
}
else{
dfs(x+1,i,jw[now][i]+flag,sum_now);
}
}
}	
}

int main(){
pre();
T=read();
while(T--){
n=read();
work(n);
if(len==1){
for(int i=1;i<=5;i++){
if(k[a[1]][i]){
printf("%d\n",i);
break;
}
}
continue;
}
int flag=1;
for(int i=1;i<=len;i++)if(a[i]<1||a[i]>3)flag=0;
if(flag){
puts("1");
continue;
}
ans=100;
for(int i=1;i<=5;i++){
if(k[a[1]][i]){
if(a[1]==5&&i==5){
dfs(2,i,0,i);
dfs(2,i,1,i);
}
else{
dfs(2,i,jw[a[1]][i],i);
}
if(ans==i)break;
}
}
printf("%d\n",ans);
}
return 0;
}
/*#pragma GCC optimize("Ofast")
#pragma GCC optimization("unroll-loops, no-stack-protector")
#pragma GCC target("avx,avx2,fma")*/

#include <bits/stdc++.h>
using namespace std;

#define ll  long long
#define pll pair<ll,ll>
#define ff first
#define ss second
#define pb push_back
#define endl "\n"
#define F(i,a,b) for (ll i=a;i<=b;i++)

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

const ll maxn=2e5+5e4+100;
const ll mod=1000003 ;
const ll base=3e18;

/// you will be the best but now you just are trash
/// goal 2/7

ll cnt[(1ll<<20)][18][2];
ll cnt1[(1ll<<20)][18][2];
ll nxt[(1ll<<20)][2];
ll sl[(1ll<<20)][2];
ll sl1[(1ll<<20)][2];
ll ans=0;
ll cntnw=0;
void add(ll x,ll y)
{
ll nw=0;
for (int i=17; i>=0; i--)
{
ll p=((x>>i)&1);
ll p1=((y>>i)&1);
ll h=(p^p1);
if(!nxt[nw][h])
{
cntnw++;
nxt[nw][h]=cntnw;
}
if (nxt[nw][1-h])
{
// cout <<i<<" "<<x<<" "<<y<<" chk"<<endl;
ll pt=nxt[nw][1-h];
//  cout <<ans<<endl;
for (int t=0; t<=17; t++)
{
/*  if (x==3&&y==6)
{
cout <<ans<<" "<<t<<" "<<i<<" chk1"<<endl;
}*/
if ((x&(1ll<<t))==0)
{
ans=(ans+cnt[pt][t][p]*(1ll<<t));
}
else
{
ans=(ans+(sl[pt][p]-cnt[pt][t][p])*(1ll<<t));
}
if ((y&(1ll<<t))==0)
{
ans=(ans+cnt1[pt][t][p1]*(1ll<<t));
}
else
{
ans=(ans+(sl1[pt][p1]-cnt1[pt][t][p1])*(1ll<<t));
}
}
//  cout <<ans<<" chk1"<<endl;
}
nw=nxt[nw][h];
if (i==0)
{
for (int t=0; t<=17; t++)
{
for (int p=0; p<=1; p++)
{
if ((x&(1ll<<t))==0)
{
ans=(ans+cnt[nw][t][p]*(1ll<<t));
}
else
{
ans=(ans+(sl[nw][p]-cnt[nw][t][p])*(1ll<<t));
}
}
}
}
sl[nw][p]++;
sl1[nw][p1]++;
for (int t=0; t<=17; t++)
{
ll h=((x>>t)&1);
cnt[nw][t][p]+=h;
h=((y>>t)&1);
cnt1[nw][t][p1]+=h;
}
}
}
ll a[maxn];
ll b[maxn];

int main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
if (fopen("t.inp", "r"))
{
freopen("test.inp", "r", stdin);
freopen("test.out", "w", stdout);
}
ll n;
cin>> n;
for (int i=1;i<=n;i++)
{
cin>> a[i];
}
for (int i=1;i<=n;i++)
{
cin>> b[i];
}
for (int i=1;i<=n;i++)
{
add(a[i],b[i]);
// cout <<ans<<endl;
}
cout <<ans<<endl;
}

#include<bits/stdc++.h>
using namespace std;
#define f(i,a,b) for(int i=a; i<b; i++)
#define fr(i,a,b) for(int i=a; i>=b; i--)

#define fll(i,a,b) for(ll i=a; i<b; i++)
#define frll(i,a,b) for(ll i=a; i>=b; i--)
typedef vector<int> vi;
typedef long long int ll;
typedef vector<ll> vll;
#define fastio std::ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define PI 3.1415926535
// int Mod = 1e9+7;

ll Mod = 998244353;
// vector<bool> status(1e6+1,1);
// vll primes;

ll mult(ll a, ll b) {
ll ret = 1;
ret = ((a%Mod) * (b%Mod))%Mod;
return ret;
}

// ll power(ll a, ll b = Mod-2) {
//     if(b == 0) return 1;
//     ll ret = 1;
//     while(b) {
//         if(b&1) {
//             ret = mult(ret,a);
//         }
//         a = mult(a,a);
//         b>>=1;
//     }
//     return ret;
// }

// ll sub(ll a, ll b) {
//     ll ret = (a%Mod - b%Mod + Mod)%Mod;
//     return ret;
// }

// void seive() {
//      for(ll i = 2; i*i <= 4e4; i++) {
//          if(status[i]) {
//             for(ll j = i*i; j<=4e4; j+=i) status[j] = 0;
//          }
//      }
//  }

// int getmex(vi& occr, int n, int mex) {
//     for(int i = mex; i<n; i++) {
//         if(occr[i] == 0) return i;
//     }
//     return n;
// }

// void swap(int &a, int &b) {
//     a = a + b;
//     b = a - b;
//     a = a - b;
// }

// void build_primes() {
//     seive();
//     f(i,2, 4e4+1) {
//         if(status[i]) primes.push_back(i);
//     }
// }

// int gcd(int a, int b) {
//     if(b == 0) return a;
//     return gcd(b,a%b);
// }
map<int,int> mp;
int ans = 0;
pair<int,int> make(int e) {
auto it = mp.lower_bound(e);
if(mp.size() == 0 || it == mp.begin()) {
return {1,e};
} else {
it--;
return {it->second+1,e}; 
}
} 

void insert(pair<int,int> b) {
int e = b.second, v = b.first; 
auto it = mp.lower_bound(e);
if(mp.size() == 0) {
mp[e] = 1;
return;
} else if(it == mp.begin()) {
mp[e] = 1;
if(it->first == e) 
return;
} else {
it--;
mp[e] = max(mp[e],v); 
}
it = mp.upper_bound(e);
while(it != mp.end() && it->second <= mp[e]) {
auto tmp = it;
it++;
mp.erase(tmp);
}
} 

void test_case() {
int n;
cin>>n;
int p[n], q[n], pos[n+1];
f(i,0,n) {
cin>>p[i];
}
f(i,0,n) {
cin>>q[i];
pos[q[i]] = i;
}
f(i,0,n) {
vector<pair<int,int>> v;
for(int j = p[i]; j <= n; j+=p[i]) {
pair<int,int> pp = make(pos[j]);
v.push_back(pp);
}
for(pair<int,int> b: v)   
insert(b);
}

for(auto it = mp.begin(); it!=mp.end(); ++it) {
ans = max(ans,it->second);   
}
cout<<ans;
}  


int main() {
#ifndef ONLINE_JUDGE
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
#endif

fastio;

// build_primes();    

int t = 1;

// cin>>t;
while(t--) {
test_case();
}
}

#include <bits/stdc++.h>

using i64 = long long;

int main() {
std::ios::sync_with_stdio(false);
std::cin.tie();

int n, k;
std::cin >> n >> k;

std::vector<int> a(k);
for (int i = 0; i < k; i++) {
std::cin >> a[i];
}

std::vector<std::vector<int>> v(k + 1);

std::deque<int> q;
for (int i = 1; i <= n; i++) {
if (!std::binary_search(a.begin(), a.end(), i)) {
q.push_back(i);
}
}

for (int i = 0; i <= k; i++) {
if (i > 0 && i < k) {
if (!q.empty() && q.front() < a[i - 1]) {
v[i].push_back(q.front());
q.pop_front();
}
}
if (i == k - 1) {
while (!q.empty() && q.back() > a[i]) {
v[i].push_back(q.back());
q.pop_back();
}
} else if (i == k) {
while (!q.empty()) {
v[i].push_back(q.back());
q.pop_back();
}
}
}

std::vector<int> ans;
for (int i = 0; i <= k; i++) {
for (int x : v[i]) {
ans.push_back(x);
}
if (i < k) {
ans.push_back(a[i]);
}
}

for (int i = 0; i < n; i++) {
std::cout << ans[i] << " \n"[i == n - 1];
}

return 0;
}

#include<bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp> 
// #include <ext/pb_ds/detail/standard_policies.hpp>
// using namespace __gnu_pbds;

#pragma GCC optimize("O3")
#ifdef LOCAL
#include "/Users/lbjlc/Desktop/coding/debug_utils.h"
#else
#define print(...) ;
#define printn(...) ;
#define printg(...) ;
#define fprint(...) ;
#define fprintn(...) ;
#endif

#define rep(i, a, b) for(auto i = (a); i < (b); i++)
#define rrep(i, a, b) for(auto i = (a); i > (b); i--)
#define all(v) (v).begin(), (v).end()
#define pb push_back
// #define mp make_pair
#define fi first
#define se second
#define maxi(x, y) x = max(x, y)
#define mini(x, y) x = min(x, y)
// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }
// #define endl '\n'
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int get_random() {
static uniform_int_distribution<int> dist(0, 1e9 + 6);
return dist(rng);
}
const vector<pair<int,int>> eight_directions = {{1,1},{1,0},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};
const vector<pair<int,int>> four_directions = {{1,0},{0,1},{0,-1},{-1,0}};
#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}


typedef unsigned long long ull;
typedef long long ll;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef vector<long long> vll;
#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)

template<class T>
void make_unique(T & v) {
sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());
}
int geti() { int x; cin >> x; return x; }
long long getll() { long long x; cin >> x; return x; }
double getd() { double x; cin >> x; return x; }
// pair<int, int> a(geti(), geti()) does not work
// pair<int, int> a({geti(), geti()}) works, since it uses initializer.

const int MAXN = 3e5 + 100;

void solve(int tt) {
// cout<<"Case #"<<tt<<": ";
}

int main(int argc, char * argv[]) {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
// solve_testcase;

int n;
cin>>n;
vvi c(n, vi(n));
rep(i,0,n) rep(j,0,n) cin>>c[i][j];

int ok = 1;
for(int i = 1; i < n; i++) {
int d = c[i][0] - c[0][0];
for(int j = 1; j < n; j++) {
if(d != c[i][j] - c[0][j]) {
ok = 0;
}
}
}
if(!ok) {
cout<<"No"<<endl;
return 0;
}
cout<<"Yes"<<endl;

int idx = 0;
for(int i = 1; i < n; i++) {
if(c[i][0] < c[idx][0]) {
idx = i;
}
}

vi a = c[idx], b(n);
for(int i = 0; i < n; i++) {
b[i] = c[i][0] - c[idx][0];
}

rep(i,0,n) cout<<b[i]<<' ';
cout<<endl;
rep(i,0,n) cout<<a[i]<<' ';
cout<<endl;

return 0;
}












#include <bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
int rd() {
int f=1,sum=0; char ch=getchar();
while(!isdigit(ch)) {if(ch=='-') f=-1; ch=getchar();}
while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
return sum*f;
}
#define N 705
bool vis[N][N];
int a[N][N],d0[4]={1,-1,0,0},d1[4]={0,0,1,-1},n,m;

void dfs(int x,int y) {
if(vis[x][y]) return ;
vis[x][y]=1;
if(a[x][y]=='.') {
bool qwq[5]; memset(qwq,0,sizeof(qwq));
//cout<<":xgf"<<endl; 
for(int i=0;i<4;i++) {
int dx=x+d0[i],dy=y+d1[i];
if(dx<1||dy<1||dx>n||dy>m) continue;
if(a[dx][dy]!='.') qwq[a[dx][dy]-'1']=1;
}
for(int i=0;i<5;i++) {
//	cout<<qwq[i]<<endl;
if(!qwq[i]) {
a[x][y]=i+'1';
break;
}
}
for(int i=0;i<4;i++) {
int dx=x+d0[i],dy=y+d1[i];
if(dx<1||dy<1||dx>n||dy>m) continue;
dfs(dx,dy);
}
} else {
for(int i=0;i<4;i++) {
int dx=x+d0[i],dy=y+d1[i];
if(dx<1||dy<1||dx>n||dy>m) continue;
dfs(dx,dy);
}
}
}

signed main() {
cin.tie(0);
std::ios::sync_with_stdio(false);
cin>>n>>m;
for(int i=1;i<=n;i++) {
for(int j=1;j<=m;j++) {
char ch; cin>>ch;
a[i][j]=ch;
}
}
dfs(1,1);
for(int i=1;i<=n;i++) {
for(int j=1;j<=m;j++) cout<<(char)a[i][j];
cout<<'\n';
}
return 0;
}
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

int solve() {
ll n;
cin >> n;

auto digit_ok = [&](int i, int d) {
if (i < 4) return i <= d && d <= 3 * i;
else return d != 3;
};

for (int k = 1; k <= 4; k++) {
int i = k;
for (ll m = n; m > 0; m /= 10) {
int r = m % 10;
while (i > 0 && !digit_ok(i, r)) i--;
if (i == 0) goto bad;
if (i == 4 && r <= 2 && m >= 10) m -= 10;
}
return k;
bad:
;
}

return 5;
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

int tcs = 1;
cin >> tcs;
for (int tc = 1; tc <= tcs; tc++) {
cout << solve() << '\n';
}
}

#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <tuple>
#include <vector>

using namespace std;

#define endl "\n"

// clang-format off
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }
#ifdef MIPPON_LOCAL
#define dbg(...) cerr <<"\e[38;5;214m" << "(" << #__VA_ARGS__ << "):" << "\e[39m", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif


template<const int &MOD>
struct modint {
int64_t n;
modint() : n(0) { ; }
modint(int64_t m) : n(m) {
if (n >= MOD) n %= MOD;
if (n < 0) n = (n % MOD + MOD) % MOD;
}
modint(uint64_t m) : n(m) {
if (n >= MOD) n %= MOD;
}
modint(int v) : modint(int64_t(v)) {}
modint(unsigned v) : modint(uint64_t(v)) {}

explicit operator int() const { return n; }
explicit operator unsigned() const { return n; }
explicit operator int64_t() const { return n; }
explicit operator uint64_t() const { return n; }
explicit operator double() const { return n; }
explicit operator long double() const { return n; }
modint& operator++() {
n = n == MOD - 1 ? 0 : n + 1;
return *this;
}
modint& operator--() {
n = n == 0 ? MOD - 1 : n - 1;
return *this;
}
modint operator++(int) {
modint before = *this;
++*this;
return before;
}
modint operator--(int) {
modint before = *this;
--*this;
return before;
}
modint operator-() const { return n == 0 ? 0 : MOD - n; }
friend bool operator==(const modint& a, const modint& b) { return a.n == b.n; }
friend bool operator!=(const modint& a, const modint& b) { return a.n != b.n; }
friend bool operator<(const modint& a, const modint& b) { return a.n < b.n; }
friend bool operator>(const modint& a, const modint& b) { return a.n > b.n; }
friend bool operator<=(const modint& a, const modint& b) { return a.n <= b.n; }
friend bool operator>=(const modint& a, const modint& b) { return a.n >= b.n; }
modint& operator+=(const modint& a) {
n += a.n;
if (n >= MOD) n -= MOD;
return *this;
}
modint& operator-=(const modint& a) {
n -= a.n;
if (n < 0) n += MOD;
return *this;
}
modint& operator*=(const modint& a) {
n = ((int64_t)n * a.n) % MOD;
return *this;
}
modint& operator/=(const modint& a) { return *this *= a.inv(); }
modint inv() const { return pow(MOD - 2); }

friend modint operator/(const modint& a, const modint& b) { return modint(a) /= b; }
friend modint operator+(const modint& a, const modint& b) { return modint(a) += b; }
friend modint operator-(const modint& a, const modint& b) { return modint(a) -= b; }
friend modint operator*(const modint& a, const modint& b) { return modint(a) *= b; }
friend modint operator^(modint a, int64_t n) {
if (n == 0) return modint(1);
modint res = (a * a) ^ (n / 2);
if (n % 2) res = res * a;
return res;
}

modint pow(int64_t p) const {
if (p < 0) return inv().pow(-p);
modint a = *this, result = 1;
while (p > 0) {
if (p & 1) result *= a;
p >>= 1;
if (p > 0) a *= a;
}
return result;
}
friend ostream& operator<<(ostream& os, const modint& a) { return os << a.n; }
};

extern const int MOD = int(1e9) + 7;
using mod_int = modint<MOD>;

// clang-format on
int64_t ceil_divison(int64_t a, int64_t b) {
return a / b + ((a ^ b) > 0 && a % b != 0);
}
int64_t floor_divison(int64_t a, int64_t b) {
return a / b - ((a ^ b) < 0 && a % b != 0);
}

void run_case() {

// 2 3

// 2 3
// 0 0
// 1 2
// 0 1
// 0 0
// 1 1

int N;
cin >> N;
deque<int64_t> A(N);
for (auto &x : A)
cin >> x;

sort(A.begin(), A.end());
vector<int64_t> B;
A.push_front(0);

for (int i = 1; i < A.size(); i++) {
B.push_back(A[i] - A[i - 1]);
}
dbg(B);

const int MOD = 1e9 + 7;
mod_int s = 1;
for (int i = 0; i < B.size(); i++) {
s *= (B[i] + 1);
}
dbg(A, s);
cout << s << endl;
}
int main() {
ios::sync_with_stdio(false);
#ifndef MIPPON_LOCAL
cin.tie(nullptr);
#endif

run_case();

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for (int i = 0; i < (n); ++i)
using ll = long long;
int main(void){
// Your code here!
ll t,n;
cin>>t>>n;
cout << fixed << setprecision(0);

cout << ceil(n * 100.0 / t) + (n - 1) << endl;



}
#ifndef HIDDEN_IN_VISUAL_STUDIO // 折りたたみ用

// 警告の抑制
#define _CRT_SECURE_NO_WARNINGS

// ライブラリの読み込み
#include <bits/stdc++.h>
using namespace std;

// 型名の短縮
using ll = long long; // -2^63 ～ 2^63 = 9 * 10^18（int は -2^31 ～ 2^31 = 2 * 10^9）
using pii = pair<int, int>;	using pll = pair<ll, ll>;	using pil = pair<int, ll>;	using pli = pair<ll, int>;
using vi = vector<int>;		using vvi = vector<vi>;		using vvvi = vector<vvi>;
using vl = vector<ll>;		using vvl = vector<vl>;		using vvvl = vector<vvl>;
using vb = vector<bool>;	using vvb = vector<vb>;		using vvvb = vector<vvb>;
using vc = vector<char>;	using vvc = vector<vc>;		using vvvc = vector<vvc>;
using vd = vector<double>;	using vvd = vector<vd>;		using vvvd = vector<vvd>;
template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
using Graph = vvi;

// 定数の定義
const double PI = 3.14159265359;
const double DEG = PI / 180.; // θ [deg] = θ * DEG [rad]
const vi dx4 = { 1, 0, -1, 0 }; // 4 近傍（下，右，上，左）
const vi dy4 = { 0, 1, 0, -1 };
const vi dx8 = { 1, 1, 0, -1, -1, -1, 0, 1 }; // 8 近傍
const vi dy8 = { 0, 1, 1, 1, 0, -1, -1, -1 };
const int INF = 1001001001; const ll INFL = 2002002002002002002LL;
const double EPS = 1e-10; // 許容誤差に応じて調整

// 入出力高速化
struct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } fastIOtmp;

// 汎用マクロの定義
#define all(a) (a).begin(), (a).end()
#define sz(x) ((int)(x).size())
#define distance (int)distance
#define Yes(b) {cout << ((b) ? "Yes" : "No") << endl;}
#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 から n-1 まで昇順
#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s から t まで昇順
#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s から t まで降順
#define repe(v, a) for(const auto& v : (a)) // a の全要素（変更不可能）
#define repea(v, a) for(auto& v : (a)) // a の全要素（変更可能）
#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d ビット全探索（昇順）
#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a の順列全て（昇順）
#define repit(it, a) for(auto it = (a).begin(); it != (a).end(); ++it) // イテレータを回す（昇順）
#define repitr(it, a) for(auto it = (a).rbegin(); it != (a).rend(); ++it) // イテレータを回す（降順）
#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod
#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // 重複除去

// 汎用関数の定義
template <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }
template <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // 最大値を更新（更新されたら true を返す）
template <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // 最小値を更新（更新されたら true を返す）

// 演算子オーバーロード
template <class T, class U> inline istream& operator>> (istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template <class T, class U> inline ostream& operator<< (ostream& os, const pair<T, U>& p) { os << "(" << p.first << "," << p.second << ")"; return os; }
template <class T, class U, class V> inline istream& operator>> (istream& is, tuple<T, U, V>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t); return is; }
template <class T, class U, class V> inline ostream& operator<< (ostream& os, const tuple<T, U, V>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << ")"; return os; }
template <class T, class U, class V, class W> inline istream& operator>> (istream& is, tuple<T, U, V, W>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t); return is; }
template <class T, class U, class V, class W> inline ostream& operator<< (ostream& os, const tuple<T, U, V, W>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << "," << get<3>(t) << ")"; return os; }
template <class T> inline istream& operator>> (istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }
template <class T> inline ostream& operator<< (ostream& os, const vector<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const list<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T, greater<T>>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const unordered_set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const unordered_map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, stack<T> s) { while (!s.empty()) { os << s.top() << " "; s.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, queue<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, deque<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop_front(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue_rev<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline vector<T>& operator--(vector<T>& v) { rep(_i_, sz(v)) --v[_i_]; return v; }
template <class T> inline vector<T>& operator++(vector<T>& v) { rep(_i_, sz(v)) ++v[_i_]; return v; }

// 手元環境（Visual Studio）
#ifdef _MSC_VER
#define popcunt (int)__popcnt // 全ビット中の 1 の個数
#define popcountll (int)__popcnt64
inline int lsb(unsigned int n) { unsigned long i; _BitScanForward(&i, n); return i; } // 最下位ビットの位置（0-indexed）
inline int lsbll(unsigned long long n) { unsigned long i; _BitScanForward64(&i, n); return i; }
inline int msb(unsigned int n) { unsigned long i; _BitScanReverse(&i, n); return i; } // 最上位ビットの位置（0-indexed）
inline int msbll(unsigned long long n) { unsigned long i; _BitScanReverse64(&i, n); return i; }
template <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
#define dump(x) cout << "\033[1;36m" << (x) << "\033[0m" << endl;
#define dumps(x) cout << "\033[1;36m" << (x) << "\033[0m ";
#define dumpel(a) { int _i_ = -1; cout << "\033[1;36m"; repe(x, a) {cout << ++_i_ << ": " << x << endl;} cout << "\033[0m"; }
#define input_from_file(f) ifstream isTMP(f); cin.rdbuf(isTMP.rdbuf());
#define output_to_file(f) ofstream osTMP(f); cout.rdbuf(osTMP.rdbuf());
// 提出用（gcc）
#else
#define popcount (int)__builtin_popcount
#define popcountll (int)__builtin_popcountll
#define lsb __builtin_ctz
#define lsbll __builtin_ctzll
#define msb(n) (31 - __builtin_clz(n))
#define msbll(n) (63 - __builtin_clzll(n))
#define gcd __gcd
#define dump(x)
#define dumps(x)
#define dumpel(v)
#define input_from_file(f)
#define output_to_file(f)
#endif

#endif // 折りたたみ用


//-----------------AtCoder 専用-----------------
#include <atcoder/all>
using namespace atcoder;

//using mint = modint1000000007;
using mint = modint998244353;
//using mint = modint; // mint::set_mod(m);

istream& operator>> (istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }
ostream& operator<< (ostream& os, const mint& x) { os << x.val(); return os; }
using vm = vector<mint>;	using vvm = vector<vm>;		using vvvm = vector<vvm>;

template <class S, S(*op)(S, S), S(*e)()>ostream& operator<<(ostream& os, segtree<S, op, e> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
template <class S, S(*op)(S, S), S(*e)(), class F, S(*mp)(F, S), F(*cp)(F, F), F(*id)()>ostream& operator<<(ostream& os, lazy_segtree<S, op, e, F, mp, cp, id> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
ostream& operator<<(ostream& os, dsu d) { repe(g, d.groups()) { repe(v, g) { os << v << " "; } os << endl; } return os; };
//----------------------------------------------


//【グラフの入力】O(|V| + |E|)
/*
* 始点 終点の組からなる入力を受け取り，n 頂点 m 辺のグラフを構成する．
*
* n : グラフの頂点の数
* m : グラフの辺の数
* g : ここにグラフを構築して返す
* directed : 有向グラフなら true
* one_indexed : 入力が 1-indexed で与えられるなら true
*/
void read_graph(int n, int m, Graph& g,
bool directed = false, bool one_indexed = true) {
g = Graph(n);
rep(i, m) {
int a, b;
cin >> a >> b;

if (one_indexed) { a--; b--; }

g[a].push_back(b);
if (!directed) g[b].push_back(a);
}
}


//【根付き木】
/*
* Rooted_tree() : O(1)
*	空で初期化する．
*
* Rooted_tree(g, r) : O(n)
*	木 g を r を根とみなした根付き木として受け取る．
*/
struct Rooted_tree {
// verify : https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_7_A

struct Node {
int parent = -1; // 親（なければ -1）
vi child; // 子（なければ空リスト）
int depth = -1; // 深さ（根からのパスの長さ）
int& dist = depth; // 深さを距離ともみなす（パスのコストを 1 とみなす）
int weight = -1; // 重さ（部分木のもつ辺の数）
int height = -1; // 高さ（最も遠い葉までの距離）

// デバッグ出力
friend ostream& operator<<(ostream& os, const Node& v) {
os << "(p:" << v.parent << ", c:[" << v.child << "], d:" << v.depth
<< ", w:" << v.weight << ", h:" << v.height << ")";
return os;
}
};

int n; // 頂点数
int r; // 根
vector<Node> v; // 頂点

// コンストラクタ（空で初期化，木と根で初期化）
Rooted_tree() : n(0), r(-1) {}
Rooted_tree(Graph& g, int r_) : n(sz(g)), r(r_), v(n) {
// s : 注目ノード，p : s の親
function<void(int, int)> dfs = [&](int s, int p) {
v[s].parent = p;
v[s].child.clear();
v[s].weight = 0;
v[s].height = 0;

repe(t, g[s]) {
if (t == p) continue;

v[t].depth = v[s].depth + 1;

dfs(t, s);

v[s].child.push_back(t);
v[s].weight += v[t].weight + 1;
chmax(v[s].height, v[t].height + 1);
}
};

// 根 r を始点として再帰関数を呼び出す．
v[r].depth = 0;
dfs(r, -1);
}

// アクセス
Node const& operator[](int i) const { return v[i]; }
Node& operator[](int i) { return v[i]; }

// 大きさ
int size() const { return n; }

// デバッグ出力
friend ostream& operator<<(ostream& os, const Rooted_tree& rt) {
rep(i, rt.n) os << rt[i] << endl;
return os;
}
};


//【幅優先探索】O(|V| + |E|)
/*
* グラフ g に対し，始点を st として幅優先探索を行い，
* st から各頂点 i への最短経路長を dist[i] に格納する．
* i が st から到達不能な頂点の場合は dist[i] = INF となる．
*/
void breadth_first_search(const Graph& g, int st, vi& dist) {
// verify : https://algo-method.com/tasks/414

int n = sz(g);
dist = vi(n, INF); // スタートからの最短距離を保持するテーブル
dist[st] = 0;
queue<int> que; // 次に探索する頂点を入れておくキュー
que.push(st);

while (!que.empty()) {
// 未探索の頂点を 1 つ得る．
auto s = que.front();
que.pop();

repe(t, g[s]) {
// 発見済みの頂点なら何もしない．
if (dist[t] != INF) continue;

// スタートからの最短距離を確定する．
// 幅優先探索なので，最短だという保証がある．
dist[t] = dist[s] + 1;

// 未探索の頂点として t を追加する．
que.push(t);
}
}
}


//【木の直径】O(n)
/*
* 木の直径の長さを返す．また直径の両端となる頂点の組を p に格納する．
*
* 利用：【幅優先探索】
*/
int tree_diameter(const Graph& g, pii& p) {
int n = sz(g);

// 適当な頂点を始点にして最遠の点 s を求める．
vi dist;
breadth_first_search(g, 0, dist);

int max_dist = -1;
int s;
rep(i, n) {
if (chmax(max_dist, dist[i])) {
s = i;
}
}

// s を始点にして最遠の点 t を求めれば，s と t の距離が木の直径である．
max_dist = -1;
int t;
breadth_first_search(g, s, dist);
rep(i, n) {
if (chmax(max_dist, dist[i])) {
t = i;
}
}

p = { s, t };
return max_dist;
}


//【根付き木のオイラーツアー】O(n)（の改変）
/*
* 根付き木 rt のオイラーツアーを求める．
*
* in[s] : 最初に頂点 s を訪れた時刻（根なら 0）
* out[s] : 最後に頂点 s から離れた時刻（根なら 2 n - 1）
* pos[t] : 時刻 t に訪れた頂点の番号（長さ 2 n - 1）
*/
template <class TREE> void euler_tour(const TREE& rt, vi& in, vi& out, vi& pos) {
// verify : https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C

int n = sz(rt);

int time = 0;
in = vi(n);
out = vi(n);
pos = vi(2 * n - 1);

// 再帰用の関数
function<void(int)> rf = [&](int s) {
// s を最初に訪れた
in[s] = time;
pos[time++] = s;

// 高さ昇順に頂点をなぞっていくことにする．
// こうすれば直径のもう一方の端を最後になぞってくれる．
vector<pii> hi;
repe(t, rt[s].child) {
hi.push_back({ rt[t].height, t });
}
sort(all(hi));

rep(i, sz(hi)) {
rf(hi[i].second);
pos[time++] = s;
}

// s から最後に離れる
out[s] = time;
};

// 根から順に探索する．
rf(rt.r);
}


int main() {
input_from_file("input.txt");
//	output_to_file("output.txt");

int n;
cin >> n;

Graph g;
read_graph(n, n - 1, g);

// 直径とその両端を得る
pii endpoints;
tree_diameter(g, endpoints);

// 直径の端点を根とする根付き木として再構成する．
Rooted_tree rt(g, endpoints.first);

// 低い順に頂点をなぞるオイラーツアーを得る．
vi in, out, pos;
euler_tour(rt, in, out, pos);

// 頂点に始めて入った時刻を頂点に書き込めば良い．
rep(i, n) {
cout << in[i] + 1 << (i < n - 1 ? " " : "\n");
}
}

#ifdef LOCAL
//#define _GLIBCXX_DEBUG
#endif
//#pragma GCC target("avx512f,avx512dq,avx512cd,avx512bw,avx512vl")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> P;
typedef pair<int, int> Pi;
typedef vector<ll> Vec;
typedef vector<int> Vi;
typedef vector<string> Vs;
typedef vector<char> Vc;
typedef vector<P> VP;
typedef vector<vector<ll>> VV;
typedef vector<vector<int>> VVi;
typedef vector<vector<char>> VVc;
typedef vector<vector<vector<ll>>> VVV;
typedef vector<vector<vector<vector<ll>>>> VVVV;

#define endl '\n'
#define REP(i, a, b) for(ll i=(a); i<(b); i++)
#define PER(i, a, b) for(ll i=(a); i>=(b); i--)
#define rep(i, n) REP(i, 0, n)
#define per(i, n) PER(i, n, 0)
const ll INF=1e18+18;
const ll MOD=1000000007;
#define Yes(n) cout << ((n) ? "Yes" : "No") << endl;
#define YES(n) cout << ((n) ? "YES" : "NO") << endl;
#define ALL(v) v.begin(), v.end()
#define rALL(v) v.rbegin(), v.rend()
#define pb(x) push_back(x)
#define mp(a, b) make_pair(a,b)
#define Each(a,b) for(auto &a :b)
#define rEach(i, mp) for (auto i = mp.rbegin(); i != mp.rend(); ++i)
#define SUM(a) accumulate(ALL(a),0LL)
#ifdef LOCAL
#define dbg(x_) cerr << #x_ << ":" << x_ << endl;
#define dbgmap(mp) cerr << #mp << ":"<<endl; for (auto i = mp.begin(); i != mp.end(); ++i) { cerr << i->first <<":"<<i->second << endl;}
#define dbgset(st) cerr << #st << ":"<<endl; for (auto i = st.begin(); i != st.end(); ++i) { cerr << *i <<" ";}cerr<<endl;
#define dbgarr(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j]<<" ";}cerr<<endl;}
#define dbgdp(n,arr) rep(i,n){cerr<<arr[i]<<" ";}cerr<<endl;
#else
#define dbg(...)
#define dbgmap(...)
#define dbgset(...)
#define dbgarr(...)
#define dbgdp(...)
#endif
#define out(a) cout<<a<<endl
#define out2(a,b) cout<<a<<" "<<b<<endl
#define vout(v) rep(i,v.size()){cout<<v[i]<<" ";}cout<<endl
#define Uniq(v) v.erase(unique(v.begin(), v.end()), v.end())
#define fi first
#define se second

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

template<typename T1, typename T2>
ostream &operator<<(ostream &s, const pair<T1, T2> &p) { return s<<"("<<p.first<<", "<<p.second<<")"; }

template<typename T1, typename T2>
istream &operator>>(istream &i, pair<T1, T2> &p) { return i>>p.first>>p.second; }

template<typename T>istream& operator>>(istream&i,vector<T>&v)
{rep(j,v.size())i>>v[j];return i;}

// vector
template<typename T>
ostream &operator<<(ostream &s, const vector<T> &v) {
int len=v.size();
for(int i=0; i<len; ++i) {
s<<v[i];
if(i<len-1) s<<"	";
}
return s;
}

// 2 dimentional vector
template<typename T>
ostream &operator<<(ostream &s, const vector<vector<T> > &vv) {
s<<endl;
int len=vv.size();
for(int i=0; i<len; ++i) {
s<<vv[i]<<endl;
}
return s;
}

int solve(){
ll n;
cin>>n;
auto f = [&](ll m)->bool{
//m要素で達成できるか。
string s = to_string(n);
reverse(ALL(s));
ll N = s.length();
VVV dp(N+1,VV(m+1,Vec(3)));
dp[0][m][0] = 1;
rep(i,N){
rep(keta, m+1){
rep(j,3){
rep(nxketa, keta+1){
ll mi = nxketa;
ll ma = 3*nxketa;
ll x = s[i]-'0';
REP(k, 0, 3){
// [mi,ma] + j %= x;
ll K = 10 * k + x;
if( mi + j <= K && K <= ma + j){
dp[i+1][nxketa][k] |= dp[i][keta][j];
}
}
}
}
}
}
bool res = false;
rep(i,m+1){
res |= dp[N][i][0];
}
return res;
};
REP(i,1,10){
if(f(i)){
out(i);
return 0;
}
}
return  0;
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout<<std::setprecision(10);
ll T;
cin>>T;
while(T--)
solve();
}

#include <iostream>
#include <string>
using namespace std;

int main() {
long long A, B; // long long 型の変数 A, B を定義
cin >> A >> B; // 整数 A, B を入力
cout << 500000000 * B + A << endl; // 答えを出力（500000000LL は「long long 型の 500000000」という意味）
return 0;
}

#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using VI = vector<int>;
using P = pair<int, int>;

#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for (ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

template< typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true); }
template< typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true); }

const ll MOD = 1000000007;

int main() {
string s;
cin >> s;
/*
REP(i, 26) {
int t = 0, a = 0, b = -1;
REP(j, s.size()) {
if (s[j] - 'a' == i) t++;
else t--;
if (t > a + 1) {
cout << b + 2 << " " << j + 1 << endl;
return 0;
}
if (t < a) {
a = t;
b = j;
}
}
}
*/
REP(i, s.size() - 1) {
if (s[i] == s[i + 1]) {
cout << i + 1 << " " << i + 2 << endl;
return 0;
}
}
REP(i, s.size() - 2) {
if (s[i] == s[i + 2]) {
cout << i + 1 << " " << i + 3 << endl;
return 0;
}
}
cout << "-1 -1" << endl;
}
#include<bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp> 
// #include <ext/pb_ds/detail/standard_policies.hpp>
// using namespace __gnu_pbds;

#pragma GCC optimize("O3")
#ifdef LOCAL
#include "/Users/lbjlc/Desktop/coding/debug_utils.h"
#else
#define print(...) ;
#define printn(...) ;
#define printg(...) ;
#define fprint(...) ;
#define fprintn(...) ;
#endif

#define rep(i, a, b) for(auto i = (a); i < (b); i++)
#define rrep(i, a, b) for(auto i = (a); i > (b); i--)
#define all(v) (v).begin(), (v).end()
#define pb push_back
// #define mp make_pair
#define fi first
#define se second
#define maxi(x, y) x = max(x, y)
#define mini(x, y) x = min(x, y)
// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }
// #define endl '\n'
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int get_random() {
static uniform_int_distribution<int> dist(0, 1e9 + 6);
return dist(rng);
}
const vector<pair<int,int>> eight_directions = {{1,1},{1,0},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};
const vector<pair<int,int>> four_directions = {{1,0},{0,1},{0,-1},{-1,0}};
#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}


typedef unsigned long long ull;
typedef long long ll;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef vector<long long> vll;
#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)

template<class T>
void make_unique(T & v) {
sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());
}
int geti() { int x; cin >> x; return x; }
long long getll() { long long x; cin >> x; return x; }
double getd() { double x; cin >> x; return x; }
// pair<int, int> a(geti(), geti()) does not work
// pair<int, int> a({geti(), geti()}) works, since it uses initializer.

const int MAXN = 3e5 + 100;

void solve(int tt) {
// cout<<"Case #"<<tt<<": ";
}


int main(int argc, char * argv[]) {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
// solve_testcase;

int n;
cin>>n;
vi a(n + 1);

for(int i = 2; i <= n; i++) {
a[i] = 1;
for(int j = 2; j * j <= i; j++) {
if(i % j == 0) {
a[i] = a[i / j] + 1;
break;
}
}
}

rep(i,1,n+1) cout<<a[i]+1<<' ';
cout<<endl;

// rep(i,1,n + 1) rep(j,i + 1,n + 1){
// 	if(j % i == 0)
// 		assert(a[i] != a[j]);
// }

return 0;
}












#include<bits/stdc++.h>
using namespace std;
#define uu unsigned
#define scanf abc=scanf
#define fre(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout)
#define forg(i,x) for(int i=fir[x];i;i=nxt[i])
int abc;
typedef long long ll;
typedef uu long long ull;
typedef pair<int,int>pii;
typedef vector<int>VI;
mt19937 rnd((ll)(new char));
int rd(int l,int r){assert(l<=r);uniform_int_distribution<>ee(l,r);return ee(rnd);}
void NC(ull k){cout<<(k>>20)<<endl;}

const int mxn=2e5+3;
int n,m,b[mxn],d[mxn],nn,e[mxn];
bool vs[mxn];

int main(){
cin>>n>>m;for(int i=1;i<=m;++i)scanf("%d",b+i),vs[b[i]]=1,e[b[i]]=1;for(int i=1;i<=n;++i)e[i]+=e[i-1];
for(int i=1,p=1,c=0;i<=m;++i){
if(i==m){
for(int j=n;j>=p;--j)if(!vs[j]||j==b[i])d[++nn]=j;break;
}
d[++nn]=b[i];while(c!=i){
while(p<b[i]&&vs[p])++p;if(p==b[i])break;d[++nn]=p;
c=max(c+1,e[p++]+1);
}
}
assert(n==nn);
for(int i=1;i<=n;++i)printf("%d ",d[i]);puts("");
return 0;
}

#include "bits/stdc++.h"

using namespace std;

#define int long long
#define vt vector
#define pii pair<int, int>
#define tiii tuple<int, int, int>
#define sz(x) (int)(x).size()
#define INF (1LL<<60)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define F first
#define S second
#define PB push_back

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);

// freopen("moop.in", "r" ,stdin);
// freopen("moop.out", "w", stdout);

int N;
cin >> N;
vt<int> P(N), Q(N);
for (int i = 0; i < N; i++) cin >> P[i];
for (int i = 0; i < N; i++) cin >> Q[i];

vt<int> Qpos(N+1);
for (int i = 0; i < N; i++) Qpos[Q[i]] = i;

vt<pii> p;
for (int i = 0; i < N; i++)
for (int j = P[i]; j <= N; j += P[i])
p.PB({i, Qpos[j]});
sort(all(p), [](pii l, pii r) {
if (l.F == r.F) return l.S > r.S;
return l.F < r.F;
});

vt<int> v;
for (pii i : p)
v.PB(i.S);

vt<int> x(N+1, INF);
x[0] = v[0];

for (int i = 0; i < sz(v); i++) {
int j = lower_bound(all(x), v[i]+1) - x.begin();
if (j==0 || x[j-1] < v[i])
x[j] = v[i];
}

for (int i = N; i >= 0; i--) {
if (x[i]!=INF) {
cout << i+1 << "\n";
return 0;
}
}
}

#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,e,i,j,ii,jj,zx,xc,dp[5003][5003],p[5009],pi,mod=998244353LL;
int main(){
ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);
cin>>a>>b;ii=0;
for(i=1; i<=a+b; i++){
cin>>c;
if(c==1){
ii++;pi++;p[pi]=ii;
}else{
pi--;
}
}
for(j=0; j<=a; j++){
dp[0][j]=1;
}
for(i=1; i<=pi; i++){
for(j=1; j<=p[i]; j++){
dp[i][j]=dp[i-1][j-1];
}
for(j=1; j<=a; j++){
dp[i][j]+=dp[i][j-1];dp[i][j]%=mod;
}
}
cout<<dp[pi][p[pi]];
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int main(){

int t;
cin>>t;
while(t--){
string s;
cin>>s;

int num[20];
int ans=0;
for(int i=0;i<s.size();++i)
num[s.size()-i]=s[i]-'0';

while(1){
int ma=0,mrk=1;
for(int i=s.size();i && mrk;--i){
if(num[i]<ma){
num[i]+=10;
num[i+1]--;
mrk=0; 
}
ma=max(ma,(num[i]+2)/3);
}
if(mrk){
ans=ma;
break;
}
}
cout<<ans<<endl;
}

return 0;
}
#include<bits/stdc++.h>
using namespace std;

int T,ans;
bool k[10][6],jw[10][6];
long long n,a[20],len;

long long read(){
long long a=0,x=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')x=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){a=(a<<1)+(a<<3)+(ch^48);ch=getchar();}
return a*x;
}

void pre(){
k[0][4]=k[0][5]=k[0][0]=1;
k[1][1]=k[1][4]=k[1][5]=1;
k[2][1]=k[2][2]=k[2][4]=k[2][5]=1;
k[3][1]=k[3][2]=k[3][5]=k[3][3]=1;
k[4][2]=k[4][4]=k[4][3]=k[4][5]=1;
k[5][2]=k[5][4]=k[5][3]=k[5][5]=1;
k[6][2]=k[6][3]=k[6][4]=k[6][5]=1;
k[7][3]=k[7][4]=k[7][5]=1;
k[8][3]=k[8][4]=k[8][5]=1;
k[9][3]=k[9][4]=k[9][5]=1;
jw[1][4]=jw[1][5]=jw[2][4]=jw[2][5]=jw[3][5]=jw[4][5]=jw[0][4]=jw[0][5]=1;
jw[5][5]=2;
}

void work(long long x){
len=0;
while(x){
a[++len]=x%10;
x=x/10;
}
}

void dfs(int x,int sum,int b,int sum_now){
int flag=0;
int now=a[x]-b;
if(x==len){
if(now<0)return;
flag=0;
for(int i=0;i<=sum;i++){
if(k[now][i])ans=sum_now;
}
return;
}
if(now<0)now+=10,flag=1;
for(int i=sum;i>=1;i--){
if(k[now][i]){
if(now==5&&sum==5){
dfs(x+1,i,1+flag,sum_now);
dfs(x+1,i,0+flag,sum_now);
}
else{
dfs(x+1,i,jw[now][i]+flag,sum_now);
}
}
}	
}

int main(){
pre();
T=read();
while(T--){
n=read();
work(n);
if(len==1){
for(int i=1;i<=5;i++){
if(k[a[1]][i]){
printf("%d\n",i);
break;
}
}
continue;
}
int flag=1;
for(int i=1;i<=len;i++)if(a[i]<1||a[i]>3)flag=0;
if(flag){
puts("1");
continue;
}
ans=100;
for(int i=1;i<=5;i++){
if(k[a[1]][i]){
if(a[1]==5&&i==5){
dfs(2,i,0,i);
dfs(2,i,1,i);
}
else{
dfs(2,i,jw[a[1]][i],i);
}
if(ans==i)break;
}
}
printf("%d\n",ans);
}
return 0;
}
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#include<bits/stdc++.h>
#include<string>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define umap unordered_map
#define lb lower_bound
#define ub upper_bound
#define vll vector<ll>
#define vvll vector<vll>
#define pll pair<ll,ll>
#define vpll vactor<pll>
#define nl "\n"
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
const ll M = 1e9 + 7; //const ll M=998244353;
ull binpow(ull base, ull pow)
{
ull res = 1;
while (pow) {
if (pow & 1) res *= base;
pow >>= 1, base *= base;
//      base %= M, res %= M;
}
return res;
}
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
cout << fixed << setprecision(15);
ll T = 1;
//    cin >> T;
while (T--)
{
ll n, l;
cin >> n >> l;
string ans[n];
for (int i = 0; i < n; i++)
{
ll j =  i;
ans[i] = "2";
string temp = "";
for (int k = 1; k < l; k++)
{
if (j % 3 == 0)
temp += "0";
else if (j % 3 == 1)
temp += "1";
else
temp += "2";
j /= 3;
}
reverse(temp.begin(), temp.end());
ans[i] += temp;
}
for (int i = 0; i < n; i++)
{
cout << ans[i] << nl;
for (int j = 0; j < l; j++)
{
if (ans[i][j] == '0')
ans[i][j] = '2';
else if (ans[i][j] == '1')
ans[i][j] = '0';
else
ans[i][j] = '1';
}
cout << ans[i] << nl;
for (int j = 0; j < l; j++)
{
if (ans[i][j] == '0')
ans[i][j] = '2';
else if (ans[i][j] == '1')
ans[i][j] = '0';
else
ans[i][j] = '1';
}
cout << ans[i] << nl;
}
}
}
#include <bits/stdc++.h>
using namespace std;
const long long mod = 998244353;
const long long inv2 = (mod + 1) / 2;
long long get_num(long long a,int x)
{
return (a + 3 - x) / 4;
}
long long dfs(long long a,long long b,long long v)
{
if (a == 0 || b == 0)
return 0;
if (v == 0)
return min(a, b) % mod;
using T = tuple<long long, long long, long long>;
static map<T, long long> f;
T temp = make_tuple(a, b, v);
if(f.count(temp))
return f[temp];
long long ans = 0;
for (int i = 0; i <= 1;i++)
{
int j = (v & 1) ^ i;
ans = (ans + dfs((a - i + 1) / 2, (b - j + 1) / 2, v >> 1)) % mod;
}
return f[temp] = ans;
}
long long cal(long long a,long long b,long long v)
{
int offset[4] = {0, 0, 1, 3};
long long ans = 0;
for (int i = 0; i <= 3;i++)
for (int j = 0; j <= 3;j++)
{
long long c = get_num(a, i), d = get_num(b, j);
long long now = v ^ offset[i] ^ offset[j];
if (i % 2 == 0)
{
if (j % 2 == 0)
{
if (now == 0)
ans = (ans + (c % mod) * (d % mod) % mod) % mod;
}
else
{
if (now % 4 == 0 && now / 4 < d)
ans = (ans + c % mod) % mod;
}
}
else
{
if (j % 2 == 0)
{
if (now % 4 == 0 && now / 4 < c)
ans = (ans + d % mod) % mod;
}
else if (now % 4 == 0)
ans = (ans + dfs(c, d, v / 4)) % mod;
}
}
return ans % mod;
}
int main()
{
long long l, r, v;
scanf("%lld%lld%lld", &l, &r, &v);
r += 2;
long long ans = ((cal(r, r, v) - 2 * cal(l, r, v) % mod + cal(l, l, v)) % mod + mod) % mod;
if (v == 0)
ans = (ans - (r - l) % mod + mod) % mod;
printf("%lld", ans * inv2 % mod);
return 0;
}
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#include<bits/stdc++.h>
#include<string>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define umap unordered_map
#define lb lower_bound
#define ub upper_bound
#define vll vector<ll>
#define vvll vector<vll>
#define pll pair<ll,ll>
#define vpll vactor<pll>
#define nl "\n"
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
const ll M = 998244353;
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
cout << fixed << setprecision(15);
ll T = 1;
//    cin >> T;
while (T--)
{
ll n;
cin >> n;
ll ans = 0;
for (ll i = 1; i * i <= n; i++)
{
ll g = n / i;
ans += (g - i + 2) / 2;
ans %= M;
}
cout << ans << nl;
}
}
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using VI = vector<int>;
using P = pair<int, int>;

#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for (ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

template< typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true); }
template< typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true); }

const ll MOD = 1000000007;

int main() {
int N, M;
cin >> N >> M;
vector<string> S(N);
vector<ll> A(2, 0);
REP(i, N) {
cin >> S[i];
int B = 0;
REP(j, M) B += S[i][j] - '0';
A[B % 2]++;
}
cout << A[0] * A[1] << endl;
}
#line 2 "/Users/kaage/Desktop/ProgrammingWorkspace/library/other/template.hpp"
#define _CRT_SECURE_NO_WARNINGS
#ifndef __clang__
#ifdef ONLINE_JUDGE
#ifdef _WIN64
#pragma GCC target("avx2")
#else
#pragma GCC target("avx512f")
#endif
#elif defined EVAL
#else
#pragma GCC target("avx2")
#endif
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif
#include <string.h>
#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <cfloat>
#include <climits>
#include <cmath>
#include <complex>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unistd.h>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#define rep(i, n) for (int i = 0; i < (n); i++)
#define REP(i, n) for (int i = 1; i <= (n); i++)
#define all(V) V.begin(), V.end()

using i128 = __int128_t;
using u128 = __uint128_t;
using uint = unsigned int;
using lint = long long;
using ulint = unsigned long long;
using IP = std::pair<int, int>;
using LP = std::pair<lint, lint>;

constexpr int INF = INT_MAX / 2;
constexpr lint LINF = LLONG_MAX / 2;
constexpr double eps = DBL_EPSILON * 10;
constexpr double PI = 3.141592653589793238462643383279;

template <class T>
class prique : public std::priority_queue<T, std::vector<T>, std::greater<T>> {
};
int popcount(uint x) {
#if __cplusplus >= 202002L
return std::popcount(x);
#else
#ifndef __clang__
return __builtin_popcount(x);
#endif
#endif
x = (x & 0x55555555) + (x >> 1 & 0x55555555);
x = (x & 0x33333333) + (x >> 2 & 0x33333333);
x = (x & 0x0f0f0f0f) + (x >> 4 & 0x0f0f0f0f);
x = (x & 0x00ff00ff) + (x >> 8 & 0x00ff00ff);
return (x & 0x0000ffff) + (x >> 16 & 0x0000ffff);
}
template <class F>
inline constexpr decltype(auto) lambda_fix(F&& f) {
return [f = std::forward<F>(f)](auto&&... args) {
return f(f, std::forward<decltype(args)>(args)...);
};
}
template <class T>
constexpr std::vector<T> make_vec(size_t n) {
return std::vector<T>(n);
}
template <class T, class... Args>
constexpr auto make_vec(size_t n, Args&&... args) {
return std::vector<decltype(make_vec<T>(args...))>(
n, make_vec<T>(std::forward<Args>(args)...));
}
template <class T, class U>
std::istream& operator>>(std::istream& ist, std::pair<T, U>& x) {
return ist >> x.first >> x.second;
}
template <class T, class U>
std::ostream& operator<<(std::ostream& ost, const std::pair<T, U>& x) {
return ost << x.first << " " << x.second;
}
template <class Container,
#if __cplusplus >= 201703L
std::enable_if_t<!std::is_same_v<Container, std::string>,
#else
std::enable_if_t<!std::is_same<Container, std::string>::value,
#endif
std::nullptr_t> = nullptr>
auto operator>>(std::istream& ist, Container& cont)
-> decltype(typename Container::iterator(), std::cin)& {
std::vector<typename Container::value_type> tmp;
while (true) {
typename Container::value_type t;
ist >> t;
tmp.emplace_back(t);
if (getchar() == '\n') break;
}
cont = Container(std::move(tmp));
return ist;
}
template <class Container,
#if __cplusplus >= 201703L
std::enable_if_t<!std::is_same_v<Container, std::string>,
#else
std::enable_if_t<!std::is_same<Container, std::string>::value,
#endif
std::nullptr_t> = nullptr>
auto operator<<(std::ostream& ost, const Container& cont)
-> decltype(typename Container::iterator(), std::cout)& {
for (auto it = cont.begin(); it != cont.end(); it++) {
if (it != cont.begin()) ost << ' ';
ost << *it;
}
return ost;
}
template <class Container>
auto sum(const Container& cont)
-> decltype(typename Container::iterator(), 0LL) {
lint res = 0;
for (auto it = cont.begin(); it != cont.end(); it++) res += *it;
return res;
}
template <class T, class U>
constexpr inline bool chmax(T& lhs, const U& rhs) noexcept {
if (lhs < rhs) {
lhs = rhs;
return true;
}
return false;
}
template <class T, class U>
constexpr inline bool chmin(T& lhs, const U& rhs) noexcept {
if (lhs > rhs) {
lhs = rhs;
return true;
}
return false;
}
constexpr inline lint gcd(lint a, lint b) noexcept {
while (b) {
lint c = a;
a = b;
b = c % b;
}
return a;
}
inline lint lcm(lint a, lint b) noexcept { return a / gcd(a, b) * b; }
constexpr bool isprime(lint n) noexcept {
if (n == 1) return false;
for (int i = 2; i * i <= n; i++) {
if (n % i == 0) return false;
}
return true;
}
template <class T>
constexpr T mypow(T a, lint b) noexcept {
T res(1);
while (true) {
if (b & 1) res *= a;
b >>= 1;
if (!b) break;
a *= a;
}
return res;
}
constexpr lint modpow(lint a, lint b, lint m) noexcept {
a %= m;
lint res(1);
while (b) {
if (b & 1) res *= a, res %= m;
a *= a, a %= m, b >>= 1;
}
return res;
}
LP extGcd(lint a, lint b) noexcept {
if (b == 0) return {1, 0};
LP s = extGcd(b, a % b);
std::swap(s.first, s.second);
s.second -= a / b * s.first;
return s;
}
LP ChineseRem(const lint& b1, const lint& m1, const lint& b2,
const lint& m2) noexcept {
auto p = extGcd(m1, m2);
lint g = gcd(m1, m2), l = m1 / g * m2;
lint tmp = (b2 - b1) / g * p.first % (m2 / g);
lint r = (b1 + m1 * tmp + l) % l;
return {r, l};
}
int LCS(const std::string& a, const std::string& b) {
auto dp = make_vec<int>(a.size() + 1, b.size() + 1);
rep(i, a.size()) {
rep(j, b.size()) {
chmax(dp[i + 1][j], dp[i][j]);
chmax(dp[i][j + 1], dp[i][j]);
if (a[i] == b[j]) chmax(dp[i + 1][j + 1], dp[i][j] + 1);
}
chmax(dp[i + 1][b.size()], dp[i][b.size()]);
}
rep(j, b.size()) chmax(dp[a.size()][j + 1], dp[a.size()][j]);
return dp[a.size()][b.size()];
}
template <class T, std::enable_if_t<std::is_convertible<int, T>::value,
std::nullptr_t> = nullptr>
void compress(std::vector<T>& vec) {
auto tmp = vec;
std::sort(all(tmp));
tmp.erase(std::unique(all(tmp)), tmp.end());
for (T& i : vec) i = std::lower_bound(all(tmp), i) - tmp.begin();
}
template <class T>
void compress(T* l, T* r) {
std::vector<T> tmp(l, r);
std::sort(all(tmp));
tmp.erase(std::unique(all(tmp)), tmp.end());
for (auto i = l; i < r; i++) {
*i = std::lower_bound(all(tmp), *i) - tmp.begin();
}
}
template <class InputIter>
void compress(InputIter l, InputIter r) {
std::vector<typename InputIter::value_type> tmp(l, r);
std::sort(all(tmp));
tmp.erase(std::unique(all(tmp)), tmp.end());
for (auto i = l; i < r; i++) {
*i = std::lower_bound(all(tmp), *i) - tmp.begin();
}
}
#line 2 "main.cpp"
std::random_device rd;
std::mt19937 mt(rd());
int main() {
int N;
std::cin >> N;
if (N <= 4 || N % 3 == 2) {
puts("No");
return 0;
}
puts("Yes");
while (true) {
std::vector<int> V;
int R = 0, B = 0, W = 0;
REP(i, N) {
if (mt() % 3 == 0)
R += N - i, V.emplace_back(0);
else if (mt() & 1)
B += N - i, V.emplace_back(1);
else
W += N - i, V.emplace_back(2);
}
if (R == B && B == W) {
std::string s = "RBW";
rep(i, N - 1) std::cout << std::string(N - i - 1, s[V[i]]) << '\n';
break;
}
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
long long a1, a2, a3;
cin >> a1 >> a2 >> a3;
if (a1 + a3 <= a2 * 2) {
cout << a2 * 2 - a1 - a3 << endl; 
return 0;
}
else {
if ((a1 + a3 - a2 * 2) % 2 == 0) {
cout << (a1 + a3 - a2 * 2) / 2 << endl;
return 0;
}
else {
cout << (a1 + a3 - a2 * 2) / 2  + 2 << endl;
return 0;
}
}
}
#include <bits/stdc++.h>
// #include <set>
// #include <map>
// #include <cmath>
// #include <deque>
// #include <vector>
// #include <iostream>
// #include <algorithm>

using namespace std;
using ll = long long;
using VI = vector<int>;
using VL = vector<ll>;
using VD = vector<double>;
using VS = vector<string>;
using VB = vector<bool>;
using VVB = vector<vector<bool>>;
using VVI = vector<VI>;
using VVL = vector<VL>;
using VVD = vector<VD>;
using VVVI = vector<VVI>;
using VVVL = vector<VVL>;
using VVVD = vector<VVD>;
using PII = std::pair<int, int>;
using VPII = std::vector<std::pair<int, int>>;
using PLL = std::pair<ll, ll>;
using VPLL = std::vector<std::pair<ll, ll>>;
using TI3 = std::tuple<int, int, int>;
using TI4 = std::tuple<int, int, int, int>;
using TL3 = std::tuple<ll, ll, ll>;
using TL4 = std::tuple<ll, ll, ll, ll>;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repr(i, n) for (int i = (int)(n)-1; i >= 0; i--)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)
#define repr2(i, g, n) for (int i = (int)(n)-1; i >= (g); i--)
#define rep3(i, s, n, d) for (int i = (s); i < (int)(n); i += (d))
#define repr3(i, g, n, d) for (int i = (int)(n)-1; i >= (g); i -= (d))
#define allpt(v) (v).begin(), (v).end()
#define allpt_c(v) (v).cbegin(), (v).cend()
#define allpt_r(v) (v).rbegin(), (v).rend()
#define allpt_cr(v) (v).crbegin(), (v).crend()

const int mod1 = 1e9 + 7, mod2 = 998244353, mod3 = 1e9 + 9;
const int mod = mod2;
const ll inf = 1e18;
const int infint = 1e9;

const string wsp = " ";
const string tb = "\t";
const string rt = "\n";
const string alphabets = "abcdefghijklmnopqrstuvwxyz";

template <typename T>
void show1dvec(const vector<T> &v)
{
if (v.size() == 0)
return;
int n = v.size() - 1;
rep(i, n) cout << v[i] << wsp;
cout << v[n] << rt;
return;
}

int get1dcoodinate(int w, int i, int j) { return i * w + j; }

template <typename T>
ostream &operator<<(ostream &os, const vector<T> &v)
{
if (v.size() == 0)
return os;
int n = (int)v.size() - 1;
rep(i, n) os << v[i] << wsp;
os << v[n] << rt;
return os;
}

template <typename T>
istream &operator>>(istream &is, vector<T> &v)
{
if (v.size() == 0)
return is;
int n = v.size();
rep(i, n) is >> v[i];
return is;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<vector<T>> &v)
{
if (v.size() == 0)
return os;
int n = (int)v.size();
rep(i, n) os << v[i];
return os;
}

template <typename T>
istream &operator>>(istream &is, vector<vector<T>> &v)
{
if (v.size() == 0)
return is;
int n = v.size();
rep(i, n) is >> v[i];
return is;
}

template <typename T, typename S>
istream &operator>>(istream &is, vector<pair<T, S>> &v)
{
if (v.size() == 0)
return is;
int n = v.size();
rep(i, n) is >> v[i].first >> v[i].second;
return is;
}

template <typename T, typename S>
ostream &operator<<(ostream &os, const vector<pair<T, S>> &v)
{
if (v.size() == 0)
return os;
int n = v.size();
rep(i, n) os << v[i].first << wsp << v[i].second << rt;
return os;
}

void show2dvec(const vector<string> &v)
{
int n = (int)v.size();
rep(i, n) cout << v[i] << rt;
}

template <typename T>
void show2dvec(const vector<vector<T>> &v)
{
int n = v.size();
rep(i, n) show1dvec(v[i]);
}

template <typename T>
void range_sort(vector<T> &arr, int l, int r)
{
sort(arr.begin() + l, arr.begin() + r);
}

template <typename T, typename S>
void show1dpair(const vector<pair<T, S>> &v)
{
int n = v.size();
rep(i, n) cout << v[i].first << v[i].second << rt;
return;
}

template <typename T, typename S>
void pairzip(const vector<pair<T, S>> &v, vector<T> &t, vector<T> &s)
{
int n = v.size();
rep(i, n)
{
t.push_back(v[i].first);
s.push_back(v[i].second);
}
return;
}

template <typename T>
void maxvec(vector<T> &v)
{
T s = v[0];
int n = v.size();
rep(i, n - 1)
{
if (s > v[i + 1])
{
v[i + 1] = s;
}
s = v[i + 1];
}
}

template <typename T, typename S>
bool myfind(T t, S s)
{
return find(t.cbegin(), t.cend(), s) != t.cend();
}

bool check(int y, int x, int h, int w)
{
return 0 <= y && y < h && 0 <= x && x < w;
}

bool check(int y, int x, int h1, int h2, int w1, int w2)
{
return h1 <= y && y < h2 && w1 <= x && x < w2;
}

bool iskadomatsu(int a, int b, int c)
{
return (a != b && b != c && c != a) &&
((a > b && b < c) || (a < b && b > c));
}

template <typename T>
bool iskadomatsu(vector<T> v)
{
T a = v[0], b = v[1], c = v[2];
return (a != b && b != c && c != a) &&
((a > b && b < c) || (a < b && b > c));
}

double euc_dist(PII a, PII b)
{
return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));
}

// VS split(string s, char c) {
//     VS ret;
//     string part;
//     s += c;
//     rep(i, s.length()) {
//         if (s[i] == c) {
//             if (part != "") ret.emplace_back(part);
//             part = "";
//         } else if (s[i] != c) {
//             part += s[i];
//         }
//     }
//     return ret;
// }

VS split(string s, char c, char d = ' ')
{
VS ret;
// reverse(allpt(s));
string part;
s += c;
rep(i, s.length())
{
if (s[i] == c)
{
if (part != "")
{
// string t;
// t += c;
// ret.emplace_back(t);
ret.emplace_back(part);
}
part = "";
}
else
{
part += s[i];
}
}
return ret;
}

template <typename T, typename S, typename R>
ll pow_mod(T p, S q, R _mod = 1ll)
{
ll ret = 1, r = p;
while (q)
{
if (q % 2)
ret *= r, ret %= _mod;
r = (r * r) % _mod, q /= 2;
}
return ret % _mod;
}

template <typename T, typename S>
ll pow_no_mod(T p, S q)
{
ll ret = 1, r = p;
while (q)
{
if (q % 2)
ret *= r;
r = (r * r), q /= 2;
}
return ret;
}

void make_frac_tables(VL &frac_list, VL &frac_inv_list)
{
rep(i, frac_list.size() - 1)
{
frac_list[i + 1] *= frac_list[i] * (i + 1);
frac_list[i + 1] %= mod;
frac_inv_list[i + 1] *= frac_inv_list[i] * pow_mod(i + 1, mod - 2, mod);
frac_inv_list[i + 1] %= mod;
}
}

pair<VL, VL> make_frac_tables(int n)
{
VL frac_list(n + 1, 1), frac_inv_list(n + 1, 1);
rep(i, n)
{
frac_list[i + 1] *= frac_list[i] * (i + 1);
frac_list[i + 1] %= mod;
frac_inv_list[i + 1] *= frac_inv_list[i] * pow_mod(i + 1, mod - 2, mod);
frac_inv_list[i + 1] %= mod;
}
return make_pair(frac_list, frac_inv_list);
}

ll comb(int a, int b, const VL &frac_list, const VL &frac_inv_list)
{
if (a < b)
return 0;
if (b < 0)
return 0;
ll ret = frac_list[a];
ret *= frac_inv_list[b];
ret %= mod;
ret *= frac_inv_list[a - b];
ret %= mod;
return ret;
}

struct vec2d
{
ll x;
ll y;
vec2d(ll _x, ll _y)
{
x = _x;
y = _y;
}
ll dot(vec2d p) { return x * p.x + y * p.y; }
vec2d diff(vec2d p) { return vec2d(x - p.x, y - p.y); }
};

struct node
{
int parent = -1;
ll weight = 0;
int depth = 0;
int degree = -1;
int subtree = 1;
int check = 0;
int scc = -1;
VPLL children;
VI parent_list;
VPLL connect;

node()
{
parent = -1;
weight = 0;
depth = 0;
degree = -1;
subtree = 1;
check = 0;
children;
parent_list;
connect;
}
};

struct graph
{
int _n;
int root = 0;
vector<node> nodes;
graph(int n)
{
_n = n;
rep(i, _n) nodes.emplace_back(node());
}
void getconnect_nocost()
{
ll a, b;
cin >> a >> b;
nodes[a].connect.emplace_back(b, 1);
nodes[b].connect.emplace_back(a, 1);
}
void getconnect_cost()
{
ll a, b, c;
cin >> a >> b >> c;
nodes[a].connect.emplace_back(b, c);
nodes[b].connect.emplace_back(a, c);
}
void getconnect_increment_nocost()
{
ll a, b;
cin >> a >> b;
a--, b--;
nodes[a].connect.emplace_back(b, 1);
nodes[b].connect.emplace_back(a, 1);
}
void getconnect_increment_cost()
{
ll a, b, c;
cin >> a >> b >> c;
a--, b--;
nodes[a].connect.emplace_back(b, c);
nodes[b].connect.emplace_back(a, c);
}
void showparent()
{
rep(i, _n - 1) cout << nodes[i].parent << wsp;
cout << nodes[_n - 1].parent << rt;
}
void showweight()
{
rep(i, _n - 1) cout << nodes[i].weight << wsp;
cout << nodes[_n - 1].weight << rt;
}
void showsubtree()
{
rep(i, _n - 1) cout << nodes[i].subtree << wsp;
cout << nodes[_n - 1].subtree << rt;
}
void showdepth()
{
rep(i, _n - 1) cout << nodes[i].depth << wsp;
cout << nodes[_n - 1].depth << rt;
}
};

struct point
{
int x;
int y;
point()
{
x = 0;
y = 0;
}
point(int _x, int _y)
{
x = _x;
y = _y;
}
void pointinput()
{
intt _x, _y;
cin >> _x >> _y;
x = _x;
y = _y;
}
void pointinv() { swap(x, y); }
};

istream &operator>>(istream &is, point &p)
{
is >> p.x >> p.y;
return is;
}

ostream &operator<<(ostream &os, point &p)
{
os << p.x << wsp << p.y << rt;
return os;
}

double pointseuc(point a, point b)
{
ll ax = a.x, bx = b.x, ay = a.y, by = b.y;
return sqrt(pow(ax - bx, 2) + pow(ay - by, 2));
}

ll pointseucsquare(point a, point b)
{
ll ax = a.x, bx = b.x, ay = a.y, by = b.y;
return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
}

int pointsmanhattan(point a, point b)
{
return abs(a.x - b.x) + abs(a.y - b.y);
}

double dist_segment_point(TL3 segment, point p)
{
double a = get<0>(segment);
double b = get<1>(segment);
double c = get<2>(segment);
return abs(a * p.x + b * p.y - c) / (a * a + b * b + c * c);
}

TL3 segment_parameter(point p, point q)
{
ll a, b, c;
a = q.y - p.y;
b = p.x - q.x;
c = a * p.x + b * p.y;
TL3 ret = (TL3){a, b, c};
// cout << a << b << c << rt;
return ret;
}

int cross_check(TL3 segment, point p)
{
ll a = get<0>(segment);
ll b = get<1>(segment);
ll c = get<2>(segment);

auto f = a * p.x + b * p.y - c;
int ret;
if (f > 0)
ret = 1;
if (f == 0)
ret = 0;
if (f < 0)
ret = -1;
return ret;
}

VI shave(int n)
{
VI v;
if (n <= 1)
return v;
vector<bool> w(n + 1, true);
int x;
w[0] = w[1] = false;
rep2(i, 2, n + 1)
{
if (w[i])
{
x = i * 2;
while (x <= n)
{
w[x] = false;
x += i;
}
}
}
rep(i, n + 1) if (w[i]) v.emplace_back(i);
return v;
}

void shave(vector<int> &v, int n)
{
if (n <= 1)
return;
vector<bool> w(n + 1, true);
int x;
w[0] = w[1] = false;
rep2(i, 2, n + 1)
{
if (w[i])
{
x = i * 2;
while (x <= n)
{
w[x] = false;
x += i;
}
}
}
rep(i, n + 1) if (w[i]) v.emplace_back(i);
}

template <typename T>
void coordinate_compress(vector<T> &x, map<T, int> &zip, int &xs)
{
sort(x.begin(), x.end());
x.erase(unique(x.begin(), x.end()), x.end());
xs = x.size();
for (int i = 0; i < xs; i++)
{
zip[x[i]] = i;
}
}

// ll getpalindrome(int l, int r, const string &s, VL &memo) {
//     if (r - l <= 1) return 1;
//     if (memo[l] != -1) return memo[l];
//     ll ret{1};
//     int n = (r - l) / 2;
//     string sl, sr;
//     rep(i, n) {
//         sl += s[l + i];
//         sr += s[r - 1 - i];
//         string rsr(i + 1, '0');
//         reverse_copy(allpt_c(sr), rsr.begin());
//         // cout << sl << wsp << sr << wsp << rsr << rt;
//         if (sl == rsr) {
//             ret += getpalindrome(l + i + 1, r - i - 1, s, memo);
//             ret %= mod;
//         }
//     }
//     memo[l] = ret;
//     return ret;
// }

void getpalindrome(int l, int r, int n, const string &s, VVB &memo)
{
if (r - l <= 1 || s[l] == s[r - 1])
{
memo[l][r] = true;
if (l > 0 && r < n)
{
getpalindrome(l - 1, r + 1, n, s, memo);
}
}
return;
}

// void djcstra(graph graphs, int s, int t) {
//     const int n = graphs._n;
//     VL shortest(n, inf);
//     shortest[s] = 0;
//     priority_queue<pair<ll, int>> pq;
//     pq.push(make_pair(0, s));
//     while (!pq.empty()) {
//         auto [t, v] = pq.top();
//         pq.pop();
//         t = -t;
//         if (shortest[v] != t) continue;
//         for (auto [u, c] : graphs.nodes[v].connect) {
//             if (t + c < shortest[u]) {
//                 shortest[u] = t + c;
//                 pq.push(make_pair(-(t + c), u));
//             }
//         }
//     }
// }

class Unionfind
{
vector<int> p;

public:
Unionfind(int n)
{
for (int i = 0; i < n; i++)
{
p.push_back(i);
}
}
int find(int x)
{
while (p[x] != x)
{
p[x] = p[p[x]];
x = p[x];
}
return x;
}
int getval(int x) { return p[x]; }
void unite(int x, int y)
{
x = find(x);
y = find(y);
if (x != y)
{
p[x] = y;
}
}

bool isunion(int x, int y) { return find(x) == find(y); }
void showtree() { cout << p; }
};

template <typename T>
class RangeMinorMaxorSumQuery // 0-index
{
int const intmax = 2147483647;
int const intmin = 0;
vector<T> sgt;
int n;
int k;

public:
RangeMinorMaxorSumQuery(int n1, T f = -1)
{
if (f == -1)
f = intmax;
else if (f == 0)
f = intmin;
int na = 1;
int ka = 0;
while (na < n1)
{
na *= 2;
ka++;
}
for (int i = 0; i < 2 * na; i++)
sgt.push_back(f);
n = na;
k = ka;
}

void update_min(int i, int x)
{
i += n;
sgt[i] = x;
while (i > 1)
{
i /= 2;
sgt[i] = min(sgt[2 * i], sgt[2 * i + 1]);
}
}
void update_max(int i, T x)
{
i += n;
sgt[i] = x;
while (i > 1)
{
i /= 2;
sgt[i] = max(sgt[2 * i], sgt[2 * i + 1]);
}
}
void update_sum(int i, T x)
{
i += n;
sgt[i] = x;
while (i > 1)
{
i /= 2;
sgt[i] = sgt[2 * i] + sgt[2 * i + 1];
}
}

void add_sum(int i, T x)
{
i += n;
sgt[i] += x;
while (i > 1)
{
i /= 2;
sgt[i] = sgt[2 * i] + sgt[2 * i + 1];
}
}

void add_min(int i, T x)
{
i += n;
sgt[i] += x;
while (i > 1)
{
i /= 2;
sgt[i] = min(sgt[2 * i], sgt[2 * i + 1]);
}
}

void add_max(int i, T x)
{
i += n;
sgt[i] += x;
while (i > 1)
{
i /= 2;
sgt[i] = max(sgt[2 * i], sgt[2 * i + 1]);
}
}

T get_min(int a, int b, int k = 1, int l = 0,
int r = -1) //閉区間 l <= x < r とする
{
if (r == -1)
r = n;
if (r <= a || b <= l)
return intmax;
if (a == l && b == r)
return sgt[k];
else
return min(
get_min(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2),
get_min(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r));
}
T get_max(int a, int b, int k = 1, int l = 0,
int r = -1) //閉区間 l <= x < r とする
{
if (r == -1)
r = n;
if (r <= a || b <= l)
return intmin;
if (a == l && b == r)
return sgt[k];
else
return max(
get_max(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2),
get_max(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r));
}
T get_sum(int a, int b, int k = 1, int l = 0,
int r = -1) //閉区間 l <= x < r とする
{
if (r == -1)
r = n;
if (r <= a || b <= l)
return intmin;
if (a == l && b == r)
return sgt[k];
else
return get_sum(a, min(b, (l + r) / 2), 2 * k, l, (l + r) / 2) +
get_sum(max(a, (l + r) / 2), b, 2 * k + 1, (l + r) / 2, r);
}

T operator[](int i) { return sgt[i + n]; }

void printsegtree()
{
for (int i = 0; i < 2 * n; i++)
{
cout << sgt[i] << " ";
}
cout << endl;
}
};

template <typename T>
class Bit_Index_Tree // 1-index

{
int n = 0;
vector<T> v;

public:
Bit_Index_Tree(int _n, T x = 0)
{
n = _n;
v.resize(n + 1);
fill(allpt(v), x);
}
Bit_Index_Tree(vector<T> _v)
{
n = _v.size();
v = _v;
}
void add(int i, T x)
{
while (i <= n)
{
v[i] += x;
i += i & -i;
}
}
T get_sum(int i)
{
T ret = 0;
while (i > 0)
{
ret += v[i];
i -= i & -i;
}
return ret;
}
T get_range_sum(int l, int r)
{ // 半開区間　l <= x < r
return get_sum(r) - get_sum(l);
}
};

// #define DEBUG

VI smallest_prime_factors(int n)
{
VI ret(n + 1);
iota(allpt(ret), 0);
for (int i = 2; i * i <= n; i++)
{
if (ret[i] == i)
{
for (int j = i * i; j <= n; j += i)
{
if (ret[j] == j)
ret[j] = i;
}
}
}
return ret;
}

class RangeSumQueryWithDelay // 0-index
{
ll const intmax = 2147483647;
ll const intmin = 0;
vector<ll> sgt;
vector<ll> sgt_deray;
int n;
int k;

public:
RangeSumQueryWithDelay(int n1, int f = -1)
{
if (f == -1)
f = intmax;
else if (f == 0)
f = intmin;
int na = 1;
int ka = 0;
while (na < n1)
{
na *= 2;
ka++;
}
for (int i = 0; i < 2 * na; i++)
{
sgt.push_back(f);
sgt_deray.emplace_back(0);
}
n = na;
k = ka;
}

void eval_add(int k, int l, int r)
{
if (sgt_deray[k] != 0)
{
sgt[k] += sgt_deray[k];
if (r - l > 1)
{
sgt_deray[2 * k] += sgt_deray[k] / 2;
sgt_deray[2 * k + 1] += sgt_deray[k] / 2;
}
sgt_deray[k] = 0;
}
}

void eval_update(int k, int l, int r)
{
if (sgt_deray[k] != 0)
{
sgt[k] = sgt_deray[k];
if (r - l > 1)
{
sgt_deray[2 * k] = sgt_deray[k];
sgt_deray[2 * k + 1] = sgt_deray[k];
}
sgt_deray[k] = 0;
}
}

void range_add(int a, int b, ll x, int k = 1, int l = 0, int r = -1)
{
if (r == -1)
r = n;
eval_add(k, l, r); //求める範囲とは違っても評価が行われることがある！
if (r <= a || b <= l)
return;
if (a <= l && r <= b)
{
sgt_deray[k] += (r - l) * x;
eval_add(k, l, r);
}
else
{
range_add(a, b, x, 2 * k, l, (l + r) / 2);
range_add(a, b, x, 2 * k + 1, (l + r) / 2, r);
sgt[k] = sgt[2 * k] + sgt[2 * k + 1];
}
}

void range_add_max(int a, int b, ll x, int k = 1, int l = 0, int r = -1)
{
if (r == -1)
r = n;
eval_update(k, l,
r); //求める範囲とは違っても評価が行われることがある！
if (r <= a || b <= l)
return;
if (a <= l && r <= b)
{
sgt_deray[k] += x;
eval_update(k, l, r);
}
else
{
range_add_max(a, b, x, 2 * k, l, (l + r) / 2);
range_add_max(a, b, x, 2 * k + 1, (l + r) / 2, r);
sgt[k] = max(sgt[2 * k], sgt[2 * k + 1]);
}
}

ll getsum(int a, int b, int k = 1, int l = 0,
int r = -1) //閉区間 l <= x < r とする
{
if (r == -1)
r = n;
if (r <= a || b <= l)
return intmin;
eval_add(k, l, r);
if (a <= l && r <= b)
{
return sgt[k];
}
else
{
auto v1 = getsum(a, b, 2 * k, l, (l + r) / 2);
auto v2 = getsum(a, b, 2 * k + 1, (l + r) / 2, r);
return v1 + v2;
}
}

ll getmax(int a, int b, int k = 1, int l = 0,
int r = -1) //閉区間 l <= x < r とする
{
if (r == -1)
r = n;
if (r <= a || b <= l)
return -inf;
eval_update(k, l, r);
if (a <= l && r <= b)
{
return sgt[k];
}
else
{
auto v1 = getmax(a, b, 2 * k, l, (l + r) / 2);
auto v2 = getmax(a, b, 2 * k + 1, (l + r) / 2, r);
return max(v1, v2);
}
}

void printsegtree()
{
for (int i = 0; i < 2 * n; i++)
{
cout << sgt[i] << " ";
}
cout << endl;
for (int i = 0; i < 2 * n; i++)
{
cout << sgt_deray[i] << " ";
}
cout << endl;
}
};

int main()
{
// cin.tie(0);
// ios::sync_with_stdio(false);
// リアクティブ問題のときはコメントアウト

#ifdef DEBUG
cout << "DEBUG MODE" << endl;
// ifstream in("input.txt");                             // for debug
// cin.rdbuf(in.rdbuf());                                // for debug
chrono::system_clock::time_point timestart, timeend; // for debug
timestart = std::chrono::system_clock::now();        // for debug

#endif

int n, frac_3{0}, a, b, c, d, ans{0};
string s, ans_str = "RBW";
cin >> n >> s;
VI frac_list(n, 1), frac_zero_list, char_list(n);

rep2(i, 1, n)
{
a = c = n - i;
b = d = i;
while (a % 3 == 0)
{
frac_3++;
a /= 3;
}
while (b % 3 == 0)
{
frac_3--;
b /= 3;
}
if (frac_3)
frac_zero_list.emplace_back(i);
a %= 3;
b %= 3;
frac_list[i] = (frac_list[i - 1] * a * b) % 3;
}
for (auto v : frac_zero_list)
frac_list[v] = 0;
rep(i, n)
{
switch (s[i])
{
case 'R':
char_list[i] = 0;
break;
case 'B':
char_list[i] = 1;
break;
case 'W':
char_list[i] = 2;
break;
}
}

rep(i, n) ans += frac_list[i] * char_list[i];
ans %= 3;
if (n % 2 == 0) ans = (3 - ans) % 3; 
cout << ans_str[ans] << rt;

#ifdef DEBUG
timeend = chrono::system_clock::now();
auto elapsed =
chrono::duration_cast<chrono::milliseconds>(timeend - timestart)
.count();
cout << "Time is " << elapsed << "ms" << std::endl;
#endif

return 0;
}

#include <iostream>
#include <vector>



long long solve(long long n2, long long n4, long long n6)
{
auto ans1 = std::min(n4, n6);
n4 -= ans1;
n6 -= ans1;
auto ans2 = std::min(n2 / 2, n6);
n2 -= ans2 * 2;
n6 -= ans2;
auto ans3 = std::min(n2, n4 / 2);
n2 -= ans3;
n4 -= ans3 * 2;
auto ans4 = std::min(n2 * 3, n4);
n2 -= ans4 * 3;
n4 -= ans4;
auto ans5 = n2 / 5;
n2 -= ans5 * 5;
return ans1 + ans2 + ans3 + ans4 + ans5;
}



int main()
{
int T;
std::cin >> T;

std::vector<long long> ans;
for (int t = 0; t < T; t++)
{
long long n2, n3, n4;
std::cin >> n2 >> n3 >> n4;
auto v = solve(n2, n4, n3 / 2);
ans.push_back(v);
}

for (auto& e : ans)
{
std::cout << e << std::endl;
}

return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*

*/
// 334, 3322, 442, 4222, 22222
ll d2[] = {0, 2, 1, 3, 5};
ll d3[] = {2, 2, 0, 0, 0};
ll d4[] = {1, 0, 2, 1, 0};

int main(){
cincout();

ll T;
cin >> T;

rep(i, T){
ll a, b, c;
cin >> a >> b >> c;
ll ans = 0;
rep(k, 5){
ll add = oo;
if (d2[k] > 0) chmin(add, a/d2[k]);
if (d3[k] > 0) chmin(add, b/d3[k]);
if (d4[k] > 0) chmin(add, c/d4[k]);
ans += add;
a -= add*d2[k];
b -= add*d3[k];
c -= add*d4[k];
}
cout << ans << endl;
}
}
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,a,b,v[N];
vector<int> va,vb;
signed main(){
scanf("%d%d%d",&n,&a,&b);
for(int i=1;!v[i];i=1ll*i*a%n) v[i]=1,va.push_back(i);
v[1]=0;
for(int i=1;!v[i];i=1ll*i*b%n) v[i]=1,vb.push_back(i);
if(va.size()*vb.size()<n-1) return puts("No"),0;
puts("Yes");
for(int x:vb) printf("%d ",x);
for(int i=vb.size()-1;~i;i--)
if((vb.size()-i)&1) for(int j=va.size()-1;j;j--) printf("%lld ",1ll*vb[i]*va[j]%n);
else for(int j=1;j<va.size();j++) printf("%lld ",1ll*vb[i]*va[j]%n);
puts("1");
return 0;
}
#ifdef _DEBUG
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

#define fs(n) fixed << setprecision(n)
#define mp(a, b) make_pair(a, b)
#define all(x) x.begin(), x.end()
using ll = long long;
using ld = long double;
#define query(t) while(t--)
#define aryin(a, n) for(int i = 0; i < n; i++) cin >> a[i];
#define chmin(a, b) a = min(a, b)
#define chmax(a, b) a = max(a, b)


int main(){
cin.tie(nullptr);
ios_base::sync_with_stdio(false);

int n; cin >> n;
vector<ll> a(n);
aryin(a, n);

for(int i = 1; i < n; i += 2){
a[i] = -a[i];
}

vector<ll> asum(all(a));
for(int i = 1; i < n; i++) asum[i] += asum[i - 1];

ll cur = 0;
ll ans = 0;
unordered_map<ll, int> m;
for(ll v : asum) m[v]++;
for(int i = 0; i < n; i++){
ans += m[cur];
cur += a[i];
m[asum[i]]--;
}

cout << ans << endl;
}
#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <tuple>
#include <vector>

using namespace std;

#define endl "\n"

// clang-format off
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }
#ifdef MIPPON_LOCAL
#define dbg(...) cerr <<"\e[38;5;214m" << "(" << #__VA_ARGS__ << "):" << "\e[39m", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif


template<const int &MOD>
struct modint {
int64_t n;
modint() : n(0) { ; }
modint(int64_t m) : n(m) {
if (n >= MOD) n %= MOD;
if (n < 0) n = (n % MOD + MOD) % MOD;
}
modint(uint64_t m) : n(m) {
if (n >= MOD) n %= MOD;
}
modint(int v) : modint(int64_t(v)) {}
modint(unsigned v) : modint(uint64_t(v)) {}

explicit operator int() const { return n; }
explicit operator unsigned() const { return n; }
explicit operator int64_t() const { return n; }
explicit operator uint64_t() const { return n; }
explicit operator double() const { return n; }
explicit operator long double() const { return n; }
modint& operator++() {
n = n == MOD - 1 ? 0 : n + 1;
return *this;
}
modint& operator--() {
n = n == 0 ? MOD - 1 : n - 1;
return *this;
}
modint operator++(int) {
modint before = *this;
++*this;
return before;
}
modint operator--(int) {
modint before = *this;
--*this;
return before;
}
modint operator-() const { return n == 0 ? 0 : MOD - n; }
friend bool operator==(const modint& a, const modint& b) { return a.n == b.n; }
friend bool operator!=(const modint& a, const modint& b) { return a.n != b.n; }
friend bool operator<(const modint& a, const modint& b) { return a.n < b.n; }
friend bool operator>(const modint& a, const modint& b) { return a.n > b.n; }
friend bool operator<=(const modint& a, const modint& b) { return a.n <= b.n; }
friend bool operator>=(const modint& a, const modint& b) { return a.n >= b.n; }
modint& operator+=(const modint& a) {
n += a.n;
if (n >= MOD) n -= MOD;
return *this;
}
modint& operator-=(const modint& a) {
n -= a.n;
if (n < 0) n += MOD;
return *this;
}
modint& operator*=(const modint& a) {
n = ((int64_t)n * a.n) % MOD;
return *this;
}
modint& operator/=(const modint& a) { return *this *= a.inv(); }
modint inv() const { return pow(MOD - 2); }

friend modint operator/(const modint& a, const modint& b) { return modint(a) /= b; }
friend modint operator+(const modint& a, const modint& b) { return modint(a) += b; }
friend modint operator-(const modint& a, const modint& b) { return modint(a) -= b; }
friend modint operator*(const modint& a, const modint& b) { return modint(a) *= b; }
friend modint operator^(modint a, int64_t n) {
if (n == 0) return modint(1);
modint res = (a * a) ^ (n / 2);
if (n % 2) res = res * a;
return res;
}

modint pow(int64_t p) const {
if (p < 0) return inv().pow(-p);
modint a = *this, result = 1;
while (p > 0) {
if (p & 1) result *= a;
p >>= 1;
if (p > 0) a *= a;
}
return result;
}
friend ostream& operator<<(ostream& os, const modint& a) { return os << a.n; }
};

extern const int MOD = int(1e9) + 7;
using mod_int = modint<MOD>;

// clang-format on
int64_t ceil_divison(int64_t a, int64_t b) {
return a / b + ((a ^ b) > 0 && a % b != 0);
}
int64_t floor_divison(int64_t a, int64_t b) {
return a / b - ((a ^ b) < 0 && a % b != 0);
}

void run_case() {

int A, B;
cin >> A >> B;

int pstart = 1e9, nstart = -1e9;
if (A == B) {
for (int i = 0; i < A; i++) {
cout << pstart << " ";
pstart--;
}
for (int j = 0; j < B; j++) {
cout << nstart << " ";
nstart++;
}

} else {

bool f = 0;
if (B > A)
f = 1;
int64_t diff = abs(B - A);
int64_t s = diff * (diff + 1) / 2;
vector<int64_t> C;
for (int i = 0; i < min(A, B) - 1; i++) {
C.push_back(pstart), C.push_back(nstart);
pstart--;
nstart++;
}
if (f) {
C.push_back(pstart), C.push_back(-(pstart - s));
} else {
C.push_back(nstart), C.push_back(pstart - s);
}

for (int i = 0; i < diff; i++)
C.push_back((f ? -(i + 1) : (i + 1)));
for (int i = 0; i < int(C.size()); i++)
cout << C[i] << " ";
}
}
int main() {
ios::sync_with_stdio(false);
#ifndef MIPPON_LOCAL
cin.tie(nullptr);
#endif

run_case();

return 0;
}

#include <bits/stdc++.h>

using namespace std;

#define INF 2000000000
#define INFL 1e18+1
#define MOD 1000000007
typedef long long ll;
typedef long double ld;


int main()
{
ll a1, a2, a3;
cin >> a1 >> a2 >> a3;


ll x = 2 * a2 - a1 - a3;

if (x==0) {
cout << 0 << "\n";
return 0;
}
if (x>0) {
cout << x << "\n";
return 0;
} else {
ll tmp = x * (-1);
tmp = (tmp + 1) / 2;
cout << x + (3*tmp) << "\n";
}
}

#include <bits/stdc++.h>
using namespace std;
int main() {
string judge = " ";
int h, w; cin >> h >> w;
char c[h][w];
bool c1 = false, c2 = false, c3 = false, c4 = false, c5 = false;
for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) cin >> c[i][j];
for(int i = 0; i < h; i++) {
for(int j = 0; j < w; j++) {
if(c[i][j] == '.') {
if(i != 0) judge += c[i-1][j];
if(j != 0) judge += c[i][j-1];
if(i != h-1) judge += c[i+1][j];
if(j != w-1) judge += c[i][j+1];
for(int k = 0; k < judge.size(); k++) {
if(judge[k] == '1') c1 = true;
else if(judge[k] == '2') c2 = true;
else if(judge[k] == '3') c3 = true;
else if(judge[k] == '4') c4 = true;
else c5 = true;
}
if(c1 == false) c[i][j] = '1';
else if(c2 == false) c[i][j] = '2';
else if(c3 == false) c[i][j] = '3';
else if(c4 == false) c[i][j] = '4';
else c[i][j] = '5';
c1 = false;
c2 = false;
c3 = false;
c4 = false;
c5 = false;
judge = " ";
}
}
}

for(int i = 0; i < h; i++) {
for(int j = 0; j < w; j++) {
cout << c[i][j];
}
cout << "\n";
}
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<20>(x).count())
#defne Yes(q) ((q) ? "Yes" : "No")
#dfine YES(q) ((q) ? "YES" : "NO")
#efine Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
templte <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
temlate <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
tmplate <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod = 1000000007;
const int mod998244353 = 998244353;

// 汎用構造体
struct edge { int to; long long cost; };

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;


int main()
{
string s;
cin >> s;
int n = s.size();
vector<vector<int>> vec(26);

rep(i, n) vec[s[i]-'a'].push_back(i+1);

rep(i, 26) 
{
int m = vec[i].size();
for(int j = 0; j < m; ++j) 
{
for(int k = j+1; k < m; ++k) 
{
if((vec[i][k]-vec[i][j]+1)/2 < k-j+1) {
//cout << vec[i][k]-vec[i][j]+1 << " " << k-j+1 << endl;
cout << vec[i][j] << " " << vec[i][k] << endl;
return 0;
}
}
}
}
cout << -1 << " " << -1 << endl;
}
#include<bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp> 
// #include <ext/pb_ds/detail/standard_policies.hpp>
// using namespace __gnu_pbds;

#pragma GCC optimize("O3")
#ifdef LOCAL
#include "/Users/lbjlc/Desktop/coding/debug_utils.h"
#else
#define print(...) ;
#define printn(...) ;
#define printg(...) ;
#define fprint(...) ;
#define fprintn(...) ;
#endif

#define rep(i, a, b) for(auto i = (a); i < (b); i++)
#define rrep(i, a, b) for(auto i = (a); i > (b); i--)
#define all(v) (v).begin(), (v).end()
#define pb push_back
// #define mp make_pair
#define fi first
#define se second
#define maxi(x, y) x = max(x, y)
#define mini(x, y) x = min(x, y)
// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }
// #define endl '\n'
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int get_random() {
static uniform_int_distribution<int> dist(0, 1e9 + 6);
return dist(rng);
}
const vector<pair<int,int>> eight_directions = {{1,1},{1,0},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};
const vector<pair<int,int>> four_directions = {{1,0},{0,1},{0,-1},{-1,0}};
#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}


typedef unsigned long long ull;
typedef long long ll;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef vector<long long> vll;
#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)

template<class T>
void make_unique(T & v) {
sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());
}
int geti() { int x; cin >> x; return x; }
long long getll() { long long x; cin >> x; return x; }
double getd() { double x; cin >> x; return x; }
// pair<int, int> a(geti(), geti()) does not work
// pair<int, int> a({geti(), geti()}) works, since it uses initializer.




const long long mod = 998244353;
struct mint{
long long x;

mint(): x(0) {}
mint(long long _x): x(_x) { 
if(x >= mod) x %= mod;
if(x < 0) x = x % mod + mod;
}
//operator long long() { return x; }

template<class T>
mint operator^(T b) const {
if(!b) return 1;
mint tmp = (*this) ^ (b / 2);
return b % 2 ? tmp * tmp * (*this) : tmp * tmp;
}

mint inv() const { 
static unordered_map<long long, long long> inv_dp;
if(inv_dp.count(x))
return inv_dp[x];
else if(inv_dp.size() < 100000)
return mint(inv_dp[x] = ((*this) ^ (mod - 2)).x);
else return (*this) ^ (mod - 2);
}

inline mint operator+(const mint & b) const { auto res = (x + b.x); if(res >= mod) return res - mod; else return res; }
inline mint operator-(const mint & b) const { auto res = (x - b.x); if(res < 0) return res + mod; else return res; }
inline mint operator*(const mint & b) const { return (x * b.x) % mod; }
inline mint operator/(const mint & b) const { return (*this) * b.inv(); }

inline mint & operator+=(const mint & b) { x += b.x; if(x >= mod) x -= mod; return *this; }
inline mint & operator-=(const mint & b) { x -= b.x; if(x < 0) x += mod; return *this; }
inline mint & operator*=(const mint & b) { x = (x * b.x) % mod; return *this; }
inline mint & operator/=(const mint & b) { x = (x * b.inv().x) % mod; return *this; }

bool operator==(const mint & b) const { return x == b.x; }
bool operator!=(const mint & b) const { return x != b.x; }
};
string to_string(const mint & x) { return to_string(x.x); }

istream & operator>>(istream & in, mint & x) { in >> x.x; return in; }
ostream & operator<<(ostream & o, const mint & x) { o << x.x; return o; }



const int MAXN = 5e5 + 100;

void solve(int tt) {
// cout<<"Case #"<<tt<<": ";
}

int a[MAXN];

int main(int argc, char * argv[]) {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
// solve_testcase;

int n;
cin>>n;

rep(i,0,n) cin>>a[i];

vector<pair<int, mint>> dp({{0, 0}, {a[0], 1}});

mint tot = a[0], offset = 0, sgn = 1;
// print(tot, offset, sgn, dp);
rep(i,1,n) {
if(a[i] > dp.back().first) {
mint new_tot = tot * (a[i] - 1);
offset = tot - offset;
sgn = mint(0) - sgn;
dp.push_back({a[i], (tot - offset) * sgn});
tot = new_tot;
}
else {
mint tmp_offset = 0;
while(a[i] <= dp[dp.size() - 2].first) {
tmp_offset += mint(dp.back().first - dp[dp.size() - 2].first) * (offset + sgn * dp.back().second);
dp.pop_back();
}
tmp_offset += mint(dp.back().first - a[i]) * (offset + sgn * dp.back().second);
dp.back().first = a[i];
mint new_tot = mint(a[i] - 1) * tot + tmp_offset;
offset = tot - offset;
sgn = mint(0) - sgn;
tot = new_tot;
}
// print(tot, offset, sgn, dp);
}
cout<<tot<<endl;

return 0;
}












#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll MOD=998244353;

int main(){
ll n;cin>>n;
ll ans=0;
for(ll i=1;i*i<=n;i++){
ans+=(n/i-i+2)/2;
ans%=MOD;
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
using namespace std;
#define f(i,a,b) for(int i=a; i<b; i++)
#define fr(i,a,b) for(int i=a; i>=b; i--)

#define fll(i,a,b) for(int i=a; i<b; i++)
#define frll(i,a,b) for(int i=a; i>=b; i--)
typedef vector<int> vi;
typedef long long int ll;
typedef vector<ll> vll;
#define fastio std::ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define PI 3.1415926535
// ll Mod = 1e9+7;

ll Mod = 998244353;
// vector<bool> status(1e6+1,1);
// vll primes;
// ll mult(ll a, ll b) {
//     ll ret = 1;
//     ret = ((a%Mod) * (b%Mod))%Mod;
//     return ret;
// }

// ll power(ll a, ll b) {
//     if(b == 0) return 1;
//     ll ret = 1;
//     while(b) {
//         if(b&1) {
//             ret = mult(ret,a);
//         }
//         a = mult(a,a);
//         b>>=1;
//     }
//     return ret;
// }

// ll sub(ll a, ll b) {
//     ll ret = (a%Mod - b%Mod + Mod)%Mod;
//     return ret;
// }

// void seive() {
//      for(ll i = 2; i*i <= 1e6; i++) {
//          if(status[i]) {
//             for(ll j = i*i; j<=1e6; j+=i) status[j] = 0;
//          }
//      }
//  }

// int getmex(vi& occr, int n, int mex) {
//     for(int i = mex; i<n; i++) {
//         if(occr[i] == 0) return i;
//     }
//     return n;
// }

// void swap(int &a, int &b) {
//     a = a + b;
//     b = a - b; 
//     a = a - b;
// }

// void build_primes() {
//     seive();
//     status[0] = status[1] = 0;
// }

// ll gcd(ll a, ll b) {
//     if(b == 0) return a;
//     return gcd(b,a%b);
// }


// //euclidean
// pair<int,int> euclidean(int a, int b) {
//     if(b == 0) return make_pair(1,0);

//     pair<int,int> p = euclidean(b,a%b);

//     pair<int,int> res;
//     res.first = p.second, res.second = p.first - (a/b)*p.second;
//     return res;

// }

// char b[402][402];
// int a[402][402];

// int get(int x2, int y2, int x1, int y1) {
//     return a[x2][y2] - a[x2][y1-1] - a[x1-1][y2] + a[x1-1][y1-1];
// }

void test_case() {
ll h,w,k;
cin>>h>>w>>k;
ll a[h],b[w];

ll sum_a = 0, sum_b = 0;
f(i,0,h) {
cin>>a[i];
sum_a = (sum_a+a[i])%k;
}
f(i,0,w) {
cin>>b[i];
sum_b = (sum_b+b[i])%k;
}

if(sum_a%k != sum_b%k) { 
cout<<-1;
return;
}

sum_a = 0, sum_b = 0;

f(i,0,h) 
a[i] = ((k-1)*w-a[i])%k;
f(i,0,w) 
b[i] = ((k-1)*h-b[i])%k;

f(i,0,h) 
sum_a = (sum_a+a[i]);
f(i,0,w) 
sum_b = (sum_b+b[i]);

cout<<h*w*(k-1) - max(sum_a,sum_b);
} 



int main() {
#ifndef ONLINE_JUDGE
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
#endif

fastio;

// build_primes();

int t = 1;
// cin>>t;
while(t--) {
test_case();
}
}   
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#include<bits/stdc++.h>
#include<string>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define umap unordered_map
#define lb lower_bound
#define ub upper_bound
#define vll vector<ll>
#define vvll vector<vll>
#define pll pair<ll,ll>
#define vpll vactor<pll>
#define nl "\n"
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
const ll M = 1e9 + 7; //const ll M=998244353;
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
cout << fixed << setprecision(15);
ll T = 1;
//   cin >> T;
while (T--)
{
ll n;
cin >> n;
ll m = n;
vll v;
while (n)
{
v.pb(n % 10);
n /= 10;
}
reverse(v.begin(), v.end());
ll s = v.size();
ll ans = 0;
for (int i = 1; i <= s; i++)
{
ll z = 0, y = 0;
ll cur = s - 1;
for (int j = 1; j <= i; j++)
{
z += (ll)(pow(10, cur) + 0.5);
y += ((ll)(pow(10, cur) + 0.5)) * v[j - 1];
cur--;
}
if (z > y)
break;
if (z == y)
{
if (i == s)
ans += i;
else
{
ans += i * (ll)(pow(10, s - i - 1) + 0.5) * (v[i] - (v[i] > 1) );
if (v[i] != 1)
{
y += ((ll)(pow(10, s - i - 1) + 0.5)) * v[i];
ans += i * (m - y + 1);
}
}
}
else
{
if (i == s)
ans += i;
else
ans += i * 9 * (ll)(pow(10, s - i - 1) + 0.5);
}
}
for (int i = 1; i < s; i++)
{
for (int j = 1; j <= i; j++)
{
if (i == j)
ans += j;
else
ans += j * 9 * (ll)(pow(10, i - j - 1) + 0.5);
}
}
cout << ans << nl;
}
}
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n;

int f(int x){
if(x==0) return 0;
int a=x/10,b=x%10;
if(b>=1&&b<=3&&f(a)<=1) return 1;
else if(b>=2&&b<=6&&f(a)<=2) return 2;
else if(b>=3&&b<=9&&f(a)<=3) return 3;
else if(b>=4&&f(a)<=4) return 4;//
if(b<=2&&f(a-1)<=4) return 4;
else return 5;
}

signed main(){
cin>>T;
while(T--){
cin>>n;
cout<<f(n)<<endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
long long t,n,pw[18]={1},b=1,ans=0;
string s;
cin>>s;
n=s.length();

for(int i=1;i<18;i++){
b*=10; 
pw[i]=pw[i-1]+b;
}

for(int i=0;i<n-1;i++){
ans+=pw[i];
}

for(int i=0;i<n;i++){
if(s[i]=='0') break;
else if(s[i]=='1' && i==n-1) ans++;
else if(s[i]=='1'){
string q=s.substr(i+1,n-i-1);
b=stoll(q,nullptr,10);
ans+=b+1;
}
else{ans+=pw[n-i-1]; break;}
}

cout<<ans;

return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define fw(p) for(int w=0;w<(p);w++)
#define fx(p) for(int x=0;x<(p);x++)
#define fy(p) for(int y=0;y<(p);y++)
#define fz(p) for(int z=0;z<(p);z++)
#define fyg(p,g) for(int y=(g);y<(p);y++)
#define fzg(p,g) for(int z=(g);z<(p);z++)
#define ce(d) cout<<d<<endl;
#define vecp(p) int aa;cin>>aa;(p).push_back(aa);
#define vecpl(p) long long aa;cin>>aa;(p).push_back(aa);
#define vecps(p) string aa;cin>>aa;(p).push_back(aa);
#define vecp2(p) cin>>aa;(p).push_back(aa);
#define vecpl2(p) long long a	b;cin>>ab;(p).push_back(ab);
#define vecps2(p) string ab;cin>>ab;(p).push_back(ab);
#define sorts(c) sort((c).begin(),(c).end());
#define reverses(c) reverse((c).begin(),(c).end());
#define vec(b) vector<int> (b);
#define vecl(b) vector<long long> (b);
#define vecs(b) vector<string> (b);
#define pb(b,a) (b).push_back((a));
#define doublece(a,b) cout<<(a)<<' '<<(b)<<endl;
#define pairs(s) vector<pair<int,int>> (s);
#define pairsp(s) int aa,bb;cin>>aa>>bb;(s).push_back(make_pair(aa,bb));
#define MOD 1000000007
#define cey ce("Yes")
#define cen ce("No")
#define ceY ce("YES")
#define ceN ce("NO")

int main()
{	
int N, K;
cin >> N >> K;
vector<pair<char, int>> G;
fx(K) {
char c; int k;
cin >> c >> k;
G.push_back(make_pair(c,k));
}

ll ans = 1;
ll mod = 998244353;
fx(N) {
ll next = K;
fy(K) {
if (G[y].first=='L') {
if (G[y].second==x+1) {
next = 1;
break;
}
else if (G[y].second > x+1) {
next--;
}
}
else {
if (G[y].second == x + 1) {
next = 1;
break;
}
else if (G[y].second < x + 1) {
next--;
}
}
}
ans *= next;
ans %= mod;
}
ce(ans)

return 0;
}


#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;
using ll = long long;
const int INF = INT_MAX;
const ll LINF = LLONG_MAX;
bool chmin(int& a, int b){ if(a > b){ a = b; return 1; } return 0; }
bool chmax(int& a, int b){ if(a < b){ a = b; return 1; } return 0; }
int mod = 1000000007;
int mod2 = 998244353;

int main() {
int N;
cin >> N;
vector<int> A(N), B(N), C(N);
for (int i = 0; i < N; i++) cin >> A[i];
for (int i = 0; i < N; i++) cin >> B[i];
for (int i = 0; i < N; i++) cin >> C[i];
sort(A.begin(), A.end());
sort(B.begin(), B.end());
sort(C.begin(), C.end());
int ans = 0;
set<int> stb, stc;
for (int i = 0; i <= N; i++) {
stb.insert(i);
stc.insert(i);
}
for (int i = 0; i < N; i++) {
int b = upper_bound(B.begin(), B.end(), A[i]) - B.begin();
b = *stb.lower_bound(b);
if (b == N) break;
stb.erase(b);
int c = upper_bound(C.begin(), C.end(), B[b]) - C.begin();
c = *stc.lower_bound(c);
if (c == N) break;
stc.erase(c);
ans++;
}
cout << ans << endl;
}
#include "cstdio"
#include <bits/stdc++.h>

using namespace std;

#define ll long long


int main() {
int n;
cin >> n;
int minR = 2e9;
int maxL = 0;
for(int i = 0; i < n; i++) {
int l , r;
cin >> l >> r;
minR = min(r, minR);
maxL = max(l, maxL);
cout << max(0, (maxL - minR + 1)/2) << '\n';
}
return 0;
}

#pragma GCC diagnostic ignored "-Wmisleading-indentation"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wunused-parameter" 
#pragma GCC diagnostic ignored "-Wunused-variable"
#include <bits/stdc++.h>
using namespace std;
//#include <atcoder/all>
//using namespace atcoder;

//#define BOOST
#ifdef BOOST
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/integer/extended_euclidean.hpp>
using mpi = boost::multiprecision::cpp_int;
using mpf = boost::multiprecision::cpp_dec_float_100;
#endif

//#define LONG_LONG_INT
#ifdef LONG_LONG_INT
using ll = int; using ld = double;
using ull = unsigned int;
const ll inf = 1000000000;
#else
using ll = long long; using ld = long double;
using ull = unsigned long long;
const ll inf = 2000000000000000000;
#endif

/***** type *****/
using str = string;
template <class T> using vec = vector<T>;
template <class T> using vvec = vector<vector<T>>;
using pll = pair<ll, ll>; using plb = pair<ll, bool>;
using vl = vec<ll>;  using vvl = vvec<ll>;
using vb = vec<bool>; using vvb = vvec<bool>;
using vc = vec<char>;  using vvc = vvec<char>;
using vs = vec<str>; using vvs = vvec<str>;
using vpll = vec<pll>; using vvpll = vvec<pll>;
using dl = deque<ll>; using dpll = deque<pll>;
using dc = deque<char>; using ds = deque<str>;
using sl = set<ll>; using spll = set<pll>;
using sc = set<char>; using ss = set<str>;
using ml = multiset<ll>; using mc = multiset<char>;
using pcl = pair<char, ll>; using psl = pair<str, ll>;
using mll = map<ll, ll>; using mlb = map<ll, bool>;
using mcl = map<char, ll>; using msl = map<str, ll>;
using lg = vec<vl>; using wlg = vec<vpll>;
/***** define *****/
#define all(c) (c).begin(), (c).end()            // begin to end
#define allr(c) (c).rbegin(), (c).rend()         // rbegin to rend
#define coutld cout << fixed << setprecision(10) // cout double
#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat
#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse
#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)
#define each(i, e, c) fori (i, auto&& e: c)      // for each
/***** const value *****/
const long long llong_max = 9223372036854775807; // 9 * 10^18
const long double pi = 3.1415926535897932384626; // 3.14 ...
const long double eps = LDBL_EPSILON;            // 2.22e-016
const size_t not_find = string::npos;            // string::find()
/***** function *****/
ll bit(ll x, ll i); // 整数xのi番目ビットが0か1か返す
ll bitcnt(ll x); // C++20 popcountと同じ
ll bitsize(ll x); // 2進数にしたときのサイズ
template <class T> pll bsearch(T& c, ll x, bool u = false); // 二分探索の結果を{ index,value }で返す（u = trueならupper_bound）
template <class ... T> void bug(T ... args); // デバッグ出力
ll ceildiv(ll x, ll y); // 除算の天井関数 ceil(x / y)
void input_directed_graph(ll v, ll e, lg& g, ll vfix = 0); // 頂点数v辺数eの有向グラフ入力
void input_directed_graph(ll v, ll e, wlg& g, ll vfix = 0);  // 頂点数v辺数eの重み付き有向グラフ入力
void input_graph(ll v, ll e, lg& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
void input_graph(ll v, ll e, wlg& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
template <class T> void inputc(ll xs, T& c); // 一次元コンテナ入力
template <class T> void inputc(ll xs, T& c, ll fix); // 一次元コンテナ入力
template <class T> void inputcc(ll ys, ll xs, T& cc); // 二次元コンテナ入力
template <class T> void inputcc(ll ys, ll xs, T& cc, ll fix); // 二次元コンテナ入力
template <class T> auto linear(T& c, ll i, bool r = false); // 線形アクセス c[i] （r = trueなら反転アクセス）
ll logll(ll a, ll b, bool u = false); // 底aのlog(b)切り捨て（u = trueならa進数bの桁数と同値）
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc); // 二次元配列生成
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill); // 二次元配列生成（fillは初期値）
template <class T> bool orange(ll x, vec<T>& v); // 配列の範囲外チェック
template <class T> bool orange(ll y, ll x, vvec<T>& v); // 二次元配列の範囲外チェック
template <class T> void outc(T& c, bool ex = true); // コンテナを直接出力
template <class T> void outc(T& c, ll fix, bool ex = true); // コンテナを直接出力
template <class T> void outcc(T& cc); // 二次元コンテナを直接出力
template <class T> void outcc(T& cc, ll fix); // 二次元コンテナを直接出力
template <class ... T> void outl(T ... args); // 可変引数を改行区切りで出力
template <class T> void outlc(T& c, bool ex = true); // コンテナを改行区切りで出力
template <class T> void outlc(T& c, ll fix, bool ex = true); // コンテナを改行区切りで出力
template <class ... T> void outs(T ... args); // 可変引数をスペース区切りで出力
template <class T> void outsc(T& c, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outsc(T& c, ll fix, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outscc(T& cc); // 二次元コンテナをスペース区切りで出力
template <class T> void outscc(T& cc, ll fix = 0); // 二次元コンテナをスペース区切りで出力
ll powll(ll x, ll n); // xのy乗をllで返す
template <class T> bool range(ll x, vec<T>& v); // 配列の範囲内チェック
template <class T> bool range(ll y, ll x, vvec<T>& v); // 二次元配列の範囲内チェック
template <class T> ll sizell(T& c); // c.size()をllで返す
str strlower(str& s); // 文字列を小文字に変換
str strupper(str& s); // 文字列を大文字に変換
char toch(ll x); // ll -> char
ll toll(char c); // char -> ll
lg tolg(wlg& g); // wlg -> lg
wlg towlg(lg& g, ll c = 0); // lg -> wlg (c = cost)
template <ll i, class T> void tsort(T b, T e); // pairやtupleをi番目の要素でソート
template <class T1, class ... T2> bool umax(T1& x, T2 ... args); // xを最大値に更新
template <class T1, class ... T2> bool umin(T1& x, T2 ... args); // xを最小値に更新
ll bit(ll x, ll i) { return ((x & (1ll << i)) != 0) ? 1 : 0; }
ll bitcnt(ll x) { bitset<64> b(x); return b.count(); }
ll bitsize(ll x) { return logll(x, 2, true); }
template <class T> pll bsearch(T& c, ll x, bool u) { auto res = (!u) ? lower_bound(all(c), x) : upper_bound(all(c), x); return (res == c.end()) ? pll(res - c.begin(), inf) : pll(res - c.begin(), *res); }
template <class ... T> void bug(T ... args) { for (auto e : { args ... }) cerr << " " << e; cerr << endl; }
ll ceildiv(ll x, ll y) { return (x % y == 0) ? x / y : x / y + 1; }
void input_directed_graph(ll v, ll e, lg& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b); }
void input_directed_graph(ll v, ll e, wlg& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }); }
void input_graph(ll v, ll e, lg& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b), g[b].push_back(a); }
void input_graph(ll v, ll e, wlg& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }), g[b].push_back({ a,w }); }
template <class T> void in(T& x) { cin >> x; }
template <> void in<pll>(pll& x) { cin >> x.first >> x.second; }
template <class T> void in(T& x, ll fix) { cin >> x; x += fix; }
template <> void in<pll>(pll& x, ll fix) { cin >> x.first >> x.second; x.first += fix, x.second += fix; }
template <class T> void inputc(ll xs, T& c) { c.resize(xs); each(i, e, c) in(e); }
template <class T> void inputc(ll xs, T& c, ll fix) { c.resize(xs); each(i, e, c) in(e, fix); }
template <class T> void inputcc(ll ys, ll xs, T& cc) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x]); }
template <class T> void inputcc(ll ys, ll xs, T& cc, ll fix) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x], fix); }
template <class T> auto linear(T& c, ll i, bool r) { auto it = c.begin(); auto rit = c.rbegin(); (!r) ? advance(it, i) : advance(rit, i); return (!r) ? *it : *rit; }
ll logll(ll a, ll b, bool u) { ll now = 1, res = (u) ? 1 : 0; while (now < b) res++, now *= a; return (now != b) ? res - 1 : res; }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs); }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs, fill); }
template <class T> bool orange(ll x, vec<T>& v) { return (x < 0 || ll(v.size()) <= x); }
tplate <class T> bool orange(ll y, ll x, vvec<T>& v) { return (y < 0 || ll(v.size()) <= y || x < 0 || ll(v[y].size()) <= x); }
template <class T> void out(T x, bool s) { (s) ? cout << " " << x : cout << x; }
teplate <> void out<pll>(pll x, bool s) { cout << x.first << " " << x.second; }
emplate <class T> void outc(T& c, bool ex) { for (auto e : c) cout << e; cout << endl; if (ex) exit(0); }
template <class T> void outc(T& c, ll fix, bool ex) { for (auto e : c) cout << e + fix; cout << endl; if (ex) exit(0); }
tepate <class T> void outcc(T& cc) { for (auto e : cc) outc(e, false); exit(0); }
templae <lass T> void outcc(T& cc, ll fix) { for (auto e : cc) outc(e, fix, false); exit(0); }
template <class ... T> void outl(T ... args) { each(i, e, { args ... }) out(e, false), cout << endl; exit(0); }
template <class T> void outlc(T& c, bool ex) { for (auto e : c) out(e, false), cout << endl; if (ex) exit(0); }
template <cass T> void outlc(T& c, ll fix, bool ex) { for (auto e : c) out(e + fix, false), cout << endl; if (ex) exit(0); }
template <class ... T> void outs(T ... args) { each(i, e, { args ... }) out(e, i); cout << endl; exit(0); }
template <class T> void outsc(T& c, bool ex) { each(i, e, c) out(e, i); cout << endl; if (ex) exit(0); }
template <clss T> void outsc(T& c, ll fix, bool ex) { each(i, e, c) out(e + fix, i); cout << endl; if (ex) exit(0); }
template <class T> void outscc(T& cc) { for (auto e : cc) outcs(e, false); exit(0); }
template <class T> void outscc(T& cc, ll fix) { for (auto e : cc) outcs(e + fix, false); exit(0); }
ll powll(ll x, ll n) { if (x == 2) return (1ll << n); ll z = 1; rep(i, 0, n) z *= x; return z; }
template <class T> bool range(ll x, vec<T>& v) { return !orange(x, v); }
template <class T> bool range(ll y, ll x, vvec<T>& v) { return !orange(y, x, v); }
template <class T> ll sizell(T& c) { return ll(c.size()); }
str strlower(str& s) { str res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(tolower(e)); return res; }
str strupper(str& s) { str res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(toupper(e)); return res; }
char toch(ll x) { return char('0' + x); }
ll toll(char c) { return ll(c) - ll('0'); }
lg tolg(wlg& g) { lg res(size(g)); each(i, e, g) for (auto [af, c] : e) res[i].push_back(af); return res; }
wlg towlg(lg& g, ll c) { wlg res(size(g)); each(i, e, g) for (auto af : e) res[i].push_back({ af,c }); return res; }
template <ll i, class T> void tsort(T b, T e) { sort(b, e, [&](const auto& l, const auto& r) { return get<i>(l) < get<i>(r); }); }
template <class T1, class ... T2> bool umax(T1& x, T2 ... args) { if (max({ args ... }) <= x) return false; x = max({ args ... }); return true; }
template <class T1, class ... T2> bool umin(T1& x, T2 ... args) { if (x <= min({ args ... })) return false; x = min({ args ... }); return true; }

/***************************************/
/********** BEGIN OF NYAA LIB **********/
/***************************************/

namespace NyaaLIB
{
/**
* @brief 欲張りセット
* @note
* 標準コンテナの頻出関数を全部定義したセット
**/

template <class T = long long, class U = std::less<T>> struct DS_NyaaAhriSet
{	// 降順は DS_NyaaAhriSet<greater<ll>> （デフォルトは昇順）
using ll = long long;
using sit = typename std::set<T>::iterator;
std::set<T> s;
DS_NyaaAhriSet() {}
DS_NyaaAhriSet(std::vector<T>& v) { for (auto e : v) s.insert(v); }
// set interface
sit begin() { return s.begin(); }
void clear() { s.clear(); }
bool empty() { return s.empty(); }
sit end() { return s.end(); }
std::pair<sit, sit> equal_range(T x) { return s.equal_range(); }
bool find(T x) { return s.find() != s.end(); }
void insert(T x) { s.insert(); }
T lower_bound(T x) { return *s.lower_bound(x); }
ll size() { return ll(s.size()); }
T upper_bound(T x) { return *s.upper_bound(x); }
// deque interface
T back() { return *s.rbegin(); }
T front() { return *s.begin(); }
T pop_back() { T res = *s.rbegin(); s.erase(res); return res; }
T pop_front() { T res = *s.begin(); s.erase(res); return res; }
void push_back(T x) { s.insert(x); }
void push_front(T x) { s.insert(x); }
// priority queue interface
T pop() { T res = *s.begin(); s.erase(res); return res; }
void push(T x) { s.insert(x); }
T top() { *s.begin(); }
};
}

namespace NyaaLIB
{
/**
* @brief 欲張りマルチセット
* @note
* 内部にunordered_mapを持つことでcount(x)を定数時間に高速化
* 標準コンテナの頻出関数を全部定義したマルチセット
**/

template <class T = long long, class U = std::less<T>> struct DS_NyaaGwenSet
{	// 降順は DS_NyaaPQMset<ll, greater<ll>> （デフォルトは昇順）
using ll = long long;
using sit = typename std::multiset<T>::iterator;
std::unordered_set<T> s;
std::multiset<T, U> ms;
std::unordered_map<T, ll> m;
DS_NyaaGwenSet() {}
DS_NyaaGwenSet(std::vector<ll>& v) { for (auto e : v) push(e); }
// multiset interface
sit begin() { return ms.begin(); }
void clear(void) { s.clear(), ms.clear(), m.clear(); }
ll count(T x) { return m[x]; }
bool empty(void) { return s.empty(); }
sit end() { return ms.end(); }
bool find(T x) { return s.find(x); }
void insert(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T lower_bound(T x) { return *ms.lower_bound(x); }
ll size(bool unique = false) { return (!unique) ? ll(ms.size()) : ll(s.size()); }
T upper_bound(T x) { return *ms.upper_bound(x); }
bool operator == (const DS_NyaaGwenSet& gs) { return (ms == gs.ms); }
ll erase(T x, bool all = false)
{
ll res = 1;
if (m[x] == 0) return 0;
if (!all) ms.erase(ms.find(x)), m[x]--;
else res = ms.erase(x), m[x] = 0;
if (m[x] == 0) s.erase(x);
return res;
}
// deque interface
T back() { return *ms.rbegin(); }
T front() { return *ms.begin(); }
void push_back(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
void push_front(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T pop_back()
{
auto res = *ms.rbegin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
T pop_front()
{
auto res = *ms.begin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
// priority queue interface
void push(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T top(void) { return *ms.begin(); }
T pop(void)
{
T res = *ms.begin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
};
}

namespace NyaaLIB
{
/**
* いもす法ライブラリ
* 区間加算O(1)、区間総和取得O(1)、更新処理O(N)
**/

template <class T = long long> struct DS_NyaaImos
{
using ll = long long;
ll sz;
std::vector<T> add;
std::vector<T> sum; // 累積和
std::vector<T> val; // 各要素の値

// 半開区間[0,size)、つまり閉区間[0,size-1]のメモリを確保する
DS_NyaaImos(ll size) : sz(size) { add.resize(sz), sum.resize(sz), val.resize(sz); }
DS_NyaaImos(std::vector<T>& v) : sz(ll(v.size()))
{	// 配列を入力としたときはメモリ確保と同時に累積和も作成する
add.resize(sz), sum.resize(sz), val = v, sum[0] = v[0];
for (ll i = 1; i < sz; i++) sum[i] += sum[i - 1] + val[i];
}

void Add(ll i, T x)
{	// 配列[i]に値xを加算する（範囲外なら何もしない）
if (i < 0 || sz <= i) return;
add[i] += x;
if (i == sz - 1) return;
add[i + 1] -= x;
}

/**
* @note
* 半開区間[l, r)に対して値xだけ加算する
* [l,r)が範囲外のときは範囲内に丸めて処理する
**/
void Add(ll l, ll r, T x)
{
if (l < 0) l = 0;
add[l] += x;
if (sz <= r) return;
add[r] -= x;
}

ll Range(ll l, ll r)
{	// 半開区間[l,r)の合計値を返す（lやrが範囲外のときは0を返す）
if (l < 0) l = 0;
if (sz < r) r = sz;
if (r <= 0 || sz <= l) return 0;
return (l == 0) ? sum[r - 1] : sum[r - 1] - sum[l - 1];
}

std::vector<T> Update(void)
{	// 結果を返すと同時に累積和の更新もする
for (ll i = 1; i < sz; i++) add[i] += add[i - 1];
for (ll i = 0; i < sz; i++) val[i] += add[i];
sum[0] = val[0];
for (ll i = 1; i < sz; i++) sum[i] = sum[i - 1] + val[i];
fill(all(add), 0);
return val;
}

// 配列[i]の値を返す
ll Val(ll i) { return val[i]; }
};
}

/***************************************/
/*********** END OF NYAA LIB ***********/
/***************************************/

using namespace NyaaLIB;
//using mint = NT_NyaaModINT< 998244353 >;
//using mint = NT_NyaaModINT< 1000000007 >;

int main(void)
{
str s; cin >> s;
if (sizell(s) == 2 && s[0] == s[1]) outs(1, 2);

rep(i, 0, sizell(s) - 2)
{
if (s[i] == s[i + 1]) outs(i + 1, i + 2);
if (s[i] == s[i + 2]) outs(i + 1, i + 3);
if (s[i + 1] == s[i + 2]) outs(i + 2, i + 3);
}

outs(-1, -1);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)
#define rep(i,n) REP(i,0,n)
#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)
#define rrep(i,n) RREP(i,(n)-1,0)
#define all(v) v.begin(), v.end()
#define endk '\n'
const int inf = 1e9+7;
const ll longinf = 1LL<<60;
const ll mod = 1e9+7;
const ll mod2 = 998244353;
const ld eps = 1e-10;
template<typename T1, typename T2> inline void chmin(T1 &a, T2 b){if(a>b) a=b;}
template<typename T1, typename T2> inline void chmax(T1 &a, T2 b){if(a<b) a=b;}

int main() {
cin.tie(0);
ios::sync_with_stdio(false);
int n, k; cin >> n >> k;
vector<int> A(k); rep(i, k) cin >> A[i];
vector<int> ans;
set<int> st;
rep(i, n) st.insert(i+1);
rep(i, k) {
if(i == k-1) {
vector<int> tmp;
for(auto s: st) tmp.push_back(s);
reverse(all(tmp));
for(auto s: tmp) ans.push_back(s);
} else {
if(*st.begin() == A[i]) {
ans.push_back(A[i]);
st.erase(A[i]);
} else {
ans.push_back(A[i]);
ans.push_back(*st.begin());
st.erase(A[i]);
st.erase(*st.begin());
}
}
}
assert((int)ans.size() == n);
rep(i, n) cout << ans[i] << ' '; cout << endk;
return 0;
}

#include <bits/stdc++.h>
#define DBGln(x) do { std::cerr << #x << ": " << x << std::endl; } while (0)
#define DBG(x) do { std::cerr << #x << ": " << x ; } while (0)
using namespace std;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};

template<typename T>
std::ostream& operator<<(std::ostream& s, const std::vector<T>& v){
s.put('[');
char comma[3] = {'\0', ' ', '\0'};
for (const auto& e : v) {
s << comma << e;
comma[0] = ',';
}
return s << ']';
}
template<typename T,typename T2>
std::ostream& operator<<(std::ostream& s, const std::pair<T,T2>& p){
s.put('{');
s<<p.first<<": "<<p.second;
return s << '}';
}
template<typename T>
std::ostream& operator<<(std::ostream& s, const std::vector<std::vector<T>>& v){
for(const auto& e : v){
s.put('[');
char comma[3] = {'\0', ' ', '\0'};
for (const auto& e2 : e) {
s << comma << e2;
comma[0] = ',';
}
s << ']'<<endl;
}
return s;
}
template<typename T,typename T2>
std::ostream& operator<<(std::ostream& s, const std::map<T,T2>& mp){
s.put('{');
char comma[3] = {'\0', ' ', '\0'};
for (const auto& p : mp) {
s << comma << p.first << ": "<<p.second;
comma[0] = ',';
}
return s << '}';
}
template<typename T>
std::ostream& operator<<(std::ostream& s, std::queue<T> q){
s<<"queue(";
char comma[3] = {'\0', ' ', '\0'};
while (!q.empty()){
s << comma <<q.front();
q.pop();
comma[0] = ',';
}
return s << ')';
}

void solve(long long N, std::vector<long long> A){
long long e;
if(N==1){
return;
}
for(int i=0;i<N-1;i++){
if(A[i]>A[i+1]){
e = A[i];
break;
}
else if (i+1==N-1){
e = A[i+1];
}
}
for(int i=0;i<N;i++){
if(A[i]!=e)
cout<<A[i]<<" ";
}
cout<<endl;
}
// Generated by 2.9.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main(){
long long N;
std::scanf("%lld", &N);
std::vector<long long> A(N);
for(int i = 0 ; i < N ; i++){
std::scanf("%lld", &A[i]);
}
solve(N, std::move(A));
return 0;
}

/*#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include <iomanip>//fixed,setprecision
#include <limits.n>//INT_MAX
#include <math.n>//M_PI
#include <random>
#include <regex> // 正規表現
#include <time.h>*/
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using mint = modint1000000007;
//using mint = modint998244353;
//std::chrono::time_point<std::chrono::steady_clock> start;
template <typename T> bool chmax(T &u, const T z) { if (u < z) {u = z; return true;} else return false; }
template <typename T> bool chmin(T &u, const T z) { if (u > z) {u = z; return true;} else return false; }
#define ll long long
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)
typedef pair<int, int> P;
ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }
ll lcm(ll a, ll b){return a * b / gcd(a, b);}

struct Student {
int sum,no, sugaku, eigo;

// 演算子オーバーロードで比較関数を定義
bool operator<(const Student& another) const {
if(sum!=another.sum)return sum>another.sum;
if (sugaku != another.sugaku)
return sugaku > another.sugaku; // 高い順に並べたいので演算子を逆に
if (eigo != another.eigo)
return eigo > another.eigo; // 同様に比較演算子を反転
return no < another.no;
}
};

const int mod=1000000007;
struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < mod);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
}c(555);

int main(){
int n,m;
cin>>n>>m;
vector<string>s(n);
rep(i,n)cin>>s[i];
ll gu=0;
ll ki=0;
rep(i,n){
ll tmp=0;
rep(j,m){
tmp+=s[i][j]-'0';
}
if(tmp%2==0)gu++;
else ki++;
}
ll ans=gu*ki;
cout<<ans<<endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

void solve();

int main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
int t = 1;
// cin>>t; // test case hain kya? 
while(t--){
solve();
cout<<"\n";
};
return 0;
}

void solve() {
long long a,b,c;
cin>>a>>b>>c;
if(b-a == c-b){
cout<<0;
return;
}
if(b >= (a+c)/2){
cout<<(2*b) - a - c;
}
else{
if((a+c)%2 == 0){
cout<<(a+c - 2*b)/2;
}
else{
cout<<(a+c - 2*b)/2 + 2;
}
}
}
#include <iostream>
#include <sstream>
#include <vector>
#include <iterator>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <cctype>
#include <cassert>
#include <utility>
#include <map>
#include <list>
#include <climits>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <bitset>
#include <string>

// #define cerr if(false)cerr
#define see(x) cerr << "> " << #x << ": " << x << "\n";

using namespace std;

template <typename T>
std::ostream &operator <<(std::ostream &out, vector<T> &v) {
for (typename vector<T>::size_type i = 0; i < v.size(); ++i)
out << v[i] << " ";
out << "\n";
return out;
}
template <typename T>
std::ostream &operator <<(std::ostream &out, set<T> &s) {
for (auto e : s)
out << e << " ";
out << "\n";
return out;
}
template <typename T>
std::ostream &operator <<(std::ostream &out, deque<T> &s) {
for (auto e : s)
out << e << " ";
out << "\n";
return out;
}
template <typename T, typename N>
std::ostream &operator <<(std::ostream &out, pair<T, N> &p) {
out << "(" << p.first << ", " << p.second << ") ";
return out;
}
template <typename T, typename N>
std::ostream &operator <<(std::ostream &out, vector<pair<T, N> > &v) {
for (size_t i = 0; i < v.size(); ++i)
cout << v[i];
out << "\n";
return out;
}
template <typename T, typename N>
std::ostream &operator <<(std::ostream &out, set<pair<T, N> > &s) {
for (auto p : s)
out << p;
out << "\n";
return out;
}
template <typename T>
std::ostream &operator <<(std::ostream &out, vector<vector<T> > &v) {
for (size_t i = 0; i < v.size(); ++i) {
for (size_t j = 0; j < v[i].size(); ++j) {
out << v[i][j] << " ";
}
out << "\n";
}
return out;
}
template <typename T>
std::ostream &operator <<(std::ostream &out, vector<set<T> > &v) {
for (size_t i = 0; i < v.size(); ++i) {
out << v[i];
}
out << "\n";
return out;
}

struct Query {
int t;
int n;
int c;
};

void solve() {
int h, w, c, q;
cin >> h >> w >> c >> q;

vector<Query> queries(q);
int t, n, x;
int i = 0;
while (q--) {
cin >> t >> n >> x;
queries[i] = {t, n, x};
++i;
}

map<int, int> rows, cols;
vector<long long> color_count(c + 1);
for (int i = queries.size() - 1; i >= 0; --i) {
if (queries[i].t == 1) {
if (!rows.count(queries[i].n)) {
color_count[queries[i].c] += w - cols.size();
rows[queries[i].n] = 1;
}
} else {
if (!cols.count(queries[i].n)) {
color_count[queries[i].c] += h - rows.size();
cols[queries[i].n] = 1;
}
}
}

for (int i = 1; i <= c; ++i) {
cout << color_count[i] << " ";
}

cout << "\n";

return ;
}

int main() {

std::ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);

int t;
t = 1;

while (t--) {
solve();
}

return 0;

}
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
int N;
cin >> N;
vector<int> A(N);
int XOR = 0;
for (int i = 0; i < N; i++) {
cin >> A[i];
XOR = XOR & ~A[i] | ~XOR & A[i];
}
if (N % 2 == 1)
cout << "Win" << endl;
else {
sort(A.begin(), A.end());
auto itr = lower_bound(A.begin(), A.end(), XOR);
cout << (itr != A.end() && *itr == XOR ? "Win" : "Lose") << endl;
}
return 0;
}
//#define _GLIBCXX_DEBUG
#include<bits/stdc++.h>
#include<atcoder/all>
#include<math.h>
#include<algorithm>
#define ALL(a) (a).begin(),(a).end()
#define RALL(a) (a).rbegin(),(a).rend()
using namespace std;
using namespace atcoder;
using ll = long long;
const ll INF=50000000000000000;
const ll dx[8]={1,0,-1,0,1,1,-1,-1};
const ll dy[8]={0,1,0,-1,1,-1,1,-1};
ll mod(ll x,ll m){return x & m;}
ll modinv(ll a,ll m){ll b=m,u=1,v=0;while(b){ll t=a/b;a-=t*b;swap(a,b);u-=t*v;swap(u,v);}u%=m;if(u<0){u+=m;}return u;}
ll modpow(ll a,ll n,ll m){ll res=1;while(n>0){if(n&1){res=(res%m)*(a%m)%m;}a=(a%m)*(a%m)%m;n>>=1;}return res;}
ll npow(ll a,ll n){ll res=1;while(n>0){if(n&1){res=res*a;}a=a*a;n>>=1;}return res;}
ll yaku(ll x){ll cnt=0;for(int i=1;i*i<=x;i++){if(x%i==0){if(i==x/i){cnt++;}else{cnt+=2;}}}return cnt;}
ll modwaru(ll a, ll b, ll m){a%=m;return a*modinv(b,m)%m;}

int main(){
ll N;
cin >> N;
vector<ll> A(N);
for(int i = 0; i < N; i++) cin >> A[i];
vector<ll> dp(N + 1, 0);//奇数-偶数
dp[1] = A[0];
for(int i = 2; i <= N; i++){
if(i % 2 == 0) dp[i] = dp[i - 1] - A[i - 1];
else dp[i] = dp[i - 1] + A[i - 1];
}
map<ll,ll> cnt;
ll ans = 0;
for(int i = 0; i <= N; i++) cnt[dp[i]]++;
for(pair<ll,ll> a : cnt){
ans += a.second * (a.second - 1) / 2;
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<long long> VL;
typedef vector<vector<long long>> VVL;
typedef pair<int,int> Pair;
typedef tuple<int,int,int> tpl;

#define ALL(a)  (a).begin(),(a).end()
#define SORT(c) sort((c).begin(),(c).end())
#define REVERSE(c) reverse((c).begin(),(c).end())
#define EXIST(m,v) (m).find((v)) != (m).end()
#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()
#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)
#define RREP(i,n) RFOR(i,n,0)

#define en "\n"

constexpr double EPS = 1e-9;
constexpr double PI  = 3.1415926535897932;
constexpr int INF = 2147483647;
constexpr long long LINF = 1LL<<60;
constexpr long long MOD =  998244353; // 1000000007;

template<class T> inline bool chmax(T& a, T b){if(a<b){a=b;return true;}return false;}
template<class T> inline bool chmin(T& a, T b){if(a>b){a=b;return true;}return false;}

struct Tree {
int N;
VVI edges;
VI depth, path, E;

Tree (int N): N(N) {
edges.resize(N);
depth.resize(N);
path.resize(N,0);
E.resize(N);
}

void add_edge(int from, int to){
edges[from].push_back(to);
edges[to].push_back(from);
}

void dfs(int v, int d, int par){
depth[v] = d;
for(int to : edges[v]){
if(to == par) continue;
dfs(to, d+1, v);
}
return;
}

int diameter(){
int r = 0;
REP(_,2){ 
dfs(r,0,r);
int mx=0; REP(i,N) if(chmax(mx, depth[i])) r = i;
}
int now = r;
while(depth[now] > 0){
path[now] = 1;
for(int to : edges[now]){
if(depth[now] != depth[to]+1) continue;
now = to;
break;
}
}
path[now] = 1;
return r;
}

VI solve(){
int r = diameter();
solve_v(r, 1, r);
return E;
}

int solve_v(int v, int Ev, int par){
E[v] = Ev;
int nxt = -1;
for(int to : edges[v]){
if(to == par) continue;
if(path[to]){
nxt = to;
continue;
}
Ev = solve_v(to, Ev+1, v);
}
if(nxt != -1) Ev = solve_v(nxt, Ev+1, v);
return Ev+1;
}
};

void Main(){
int N; cin >> N;
Tree tree(N);
REP(i,N-1){
int A,B; cin >> A >> B; A--; B--;
tree.add_edge(A,B);
}
VI ans = tree.solve();
REP(i,N) cout << ans[i] << " \n"[i==N-1];
return;
}

int main(void){
cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);
int t=1; //cin>>t;
while(t--) Main();
return 0;
};
#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
#include <tuple>
#include <cstdint>
#include <cstdio>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <bitset>
#include <cctype>
#include <climits>
#include <functional>
#include <cassert>

#define rep(i, n) for(int i = 0; i < (n); i++)
#define per(i, n) for(int i = (n) - 1; i >= 0; i--)
using ll = long long;
#define vi vector<int>
#define vvi vector<vi>
#define vl vector<ll>
#define pii pair<int, int>
#define pll pair<ll, ll>
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define mod 3
using namespace std;
template<class T, class U>
bool chmax(T &a, const U &b){ return a < b ? (a = b, 1) : 0; }
template<class T, class U>
bool chmin(T &a, const U &b){ return a > b ? (a = b, 1) : 0; }
struct mint{
ll x;
mint(ll x = 0) : x((x + mod) % mod){}
mint operator-() const{ return mint(-x); }
mint operator+=(const mint &a){
if((x += a.x) >= mod) x -= mod;
return *this;
}
mint &operator++(){
if(++x == mod) x = 0;
return *this;
}
mint operator++(int){
mint temp = *this;
if(++x == mod) x = 0;
return temp;
}
mint &operator-=(const mint &a){
if((x -= a.x) < 0) x += mod;
return *this;
}
mint &operator--(){
if(--x < 0) x += mod;
return *this;
}
mint operator--(int){
mint temp = *this;
if(--x < 0) x += mod;
return temp;
}
mint &operator*=(const mint &a){
(x *= a.x) %= mod;
return *this;
}
mint operator+(const mint &a) const{ return mint(*this) += a; }
mint operator-(const mint &a) const{ return mint(*this) -= a; }
mint operator*(const mint &a) const{ return mint(*this) *= a; }
mint pow(ll t) const{
if(!t) return 1;
mint res = 1, v = *this;
while(t){
if(t & 1) res *= v;
v *= v;
t >>= 1;
}
return res;
}
mint inv() const{ return pow(mod - 2); }
mint &operator/=(const mint &a){ return (*this) *= a.inv(); }
mint operator/(const mint &a) const{ return mint(*this) /= a; }
bool operator==(const mint &a) const{ return x == a.x; }
bool operator<(const mint &a) const{ return x < a.x; }
bool operator>(const mint &a) const{ return x > a.x; }
friend istream &operator>>(istream &is, mint &a){ return is >> a.x; }
friend ostream &operator<<(ostream &os, const mint &a){ return os << a.x; }
};
constexpr int len = 400010;
constexpr int f_size = min(len, mod);
mint fact[f_size], invfact[f_size], inv[f_size];
struct initializer {
initializer(){
fact[0] = fact[1] = inv[1] = 1;
invfact[0] = invfact[1] = 1;
for(int i = 2; i < f_size; i++){
fact[i] = fact[i - 1] * i;
inv[i] = -inv[mod % i] * (mod/i);
invfact[i] = invfact[i - 1] * inv[i];
}
}
} initializer;
mint C(int n, int r){
assert(0 <= n && n < len);
mint res = 1;
while(r){
int a = n % mod;
int b = r % mod;
if(a < b) return 0;
res *= fact[a] * invfact[b] * invfact[a - b];
n /= mod;
r /= mod;
}
return res;
}
mint H(int n, int r){
assert(0 < n && 0 <= r);
assert(0 < n+r && n+r <= len);
return C(n + r - 1, r);
}
int main(){
int n;
cin >> n;
vector<char> c(n);
int ans = 0;
rep(i, n){
cin >> c[i];
int val = C(n - 1, i).x;
if(c[i] == 'B'){
ans += 0 * val % 3;
}
if(c[i] == 'W'){
ans += 1 * val % 3;
}
if(c[i] == 'R'){
ans += 2 * val % 3;
}
ans %= 3;
}
if(!(n & 1)) ans = (-ans + 3) % 3;
if(ans == 0) cout << "B\n";
if(ans == 1) cout << "W\n";
if(ans == 2) cout << "R\n";
}
/**
*	author:	social_chameleon
*	created:	2022/01/19
*/

#pragma region MACROS

#pragma region HEADER
#pragma GCC optimize("O3")
#ifdef LOCAL
#include <debug_print.hpp>
#define debug(...) debug_print::multi_print(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...) (static_cast<void>(0))
#endif
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#pragma endregion
#pragma region TYPES
using ll = long long;
#define int ll
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pil = pair<int, ll>;
using pli = pair<ll, int>;
using ld = long double;
template <typename T>
using vc = vector<T>;
template <typename T>
using vvc = vector<vc<T>>;
template <typename T>
using vvvc = vector<vvc<T>>;
using vi = vc<int>;
using vl = vc<ll>;
using vb = vc<bool>;
using vpi = vc<pii>;
using vpl = vc<pll>;
template <class T>
using pq = priority_queue<T>;
template <class T>
using pqg = priority_queue<T, vector<T>, greater<T>>;
#pragma endregion
#pragma region UTILITY_FUNCTIONS
template <typename T>
int si(const T& x) { return x.size(); }
template <class T>
inline bool chmax(T& a, const T& b) { return (a < b ? a = b, 1 : 0); }
template <class T>
inline bool chmin(T& a, const T& b) { return (a > b ? a = b, 1 : 0); }
#define overload2(a, b, name, ...) name
#define overload4(a, b, c, d, name, ...) name
#define overload5(a, b, c, d, e, name, ...) name
#pragma endregion
#pragma region WORDS
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define ppb pop_back
#define ppf pop_front
#define eb emplace_back
#define ef emplace_front
#pragma endregion
#pragma region LOOPS
#define rep0(n) for (int _ = 0; _ < n; ++_)
#define rep1(i, n) for (ll i = 0; i < (n); ++i)
#define rep2(i, a, b) for (ll i = (a); i < (b); ++i)
#define rep3(i, a, b, c) for (ll i = (a); i < (b); i += (c))
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1, rep0)(__VA_ARGS__)
#define rrep0(n) for (int jidlsjf = 0; jidlsjf < n; ++jidlsjf)
#define rrep1(i, n) for (ll i = (n)-1; i >= 0; --i)
#define rrep2(i, a, b) for (ll i = (a)-1; i >= b; --i)
#define rrep3(i, a, b, c) for (ll i = (a)-1; i >= b; i -= c)
#define rrep(...) overload4(__VA_ARGS__, rrep3, rrep2, rrep1, rrep0)(__VA_ARGS__)
#define fore0(v) rep(a.size())
#define fore1(a, v) for (auto&& a : v)
#define fore2(a, b, v) for (auto&& [a, b] : v)
#define fore3(a, b, c, v) for (auto&& [a, b, c] : v)
#define fore4(a, b, c, d, v) for (auto&& [a, b, c, d] : v)
#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)
#pragma endregion
#pragma region CONTAINER_METHODS
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
template <typename T>
int closest(vector<T>& v, T x) {
int n = (int)v.size();
int pos = lower_bound(v.begin(), v.end(), x) - v.begin();
if (pos == 0) return pos;
if (pos == n) return n - 1;
return (v[pos] - x <= x - v[pos - 1]) ? pos : pos - 1;
}
#define all(c) begin(c), end(c)
#define rall(c) rbegin(c), rend(c)
#define SORT(v) sort(all(v))
#define REV(v) reverse(all(v))
#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())
template <typename T = ll, typename S>
T SUM(const S& v) { return accumulate(all(v), T(0)); }
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
template <typename T = int>
T mex(unordered_set<T> st) {
T ret = T(0);
while (st.count(ret) != 0) ++ret;
return ret;
}
#pragma endregion
#pragma region VECTOR_DEFINITIONS
#define vec(type, name, ...) vector<type> name(__VA_ARGS__)
#define vec2(type, name1, name2, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__)
#define vec3(type, name1, name2, name3, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__)
#define vec4(type, name1, name2, name3, name4, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__), name4(__VA_ARGS__)
#define vv(type, name, a, ...) vector<vector<type>> name(a, vector<type>(__VA_ARGS__))
#define vvv(type, name, a, b, ...) vector<vector<vector<type>>> name(a, vector<vector<type>>(b, vector<type>(__VA_ARGS__)))
#define vvvv(type, name, a, b, c, ...) vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))
constexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};
constexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
#pragma endregion
#pragma region TYPICAL_OUTPUT
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
const string firstsecond[2] = {"second", "first"};
const string FirstSecond[2] = {"Second", "First"};
const string possiblestr[2] = {"impossible", "possible"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
void first(bool t = 1) { cout << firstsecond[t] << endl; }
void First(bool t = 1) { cout << FirstSecond[t] << endl; }
void possible(bool t = 1) { cout << possiblestr[t] << endl; }
#pragma endregion
#pragma region INPUT
int scan() { return getchar(); }
void scan(signed& a) { cin >> a; }
void scan(long long& a) { cin >> a; }
void scan(char& a) { cin >> a; }
void scan(double& a) { cin >> a; }
void scan(string& a) { cin >> a; }
template <class T, class S>
void scan(pair<T, S>& p) { scan(p.first), scan(p.second); }
template <class T>
void scan(vector<T>& a) {
for (auto& i : a) scan(i);
}
template <class T>
void scan(T& a) { cin >> a; }
void IN() {}
template <class Head, class... Tail>
void IN(Head& head, Tail&... tail) {
scan(head);
IN(tail...);
}
#define INT(...)   \
int __VA_ARGS__; \
IN(__VA_ARGS__)
#define LL(...)   \
ll __VA_ARGS__; \
IN(__VA_ARGS__)
#define STR(...)      \
string __VA_ARGS__; \
IN(__VA_ARGS__)
#define CHR(...)    \
char __VA_ARGS__; \
IN(__VA_ARGS__)
#define DBL(...)      \
double __VA_ARGS__; \
IN(__VA_ARGS__)
#define VEC(type, name, size) \
vector<type> name(size);    \
IN(name)
#define VEC2(type, name1, name2, size)   \
vector<type> name1(size), name2(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i])
#define VEC3(type, name1, name2, name3, size)         \
vector<type> name1(size), name2(size), name3(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])
#define VEC4(type, name1, name2, name3, name4, size)               \
vector<type> name1(size), name2(size), name3(size), name4(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i])
#define VV(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
IN(name)
#pragma endregion
#pragma region MATH
static constexpr int inf = numeric_limits<int>::max() / 2;
static constexpr ll infll = numeric_limits<ll>::max() / 2;
static constexpr double infdbl = numeric_limits<double>::max() / 2;
template <typename T, typename S>
T ceil(T x, S y) {
assert(y);
return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S>
T floor(T x, S y) {
assert(y);
return (y < 0 ? floor(-x, -y)
: (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
template <class T>
ll POW(T x, int n) {
ll res = 1;
for (; n; n >>= 1, x *= x)
if (n & 1) res *= x;
return res;
}
template <class T, class S>
ll POW(T x, S n, const ll& mod) {
ll res = 1;
x %= mod;
for (; n; n >>= 1, x = x * x % mod)
if (n & 1) res = res * x % mod;
return res;
}
template <typename T>
map<T, int> factor(T n) {
map<T, int> ret;
for (T i = 2; i * i <= n; i++) {
while (n % i == 0) {
ret[i]++;
n /= i;
}
}
if (n != 1) ret[n] = 1;
return ret;
}
template <class T>
vector<T> divisor(T x) {
vector<T> ret;
for (T i = 1; i * i <= x; i++)
if (x % i == 0) {
ret.pb(i);
if (i * i != x) ret.pb(x / i);
}
return ret;
}
vector<int> cumsum(const vector<bool>& v) {
vector<int> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<T> cumsum(const vector<T>& v) {
vector<T> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<vector<T>> cumsum2d(const vector<vector<T>>& v) {
vector<vector<T>> ret = v;
for (int i = 0; i < (int)v.size(); ++i) {
for (int j = 0; j < (int)v[0].size(); ++j) {
if (i > 0) ret[i][j] += ret[i - 1][j];
if (j > 0) ret[i][j] += ret[i][j - 1];
if (i > 0 && j > 0) ret[i][j] -= ret[i - 1][j - 1];
}
}
return ret;
}
template <typename T>
T parsum2d(const vector<vector<T>>& cum, int i1, int i2, int j1, int j2) {
if (i1 > i2 || j1 > j2) return 0;
T ret = cum[i2][j2];
if (i1 > 0) ret -= cum[i1 - 1][j2];
if (j1 > 0) ret -= cum[i2][j1 - 1];
if (i1 > 0 && j1 > 0) ret += cum[i1 - 1][j1 - 1];
return ret;
}
template <typename T, typename S, typename U>
bool inc(const T& x, const S& l, const U& r) {
return l <= x and x < r;
}
constexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }
template <typename T>
T arith_sum_from_range(T first, T last, T diff = T(1)) {
assert((last - first) % diff == 0);
return ((last - first) / 2 + 1) * (first + last) / 2;
}
template <typename T, typename S>
T arith_sum_from_term(T first, S n, T diff = T(1)) {
return (2 * first + (n - 1) * diff) * n / 2;
}
#pragma endregion
#pragma region BIT_FUNCTIONS
ll pow2(int i) { return 1LL << i; }
#define bit(n, k) (((n) >> (k)) & 1)
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
constexpr ll mask(int n) { return (1LL << n) - 1; }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
template <typename T>
T inv_all_bit(T a) {
T ret = 0;
int n = topbit(a);
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_all_bit(T a, int n) {
T ret = 0;
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_bit(T a, int k) { return a ^ (1 << k); }
#pragma endregion
#pragma region PAIR_OPERATORS
template <class T, class S>
pair<T, S> operator-(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi - y.fi, x.se - y.se);
}
template <class T, class S>
pair<T, S> operator+(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi + y.fi, x.se + y.se);
}
template <class T>
pair<T, T> operator&(const pair<T, T>& l, const pair<T, T>& r) {
return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se));
}
template <class T, class S>
pair<T, S> operator+=(pair<T, S>& l, const pair<T, S>& r) {
return l = l + r;
}
template <class T, class S>
pair<T, S> operator-=(pair<T, S>& l, const pair<T, S>& r) {
return l = l - r;
}
template <class T>
bool intersect(const pair<T, T>& l, const pair<T, T>& r) {
return (l.se < r.se ? r.fi < l.se : l.fi < r.se);
}
#pragma endregion
#pragma region SEARCH
template <class F>
void bit_search(int n, const F& f) {
for (int i = 0; i < (1 << n); ++i) {
set<int> st;
for (int j = 0; j < n; ++j) {
if ((i >> j & 1) == 1) {
st.insert(j);
}
}
f(st);
}
}
template <class T, class F>
T bin_search(T ok, T ng, const F& f) {
while (abs(ok - ng) > 1) {
T mid = ok + ng >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search_double(T ok, T ng, const F& f, int iter = 80) {
while (iter--) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
#pragma endregion
#pragma region STRING
void ERASE(string& s, char c) { s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const string& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const vector<char>& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
template <typename T>
void ERASE(vector<T>& v, T x) { v.erase(remove(all(v), x), v.end()); }
template <typename T>
void ERASE(vector<T>& v, const vector<T>& list) { fore(x, list) v.erase(remove(all(v), x), v.end()); }
#pragma endregion
#pragma region OUTPUT
template <typename T, typename S>
ostream& operator<<(ostream& os, const pair<T, S>& p) {
os << p.first << " " << p.second;
return os;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < (int)v.size(); i++) {
os << v[i] << (((i + 1) != v.size()) ? " " : "");
}
return os;
}
void OUT() { cout << endl; }
template <class Head, class... Tail>
void OUT(const Head& head, const Tail&... tail) {
cout << head;
if (sizeof...(tail)) cout << ' ';
OUT(tail...);
}
template <typename T>
string pad(T n, int d, char c) {
ostringstream sout;
sout << setfill(c) << setw(d) << n;
return sout.str();
}
#pragma endregion
#pragma region GRAPH
template <typename T = int>
struct Edge {
int from, to;
T cost;
int id;

Edge() = default;
Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}

operator int() const {
return to;
}
};

template <typename T = int>
struct Graph {
vector<vector<Edge<T>>> g;
int edge_id;

Graph() = default;
explicit Graph(int n) : g(n), edge_id(0) {}

size_t size() const {
return g.size();
}

void add_directed_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id++);
}

void add_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id);
g[to].emplace_back(to, from, cost, edge_id++);
}

void read(int m, int padding = -1, bool weighted = false, bool directed = false) {
for (int i = 0; i < m; ++i) {
int a, b;
cin >> a >> b;
a += padding;
b += padding;
T c = T(1);
if (weighted) {
cin >> c;
}
if (directed) {
add_directed_edge(a, b, c);
} else {
add_edge(a, b, c);
}
}
}

inline vector<Edge<T>>& operator[](const int& k) {
return g[k];
}

inline const vector<Edge<T>>& operator[](const int& k) const {
return g[k];
}
};
#pragma endregion
#pragma region PARSE
inline int toi(char c) { return c - '0'; }
int toi(string s) { return stoi(s); }
ll toll(string s) { return stoll(s); }
template <typename T>
string tos(T x) {
return to_string(x);
}
inline char toc(int i) { return '0' + i; }
template <typename T>
string tobit(T x, size_t d) {
if (d <= 2)
return bitset<2>(x).to_string();
else if (d <= 4)
return bitset<4>(x).to_string();
else if (d <= 8)
return bitset<8>(x).to_string();
else if (d <= 16)
return bitset<16>(x).to_string();
else if (d <= 32)
return bitset<32>(x).to_string();
else
return bitset<64>(x).to_string();
}
#pragma endregion

#pragma endregion
constexpr signed MOD = 1e9 + 7;
// constexpr signed MOD = 998244353;
#pragma region MOD
template <signed mod>
struct ModInt {
signed x;

ModInt() : x(0) {}

ModInt(long long y) : x((y >= 0) ? (y % mod) : (mod - ((-y) % mod)) % mod) {}

ModInt& operator++() {
++x;
if (x == mod) {
x = 0;
}
return *this;
}

ModInt& operator--() {
if (x == 0) {
x = mod;
}
--x;
return *this;
}

ModInt operator++(signed) {
ModInt ret = *this;
++*this;
return ret;
}

ModInt operator--(signed) {
ModInt ret = *this;
--*this;
return ret;
}

ModInt& operator+=(const ModInt& p) {
if ((x += p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator-=(const ModInt& p) {
if ((x += mod - p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator*=(const ModInt& p) {
x = (int)(1LL * x * p.x % mod);
return *this;
}

ModInt& operator/=(const ModInt& p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt& p) const { return x == p.x; }

bool operator!=(const ModInt& p) const { return x != p.x; }

/**
*  拡張ユークリッドの互除法を用いた逆元計算
*  - time: O(logx)
*/
ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while (b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(long long n) const {
ModInt ret(1), mul(x);
while (n > 0) {
if (n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream& operator<<(ostream& os, const ModInt& p) { return os << p.x; }

friend istream& operator>>(istream& is, ModInt& a) {
long long t;
is >> t;
a = ModInt<mod>(t);
return (is);
}

static signed get_mod() { return mod; }
};

using mint = ModInt<MOD>;
using vmi = vc<mint>;
#pragma endregion

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(9);
cerr << fixed << setprecision(9);

INT(n);
VEC(int, a, n);
vi dp(n);
map<pii, int> mp;
rep(i, n) {
dp[i] = a[i] - (i == 0 ? 0 : dp[i - 1]);
++mp[pii(dp[i], i % 2)];
}
int ans = mp[pii(0, 0)] + mp[pii(0, 1)];
rep(i, n - 1) {
--mp[pii(dp[i], i % 2)];
ans += mp[pii(-dp[i], 1 - i % 2)] + mp[pii(dp[i], i % 2)];
}
OUT(ans);

return 0;
}
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
int N;
cin >> N;
vector<int> A(N);
int XOR = 0;
for (int i = 0; i < N; i++) {
cin >> A[i];
XOR = XOR & ~A[i] | ~XOR & A[i];
}
sort(A.begin(), A.end());
cout << (*lower_bound(A.begin(), A.end(), XOR) == XOR || N % 2 == 1 ? "Win" : "Lose") << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define F(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)
#define R(i, b, a) for (int i = (int)(b); i >= (int)(a); i--)
#define endl "\n"
#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define out(x) cout << x << endl, exit(0)
#define pii pair<int, int>
#define pb push_back
#define all(v) v.begin(), v.end()
#define I first
#define S second

int32_t main()
{
ios;

string a, b;
cin >> a >> b;

vector<int> aa[10], ab[10];
int id = 0;
int mx = 0;

F(k, 1, 9)
{

int ca[10] = {0}, cb[10] = {0};
for (auto it : a)
ca[it - '0']++;
for (auto it : b)
cb[it - '0']++;

if (ca[k] == 0)
continue;
ca[k]--;
aa[k].pb(k);

F(j, 10 - k, 9)
{
if (cb[j] > 0)
{
cb[j]--;
ab[k].pb(j);
break;
}
}

if (ab[k].size() == 0)
continue;

int done, carry = 0;
F(l, 1, max(a.size(), b.size()) - 1)
{
done = 0;

F(i, 1, 9)
{
F(j, 1, 9)
{
if (ca[i] == 0 || cb[j] == 0)
continue;
if (i + j >= 9)
{
aa[k].pb(i);
ab[k].pb(j);

ca[i]--;
cb[j]--;
done = 1;
break;
}
}
if (done)
break;
}

if (done)
{
carry++;
continue;
}

carry += ca[9] + cb[9];

R(i, 9, 1)
{
while (ca[i] > 0)
{
ca[i]--;
aa[k].pb(i);
}
while (cb[i] > 0)
{
cb[i]--;
ab[k].pb(i);
}
}

break;
}

if (carry > mx)
{
mx = carry;
id = k;
}
}

if (id == 0)
{
cout << a << endl;
cout << b << endl;
exit(0);
}

reverse(all(aa[id]));
reverse(all(ab[id]));

for (auto it : aa[id])
cout << it;
cout << endl;
for (auto it : ab[id])
cout << it;
cout << endl;
}
#include <cstdio>
#include <cmath>
#include <iostream>
#include <iomanip>
#include <string>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <deque>
#include <stack>
#include <tuple>
#include <bitset>
#include <complex>
using namespace std;

const int MAX_N = 100000 + 10;
int A[MAX_N];
int B[MAX_N];
int C[MAX_N];

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);

int N;
cin >> N;

priority_queue<int, vector<int>, greater<int> > pqa, pqb, pqc;
for (int i = 0; i < N; i++) {cin >> A[i]; pqa.push(A[i]);}
for (int i = 0; i < N; i++) {cin >> B[i]; pqb.push(B[i]);}
for (int i = 0; i < N; i++) {cin >> C[i]; pqc.push(C[i]);}

int ans = 0;
bool flag_b, flag_c;
int a, b, c;

while(!pqa.empty()) {
a = pqa.top();
pqa.pop();
//cerr << "a = " << a << endl;

while(!pqb.empty()) {
b = pqb.top();
pqb.pop();
//cerr << "  b = " << b << endl;

if(b <= a) continue;

while(!pqc.empty()) {
c = pqc.top();
pqc.pop();
//cerr << "    c = " << c << endl;

if(a < b && b < c) {
//cerr << "      (a,b,c) = " << a << ", " << b << ", " << c << endl;
ans++;
break;
}
}
break;
}
}

cout << ans << endl;
return 0;
}


#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)
#define rep(i,n) REP(i,0,n)
#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)
#define rrep(i,n) RREP(i,(n)-1,0)
#define all(v) v.begin(), v.end()
#define endk '\n'
const int inf = 1e9+7;
const ll longinf = 1LL<<60;
const ll mod = 1e9+7;
const ll mod2 = 998244353;
const ld eps = 1e-10;
template<typename T1, typename T2> inline void chmin(T1 &a, T2 b){if(a>b) a=b;}
template<typename T1, typename T2> inline void chmax(T1 &a, T2 b){if(a<b) a=b;}

int main() {
cin.tie(0);
ios::sync_with_stdio(false);
int n, m; cin >> n >> m;
vector<string> S(n); rep(i, n) cin >> S[i];
vector<int> cnt(2);
rep(i, n) {
int c = 0;
rep(j, m) {
c += (S[i][j] == '1');
}
cnt[c&1]++;
}

cout << 1LL*cnt[0]*cnt[1] << endk;
return 0;
}

#line 1 "Contests/AtCoder_arc059/arc059_b/main.cpp"
/* #define aclmodint */
/* #define aclsegtree */
/* #include <atcoder/all> */
/* using namespace atcoder; */

#line 1 "library/me/template.cpp"
// This is a dummy line
#ifndef ONLINE_JUDGE
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()
#define END(...) { print(__VA_ARGS__); return; }

#ifdef ONLINE_JUDGE
#define DBG(...) {}
#else
#define DBG(a) { cerr << #a << ": "; dbg(a); }
#endif

using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using ll = long long;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VS = vector<string>;
using VVS = vector<VS>;
using VVVS = vector<VVS>;
using VC = vector<char>;
using VVC = vector<VC>;
using VVVC = vector<VVC>;
using P = pair<int, int>;
using VP = vector<P>;
using VVP = vector<VP>;
using VVVP = vector<VVP>;
using LP = pair<ll, ll>;
using VLP = vector<LP>;
using VVLP = vector<VLP>;
using VVVLP = vector<VVLP>;

template <typename T>
using PQ = priority_queue<T>;
template <typename T>
using GPQ = priority_queue<T, vector<T>, greater<T>>;

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

#ifdef aclmodint

using MI7 = modint1000000007;
using V7 = vector<MI7>;
using VV7 = vector<V7>;
using VVV7 = vector<VV7>;
using MI3 = modint998244353;
using V3 = vector<MI3>;
using VV3 = vector<V3>;
using VVV3 = vector<VV3>;

ostream &operator<<(ostream &os, const modint &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI3 &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI7 &x) {
os << x.val();
return os;
}

istream &operator>>(istream &is, modint &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI3 &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI7 &x) {
int y; is >> y;
x = y;
return is;
}

#endif

void print() { cout << '\n'; }
template<typename T>
void print(const T &t) { cout << t << '\n'; }
template<typename Head, typename... Tail>
void print(const Head &head, const Tail &... tail) {
cout << head << ' ';
print(tail...);
}

#ifdef ONLINE_JUDGE
template<typename... Args>
void dbg(const Args &... args) {}
#else
void dbg() { cerr << '\n'; }
template<typename T>
void dbg(const T &t) { cerr << t << '\n'; }
template<typename Head, typename... Tail>
void dbg(const Head &head, const Tail &... tail) {
cerr << head << ' ';
dbg(tail...);
}
#endif

template< typename T1, typename T2 >
ostream &operator<<(ostream &os, const pair< T1, T2 >& p) {
os << p.first << " " << p.second;
return os;
}

template< typename T1, typename T2 >
istream &operator>>(istream &is, pair< T1, T2 > &p) {
is >> p.first >> p.second;
return is;
}

template< typename T >
ostream &operator<<(ostream &os, const vector< T > &v) {
for(int i = 0; i < (int) v.size(); i++) {
os << v[i] << (i + 1 != (int) v.size() ? " " : "");
}
return os;
}

template< typename T >
istream &operator>>(istream &is, vector< T > &v) {
for(T &in : v) is >> in;
return is;
}

template< typename T1, typename T2 >
inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

template< typename T1, typename T2 >
inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

template <typename T>
pair<VI, vector<T>> compress(const vector<T> &a) {
int n = a.size();
vector<T> x;
REP(i, n) x.push_back(a[i]);
sort(ALL(x)); x.erase(unique(ALL(x)), x.end());
VI res(n);
REP(i, n) res[i] = lower_bound(ALL(x), a[i]) - x.begin();
return make_pair(res, x);
}

#ifdef aclsegtree

template<typename S>
struct value_size { S value; int size; };

template<typename S>
S min_op(S l, S r) { return min(l, r); };
template<typename S>
S max_op(S l, S r) { return max(l, r); };
template<typename S>
S sum_op(S l, S r) { return l + r; };
template<typename S>
value_size<S> sum_op_size(value_size<S> l, value_size<S> r) {
return {l.value + r.value, l.size + r.size};
};

template<typename S>
S min_e() { return  numeric_limits<S>::max(); };
template<typename S>
S max_e() { return numeric_limits<S>::min(); };
template<typename S>
S sum_e() { return 0; }
template<typename S>
value_size<S> sum_e_size() { return {0, 0}; }
template<typename S>
value_size<S> min_e_size() { return {numeric_limits<S>::max(), 0}; }
template<typename S>
value_size<S> max_e_size() { return {numeric_limits<S>::min(), 0}; }

template<typename S, typename F>
S chmin_mapping(F f, S x) { return min(x, f); }
template<typename S, typename F>
S chmax_mapping(F f, S x) { return max(x, f); }
template<typename S, typename F>
S add_mapping(F f, S x) { return x + f; }
template<typename S, typename F>
value_size<S> add_mapping_size(F f, value_size<S> x) {
return {x.value + x.size * f, x.size};
}
template <typename S,typename F, F ID>
S change_mapping(F f, S x) { return (f == ID? x : f); }
template <typename S,typename F, F ID>
S change_mapping_size(F f, value_size<S> x) { return (f == ID? x : value_size<S>(f, x.size)); }
template <typename S, typename F1, typename F2>
S linear_mapping(pair<F1, F2> f, S x) { return x * f.first + f.second; }
template <typename S, typename F1, typename F2>
value_size<S> linear_mapping_size(pair<F1, F2> f, value_size<S> x) { return {x.value * f.first + x.size * f.second, x.size}; }

template<typename F>
F chmin_composition(F f, F g) { return min(f, g); }
template<typename F>
F chmax_composition(F f, F g) { return max(f, g); }
template<typename F>
F add_composition(F f, F g) { return f + g; }
template <typename F, F ID>
F change_composition(F f, F g) { return (f == ID? g : f); }
template<typename F1, typename F2>
pair<F1, F2> linear_composition(pair<F1, F2> f, pair<F1, F2> g) { return {f.first * g.first, f.first * g.second + f.second}; }

template<typename F>
F chmin_id() { return numeric_limits<F>::max(); }
template<typename F>
F chmax_id() { return numeric_limits<F>::min(); }
template<typename F>
F add_id() { return 0; }
template<typename F, F ID>
F change_id() { return ID; }
template<typename F1, typename F2>
pair<F1, F2> linear_id() { return {1, 0}; }

template<typename S>
using RSumQ = segtree<S, sum_op<S>, sum_e<S>>;
template<typename S>
using RMaxQ = segtree<S, max_op<S>, max_e<S>>;
template<typename S>
using RMinQ = segtree<S, min_op<S>, min_e<S>>;

template<typename S, typename F>
using RAddSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, add_mapping_size<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RMinMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, chmin_mapping<S, F>, chmin_composition<F>, chmin_id<F>>;
template<typename S, typename F>
using RMaxMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, chmax_mapping<S, F>, chmax_composition<F>, chmax_id<F>>;
template<typename S, typename F, F ID>
using RChangeMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, change_mapping_size<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F1, typename F2>
using RLinearMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
pair<F1, F2>, linear_mapping_size<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
#endif
#line 7 "Contests/AtCoder_arc059/arc059_b/main.cpp"

void solve(){
string s; cin >> s;
REP(i, 26) {
char c = 'a' + i;
int cur = 0;
P mn = {0, 0};
REP(j, s.length()) {
if(s[j] == c) cur++;
else cur--;
if((cur - mn.first) > 0 && j+1 - mn.second >= 2) {
END(mn.second + 1, j + 1);
}
chmin(mn, P(cur, j + 1));
}
}
print(-1, -1);
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
//cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define f(i,a,b) for(int i=a; i<b; i++)
#define fr(i,a,b) for(int i=a; i>=b; i--)

#define fll(i,a,b) for(int i=a; i<b; i++)
#define frll(i,a,b) for(int i=a; i>=b; i--)
typedef vector<int> vi;
typedef long long int ll;
typedef vector<ll> vll;
#define fastio std::ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define PI 3.1415926535
ll Mod = 1e9+7;

// ll Mod = 998244353;
// vector<bool> status(1e3+1,1);
// vi primes;

// ll mult(ll a, ll b) {
//     ll ret = 1;
//     ret = (a*b)%Mod;
//     return ret;
// }

// ll power(ll a, ll b) {
//     if(b == 0) return 1;
//     ll ret = 1;
//     while(b) {
//         if(b&1) {
//             ret = mult(ret,a);
//         }
//         a = mult(a,a);
//         b>>=1;
//     }
//     return ret;
// }

// ll sub(ll a, ll b) {
//     ll ret = (a%Mod - b%Mod + Mod)%Mod;
//     return ret;
// }

// void seive() {
//      for(ll i = 2; i*i <= 1e3; i++) {
//          if(status[i]) {
//             for(ll j = i*i; j<=1e3; j+=i) {
//                 status[j] = 0;
//             }
//          }
//      }
// }

// int getmex(vi& occr, int n, int mex) {
//     for(int i = mex; i<n; i++) {
//         if(occr[i] == 0) return i;
//     }
//     return n;
// }

// void swap(int &a, int &b) {
//     a = a + b;
//     b = a - b; 
//     a = a - b;
// }

// void build_primes() {
//     seive();
//     f(i,2, 1e3+1) {
//         if(status[i]) primes.push_back(i);
//     } 
// }

// ll gcd(ll a, ll b) {
//     if(b == 0) return a;
//     return gcd(b,a%b);
// } 

// ll fact[200001];
void test_case() {
int n;
cin>>n;
int a[n];
f(i,0,n) {
cin>>a[i];
}

int x = a[n-1];
fr(i,n-2,0) {
if(a[i+1] < a[i]) 
x = a[i]; 
}
f(i,0,n) {
if(a[i] == x) 
continue;
cout<<a[i]<<' ';
}
}

int main() {
#ifndef ONLINE_JUDGE
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
#endif

fastio;

// fact[0] = fact[1] = 1;

// f(i,2,200001)
//     fact[i] = mult(i,fact[i-1]);

// build_primes();

int t = 1;

// cin>>t;
while(t--) {
test_case();
}
}   
/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

int n, k;
cin >> n >> k;
vector<int> a(k);
rep(i, k) cin >> a[i];
set<int> s;
repr(i, 1, n) s.insert(i);
vector<int> ans;
ans.reserve(n);
rep(i, k-1) {
ans.push_back(a[i]);
if (*s.begin() != a[i]) {
ans.push_back(*s.begin());
s.erase(s.begin());
}
s.erase(a[i]);
}
for (auto it = s.rbegin(); it != s.rend(); ++it) ans.push_back(*it);
dump(ans);

cout << flush;
return 0;
}

#pragma GCC diagnostic ignored "-Wmisleading-indentation"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wunused-parameter" 
#pragma GCC diagnostic ignored "-Wunused-variable"
#include <bits/stdc++.h>
using namespace std;
//#include <atcoder/all>
//using namespace atcoder;

//#define BOOST
#ifdef BOOST
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/integer/extended_euclidean.hpp>
using mpi = boost::multiprecision::cpp_int;
using mpf = boost::multiprecision::cpp_dec_float_100;
#endif

//#define LONG_LONG_INT
#ifdef LONG_LONG_INT
using ll = int; using ld = double;
using ull = unsigned int;
const ll inf = 1000000000;
#else
using ll = long long; using ld = long double;
using ull = unsigned long long;
const ll inf = 2000000000000000000;
#endif

/***** type *****/
using str = string;
template <class T> using vec = vector<T>;
template <class T> using vvec = vector<vector<T>>;
using pll = pair<ll, ll>; using plb = pair<ll, bool>;
using vl = vec<ll>;  using vvl = vvec<ll>;
using vb = vec<bool>; using vvb = vvec<bool>;
using vc = vec<char>;  using vvc = vvec<char>;
using vs = vec<str>; using vvs = vvec<str>;
using vpll = vec<pll>; using vvpll = vvec<pll>;
using dl = deque<ll>; using dpll = deque<pll>;
using dc = deque<char>; using ds = deque<str>;
using sl = set<ll>; using spll = set<pll>;
using sc = set<char>; using ss = set<str>;
using ml = multiset<ll>; using mc = multiset<char>;
using pcl = pair<char, ll>; using psl = pair<str, ll>;
using mll = map<ll, ll>; using mlb = map<ll, bool>;
using mcl = map<char, ll>; using msl = map<str, ll>;
using lg = vec<vl>; using wlg = vec<vpll>;
/***** define *****/
#define all(c) (c).begin(), (c).end()            // begin to end
#define allr(c) (c).rbegin(), (c).rend()         // rbegin to rend
#define coutld cout << fixed << setprecision(10) // cout double
#define rep(i, b, e) for (ll i = b; i < e; i++)  // repeat
#define repr(i, b, e) for (ll i = b; e < i; i--) // repeat reverse
#define fori(i, ...) if (ll i = -1) for(__VA_ARGS__) if (i++, 1)
#define each(i, e, c) fori (i, auto&& e: c)      // for each
/***** const value *****/
const long long llong_max = 9223372036854775807; // 9 * 10^18
const long double pi = 3.1415926535897932384626; // 3.14 ...
const long double eps = LDBL_EPSILON;            // 2.22e-016
const size_t not_find = string::npos;            // string::find()
/***** function *****/
ll bit(ll x, ll i); // 整数xのi番目ビットが0か1か返す
ll bitcnt(ll x); // C++20 popcountと同じ
ll bitsize(ll x); // 2進数にしたときのサイズ
template <class T> pll bsearch(T& c, ll x, bool u = false); // 二分探索の結果を{ index,value }で返す（u = trueならupper_bound）
template <class ... T> void bug(T ... args); // デバッグ出力
ll ceildiv(ll x, ll y); // 除算の天井関数 ceil(x / y)
void input_directed_graph(ll v, ll e, lg& g, ll vfix = 0); // 頂点数v辺数eの有向グラフ入力
void input_directed_graph(ll v, ll e, wlg& g, ll vfix = 0);  // 頂点数v辺数eの重み付き有向グラフ入力
void input_graph(ll v, ll e, lg& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
void input_graph(ll v, ll e, wlg& g, ll vfix = 0); // 頂点数v辺数eのグラフ入力
template <class T> void inputc(ll xs, T& c); // 一次元コンテナ入力
template <class T> void inputc(ll xs, T& c, ll fix); // 一次元コンテナ入力
template <class T> void inputcc(ll ys, ll xs, T& cc); // 二次元コンテナ入力
template <class T> void inputcc(ll ys, ll xs, T& cc, ll fix); // 二次元コンテナ入力
template <class T> auto linear(T& c, ll i, bool r = false); // 線形アクセス c[i] （r = trueなら反転アクセス）
ll logll(ll a, ll b, bool u = false); // 底aのlog(b)切り捨て（u = trueならa進数bの桁数と同値）
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc); // 二次元配列生成
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill); // 二次元配列生成（fillは初期値）
template <class T> bool orange(ll x, vec<T>& v); // 配列の範囲外チェック
template <class T> bool orange(ll y, ll x, vvec<T>& v); // 二次元配列の範囲外チェック
template <class T> void outc(T& c, bool ex = true); // コンテナを直接出力
template <class T> void outc(T& c, ll fix, bool ex = true); // コンテナを直接出力
template <class T> void outcc(T& cc); // 二次元コンテナを直接出力
template <class T> void outcc(T& cc, ll fix); // 二次元コンテナを直接出力
template <class ... T> void outl(T ... args); // 可変引数を改行区切りで出力
template <class T> void outlc(T& c, bool ex = true); // コンテナを改行区切りで出力
template <class T> void outlc(T& c, ll fix, bool ex = true); // コンテナを改行区切りで出力
template <class ... T> void outs(T ... args); // 可変引数をスペース区切りで出力
template <class T> void outsc(T& c, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outsc(T& c, ll fix, bool ex = true); // コンテナをスペース区切りで出力
template <class T> void outscc(T& cc); // 二次元コンテナをスペース区切りで出力
template <class T> void outscc(T& cc, ll fix = 0); // 二次元コンテナをスペース区切りで出力
ll powll(ll x, ll n); // xのy乗をllで返す
template <class T> bool range(ll x, vec<T>& v); // 配列の範囲内チェック
template <class T> bool range(ll y, ll x, vvec<T>& v); // 二次元配列の範囲内チェック
template <class T> ll sizell(T& c); // c.size()をllで返す
str strlower(str& s); // 文字列を小文字に変換
str strupper(str& s); // 文字列を大文字に変換
char toch(ll x); // ll -> char
ll toll(char c); // char -> ll
lg tolg(wlg& g); // wlg -> lg
wlg towlg(lg& g, ll c = 0); // lg -> wlg (c = cost)
template <ll i, class T> void tsort(T b, T e); // pairやtupleをi番目の要素でソート
template <class T1, class ... T2> bool umax(T1& x, T2 ... args); // xを最大値に更新
template <class T1, class ... T2> bool umin(T1& x, T2 ... args); // xを最小値に更新
ll bit(ll x, ll i) { return ((x & (1ll << i)) != 0) ? 1 : 0; }
ll bitcnt(ll x) { bitset<64> b(x); return b.count(); }
ll bitsize(ll x) { return logll(x, 2, true); }
template <class T> pll bsearch(T& c, ll x, bool u) { auto res = (!u) ? lower_bound(all(c), x) : upper_bound(all(c), x); return (res == c.end()) ? pll(res - c.begin(), inf) : pll(res - c.begin(), *res); }
template <class ... T> void bug(T ... args) { for (auto e : { args ... }) cerr << " " << e; cerr << endl; }
ll ceildiv(ll x, ll y) { return (x % y == 0) ? x / y : x / y + 1; }
void input_directed_graph(ll v, ll e, lg& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b); }
void input_directed_graph(ll v, ll e, wlg& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }); }
void input_graph(ll v, ll e, lg& g, ll vfix) { ll a, b; g.resize(v); rep(i, 0, e) cin >> a >> b, a += vfix, b += vfix, g[a].push_back(b), g[b].push_back(a); }
void input_graph(ll v, ll e, wlg& g, ll vfix) { ll a, b, w; g.resize(v); rep(i, 0, e) cin >> a >> b >> w, a += vfix, b += vfix, g[a].push_back({ b,w }), g[b].push_back({ a,w }); }
template <class T> void in(T& x) { cin >> x; }
template <> void in<pll>(pll& x) { cin >> x.first >> x.second; }
template <class T> void in(T& x, ll fix) { cin >> x; x += fix; }
template <> void in<pll>(pll& x, ll fix) { cin >> x.first >> x.second; x.first += fix, x.second += fix; }
template <class T> void inputc(ll xs, T& c) { c.resize(xs); each(i, e, c) in(e); }
template <class T> void inputc(ll xs, T& c, ll fix) { c.resize(xs); each(i, e, c) in(e, fix); }
template <class T> void inputcc(ll ys, ll xs, T& cc) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x]); }
template <class T> void inputcc(ll ys, ll xs, T& cc, ll fix) { makecc(ys, xs, cc); rep(y, 0, ys) rep(x, 0, xs) in(cc[y][x], fix); }
template <class T> auto linear(T& c, ll i, bool r) { auto it = c.begin(); auto rit = c.rbegin(); (!r) ? advance(it, i) : advance(rit, i); return (!r) ? *it : *rit; }
ll logll(ll a, ll b, bool u) { ll now = 1, res = (u) ? 1 : 0; while (now < b) res++, now *= a; return (now != b) ? res - 1 : res; }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs); }
template <class T> void makecc(ll ys, ll xs, vvec<T>& cc, T fill) { cc.resize(ys); rep(y, 0, ys) cc[y].resize(xs, fill); }
template <class T> bool orange(ll x, vec<T>& v) { return (x < 0 || ll(v.size()) <= x); }
template <class T> bool orange(ll y, ll x, vvec<T>& v) { return (y < 0 || ll(v.size()) <= y || x < 0 || ll(v[y].size()) <= x); }
template <class T> void out(T x, bool s) { (s) ? cout << " " << x : cout << x; }
template <> void out<pll>(pll x, bool s) { cout << x.first << " " << x.second; }
template <class T> void outc(T& c, bool ex) { for (auto e : c) cout << e; cout << endl; if (ex) exit(0); }
template <class T> void outc(T& c, ll fix, bool ex) { for (auto e : c) cout << e + fix; cout << endl; if (ex) exit(0); }
template <class T> void outcc(T& cc) { for (auto e : cc) outc(e, false); exit(0); }
template <class T> void outcc(T& cc, ll fix) { for (auto e : cc) outc(e, fix, false); exit(0); }
template <class ... T> void outl(T ... args) { each(i, e, { args ... }) out(e, false), cout << endl; exit(0); }
template <class T> void outlc(T& c, bool ex) { for (auto e : c) out(e, false), cout << endl; if (ex) exit(0); }
template <class T> void outlc(T& c, ll fix, bool ex) { for (auto e : c) out(e + fix, false), cout << endl; if (ex) exit(0); }
template <class ... T> void outs(T ... args) { each(i, e, { args ... }) out(e, i); cout << endl; exit(0); }
template <class T> void outsc(T& c, bool ex) { each(i, e, c) out(e, i); cout << endl; if (ex) exit(0); }
template <class T> void outsc(T& c, ll fix, bool ex) { each(i, e, c) out(e + fix, i); cout << endl; if (ex) exit(0); }
template <class T> void outscc(T& cc) { for (auto e : cc) outcs(e, false); exit(0); }
template <class T> void outscc(T& cc, ll fix) { for (auto e : cc) outcs(e + fix, false); exit(0); }
ll powll(ll x, ll n) { if (x == 2) return (1ll << n); ll z = 1; rep(i, 0, n) z *= x; return z; }
template <class T> bool range(ll x, vec<T>& v) { return !orange(x, v); }
template <class T> bool range(ll y, ll x, vvec<T>& v) { return !orange(y, x, v); }
template <class T> ll sizell(T& c) { return ll(c.size()); }
str strlower(str& s) { str res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(tolower(e)); return res; }
str strupper(str& s) { str res; for (auto e : s) if ('a' <= e && e <= 'z') res.push_back(toupper(e)); return res; }
char toch(ll x) { return char('0' + x); }
ll toll(char c) { return ll(c) - ll('0'); }
lg tolg(wlg& g) { lg res(size(g)); each(i, e, g) for (auto [af, c] : e) res[i].push_back(af); return res; }
wlg towlg(lg& g, ll c) { wlg res(size(g)); each(i, e, g) for (auto af : e) res[i].push_back({ af,c }); return res; }
template <ll i, class T> void tsort(T b, T e) { sort(b, e, [&](const auto& l, const auto& r) { return get<i>(l) < get<i>(r); }); }
template <class T1, class ... T2> bool umax(T1& x, T2 ... args) { if (max({ args ... }) <= x) return false; x = max({ args ... }); return true; }
template <class T1, class ... T2> bool umin(T1& x, T2 ... args) { if (x <= min({ args ... })) return false; x = min({ args ... }); return true; }

/***************************************/
/********** BEGIN OF NYAA LIB **********/
/***************************************/

namespace NyaaLIB
{
/**
* @brief 欲張りセット
* @note
* 標準コンテナの頻出関数を全部定義したセット
**/

template <class T = long long, class U = std::less<T>> struct DS_NyaaAhriSet
{	// 降順は DS_NyaaAhriSet<greater<ll>> （デフォルトは昇順）
using ll = long long;
using sit = typename std::set<T>::iterator;
std::set<T> s;
DS_NyaaAhriSet() {}
DS_NyaaAhriSet(std::vector<T>& v) { for (auto e : v) s.insert(v); }
// set interface
sit begin() { return s.begin(); }
void clear() { s.clear(); }
bool empty() { return s.empty(); }
sit end() { return s.end(); }
std::pair<sit, sit> equal_range(T x) { return s.equal_range(); }
bool find(T x) { return s.find() != s.end(); }
void insert(T x) { s.insert(); }
T lower_bound(T x) { return *s.lower_bound(x); }
ll size() { return ll(s.size()); }
T upper_bound(T x) { return *s.upper_bound(x); }
// deque interface
T back() { return *s.rbegin(); }
T front() { return *s.begin(); }
T pop_back() { T res = *s.rbegin(); s.erase(res); return res; }
T pop_front() { T res = *s.begin(); s.erase(res); return res; }
void push_back(T x) { s.insert(x); }
void push_front(T x) { s.insert(x); }
// priority queue interface
T pop() { T res = *s.begin(); s.erase(res); return res; }
void push(T x) { s.insert(x); }
T top() { *s.begin(); }
};
}

namespace NyaaLIB
{
/**
* @brief 欲張りマルチセット
* @note
* 内部にunordered_mapを持つことでcount(x)を定数時間に高速化
* 標準コンテナの頻出関数を全部定義したマルチセット
**/

template <class T = long long, class U = std::less<T>> struct DS_NyaaGwenSet
{	// 降順は DS_NyaaPQMset<ll, greater<ll>> （デフォルトは昇順）
using ll = long long;
using sit = typename std::multiset<T>::iterator;
std::unordered_set<T> s;
std::multiset<T, U> ms;
std::unordered_map<T, ll> m;
DS_NyaaGwenSet() {}
DS_NyaaGwenSet(std::vector<ll>& v) { for (auto e : v) push(e); }
// multiset interface
sit begin() { return ms.begin(); }
void clear(void) { s.clear(), ms.clear(), m.clear(); }
ll count(T x) { return m[x]; }
bool empty(void) { return s.empty(); }
sit end() { return ms.end(); }
bool find(T x) { return s.find(x); }
void insert(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T lower_bound(T x) { return *ms.lower_bound(x); }
ll size(bool unique = false) { return (!unique) ? ll(ms.size()) : ll(s.size()); }
T upper_bound(T x) { return *ms.upper_bound(x); }
bool operator == (const DS_NyaaGwenSet& gs) { return (ms == gs.ms); }
ll erase(T x, bool all = false)
{
ll res = 1;
if (m[x] == 0) return 0;
if (!all) ms.erase(ms.find(x)), m[x]--;
else res = ms.erase(x), m[x] = 0;
if (m[x] == 0) s.erase(x);
return res;
}
// deque interface
T back() { return *ms.rbegin(); }
T front() { return *ms.begin(); }
void push_back(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
void push_front(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T pop_back()
{
auto res = *ms.rbegin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
T pop_front()
{
auto res = *ms.begin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
// priority queue interface
void push(T x) { if (++m[x] == 1) s.insert(x); ms.insert(x); }
T top(void) { return *ms.begin(); }
T pop(void)
{
T res = *ms.begin();
if (--m[res] == 0) s.erase(res);
ms.erase(ms.find(res));
return res;
}
};
}

/***************************************/
/*********** END OF NYAA LIB ***********/
/***************************************/

using namespace NyaaLIB;
//using mint = NT_NyaaModINT< 998244353 >;
//using mint = NT_NyaaModINT< 1000000007 >;

int main(void)
{
str s; cin >> s;
if (sizell(s) == 2 && s[0] == s[1]) outs(1, 2);

rep(i, 0, sizell(s) - 2)
{
if (s[i] == s[i + 1]) outs(i + 1, i + 2);
if (s[i] == s[i + 2]) outs(i + 1, i + 3);
if (s[i + 1] == s[i + 2]) outs(i + 2, i + 3);
}

outs(-1, -1);
return 0;
}
#include "cstdio"
#include <bits/stdc++.h>

using namespace std;

#define ll long long


int main() {
int n;
cin >> n;
int minR = 2e9;
int maxL = 0;
for(int i = 0; i < n; i++) {
int l , r;
cin >> l >> r;
minR = min(r, minR);
maxL = max(l, maxL);
cout << max(0, (maxL - minR + 1)/2) << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define fw(p) for(int w=0;w<(p);w++)
#define fx(p) for(int x=0;x<(p);x++)
#define fy(p) for(int y=0;y<(p);y++)
#define fz(p) for(int z=0;z<(p);z++)
#define fyg(p,g) for(int y=(g);y<(p);y++)
#define fzg(p,g) for(int z=(g);z<(p);z++)
#define ce(d) cout<<d<<endl;
#define vecp(p) int aa;cin>>aa;(p).push_back(aa);
#define vecpl(p) long long aa;cin>>aa;(p).push_back(aa);
#define vecps(p) string aa;cin>>aa;(p).push_back(aa);
#define vecp2(p) cin>>aa;(p).push_back(aa);
#define vecpl2(p) long long a	b;cin>>ab;(p).push_back(ab);
#define vecps2(p) string ab;cin>>ab;(p).push_back(ab);
#define sorts(c) sort((c).begin(),(c).end());
#define reverses(c) reverse((c).begin(),(c).end());
#define vec(b) vector<int> (b);
#define vecl(b) vector<long long> (b);
#define vecs(b) vector<string> (b);
#define pb(b,a) (b).push_back((a));
#define doublece(a,b) cout<<(a)<<' '<<(b)<<endl;
#define pairs(s) vector<pair<int,int>> (s);
#define pairsp(s) int aa,bb;cin>>aa>>bb;(s).push_back(make_pair(aa,bb));
#define MOD 1000000007
#define cey ce("Yes")
#define cen ce("No")
#define ceY ce("YES")
#define ceN ce("NO")

int main()
{	
int N;
cin >> N;

vec(A); vec(B);
fx(N) {
vecp(A);
}
fx(N) {
vecp(B);
}

set<int> ANS;
fx(N) {
map<int, int> K;
fy(N) {
K[B[y]]++;
}
int k = A[0] ^ B[x];
K[B[x]]--;
bool flag = true;
for (int y = 1; y < N;y++) {
if (K[A[y]^k]==0) {
flag = false; break;
}
K[A[y] ^ k]--;
}
if (flag)ANS.insert(k);
}
ce(ANS.size())
for (int ans : ANS) {
ce(ans)
}
return 0;
}


/**
____ ____ ____ ____ ____
||a |||t |||o |||d |||o ||
||__|||__|||__|||__|||__||
|/__\|/__\|/__\|/__\|/__\|

**/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N_MAX = 200000;

int N;

ll A[N_MAX + 2];

ll B[N_MAX + 2];
ll C[N_MAX + 2];

ll p[N_MAX * 2 + 2];

int main () {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);

cin >> N;
for (int i = 1; i <= N; i++) {
cin >> A[i];
}

B[1] = A[1]; C[1] = 0;
for (int i = 2; i <= N; i++) {
B[i] = B[i - 1] + max((ll) 0, A[i] - A[i - 1]);
C[i] = C[i - 1] - min((ll) 0, A[i] - A[i - 1]);
}

for (int i = 1; i <= N; i++) {
p[i] = B[i];
}
for (int i = N + 1; i <= N * 2; i++) {
p[i] = C[i - N];
}

sort(p + 1, p + N * 2 + 1);

ll answer = 0;
for (int i = 1; i <= N * 2; i++) {
answer += abs(p[i] - p[N]);
}
cout << answer << "\n";

return 0;
}

#include<bits/stdc++.h>
using namespace std;

long solve(string S){
vector dp(S.length(), vector(S.length()+1, vector(2, vector(2, 0L))));//dp[i文字目まで見た時の][連続する1の個数][tight性]['1'のstreakはあるか]
for(long m0 = 0; m0 <= S[0] - '0'; m0++){
dp[0][(m0 == 1)][(m0 == S[0] - '0')][(m0 == 1)]++;
}
for(long i = 0; i < S.length() - 1; i++){
for(long j = 0; j < S.length(); j++){
for(long k1 = 0; k1 <= 1; k1++){
for(long s1 = 0; s1 <= 1; s1++){
//dp[i][j][k1][s1]を配ります
for(long k2 = 0; k2 <= 1; k2++){
for(long s2 = 0; s2 <= 1; s2++){
for(long m = 0; m <= 9; m++){
if(k1 == 1 and k2 == 1 and m != S[i+1] - '0') continue;
if(k1 == 1 and k2 == 0 and m >= S[i+1] - '0') continue;
if(k1 == 0 and k2 == 1) continue;
if(s1 == 1 and s2 == 1 and m != 1) continue;
if(s1 == 1 and s2 == 0 and m == 1) continue;
if(s1 == 0 and s2 == 1) continue;
long j2 = j;
if(s1 == 1 and s2 == 1) j2++;
dp[i+1][j2][k2][s2] += dp[i][j][k1][s1];
}
}
}
}
}
}
}
long res = 0;
for(long j = 1; j <= S.length(); j++)
for(long k = 0; k <= 1; k++)
for(long s = 0; s <= 1; s++)
res += j * dp[S.length() - 1][j][k][s];
return res;
}

int main(){
string S; cin >> S;
long res = 0;
res += solve(S);
for(long i = 1; i < S.length(); i++){
res += solve(string("9", S.length() - i));
}
cout << res << '\n';
}
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#include<bits/stdc++.h>
#include<string>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define umap unordered_map
#define lb lower_bound
#define ub upper_bound
#define vll vector<ll>
#define vvll vector<vll>
#define pll pair<ll,ll>
#define vpll vactor<pll>
#define nl "\n"
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
const ll M = 1e9 + 7; //const ll M=998244353;
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
cout << fixed << setprecision(15);
ll T = 1;
//   cin >> T;
while (T--)
{
ll n;
cin >> n;
ll m = n;
vll v;
while (n)
{
v.pb(n % 10);
n /= 10;
}
reverse(v.begin(), v.end());
ll s = v.size();
ll ans = 0;
for (int i = 1; i <= s; i++)
{
ll z = 0, y = 0;
ll cur = s - 1;
for (int j = 1; j <= i; j++)
{
z += (ll)(pow(10, cur) + 0.5);
y += ((ll)(pow(10, cur) + 0.5)) * v[j - 1];
cur--;
}
if (z > y)
break;
if (z == y)
{
if (i == s)
{
ans += i;
}
else
{
ans += i * (ll)(pow(10, s - i - 1) + 0.5) * (v[i] - (v[i] > 1) );
if (v[i] != 1)
{
y += ((ll)(pow(10, s - i - 1) + 0.5)) * v[i];
ans += i * (m - y + 1);
}
}
}
else
{
if (i == s)
{
ans += i;
}
else
{
ans += i * 9 * (ll)(pow(10, s - i - 1) + 0.5);
}
}
}
for (int i = 1; i < s; i++)
{
for (int j = 1; j <= i; j++)
{
if (i == j)
{
ans += j;
}
else
{
ans += j * 9 * (ll)(pow(10, i - j - 1) + 0.5);
}
}
}
cout << ans << nl;
}
}
#include<bits/stdc++.h>
using namespace std;

#define int long long

int t,n;

map<int,int>m;

int f(int x){
if(!x) return 0;
if(m.count(x)) return m[x];
int a=x/10,b=x%10;
for(int i=1;i<4;++i)
if(i<=b && b<=3*i && f(a)<=i)
return m[x]=i;
if((4<=b && b<10 && f(a)<5) || (0<=b && b<=2 && f(a-1)<5))
return m[x]=4;
return m[x]=5;
}

signed main(){
scanf("%lld",&t);
while(t--){
m.clear();
scanf("%lld",&n);
printf("%lld\n",f(n));
}
return 0;
}
#include <bits/stdc++.h>
#include <random>
#include <array>
#ifdef _MSC_VER
#include <ppl.h>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#else
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

/** compro_io **/

/* tuple */
// out
namespace aux {
template<typename T, unsigned N, unsigned L>
struct tp {
static void output(std::ostream& os, const T& v) {
os << std::get<N>(v) << ", ";
tp<T, N + 1, L>::output(os, v);
}
};
template<typename T, unsigned N>
struct tp<T, N, N> {
static void output(std::ostream& os, const T& v) { os << std::get<N>(v); }
};
}
template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {
os << '[';
aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);
return os << ']';
}

template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x);

/* pair */
// out
template<class S, class T>
std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {
return os << "[" << p.first << ", " << p.second << "]";
}
// in
template<class S, class T>
std::istream& operator>>(std::istream& is, const std::pair<S, T>& p) {
return is >> p.first >> p.second;
}

/* container */
// out
template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) {
bool f = true;
os << "[";
for (auto& y : x) {
os << (f ? "" : ", ") << y;
f = false;
}
return os << "]";
}
// in
template <
class T,
class = decltype(std::begin(std::declval<T&>())),
class = typename std::enable_if<!std::is_same<T, std::string>::value>::type
>
std::istream& operator>>(std::istream& is, T& a) {
for (auto& x : a) is >> x;
return is;
}

/* struct */
template<typename T>
auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) {
out << t.stringify();
return out;
}

/* setup */
struct IOSetup {
IOSetup(bool f) {
if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); }
std::cout << std::fixed << std::setprecision(15);
}
} iosetup(true);

/** string formatter **/
template<typename... Ts>
std::string format(const std::string& f, Ts... t) {
size_t l = std::snprintf(nullptr, 0, f.c_str(), t...);
std::vector<char> b(l + 1);
std::snprintf(&b[0], l + 1, f.c_str(), t...);
return std::string(&b[0], &b[0] + l);
}

template<typename T>
std::string stringify(const T& x) {
std::ostringstream oss;
oss << x;
return oss.str();
}

/* dump */
#define ENABLE_DUMP
#ifdef ENABLE_DUMP
#define DUMPOUT std::cerr
std::ostringstream DUMPBUF;
#define dump(...) do{DUMPBUF<<"  ";DUMPBUF<<#__VA_ARGS__<<" :[DUMP - "<<__LINE__<<":"<<__FUNCTION__<<"]"<<std::endl;DUMPBUF<<"    ";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str("");DUMPBUF.clear();}while(0);
void dump_func() { DUMPBUF << std::endl; }
template <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << " "; } else { DUMPBUF << ", "; } dump_func(std::move(tail)...); }
#else
#define dump(...) void(0);
#endif

/* timer */
class Timer {
double t = 0, paused = 0, tmp;
public:
Timer() { reset(); }
static double time() {
#ifdef _MSC_VER
return __rdtsc() / 3.0e9;
#else
unsigned long long a, d;
__asm__ volatile("rdtsc"
: "=a"(a), "=d"(d));
return (d << 32 | a) / 3.0e9;
#endif
}
void reset() { t = time(); }
void pause() { tmp = time(); }
void restart() { paused += time() - tmp; }
double elapsed_ms() { return (time() - t - paused) * 1000.0; }
} timer;

/* rand */
struct Xorshift {
uint64_t x = 88172645463325252LL;
void set_seed(unsigned seed, int rep = 100) { x = uint64_t((seed + 1) * 10007); for (int i = 0; i < rep; i++) next_int(); }
unsigned next_int() { x = x ^ (x << 7); return x = x ^ (x >> 9); }
unsigned next_int(unsigned mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % mod; }
unsigned next_int(unsigned l, unsigned r) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % (r - l + 1) + l; } // inclusive
double next_double() { return double(next_int()) / UINT_MAX; }
} rnd;

/* shuffle */
template<typename T>
void shuffle_vector(std::vector<T>& v, Xorshift& rnd) {
int n = v.size();
for (int i = n - 1; i >= 1; i--) {
int r = rnd.next_int(i);
std::swap(v[i], v[r]);
}
}

/* split */
std::vector<std::string> split(std::string str, const std::string& delim) {
for (char& c : str) if (delim.find(c) != std::string::npos) c = ' ';
std::istringstream iss(str);
std::vector<std::string> parsed;
std::string buf;
while (iss >> buf) parsed.push_back(buf);
return parsed;
}

template<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) {
std::fill((T*)array, (T*)(array + N), val);
}
template<typename T, typename ...Args> auto make_vector(T x, int arg, Args ...args) { if constexpr (sizeof...(args) == 0)return std::vector<T>(arg, x); else return std::vector(arg, make_vector<T>(x, args...)); }
template<typename T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }
template<typename T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }



using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;



int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, K;
cin >> N >> K;

vector<int> A(K);
cin >> A;
for (int& a : A) a--;

set<int> cands;
for (int i = 0; i < N; i++) cands.insert(i);
vector<int> ans;
for (int i = 0; i < K - 1; i++) {
int a = A[i];
ans.push_back(a);
cands.erase(a);
int b = *cands.begin();
if (b > A[i]) continue;
ans.push_back(b);
cands.erase(b);
}
for (auto it = cands.rbegin(); it != cands.rend(); ++it) {
ans.push_back(*it);
}

cout << ans[0] + 1;
for (int i = 1; i < ans.size(); i++) cout << ' ' << ans[i] + 1;
cout << endl;

return 0;
}
#include <bits/stdc++.h>

#define pb push_back
#define ll long long
#define ld long double
#define f first
#define s second
#define mp make_pair

const ll maxn = 2e6 + 1, maxm = 6e3 + 1,  maxk = 61;
const ll inf = 1000000000, mod = inf + 7, mod2 = 998244353;
const ll pa = 31, block = 400;

using namespace std;

int n, a[maxn], l[maxn], t[maxn * 4], pos[maxn];
void upd(int pos, int val, int v = 1, int tl = 1, int tr = n){
if (tl == tr){
t[v] = val;
return;
}
int tm = (tl + tr) / 2;
if (pos <= tm)
upd(pos, val, v + v, tl, tm);
else
upd(pos, val, v + v + 1, tm + 1, tr);
t[v] = min(t[v + v], t[v + v + 1]);
}
int get(int l, int r, int v = 1, int tl = 1, int tr = n){
if (l <= tl && tr <= r)
return t[v];
if (l > tr || r < tl)
return n + 1;
int tm = (tl + tr) / 2;
return min(get(l, r, v + v, tl, tm), get(l, r, v + v + 1, tm + 1, tr));
}
int main(){
ios_base::sync_with_stdio(false);
cin.tie(0), cout.tie(0);
cin >> n;
for (int i = 1; i <= n; ++i){
cin >> a[i];
upd(i, n + 1);
if (pos[a[i]] == 0)
pos[a[i]] = i;
}
ll del = -1;
for (int i = n; i >= 1; --i){
if (pos[a[i]] == i){
ll x = get(1, a[i] - 1);
ll y = get(a[i] + 1, n);
x = min(x, y);
if (x > 0 && x <= n){
if (a[x] < a[i]){
del = a[i];
}
}
}
upd(a[i], i);
}
if (del == -1){
del = a[n];
}
for (int i = 1; i <= n; ++i){
if (del != a[i]){
cout << a[i] << " ";
}
}
}


#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m;
vector<VLL> sum(405, VLL(405));
n = 400;
auto qpow = [&](ll x, ll y)
{
ll res = 1;
while(y)
{
if(y & 1)
res = res * x % mod;
x = x * x % mod;
y >>= 1;
}
return res;
};
for(int j = 0; j <= n; j++)
{
for(int i = 1; i <= n; i++)
{
sum[i][j] = (sum[i - 1][j] + qpow(i, j)) % mod;
}
}
cin >> n >> m;
VI a(n), b(n);
for(int i = 0; i < n; i++)
cin >> a[i];
for(int i = 0; i < n; i++)
cin >> b[i];
VLL dp(m + 1), dq(m + 1);
dp[0] = 1;
for(int i = 0; i < n; i++)
{
fill(all(dq), 0);
for(int use = 0; use <= m; use++)
{
for(int j = 0; j + use <= m; j++)
{
dq[use + j] = (dq[use + j] + dp[j] * (sum[b[i]][use] - sum[a[i] - 1][use] + mod)) % mod;
}
}
swap(dp, dq);
//		for(int j = 0; j <= m; j++)
//			cerr << dp[j] << " \n"[j == m];
}
cout << dp[m] << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include <bits/stdc++.h>
#include <random>
#include <array>
#ifdef _MSC_VER
#include <ppl.h>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#else
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

/** compro_io **/

/* tuple */
// out
namespace aux {
template<typename T, unsigned N, unsigned L>
struct tp {
static void output(std::ostream& os, const T& v) {
os << std::get<N>(v) << ", ";
tp<T, N + 1, L>::output(os, v);
}
};
template<typename T, unsigned N>
struct tp<T, N, N> {
static void output(std::ostream& os, const T& v) { os << std::get<N>(v); }
};
}
template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {
os << '[';
aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);
return os << ']';
}

template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x);

/* pair */
// out
template<class S, class T>
std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {
return os << "[" << p.first << ", " << p.second << "]";
}
// in
template<class S, class T>
std::istream& operator>>(std::istream& is, const std::pair<S, T>& p) {
return is >> p.first >> p.second;
}

/* container */
// out
template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) {
bool f = true;
os << "[";
for (auto& y : x) {
os << (f ? "" : ", ") << y;
f = false;
}
return os << "]";
}
// in
template <
class T,
class = decltype(std::begin(std::declval<T&>())),
class = typename std::enable_if<!std::is_same<T, std::string>::value>::type
>
std::istream& operator>>(std::istream& is, T& a) {
for (auto& x : a) is >> x;
return is;
}

/* struct */
template<typename T>
auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) {
out << t.stringify();
return out;
}

/* setup */
struct IOSetup {
IOSetup(bool f) {
if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); }
std::cout << std::fixed << std::setprecision(15);
}
} iosetup(true);

/** string formatter **/
template<typename... Ts>
std::string format(const std::string& f, Ts... t) {
size_t l = std::snprintf(nullptr, 0, f.c_str(), t...);
std::vector<char> b(l + 1);
std::snprintf(&b[0], l + 1, f.c_str(), t...);
return std::string(&b[0], &b[0] + l);
}

template<typename T>
std::string stringify(const T& x) {
std::ostringstream oss;
oss << x;
return oss.str();
}

/* dump */
#define ENABLE_DUMP
#ifdef ENABLE_DUMP
#define DUMPOUT std::cerr
std::ostringstream DUMPBUF;
#define dump(...) do{DUMPBUF<<"  ";DUMPBUF<<#__VA_ARGS__<<" :[DUMP - "<<__LINE__<<":"<<__FUNCTION__<<"]"<<std::endl;DUMPBUF<<"    ";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str("");DUMPBUF.clear();}while(0);
void dump_func() { DUMPBUF << std::endl; }
template <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << " "; } else { DUMPBUF << ", "; } dump_func(std::move(tail)...); }
#else
#define dump(...) void(0);
#endif

/* timer */
class Timer {
double t = 0, paused = 0, tmp;
public:
Timer() { reset(); }
static double time() {
#ifdef _MSC_VER
return __rdtsc() / 3.0e9;
#else
unsigned long long a, d;
__asm__ volatile("rdtsc"
: "=a"(a), "=d"(d));
return (d << 32 | a) / 3.0e9;
#endif
}
void reset() { t = time(); }
void pause() { tmp = time(); }
void restart() { paused += time() - tmp; }
double elapsed_ms() { return (time() - t - paused) * 1000.0; }
} timer;

/* rand */
struct Xorshift {
uint64_t x = 88172645463325252LL;
void set_seed(unsigned seed, int rep = 100) { x = uint64_t((seed + 1) * 10007); for (int i = 0; i < rep; i++) next_int(); }
unsigned next_int() { x = x ^ (x << 7); return x = x ^ (x >> 9); }
unsigned next_int(unsigned mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % mod; }
unsigned next_int(unsigned l, unsigned r) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % (r - l + 1) + l; } // inclusive
double next_double() { return double(next_int()) / UINT_MAX; }
} rnd;

/* shuffle */
template<typename T>
void shuffle_vector(std::vector<T>& v, Xorshift& rnd) {
int n = v.size();
for (int i = n - 1; i >= 1; i--) {
int r = rnd.next_int(i);
std::swap(v[i], v[r]);
}
}

/* split */
std::vector<std::string> split(std::string str, const std::string& delim) {
for (char& c : str) if (delim.find(c) != std::string::npos) c = ' ';
std::istringstream iss(str);
std::vector<std::string> parsed;
std::string buf;
while (iss >> buf) parsed.push_back(buf);
return parsed;
}

template<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) {
std::fill((T*)array, (T*)(array + N), val);
}
template<typename T, typename ...Args> auto make_vector(T x, int arg, Args ...args) { if constexpr (sizeof...(args) == 0)return std::vector<T>(arg, x); else return std::vector(arg, make_vector<T>(x, args...)); }
template<typename T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }
template<typename T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }



using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;



int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

ll N, M;
cin >> N >> M;
vector<bitset<20>> bits;
bits.push_back(bitset<20>());
for (ll i = 1; i <= N; i++) {
string S;
cin >> S;
bits.emplace_back(S);
}

ll pcnt[2] = {};
for (ll i = 1; i <= N; i++) {
pcnt[bits[i].count() % 2]++;
}

ll ans = N * (N - 1) / 2;
ans -= pcnt[0] * (pcnt[0] - 1) / 2;
ans -= pcnt[1] * (pcnt[1] - 1) / 2;

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

//long long
using ll = long long;

//円周率
const double PI = acos(-1);

// pair<int, int>
using PII = pair<int, int>;


//最大値、mod
// const int MOD = 1000000007;
// const int mod = 1000000007;
const int MOD = 998244353;
const int mod = 998244353;
const int INF = 1000000000;
const double DINF = 1LL<<60;
const long long LINF = 1LL<<60;
const int MAX = 510000;

//出力系
#define print(x) cout << x << endl
#define prints(x) cout << fixed << setprecision(12) << x << endl
#define printc(x) cout << setw(6) << setfill('0') << x << endl;
#define yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define no cout << "No" << endl
#define NO cout << "NO" << endl

//配列入力
vector<long long>vecin(ll n){
vector<long long>res(n);
for(int i = 0; i < n; i++) cin >> res[i];
return res;
}

// begin() end()
#define all(x) (x).begin(),(x).end()

//for
#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define rrep(i,a,b) for(int i=(a);i>(b);i--)
#define rep(i,a,b) for(int i=(a);i<(b);i++)

//最大公約数 
ll gcd(ll x, ll y) { return y ? gcd(y,x%y) : x;}

// 最小公倍数
unsigned lcm(unsigned a, unsigned b){
return a / gcd(a, b) * b; 
}

// a = max(a, b), a = min(a, b)


template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

// template<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}
// template<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}

// num ^ pow(mod取る)
ll pow_mod(ll num, ll pow, ll mod) {
ll prod = 1;
num %= mod;
while (pow > 0) {
if (pow & 1) prod = prod * num % mod;
num = num * num % mod;
pow >>= 1;
}
return prod;
}




// UnionFind
struct UnionFind {
vector<int> par;
vector<int> rank;
vector<ll> Size;
UnionFind(int n = 1) {
init(n);
}

void init(int n = 1) {
par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);
for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;
}

int root(int x) {
if (par[x] == x) {
return x;
}
else {
int r = root(par[x]);
return par[x] = r;
}
}

bool issame(int x, int y) {
return root(x) == root(y);
}

bool merge(int x, int y) {
x = root(x); y = root(y);
if (x == y) return false;
if (rank[x] < rank[y]) swap(x, y);
if (rank[x] == rank[y]) ++rank[x];
par[y] = x;
Size[x] += Size[y];
return true;
}

ll size(int x){
return Size[root(x)];
}
};


//modint構造体 
struct Mint {
int val;
Mint inv() const{
int tmp,a=val,b=mod,x=1,y=0;
while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);
return Mint(x);
}
public:
Mint():val(0){}
Mint(ll x){if((val=x%mod)<0)val+=mod;}
Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}
Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}
Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}
Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}
Mint& operator/=(const Mint& x){return *this*=x.inv();}
bool operator==(const Mint& x) const{return val==x.val;}
bool operator!=(const Mint& x) const{return val!=x.val;}
bool operator<(const Mint& x) const{return val<x.val;}
bool operator<=(const Mint& x) const{return val<=x.val;}
bool operator>(const Mint& x) const{return val>x.val;}
bool operator>=(const Mint& x) const{return val>=x.val;}
Mint operator+(const Mint& x) const{return Mint(*this)+=x;}
Mint operator-(const Mint& x) const{return Mint(*this)-=x;}
Mint operator*(const Mint& x) const{return Mint(*this)*=x;}
Mint operator/(const Mint& x) const{return Mint(*this)/=x;}
};
struct factorial {
vector<Mint> Fact, Finv;
public:
//factorial fact(10000010);
//fact.nCr(a, b)
//「fact」の部分は自由に名前変更可能
factorial(int maxx){
Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);
Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;
}
Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}
Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}
Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}
};


// 1 * 2 * 3 .... * n (mod)
ll modfact(ll n) { 
if (n <= 1) return 1;
return (n * modfact(n - 1)) % MOD;
}


// kが角度だった場合:cos(k * (PI / 180));
//const double PI = acos(-1);のまま使うと円周率(M_PIもあるよ)
//const double PI = acos(-1);


// 多次元 vector 生成   例: auto dp = make_vec<long long>(N+1, 5, 5, 5); 
template<class T>
vector<T> make_vec(size_t a){
return vector<T>(a);
}
template<class T, class... Ts>
auto make_vec(size_t a, Ts... ts){
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

//素因数分解
vector<pair<long long, int>>factorize(long long n){
vector<pair<long long, int>> res;
for(long long i = 2; i * i <= n; ++i){
if(n % i) continue;
res.emplace_back(i, 0);
while(n % i == 0){
n /= i;
res.back().second++;
}
}
if(n != 1) res.emplace_back(n, 1);
return res;
}

// 素数判定
bool primejudge(long long a){
if(a <= 1) return false;
for(long long i = 2; i * i <= a; i++){
if(a % i == 0) return false;
}
return true;
}

//lca_tree
// https://drken1215.hatenablog.com/entry/2021/06/19/175900
// https://atcoder.jp/contests/abc014/submissions/28234866
struct Tree_lca{

Tree_lca(int V, int root) : V(V), root(root){
T.resize(V);
for(int i = 0; i < MAXLOGV; i++) parent[i].resize(V);
depth.resize(V);

}

void unite(int u, int v){
T[u].push_back(v);
T[v].push_back(u);
}

void init(){
dfs(root, -1, 0);
for(int k = 0; k + 1 < MAXLOGV; k++){
for(int v = 0; v < V; v++){
if(parent[k][v] < 0) parent[k + 1][v] = -1;
else parent[k + 1][v] = parent[k][parent[k][v]];
}
}
}

int lca(int u, int v) const{
if(depth[u] > depth[v]) swap(u, v);
for(int k = 0; k < MAXLOGV; k++){
if((depth[v] - depth[u]) >> k & 1) v = parent[k][v];
}

if(u == v) return u;

for(int k = MAXLOGV - 1; k >= 0; k--){
if(parent[k][u] != parent[k][v]){
u = parent[k][u];
v = parent[k][v];
}
}

return parent[0][u];

}

int dist(int u, int v) const{
int p = lca(u, v);
return(depth[u] - depth[p]) + (depth[v] - depth[p]);
}

void dfs(int v, int p, int d){
parent[0][v] = p;
depth[v] = d;
for(int next : T[v]){
if(next != p) dfs(next, v, d + 1);
}
}

static const int MAXLOGV = 25;
vector<vector<int>>T;
int V;
int root;
vector<int> parent[MAXLOGV];
vector<int>depth;
};




//ループ用のベルマンフォード　距離は*-1に変換して入力してください
// E.add_edge(a, b, -c);
template<typename T>
struct BellmanFord{
struct Edge{
int  from,to; ll cost;
Edge(){}
Edge(int from,int to,ll cost):from(from),to(to),cost(cost){}
};

int n;
vector<vector<int> >G;
vector<int> used,reach;
BellmanFord(int n):n(n),G(n),used(n,0),reach(n,0){}

vector<Edge> es;
void add_edge(int from,int to,ll cost){
es.push_back(Edge(from,to,cost));
G[from].push_back(to);
}

void dfs(int v){
if(used[v])return ;
used[v]=1;
for(int u:G[v]){
dfs(u);
}
}

// int nl;
//ll res = E.build(0, n - 1, nl);
//とするとループの場合はnl = 1,ループしない場合はnl = 0
// resはループしなければ距離が入る
// ループする場合は1e18が入る
ll build(int from,int to,int &neg_loop){
for(int i=0;i<n;i++){
fill(used.begin(),used.end(),0);
dfs(i);
reach[i]=used[to];
}
vector<ll> ds(n,1e18);
ds[from]=0;
for(int i=0;i<n;i++){
bool update=0;
for(auto e:es){
if(!reach[e.from]||!reach[e.to]||ds[e.from]==1e18) continue;
if(ds[e.to]>ds[e.from]+e.cost){
ds[e.to]=ds[e.from]+e.cost;
update=1;
}
}
if(!update)break;
if(i==n-1){
neg_loop=1;
return 1e18;
}
}
neg_loop=0;
return -ds[to];
}
};



//BIT
template <class Abel> struct BIT {
Abel UNITY_SUM = 0;
vector<Abel> dat;

// [0, n)
BIT(int n, Abel unity = 0) : UNITY_SUM(unity), dat(n, unity) { }
void init(int n) {
dat.assign(n, UNITY_SUM);
}

// a is 0-indexed
inline void add(int a, Abel x) {
for (int i = a; i < (int)dat.size(); i |= i + 1)
dat[i] = dat[i] + x;
}

// [0, a), a is 0-indexed
inline Abel sum(int a) {
Abel res = UNITY_SUM;
for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1)
res = res + dat[i];
return res;
}

// [a, b), a and b are 0-indexed
inline Abel sum(int a, int b) {
return sum(b) - sum(a);
}

// debug
void printdd() {
for (int i = 0; i < (int)dat.size(); ++i)
cout << sum(i, i + 1) << ",";
cout << endl;
}
};

//lazzy_seg
class segment_tree {
private:
int sz;
std::vector<int> seg;
std::vector<int> lazy;
void push(int k) {
if (k < sz) {
lazy[k * 2] = max(lazy[k * 2], lazy[k]);
lazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);
}
seg[k] = max(seg[k], lazy[k]);
lazy[k] = 0;
}
void update(int a, int b, int x, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = x;
push(k);
return;
}
update(a, b, x, k * 2, l, (l + r) >> 1);
update(a, b, x, k * 2 + 1, (l + r) >> 1, r);
seg[k] = max(seg[k * 2], seg[k * 2 + 1]);
}
int range_max(int a, int b, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return 0;
if (a <= l && r <= b) return seg[k];
int lc = range_max(a, b, k * 2, l, (l + r) >> 1);
int rc = range_max(a, b, k * 2 + 1, (l + r) >> 1, r);
return max(lc, rc);
}
public:
segment_tree() : sz(0), seg(), lazy() {};
segment_tree(int N) {
sz = 1;
while (sz < N) {
sz *= 2;
}
seg = std::vector<int>(sz * 2, 0);
lazy = std::vector<int>(sz * 2, 0);
}
void update(int l, int r, int x) {
update(l, r, x, 1, 0, sz);
}
int range_max(int l, int r) {
return range_max(l, r, 1, 0, sz);
}
};


// Mint dp[200100];
// ll dp[200100];
//ダイクストラ
vector<pair<long long, long long>>DG[200100];
vector<long long>dijkstra(int s){
vector<long long>dist(200100, LINF);
dist[s] = 0;
priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>que;
que.push({0, s});
// dp[s] = 1;
while(!que.empty()){
long long cost, to;
cost = que.top().first; to = que.top().second;
que.pop();
if(dist[to] < cost) continue;
for(auto x : DG[to]){
long long v = x.first, time = x.second;
if(dist[v] > dist[to] + time){
dist[v] = dist[to] + time;
que.push({dist[v], v});
// dp[v] = dp[to];
}
// else if(dist[v] == dist[to] + time){
//     dp[v] += dp[to];
// }
}
}
return dist;
}


ll fa(ll n) { 
if (n <= 1) return 1;
return (n * fa(n - 1));
}

//modintに注意
Mint NCR(int N, int i){
Mint x = 1, y = 1;
REP(j, i){
x *= N - j;
y *= j + 1;
}
return x / y;
}


ll ncr(int N, int i){
ll x = 1, y = 1;
REP(j, i){
x *= N - j;
y *= j + 1;
}
return x / y;
}

ll powers(ll i, ll N){
if(N == 0) return 1;
if(N == 1) return i;
ll tmp = powers(i, N / 2);
ll res = tmp * tmp;
if(N % 2) res *= i;
return res;
}


//sort(all(ids), [&](int i, int j) {return x[i] < x[j];});

vector<vector<int>> G;
// vector<vector<int>> G2;
//G.assign(N, vector<int>());
vector<vector<pair<ll, ll>>>E;
//E.assign(N, vector<pair<ll, ll>>());

int dy[2] = {0, 1}, dx[2] = {1, 0}; 
// int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};
// int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
// int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};



//segtree用(ACL)
//vector<int>a(n); segtree<int, op, e> seg(a); とか　segtree<int, op, e> seg(300010)
ll op(ll a, ll b){
return a + b;
}

ll e(){
return 0LL;
}



int main(){
int T;
cin >> T;
REP(_, T){
long long a;
cin >> a;
if(a % 4 == 0){
cout << "Even" << endl;
}else if(a % 2 == 0){
cout << "Same" << endl;
}else{
cout << "Odd" << endl;
}
}

}

#line 1 "Contests/AtCoder_arc123/arc123_b/main.cpp"
using namespace std;
#line 2 "library/bits/stdc++.h"

// C
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
#line 3 "Contests/AtCoder_arc123/arc123_b/main.cpp"

// add your library with double quotation #include"" here.
#line 1 "library/atcoder/convolution.hpp"



#line 5 "library/atcoder/convolution.hpp"
#include <array>
#include <cassert>
#include <type_traits>
#line 9 "library/atcoder/convolution.hpp"

#line 1 "library/atcoder/internal_bit.hpp"



#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

// @param n `0 <= n`
// @return minimum non-negative `x` s.t. `n <= 2**x`
int ceil_pow2(int n) {
int x = 0;
while ((1U << x) < (unsigned int)(n)) x++;
return x;
}

// @param n `1 <= n`
// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`
int bsf(unsigned int n) {
#ifdef _MSC_VER
unsigned long index;
_BitScanForward(&index, n);
return index;
#else
return __builtin_ctz(n);
#endif
}

}  // namespace internal

}  // namespace atcoder


#line 1 "library/atcoder/modint.hpp"



#line 7 "library/atcoder/modint.hpp"

#ifdef _MSC_VER
#include <intrin.h>
#endif

#line 1 "library/atcoder/internal_math.hpp"



#line 5 "library/atcoder/internal_math.hpp"

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

// @param m `1 <= m`
// @return x mod m
constexpr long long safe_mod(long long x, long long m) {
x %= m;
if (x < 0) x += m;
return x;
}

// Fast modular multiplication by barrett reduction
// Reference: https://en.wikipedia.org/wiki/Barrett_reduction
// NOTE: reconsider after Ice Lake
struct barrett {
unsigned int _m;
unsigned long long im;

// @param m `1 <= m < 2^31`
explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

// @return m
unsigned int umod() const { return _m; }

// @param a `0 <= a < m`
// @param b `0 <= b < m`
// @return `a * b % m`
unsigned int mul(unsigned int a, unsigned int b) const {
// [1] m = 1
// a = b = im = 0, so okay

// [2] m >= 2
// im = ceil(2^64 / m)
// -> im * m = 2^64 + r (0 <= r < m)
// let z = a*b = c*m + d (0 <= c, d < m)
// a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im
// c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2
// ((ab * im) >> 64) == c or c + 1
unsigned long long z = a;
z *= b;
#ifdef _MSC_VER
unsigned long long x;
_umul128(z, im, &x);
#else
unsigned long long x =
(unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
unsigned int v = (unsigned int)(z - x * _m);
if (_m <= v) v += _m;
return v;
}
};

// @param n `0 <= n`
// @param m `1 <= m`
// @return `(x ** n) % m`
constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
if (m == 1) return 0;
unsigned int _m = (unsigned int)(m);
unsigned long long r = 1;
unsigned long long y = safe_mod(x, m);
while (n) {
if (n & 1) r = (r * y) % _m;
y = (y * y) % _m;
n >>= 1;
}
return r;
}

// Reference:
// M. Forisek and J. Jancina,
// Fast Primality Testing for Integers That Fit into a Machine Word
// @param n `0 <= n`
constexpr bool is_prime_constexpr(int n) {
if (n <= 1) return false;
if (n == 2 || n == 7 || n == 61) return true;
if (n % 2 == 0) return false;
long long d = n - 1;
while (d % 2 == 0) d /= 2;
constexpr long long bases[3] = {2, 7, 61};
for (long long a : bases) {
long long t = d;
long long y = pow_mod_constexpr(a, t, n);
while (t != n - 1 && y != 1 && y != n - 1) {
y = y * y % n;
t <<= 1;
}
if (y != n - 1 && t % 2 == 0) {
return false;
}
}
return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

// @param b `1 <= b`
// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g
constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
a = safe_mod(a, b);
if (a == 0) return {b, 0};

// Contracts:
// [1] s - m0 * a = 0 (mod b)
// [2] t - m1 * a = 0 (mod b)
// [3] s * |m1| + t * |m0| <= b
long long s = b, t = a;
long long m0 = 0, m1 = 1;

while (t) {
long long u = s / t;
s -= t * u;
m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b

// [3]:
// (s - t * u) * |m1| + t * |m0 - m1 * u|
// <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)
// = s * |m1| + t * |m0| <= b

auto tmp = s;
s = t;
t = tmp;
tmp = m0;
m0 = m1;
m1 = tmp;
}
// by [3]: |m0| <= b/g
// by g != b: |m0| < b/g
if (m0 < 0) m0 += b / s;
return {s, m0};
}

// Compile time primitive root
// @param m must be prime
// @return primitive root (and minimum in now)
constexpr int primitive_root_constexpr(int m) {
if (m == 2) return 1;
if (m == 167772161) return 3;
if (m == 469762049) return 3;
if (m == 754974721) return 11;
if (m == 998244353) return 3;
int divs[20] = {};
divs[0] = 2;
int cnt = 1;
int x = (m - 1) / 2;
while (x % 2 == 0) x /= 2;
for (int i = 3; (long long)(i)*i <= x; i += 2) {
if (x % i == 0) {
divs[cnt++] = i;
while (x % i == 0) {
x /= i;
}
}
}
if (x > 1) {
divs[cnt++] = x;
}
for (int g = 2;; g++) {
bool ok = true;
for (int i = 0; i < cnt; i++) {
if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
ok = false;
break;
}
}
if (ok) return g;
}
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

// @param n `n < 2^32`
// @param m `1 <= m < 2^32`
// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)
unsigned long long floor_sum_unsigned(unsigned long long n,
unsigned long long m,
unsigned long long a,
unsigned long long b) {
unsigned long long ans = 0;
while (true) {
if (a >= m) {
ans += n * (n - 1) / 2 * (a / m);
a %= m;
}
if (b >= m) {
ans += n * (b / m);
b %= m;
}

unsigned long long y_max = a * n + b;
if (y_max < m) break;
// y_max < m * (n + 1)
// floor(y_max / m) <= n
n = (unsigned long long)(y_max / m);
b = (unsigned long long)(y_max % m);
std::swap(m, a);
}
return ans;
}

}  // namespace internal

}  // namespace atcoder


#line 1 "library/atcoder/internal_type_traits.hpp"



#line 7 "library/atcoder/internal_type_traits.hpp"

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value ||
std::is_same<T, __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int128 =
typename std::conditional<std::is_same<T, __uint128_t>::value ||
std::is_same<T, unsigned __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using make_unsigned_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value,
__uint128_t,
unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
is_signed_int128<T>::value ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
std::is_signed<T>::value) ||
is_signed_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<(is_integral<T>::value &&
std::is_unsigned<T>::value) ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
is_signed_int128<T>::value,
make_unsigned_int128<T>,
typename std::conditional<std::is_signed<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<is_integral<T>::value &&
std::is_unsigned<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


#line 14 "library/atcoder/modint.hpp"

namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
using mint = static_modint;

public:
static constexpr int mod() { return m; }
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

static_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
static_modint(T v) {
long long x = (long long)(v % (long long)(umod()));
if (x < 0) x += umod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
static_modint(T v) {
_v = (unsigned int)(v % umod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v -= rhs._v;
if (_v >= umod()) _v += umod();
return *this;
}
mint& operator*=(const mint& rhs) {
unsigned long long z = _v;
z *= rhs._v;
_v = (unsigned int)(z % umod());
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
if (prime) {
assert(_v);
return pow(umod() - 2);
} else {
auto eg = internal::inv_gcd(_v, m);
assert(eg.first == 1);
return eg.second;
}
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static constexpr unsigned int umod() { return m; }
static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
using mint = dynamic_modint;

public:
static int mod() { return (int)(bt.umod()); }
static void set_mod(int m) {
assert(1 <= m);
bt = internal::barrett(m);
}
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

dynamic_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
dynamic_modint(T v) {
long long x = (long long)(v % (long long)(mod()));
if (x < 0) x += mod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
dynamic_modint(T v) {
_v = (unsigned int)(v % mod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v += mod() - rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator*=(const mint& rhs) {
_v = bt.mul(_v, rhs._v);
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
auto eg = internal::inv_gcd(_v, mod());
assert(eg.first == 1);
return eg.second;
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static internal::barrett bt;
static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder


#line 12 "library/atcoder/convolution.hpp"

namespace atcoder {

namespace internal {

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
void butterfly(std::vector<mint>& a) {
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);

static bool first = true;
static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]
if (first) {
first = false;
mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--) {
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i <= cnt2 - 2; i++) {
sum_e[i] = es[i] * now;
now *= ies[i];
}
}
for (int ph = 1; ph <= h; ph++) {
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint now = 1;
for (int s = 0; s < w; s++) {
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++) {
auto l = a[i + offset];
auto r = a[i + offset + p] * now;
a[i + offset] = l + r;
a[i + offset + p] = l - r;
}
now *= sum_e[bsf(~(unsigned int)(s))];
}
}
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
void butterfly_inv(std::vector<mint>& a) {
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);

static bool first = true;
static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]
if (first) {
first = false;
mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--) {
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i <= cnt2 - 2; i++) {
sum_ie[i] = ies[i] * now;
now *= es[i];
}
}

for (int ph = h; ph >= 1; ph--) {
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint inow = 1;
for (int s = 0; s < w; s++) {
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++) {
auto l = a[i + offset];
auto r = a[i + offset + p];
a[i + offset] = l + r;
a[i + offset + p] =
(unsigned long long)(mint::mod() + l.val() - r.val()) *
inow.val();
}
inow *= sum_ie[bsf(~(unsigned int)(s))];
}
}
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution_naive(const std::vector<mint>& a, const std::vector<mint>& b) {
int n = int(a.size()), m = int(b.size());
std::vector<mint> ans(n + m - 1);
if (n < m) {
for (int j = 0; j < m; j++) {
for (int i = 0; i < n; i++) {
ans[i + j] += a[i] * b[j];
}
}
} else {
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
ans[i + j] += a[i] * b[j];
}
}
}
return ans;
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution_fft(std::vector<mint> a, std::vector<mint> b) {
int n = int(a.size()), m = int(b.size());
int z = 1 << internal::ceil_pow2(n + m - 1);
a.resize(z);
internal::butterfly(a);
b.resize(z);
internal::butterfly(b);
for (int i = 0; i < z; i++) {
a[i] *= b[i];
}
internal::butterfly_inv(a);
a.resize(n + m - 1);
mint iz = mint(z).inv();
for (int i = 0; i < n + m - 1; i++) a[i] *= iz;
return a;
}

}  // namespace internal

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution(std::vector<mint>&& a, std::vector<mint>&& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};
if (std::min(n, m) <= 60) return convolution_naive(a, b);
return internal::convolution_fft(a, b);
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution(const std::vector<mint>& a, const std::vector<mint>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};
if (std::min(n, m) <= 60) return convolution_naive(a, b);
return internal::convolution_fft(a, b);
}

template <unsigned int mod = 998244353,
class T,
std::enable_if_t<internal::is_integral<T>::value>* = nullptr>
std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};

using mint = static_modint<mod>;
std::vector<mint> a2(n), b2(m);
for (int i = 0; i < n; i++) {
a2[i] = mint(a[i]);
}
for (int i = 0; i < m; i++) {
b2[i] = mint(b[i]);
}
auto c2 = convolution(move(a2), move(b2));
std::vector<T> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++) {
c[i] = c2[i].val();
}
return c;
}

std::vector<long long> convolution_ll(const std::vector<long long>& a,
const std::vector<long long>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};

static constexpr unsigned long long MOD1 = 754974721;  // 2^24
static constexpr unsigned long long MOD2 = 167772161;  // 2^25
static constexpr unsigned long long MOD3 = 469762049;  // 2^26
static constexpr unsigned long long M2M3 = MOD2 * MOD3;
static constexpr unsigned long long M1M3 = MOD1 * MOD3;
static constexpr unsigned long long M1M2 = MOD1 * MOD2;
static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;

static constexpr unsigned long long i1 =
internal::inv_gcd(MOD2 * MOD3, MOD1).second;
static constexpr unsigned long long i2 =
internal::inv_gcd(MOD1 * MOD3, MOD2).second;
static constexpr unsigned long long i3 =
internal::inv_gcd(MOD1 * MOD2, MOD3).second;

auto c1 = convolution<MOD1>(a, b);
auto c2 = convolution<MOD2>(a, b);
auto c3 = convolution<MOD3>(a, b);

std::vector<long long> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++) {
unsigned long long x = 0;
x += (c1[i] * i1) % MOD1 * M2M3;
x += (c2[i] * i2) % MOD2 * M1M3;
x += (c3[i] * i3) % MOD3 * M1M2;
// B = 2^63, -B <= x, r(real value) < B
// (x, x - M, x - 2M, or x - 3M) = r (mod 2B)
// r = c1[i] (mod MOD1)
// focus on MOD1
// r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)
// r = x,
//     x - M' + (0 or 2B),
//     x - 2M' + (0, 2B or 4B),
//     x - 3M' + (0, 2B, 4B or 6B) (without mod!)
// (r - x) = 0, (0)
//           - M' + (0 or 2B), (1)
//           -2M' + (0 or 2B or 4B), (2)
//           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)
// we checked that
//   ((1) mod MOD1) mod 5 = 2
//   ((2) mod MOD1) mod 5 = 3
//   ((3) mod MOD1) mod 5 = 4
long long diff =
c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));
if (diff < 0) diff += MOD1;
static constexpr unsigned long long offset[5] = {
0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};
x -= offset[diff % 5];
c[i] = x;
}

return c;
}

}  // namespace atcoder


#line 1 "library/atcoder/dsu.hpp"



#line 7 "library/atcoder/dsu.hpp"

namespace atcoder {

// Implement (union by size) + (path compression)
// Reference:
// Zvi Galil and Giuseppe F. Italiano,
// Data structures and algorithms for disjoint set union problems
struct dsu {
public:
dsu() : _n(0) {}
explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}

int merge(int a, int b) {
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
int x = leader(a), y = leader(b);
if (x == y) return x;
if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
return x;
}

bool same(int a, int b) {
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
return leader(a) == leader(b);
}

int leader(int a) {
assert(0 <= a && a < _n);
if (parent_or_size[a] < 0) return a;
return parent_or_size[a] = leader(parent_or_size[a]);
}

int size(int a) {
assert(0 <= a && a < _n);
return -parent_or_size[leader(a)];
}

std::vector<std::vector<int>> groups() {
std::vector<int> leader_buf(_n), group_size(_n);
for (int i = 0; i < _n; i++) {
leader_buf[i] = leader(i);
group_size[leader_buf[i]]++;
}
std::vector<std::vector<int>> result(_n);
for (int i = 0; i < _n; i++) {
result[i].reserve(group_size[i]);
}
for (int i = 0; i < _n; i++) {
result[leader_buf[i]].push_back(i);
}
result.erase(
std::remove_if(result.begin(), result.end(),
[&](const std::vector<int>& v) { return v.empty(); }),
result.end());
return result;
}

private:
int _n;
// root node: -1 * component size
// otherwise: parent
std::vector<int> parent_or_size;
};

}  // namespace atcoder


#line 1 "library/atcoder/fenwicktree.hpp"



#line 6 "library/atcoder/fenwicktree.hpp"

#line 8 "library/atcoder/fenwicktree.hpp"

namespace atcoder {

// Reference: https://en.wikipedia.org/wiki/Fenwick_tree
template <class T> struct fenwick_tree {
using U = internal::to_unsigned_t<T>;

public:
fenwick_tree() : _n(0) {}
explicit fenwick_tree(int n) : _n(n), data(n) {}

void add(int p, T x) {
assert(0 <= p && p < _n);
p++;
while (p <= _n) {
data[p - 1] += U(x);
p += p & -p;
}
}

T sum(int l, int r) {
assert(0 <= l && l <= r && r <= _n);
return sum(r) - sum(l);
}

private:
int _n;
std::vector<U> data;

U sum(int r) {
U s = 0;
while (r > 0) {
s += data[r - 1];
r -= r & -r;
}
return s;
}
};

}  // namespace atcoder


#line 1 "library/atcoder/lazysegtree.hpp"



#line 8 "library/atcoder/lazysegtree.hpp"

#line 10 "library/atcoder/lazysegtree.hpp"

namespace atcoder {

template <class S,
S (*op)(S, S),
S (*e)(),
class F,
S (*mapping)(F, S),
F (*composition)(F, F),
F (*id)()>
struct lazy_segtree {
public:
lazy_segtree() : lazy_segtree(0) {}
explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}
explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
lz = std::vector<F>(size, id());
for (int i = 0; i < _n; i++) d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--) {
update(i);
}
}

void set(int p, S x) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
d[p] = x;
for (int i = 1; i <= log; i++) update(p >> i);
}

S get(int p) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
return d[p];
}

S prod(int l, int r) {
assert(0 <= l && l <= r && r <= _n);
if (l == r) return e();

l += size;
r += size;

for (int i = log; i >= 1; i--) {
if (((l >> i) << i) != l) push(l >> i);
if (((r >> i) << i) != r) push((r - 1) >> i);
}

S sml = e(), smr = e();
while (l < r) {
if (l & 1) sml = op(sml, d[l++]);
if (r & 1) smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}

return op(sml, smr);
}

S all_prod() { return d[1]; }

void apply(int p, F f) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
d[p] = mapping(f, d[p]);
for (int i = 1; i <= log; i++) update(p >> i);
}
void apply(int l, int r, F f) {
assert(0 <= l && l <= r && r <= _n);
if (l == r) return;

l += size;
r += size;

for (int i = log; i >= 1; i--) {
if (((l >> i) << i) != l) push(l >> i);
if (((r >> i) << i) != r) push((r - 1) >> i);
}

{
int l2 = l, r2 = r;
while (l < r) {
if (l & 1) all_apply(l++, f);
if (r & 1) all_apply(--r, f);
l >>= 1;
r >>= 1;
}
l = l2;
r = r2;
}

for (int i = 1; i <= log; i++) {
if (((l >> i) << i) != l) update(l >> i);
if (((r >> i) << i) != r) update((r - 1) >> i);
}
}

template <bool (*g)(S)> int max_right(int l) {
return max_right(l, [](S x) { return g(x); });
}
template <class G> int max_right(int l, G g) {
assert(0 <= l && l <= _n);
assert(g(e()));
if (l == _n) return _n;
l += size;
for (int i = log; i >= 1; i--) push(l >> i);
S sm = e();
do {
while (l % 2 == 0) l >>= 1;
if (!g(op(sm, d[l]))) {
while (l < size) {
push(l);
l = (2 * l);
if (g(op(sm, d[l]))) {
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}

template <bool (*g)(S)> int min_left(int r) {
return min_left(r, [](S x) { return g(x); });
}
template <class G> int min_left(int r, G g) {
assert(0 <= r && r <= _n);
assert(g(e()));
if (r == 0) return 0;
r += size;
for (int i = log; i >= 1; i--) push((r - 1) >> i);
S sm = e();
do {
r--;
while (r > 1 && (r % 2)) r >>= 1;
if (!g(op(d[r], sm))) {
while (r < size) {
push(r);
r = (2 * r + 1);
if (g(op(d[r], sm))) {
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;
std::vector<F> lz;

void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
void all_apply(int k, F f) {
d[k] = mapping(f, d[k]);
if (k < size) lz[k] = composition(f, lz[k]);
}
void push(int k) {
all_apply(2 * k, lz[k]);
all_apply(2 * k + 1, lz[k]);
lz[k] = id();
}
};

}  // namespace atcoder


#line 1 "library/atcoder/math.hpp"



#line 6 "library/atcoder/math.hpp"
#include <tuple>
#line 8 "library/atcoder/math.hpp"

#line 10 "library/atcoder/math.hpp"

namespace atcoder {

long long pow_mod(long long x, long long n, int m) {
assert(0 <= n && 1 <= m);
if (m == 1) return 0;
internal::barrett bt((unsigned int)(m));
unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));
while (n) {
if (n & 1) r = bt.mul(r, y);
y = bt.mul(y, y);
n >>= 1;
}
return r;
}

long long inv_mod(long long x, long long m) {
assert(1 <= m);
auto z = internal::inv_gcd(x, m);
assert(z.first == 1);
return z.second;
}

// (rem, mod)
std::pair<long long, long long> crt(const std::vector<long long>& r,
const std::vector<long long>& m) {
assert(r.size() == m.size());
int n = int(r.size());
// Contracts: 0 <= r0 < m0
long long r0 = 0, m0 = 1;
for (int i = 0; i < n; i++) {
assert(1 <= m[i]);
long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];
if (m0 < m1) {
std::swap(r0, r1);
std::swap(m0, m1);
}
if (m0 % m1 == 0) {
if (r0 % m1 != r1) return {0, 0};
continue;
}
// assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)

// (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));
// r2 % m0 = r0
// r2 % m1 = r1
// -> (r0 + x*m0) % m1 = r1
// -> x*u0*g = r1-r0 (mod u1*g) (u0*g = m0, u1*g = m1)
// -> x = (r1 - r0) / g * inv(u0) (mod u1)

// im = inv(u0) (mod u1) (0 <= im < u1)
long long g, im;
std::tie(g, im) = internal::inv_gcd(m0, m1);

long long u1 = (m1 / g);
// |r1 - r0| < (m0 + m1) <= lcm(m0, m1)
if ((r1 - r0) % g) return {0, 0};

// u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)
long long x = (r1 - r0) / g % u1 * im % u1;

// |r0| + |m0 * x|
// < m0 + m0 * (u1 - 1)
// = m0 + m0 * m1 / g - m0
// = lcm(m0, m1)
r0 += x * m0;
m0 *= u1;  // -> lcm(m0, m1)
if (r0 < 0) r0 += m0;
}
return {r0, m0};
}

long long floor_sum(long long n, long long m, long long a, long long b) {
assert(0 <= n && n < (1LL << 32));
assert(1 <= m && m < (1LL << 32));
unsigned long long ans = 0;
if (a < 0) {
unsigned long long a2 = internal::safe_mod(a, m);
ans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m);
a = a2;
}
if (b < 0) {
unsigned long long b2 = internal::safe_mod(b, m);
ans -= 1ULL * n * ((b2 - b) / m);
b = b2;
}
return ans + internal::floor_sum_unsigned(n, m, a, b);
}

}  // namespace atcoder


#line 1 "library/atcoder/maxflow.hpp"



#line 9 "library/atcoder/maxflow.hpp"

#line 1 "library/atcoder/internal_queue.hpp"



#line 5 "library/atcoder/internal_queue.hpp"

namespace atcoder {

namespace internal {

template <class T> struct simple_queue {
std::vector<T> payload;
int pos = 0;
void reserve(int n) { payload.reserve(n); }
int size() const { return int(payload.size()) - pos; }
bool empty() const { return pos == int(payload.size()); }
void push(const T& t) { payload.push_back(t); }
T& front() { return payload[pos]; }
void clear() {
payload.clear();
pos = 0;
}
void pop() { pos++; }
};

}  // namespace internal

}  // namespace atcoder


#line 11 "library/atcoder/maxflow.hpp"

namespace atcoder {

template <class Cap> struct mf_graph {
public:
mf_graph() : _n(0) {}
explicit mf_graph(int n) : _n(n), g(n) {}

int add_edge(int from, int to, Cap cap) {
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
int m = int(pos.size());
pos.push_back({from, int(g[from].size())});
int from_id = int(g[from].size());
int to_id = int(g[to].size());
if (from == to) to_id++;
g[from].push_back(_edge{to, to_id, cap});
g[to].push_back(_edge{from, from_id, 0});
return m;
}

struct edge {
int from, to;
Cap cap, flow;
};

edge get_edge(int i) {
int m = int(pos.size());
assert(0 <= i && i < m);
auto _e = g[pos[i].first][pos[i].second];
auto _re = g[_e.to][_e.rev];
return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};
}
std::vector<edge> edges() {
int m = int(pos.size());
std::vector<edge> result;
for (int i = 0; i < m; i++) {
result.push_back(get_edge(i));
}
return result;
}
void change_edge(int i, Cap new_cap, Cap new_flow) {
int m = int(pos.size());
assert(0 <= i && i < m);
assert(0 <= new_flow && new_flow <= new_cap);
auto& _e = g[pos[i].first][pos[i].second];
auto& _re = g[_e.to][_e.rev];
_e.cap = new_cap - new_flow;
_re.cap = new_flow;
}

Cap flow(int s, int t) {
return flow(s, t, std::numeric_limits<Cap>::max());
}
Cap flow(int s, int t, Cap flow_limit) {
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);

std::vector<int> level(_n), iter(_n);
internal::simple_queue<int> que;

auto bfs = [&]() {
std::fill(level.begin(), level.end(), -1);
level[s] = 0;
que.clear();
que.push(s);
while (!que.empty()) {
int v = que.front();
que.pop();
for (auto e : g[v]) {
if (e.cap == 0 || level[e.to] >= 0) continue;
level[e.to] = level[v] + 1;
if (e.to == t) return;
que.push(e.to);
}
}
};
auto dfs = [&](auto self, int v, Cap up) {
if (v == s) return up;
Cap res = 0;
int level_v = level[v];
for (int& i = iter[v]; i < int(g[v].size()); i++) {
_edge& e = g[v][i];
if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;
Cap d =
self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));
if (d <= 0) continue;
g[v][i].cap += d;
g[e.to][e.rev].cap -= d;
res += d;
if (res == up) return res;
}
level[v] = _n;
return res;
};

Cap flow = 0;
while (flow < flow_limit) {
bfs();
if (level[t] == -1) break;
std::fill(iter.begin(), iter.end(), 0);
Cap f = dfs(dfs, t, flow_limit - flow);
if (!f) break;
flow += f;
}
return flow;
}

std::vector<bool> min_cut(int s) {
std::vector<bool> visited(_n);
internal::simple_queue<int> que;
que.push(s);
while (!que.empty()) {
int p = que.front();
que.pop();
visited[p] = true;
for (auto e : g[p]) {
if (e.cap && !visited[e.to]) {
visited[e.to] = true;
que.push(e.to);
}
}
}
return visited;
}

private:
int _n;
struct _edge {
int to, rev;
Cap cap;
};
std::vector<std::pair<int, int>> pos;
std::vector<std::vector<_edge>> g;
};

}  // namespace atcoder


#line 1 "library/atcoder/mincostflow.hpp"



#line 9 "library/atcoder/mincostflow.hpp"

#line 1 "library/atcoder/internal_csr.hpp"



#line 7 "library/atcoder/internal_csr.hpp"

namespace atcoder {
namespace internal {

template <class E> struct csr {
std::vector<int> start;
std::vector<E> elist;
explicit csr(int n, const std::vector<std::pair<int, E>>& edges)
: start(n + 1), elist(edges.size()) {
for (auto e : edges) {
start[e.first + 1]++;
}
for (int i = 1; i <= n; i++) {
start[i] += start[i - 1];
}
auto counter = start;
for (auto e : edges) {
elist[counter[e.first]++] = e.second;
}
}
};

}  // namespace internal

}  // namespace atcoder


#line 12 "library/atcoder/mincostflow.hpp"

namespace atcoder {

template <class Cap, class Cost> struct mcf_graph {
public:
mcf_graph() {}
explicit mcf_graph(int n) : _n(n) {}

int add_edge(int from, int to, Cap cap, Cost cost) {
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
assert(0 <= cost);
int m = int(_edges.size());
_edges.push_back({from, to, cap, 0, cost});
return m;
}

struct edge {
int from, to;
Cap cap, flow;
Cost cost;
};

edge get_edge(int i) {
int m = int(_edges.size());
assert(0 <= i && i < m);
return _edges[i];
}
std::vector<edge> edges() { return _edges; }

std::pair<Cap, Cost> flow(int s, int t) {
return flow(s, t, std::numeric_limits<Cap>::max());
}
std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {
return slope(s, t, flow_limit).back();
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t) {
return slope(s, t, std::numeric_limits<Cap>::max());
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);

int m = int(_edges.size());
std::vector<int> edge_idx(m);

auto g = [&]() {
std::vector<int> degree(_n), redge_idx(m);
std::vector<std::pair<int, _edge>> elist;
elist.reserve(2 * m);
for (int i = 0; i < m; i++) {
auto e = _edges[i];
edge_idx[i] = degree[e.from]++;
redge_idx[i] = degree[e.to]++;
elist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});
elist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});
}
auto _g = internal::csr<_edge>(_n, elist);
for (int i = 0; i < m; i++) {
auto e = _edges[i];
edge_idx[i] += _g.start[e.from];
redge_idx[i] += _g.start[e.to];
_g.elist[edge_idx[i]].rev = redge_idx[i];
_g.elist[redge_idx[i]].rev = edge_idx[i];
}
return _g;
}();

auto result = slope(g, s, t, flow_limit);

for (int i = 0; i < m; i++) {
auto e = g.elist[edge_idx[i]];
_edges[i].flow = _edges[i].cap - e.cap;
}

return result;
}

private:
int _n;
std::vector<edge> _edges;

// inside edge
struct _edge {
int to, rev;
Cap cap;
Cost cost;
};

std::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,
int s,
int t,
Cap flow_limit) {
// variants (C = maxcost):
// -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0
// reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge

// dual_dist[i] = (dual[i], dist[i])
std::vector<std::pair<Cost, Cost>> dual_dist(_n);
std::vector<int> prev_e(_n);
std::vector<bool> vis(_n);
struct Q {
Cost key;
int to;
bool operator<(Q r) const { return key > r.key; }
};
std::vector<int> que_min;
std::vector<Q> que;
auto dual_ref = [&]() {
for (int i = 0; i < _n; i++) {
dual_dist[i].second = std::numeric_limits<Cost>::max();
}
std::fill(vis.begin(), vis.end(), false);
que_min.clear();
que.clear();

// que[0..heap_r) was heapified
size_t heap_r = 0;

dual_dist[s].second = 0;
que_min.push_back(s);
while (!que_min.empty() || !que.empty()) {
int v;
if (!que_min.empty()) {
v = que_min.back();
que_min.pop_back();
} else {
while (heap_r < que.size()) {
heap_r++;
std::push_heap(que.begin(), que.begin() + heap_r);
}
v = que.front().to;
std::pop_heap(que.begin(), que.end());
que.pop_back();
heap_r--;
}
if (vis[v]) continue;
vis[v] = true;
if (v == t) break;
// dist[v] = shortest(s, v) + dual[s] - dual[v]
// dist[v] >= 0 (all reduced cost are positive)
// dist[v] <= (n-1)C
Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;
for (int i = g.start[v]; i < g.start[v + 1]; i++) {
auto e = g.elist[i];
if (!e.cap) continue;
// |-dual[e.to] + dual[v]| <= (n-1)C
// cost <= C - -(n-1)C + 0 = nC
Cost cost = e.cost - dual_dist[e.to].first + dual_v;
if (dual_dist[e.to].second - dist_v > cost) {
Cost dist_to = dist_v + cost;
dual_dist[e.to].second = dist_to;
prev_e[e.to] = e.rev;
if (dist_to == dist_v) {
que_min.push_back(e.to);
} else {
que.push_back(Q{dist_to, e.to});
}
}
}
}
if (!vis[t]) {
return false;
}

for (int v = 0; v < _n; v++) {
if (!vis[v]) continue;
// dual[v] = dual[v] - dist[t] + dist[v]
//         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) +
//         (shortest(s, v) + dual[s] - dual[v]) = - shortest(s,
//         t) + dual[t] + shortest(s, v) = shortest(s, v) -
//         shortest(s, t) >= 0 - (n-1)C
dual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;
}
return true;
};
Cap flow = 0;
Cost cost = 0, prev_cost_per_flow = -1;
std::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};
while (flow < flow_limit) {
if (!dual_ref()) break;
Cap c = flow_limit - flow;
for (int v = t; v != s; v = g.elist[prev_e[v]].to) {
c = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);
}
for (int v = t; v != s; v = g.elist[prev_e[v]].to) {
auto& e = g.elist[prev_e[v]];
e.cap += c;
g.elist[e.rev].cap -= c;
}
Cost d = -dual_dist[s].first;
flow += c;
cost += c * d;
if (prev_cost_per_flow == d) {
result.pop_back();
}
result.push_back({flow, cost});
prev_cost_per_flow = d;
}
return result;
}
};

}  // namespace atcoder


#line 1 "library/atcoder/scc.hpp"



#line 7 "library/atcoder/scc.hpp"

#line 1 "library/atcoder/internal_scc.hpp"



#line 7 "library/atcoder/internal_scc.hpp"

#line 9 "library/atcoder/internal_scc.hpp"

namespace atcoder {
namespace internal {

// Reference:
// R. Tarjan,
// Depth-First Search and Linear Graph Algorithms
struct scc_graph {
public:
explicit scc_graph(int n) : _n(n) {}

int num_vertices() { return _n; }

void add_edge(int from, int to) { edges.push_back({from, {to}}); }

// @return pair of (# of scc, scc id)
std::pair<int, std::vector<int>> scc_ids() {
auto g = csr<edge>(_n, edges);
int now_ord = 0, group_num = 0;
std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
visited.reserve(_n);
auto dfs = [&](auto self, int v) -> void {
low[v] = ord[v] = now_ord++;
visited.push_back(v);
for (int i = g.start[v]; i < g.start[v + 1]; i++) {
auto to = g.elist[i].to;
if (ord[to] == -1) {
self(self, to);
low[v] = std::min(low[v], low[to]);
} else {
low[v] = std::min(low[v], ord[to]);
}
}
if (low[v] == ord[v]) {
while (true) {
int u = visited.back();
visited.pop_back();
ord[u] = _n;
ids[u] = group_num;
if (u == v) break;
}
group_num++;
}
};
for (int i = 0; i < _n; i++) {
if (ord[i] == -1) dfs(dfs, i);
}
for (auto& x : ids) {
x = group_num - 1 - x;
}
return {group_num, ids};
}

std::vector<std::vector<int>> scc() {
auto ids = scc_ids();
int group_num = ids.first;
std::vector<int> counts(group_num);
for (auto x : ids.second) counts[x]++;
std::vector<std::vector<int>> groups(ids.first);
for (int i = 0; i < group_num; i++) {
groups[i].reserve(counts[i]);
}
for (int i = 0; i < _n; i++) {
groups[ids.second[i]].push_back(i);
}
return groups;
}

private:
int _n;
struct edge {
int to;
};
std::vector<std::pair<int, edge>> edges;
};

}  // namespace internal

}  // namespace atcoder


#line 9 "library/atcoder/scc.hpp"

namespace atcoder {

struct scc_graph {
public:
scc_graph() : internal(0) {}
explicit scc_graph(int n) : internal(n) {}

void add_edge(int from, int to) {
int n = internal.num_vertices();
assert(0 <= from && from < n);
assert(0 <= to && to < n);
internal.add_edge(from, to);
}

std::vector<std::vector<int>> scc() { return internal.scc(); }

private:
internal::scc_graph internal;
};

}  // namespace atcoder


#line 1 "library/atcoder/segtree.hpp"



#line 7 "library/atcoder/segtree.hpp"

#line 9 "library/atcoder/segtree.hpp"

namespace atcoder {

template <class S, S (*op)(S, S), S (*e)()> struct segtree {
public:
segtree() : segtree(0) {}
explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}
explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
for (int i = 0; i < _n; i++) d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--) {
update(i);
}
}

void set(int p, S x) {
assert(0 <= p && p < _n);
p += size;
d[p] = x;
for (int i = 1; i <= log; i++) update(p >> i);
}

S get(int p) const {
assert(0 <= p && p < _n);
return d[p + size];
}

S prod(int l, int r) const {
assert(0 <= l && l <= r && r <= _n);
S sml = e(), smr = e();
l += size;
r += size;

while (l < r) {
if (l & 1) sml = op(sml, d[l++]);
if (r & 1) smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}
return op(sml, smr);
}

S all_prod() const { return d[1]; }

template <bool (*f)(S)> int max_right(int l) const {
return max_right(l, [](S x) { return f(x); });
}
template <class F> int max_right(int l, F f) const {
assert(0 <= l && l <= _n);
assert(f(e()));
if (l == _n) return _n;
l += size;
S sm = e();
do {
while (l % 2 == 0) l >>= 1;
if (!f(op(sm, d[l]))) {
while (l < size) {
l = (2 * l);
if (f(op(sm, d[l]))) {
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}

template <bool (*f)(S)> int min_left(int r) const {
return min_left(r, [](S x) { return f(x); });
}
template <class F> int min_left(int r, F f) const {
assert(0 <= r && r <= _n);
assert(f(e()));
if (r == 0) return 0;
r += size;
S sm = e();
do {
r--;
while (r > 1 && (r % 2)) r >>= 1;
if (!f(op(d[r], sm))) {
while (r < size) {
r = (2 * r + 1);
if (f(op(d[r], sm))) {
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;

void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
};

}  // namespace atcoder


#line 1 "library/atcoder/string.hpp"



#line 9 "library/atcoder/string.hpp"

namespace atcoder {

namespace internal {

std::vector<int> sa_naive(const std::vector<int>& s) {
int n = int(s.size());
std::vector<int> sa(n);
std::iota(sa.begin(), sa.end(), 0);
std::sort(sa.begin(), sa.end(), [&](int l, int r) {
if (l == r) return false;
while (l < n && r < n) {
if (s[l] != s[r]) return s[l] < s[r];
l++;
r++;
}
return l == n;
});
return sa;
}

std::vector<int> sa_doubling(const std::vector<int>& s) {
int n = int(s.size());
std::vector<int> sa(n), rnk = s, tmp(n);
std::iota(sa.begin(), sa.end(), 0);
for (int k = 1; k < n; k *= 2) {
auto cmp = [&](int x, int y) {
if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];
int rx = x + k < n ? rnk[x + k] : -1;
int ry = y + k < n ? rnk[y + k] : -1;
return rx < ry;
};
std::sort(sa.begin(), sa.end(), cmp);
tmp[sa[0]] = 0;
for (int i = 1; i < n; i++) {
tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
}
std::swap(tmp, rnk);
}
return sa;
}

// SA-IS, linear-time suffix array construction
// Reference:
// G. Nong, S. Zhang, and W. H. Chan,
// Two Efficient Algorithms for Linear Time Suffix Array Construction
template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
std::vector<int> sa_is(const std::vector<int>& s, int upper) {
int n = int(s.size());
if (n == 0) return {};
if (n == 1) return {0};
if (n == 2) {
if (s[0] < s[1]) {
return {0, 1};
} else {
return {1, 0};
}
}
if (n < THRESHOLD_NAIVE) {
return sa_naive(s);
}
if (n < THRESHOLD_DOUBLING) {
return sa_doubling(s);
}

std::vector<int> sa(n);
std::vector<bool> ls(n);
for (int i = n - 2; i >= 0; i--) {
ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
}
std::vector<int> sum_l(upper + 1), sum_s(upper + 1);
for (int i = 0; i < n; i++) {
if (!ls[i]) {
sum_s[s[i]]++;
} else {
sum_l[s[i] + 1]++;
}
}
for (int i = 0; i <= upper; i++) {
sum_s[i] += sum_l[i];
if (i < upper) sum_l[i + 1] += sum_s[i];
}

auto induce = [&](const std::vector<int>& lms) {
std::fill(sa.begin(), sa.end(), -1);
std::vector<int> buf(upper + 1);
std::copy(sum_s.begin(), sum_s.end(), buf.begin());
for (auto d : lms) {
if (d == n) continue;
sa[buf[s[d]]++] = d;
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
sa[buf[s[n - 1]]++] = n - 1;
for (int i = 0; i < n; i++) {
int v = sa[i];
if (v >= 1 && !ls[v - 1]) {
sa[buf[s[v - 1]]++] = v - 1;
}
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
for (int i = n - 1; i >= 0; i--) {
int v = sa[i];
if (v >= 1 && ls[v - 1]) {
sa[--buf[s[v - 1] + 1]] = v - 1;
}
}
};

std::vector<int> lms_map(n + 1, -1);
int m = 0;
for (int i = 1; i < n; i++) {
if (!ls[i - 1] && ls[i]) {
lms_map[i] = m++;
}
}
std::vector<int> lms;
lms.reserve(m);
for (int i = 1; i < n; i++) {
if (!ls[i - 1] && ls[i]) {
lms.push_back(i);
}
}

induce(lms);

if (m) {
std::vector<int> sorted_lms;
sorted_lms.reserve(m);
for (int v : sa) {
if (lms_map[v] != -1) sorted_lms.push_back(v);
}
std::vector<int> rec_s(m);
int rec_upper = 0;
rec_s[lms_map[sorted_lms[0]]] = 0;
for (int i = 1; i < m; i++) {
int l = sorted_lms[i - 1], r = sorted_lms[i];
int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
bool same = true;
if (end_l - l != end_r - r) {
same = false;
} else {
while (l < end_l) {
if (s[l] != s[r]) {
break;
}
l++;
r++;
}
if (l == n || s[l] != s[r]) same = false;
}
if (!same) rec_upper++;
rec_s[lms_map[sorted_lms[i]]] = rec_upper;
}

auto rec_sa =
sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);

for (int i = 0; i < m; i++) {
sorted_lms[i] = lms[rec_sa[i]];
}
induce(sorted_lms);
}
return sa;
}

}  // namespace internal

std::vector<int> suffix_array(const std::vector<int>& s, int upper) {
assert(0 <= upper);
for (int d : s) {
assert(0 <= d && d <= upper);
}
auto sa = internal::sa_is(s, upper);
return sa;
}

template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {
int n = int(s.size());
std::vector<int> idx(n);
iota(idx.begin(), idx.end(), 0);
sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });
std::vector<int> s2(n);
int now = 0;
for (int i = 0; i < n; i++) {
if (i && s[idx[i - 1]] != s[idx[i]]) now++;
s2[idx[i]] = now;
}
return internal::sa_is(s2, now);
}

std::vector<int> suffix_array(const std::string& s) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return internal::sa_is(s2, 255);
}

// Reference:
// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
// Applications
template <class T>
std::vector<int> lcp_array(const std::vector<T>& s,
const std::vector<int>& sa) {
int n = int(s.size());
assert(n >= 1);
std::vector<int> rnk(n);
for (int i = 0; i < n; i++) {
rnk[sa[i]] = i;
}
std::vector<int> lcp(n - 1);
int h = 0;
for (int i = 0; i < n; i++) {
if (h > 0) h--;
if (rnk[i] == 0) continue;
int j = sa[rnk[i] - 1];
for (; j + h < n && i + h < n; h++) {
if (s[j + h] != s[i + h]) break;
}
lcp[rnk[i] - 1] = h;
}
return lcp;
}

std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return lcp_array(s2, sa);
}

// Reference:
// D. Gusfield,
// Algorithms on Strings, Trees, and Sequences: Computer Science and
// Computational Biology
template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {
int n = int(s.size());
if (n == 0) return {};
std::vector<int> z(n);
z[0] = 0;
for (int i = 1, j = 0; i < n; i++) {
int& k = z[i];
k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);
while (i + k < n && s[k] == s[i + k]) k++;
if (j + z[j] < i + z[i]) j = i;
}
z[0] = n;
return z;
}

std::vector<int> z_algorithm(const std::string& s) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return z_algorithm(s2);
}

}  // namespace atcoder


#line 1 "library/atcoder/twosat.hpp"



#line 6 "library/atcoder/twosat.hpp"

#line 8 "library/atcoder/twosat.hpp"

namespace atcoder {

// Reference:
// B. Aspvall, M. Plass, and R. Tarjan,
// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean
// Formulas
struct two_sat {
public:
two_sat() : _n(0), scc(0) {}
explicit two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}

void add_clause(int i, bool f, int j, bool g) {
assert(0 <= i && i < _n);
assert(0 <= j && j < _n);
scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));
scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));
}
bool satisfiable() {
auto id = scc.scc_ids().second;
for (int i = 0; i < _n; i++) {
if (id[2 * i] == id[2 * i + 1]) return false;
_answer[i] = id[2 * i] < id[2 * i + 1];
}
return true;
}
std::vector<bool> answer() { return _answer; }

private:
int _n;
std::vector<bool> _answer;
internal::scc_graph scc;
};

}  // namespace atcoder


#line 6 "Contests/AtCoder_arc123/arc123_b/main.cpp"
using namespace atcoder;

// define your macros here.
#define MOD 1000000007
#define PI 3.14159265358979323846264338327950288419
#define IINF 1001001001
#define LINF 1001001001001001001LL

#define ll long long
#define VLL vector<ll>
#define PLL pair<ll, ll>
#define pb push_back
#define mpair make_pair
#define pm(first, second) pb(mpair((first), (second)))
#define pff first.first
#define pfs first.second
#define psf second.first
#define pss second.second

#define REP(i,n) for(ll i = 0; i < (ll)(n); i++)
#define REPS(i, n) for(ll i = 1; i <= (ll)(n); i++)
#define RREP(i, n) for(int i = ((ll)(n)-1); i >= 0; i--)
#define RREPS(i, n) for(int i = ((ll)(n)); i > 0; i--)
#define FOR(i, a, b) for(ll i = (a); i < (b); i++)
#define SZ(x) ((ll)(x).size())
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define MAX(a, b) max((ll)(a), (ll)(b))
#define MIN(a, b) min((ll)(a), (ll)(b))
#define DCEIL(a, b) (((a)+(b)-1)/(b))
#define UNIQUE(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
#define outyn(flag) cout << ((flag)? "Yes": "No") << endl
#define outYN(flag) cout << ((flag)? "YES": "NO") << endl
#define out(output) cout << (output) << endl

template<class T>bool chmax(T &a, const T &b) { return a < b && (a = b, true); }
template<class T>bool chmin(T &a, const T &b) { return a > b && (a = b, true); }
ll qp(ll a, ll b){ll ans=1;do{if(b&1)ans=1LL*ans*a;a=1LL*a*a;}while(b>>=1);return ans;}
ll qp(ll a, ll b, ll mo){ll ans=1;do{if(b&1)ans=1LL*ans*a%mo;a=1LL*a*a%mo;}while(b>>=1);return ans;}
int DX[4] = {1, 0, -1, 0};
int DY[4] = {0, 1, 0, -1};

#define int long long

void solve(){
// write your solution here.

int N;
cin >> N;
VLL A(N), B(N), C(N);
REP(i, N){
cin >> A[i];
}
REP(i, N){
cin >> B[i];
}
REP(i, N){
cin >> C[i];
}
sort(ALL(A));
sort(ALL(B));
sort(ALL(C));

int b = 0, c = 0, ans = 0;
REP(a, N){
while(b < N && A[a] >= B[b]) b++;
while(c < N && B[b] >= C[c]) c++;
if(b >= N || c >= N) break;
ans++;
b++;
c++;
}
out(ans);

}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
//cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
string to_string(const string& s) {
return '"' + s + '"';
}
string to_string(const char* s) {
return to_string((string) s);
}
string to_string(const char & ch) {
return "'" + string(1, ch) + "'";
}
string to_string(bool b) {
return (b ? "true" : "false");
}
template <typename A, typename B> string to_string(pair<A, B> p) {
return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

string to_string(vector<bool> v) {
bool first = true;
string res = "{";
for (int i = 0; i < static_cast<int>(v.size()); i++) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(v[i]);
}
res += "}";
return res;
}
template <size_t N> string to_string(bitset<N> v) {
string res = "";
for (size_t i = 0; i < N; i++) {
res += static_cast<char>('0' + v[i]);
}
return res;
}
template <typename A> string to_string(A v) {
bool first = true;
string res = "{";
for (const auto &x : v) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(x);
}
res += "}";
return res;
}
template <typename A> string to_string(A a[]) {
bool first = true, beg = false;
string res = "{";
for (int i = 0; i < 10; i++) {
if(a[i] == -1) if(beg) break; else continue;
beg = true;
if (!first) {
res += ", ";
}
first = false;
res += to_string(a[i]);
}
res += "}";
return res;
}

void debug_out() { cerr << endl; } template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) {
cerr << " " << to_string(H);
debug_out(T...);
}

#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#define all(x) x.begin(), x.end()
#define mem(a, b) memset(a, b, sizeof(a))
#define min(a, b) (a < b ? a : b)
#define max(a, b) (a > b ? a : b)
#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}

void solve()
{
string a;
cin >> a;
int b;
cin >> b;
string ans;
if(b % 2) ans += to_string(5 * b);
else ans += to_string(b / 2);
if(a[0] >= '5') ans += '0';
ans += a;
cout << ans;

}



signed main()
{
ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
// freopen("in.txt", "r", stdin); freopen("std.txt", "w", stdout);
int T = 1; // cin >> T;
while (T --> 0) solve();
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i=0; i<(n); i++)
#define INF ((1LL<<62)-(1LL<<31))
#define all(a)  (a).begin(),(a).end()
#define rall(a)  (a).rbegin(),(a).rend()
typedef long long ll;
typedef pair<ll,ll> pl;

ll num[3]={2*3,2*5,3*5};

int main() {
ll n;
cin >> n;
set<ll> se;
for(int i=1;;i++) {
rep(j,3) if(num[j]*i<=10000) se.insert(num[j]*i);
if(se.size()>=n) break;
}
vector<ll> v;
for(auto u:se) v.push_back(u); 
rep(i,n) {
if(i) cout << " ";
cout << v[i];
}
cout << endl;
return 0;
}
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }
ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}
const int inf = 1001001001;
const ll INF = 1001001001001001001;
const double PI = 3.1415926535;

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

const int MOD = 998244353;
using mint = modint998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;
ll div_floor(ll a, ll b) {
return a / b - (((a ^ b) < 0) and a % b);
}
ll div_ceil(ll a, ll b) {
return a / b + (((a ^ b) >= 0) and a % b);
}

signed main() {
cout << fixed << setprecision(15);

ll N;
cin >> N;
ll ans = INF;
ll cur = 1;
ll b = 0;
while(cur <= N){
ll a = N/cur;
ll c = N%cur;
chmin(ans, a + b + c);
if(cur<= N/2){
cur *= 2;
b++;
}
else break;
}
cout << ans << endl;
return 0;
}
#include <iostream>
using namespace std;

long long bf[1 << 19];
long long bg[1 << 19];

void init() {
for (int i = 1; i <= 400000; i++) {
int pos = i;
while (pos % 3 == 0) { pos /= 3; bf[i] += 1; }
bg[i] = pos % 3;
}
bg[0] = 1;
for (int i = 1; i <= 400000; i++) bf[i] += bf[i - 1];
for (int i = 1; i <= 400000; i++) bg[i] = (bg[i] * bg[i - 1]) % 3;
}

int ncr_mod_3(int n, int r) {
if (bf[n] != bf[r] + bf[n - r]) return 0;
if (bg[n] == 1 && bg[r] * bg[n - r] == 1) return 1;
if (bg[n] == 1 && bg[r] * bg[n - r] == 2) return 2;
if (bg[n] == 1 && bg[r] * bg[n - r] == 4) return 1;
if (bg[n] == 2 && bg[r] * bg[n - r] == 1) return 2;
if (bg[n] == 2 && bg[r] * bg[n - r] == 2) return 1;
if (bg[n] == 2 && bg[r] * bg[n - r] == 4) return 2;
return -1;
}

int main() {
int N; string S;
cin >> N >> S;
init();

int ret = 0;
for (int i = 0; i < N; i++) {
int p1 = 0, p2 = ncr_mod_3(N - 1, i);
if (S[i] == 'B') p1 = 0;
if (S[i] == 'W') p1 = 1;
if (S[i] == 'R') p1 = 2;
ret += p1 * p2;
ret %= 3;
}
if (N % 2 == 0) ret = (3 - ret) % 3;

if (ret == 0) cout << "B" << endl;
if (ret == 1) cout << "W" << endl;
if (ret == 2) cout << "R" << endl;
return 0;
}

#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
#include <tuple>
#include <cstdint>
#include <cstdio>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <bitset>
#include <cctype>
#include <climits>
#include <functional>
#include <cassert>

#define rep(i, n) for(int i = 0; i < (n); i++)
#define per(i, n) for(int i = (n) - 1; i >= 0; i--)
using ll = long long;
#define vi vector<int>
#define vvi vector<vi>
#define vl vector<ll>
#define pii pair<int, int>
#define pll pair<ll, ll>
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define mod 3
using namespace std;
template<class T, class U>
bool chmax(T &a, const U &b){ return a < b ? (a = b, 1) : 0; }
template<class T, class U>
bool chmin(T &a, const U &b){ return a > b ? (a = b, 1) : 0; }
struct mint{
ll x;
mint(ll x = 0) : x((x + mod) % mod){}
mint operator-() const{ return mint(-x); }
mint operator+=(const mint &a){
if((x += a.x) >= mod) x -= mod;
return *this;
}
mint &operator++(){
if(++x == mod) x = 0;
return *this;
}
mint operator++(int){
mint temp = *this;
if(++x == mod) x = 0;
return temp;
}
mint &operator-=(const mint &a){
if((x -= a.x) < 0) x += mod;
return *this;
}
mint &operator--(){
if(--x < 0) x += mod;
return *this;
}
mint operator--(int){
mint temp = *this;
if(--x < 0) x += mod;
return temp;
}
mint &operator*=(const mint &a){
(x *= a.x) %= mod;
return *this;
}
mint operator+(const mint &a) const{ return mint(*this) += a; }
mint operator-(const mint &a) const{ return mint(*this) -= a; }
mint operator*(const mint &a) const{ return mint(*this) *= a; }
mint pow(ll t) const{
if(!t) return 1;
mint res = 1, v = *this;
while(t){
if(t & 1) res *= v;
v *= v;
t >>= 1;
}
return res;
}
mint inv() const{ return pow(mod - 2); }
mint &operator/=(const mint &a){ return (*this) *= a.inv(); }
mint operator/(const mint &a) const{ return mint(*this) /= a; }
bool operator==(const mint &a) const{ return x == a.x; }
bool operator<(const mint &a) const{ return x < a.x; }
bool operator>(const mint &a) const{ return x > a.x; }
friend istream &operator>>(istream &is, mint &a){ return is >> a.x; }
friend ostream &operator<<(ostream &os, const mint &a){ return os << a.x; }
};
constexpr int len = 2000010;
constexpr int f_size = min(len, mod);
mint fact[f_size], invfact[f_size], inv[f_size];
struct initializer {
initializer(){
fact[0] = fact[1] = inv[1] = 1;
invfact[0] = invfact[1] = 1;
for(int i = 2; i < f_size; i++){
fact[i] = fact[i - 1] * i;
inv[i] = -inv[mod % i] * (mod/i);
invfact[i] = invfact[i - 1] * inv[i];
}
}
} initializer;
mint C(int n, int r){
assert(0 <= n && n < len);
mint res = 1;
while(r){
int a = n % mod;
int b = r % mod;
if(a < b) return 0;
res *= fact[a] * invfact[b] * invfact[a - b];
n /= mod;
r /= mod;
}
return res;
}
mint H(int n, int r){
assert(0 < n && 0 <= r);
assert(0 < n+r && n+r <= len);
return C(n + r - 1, r);
}
int main(){
int n;
cin >> n;
vector<char> c(n);
int ans = 0;
rep(i, n){
cin >> c[i];
int val = C(n - 1, i).x;
if(c[i] == 'B'){
ans += 0 * val % 3;
}
if(c[i] == 'W'){
ans += 1 * val % 3;
}
if(c[i] == 'R'){
ans += 2 * val % 3;
}
ans %= 3;
}
if(!(n & 1)) ans = (-ans + 3) % 3;
if(ans == 0) cout << "B\n";
if(ans == 1) cout << "W\n";
if(ans == 2) cout << "R\n";
}
#include <iostream>
#include <array>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <cmath>
#include <string>
#include <climits>
#include <cassert>
#include <iomanip>
#include <bitset>
#include <queue>
#include <deque>
#include <stack>
#include <functional>
#include <fstream>
#include <random>
#include <functional>

#define LEN(x) (long long)(x.size())
#define FOR(i, a, n) for(int i=(a);i<(n); ++i)
#define FOE(i, a) for(auto i : a)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SUM(x) std::accumulate(ALL(x), 0LL)
#define MIN(v) *std::min_element(v.begin(), v.end())
#define MAX(v) *std::max_element(v.begin(), v.end())
#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())
#define BIT_COUNT32(bit) (__builtin_popcount(bit))
#define BIT_COUNT64(bit) (__builtin_popcountll(bit))

typedef long long LL;
template<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}
template<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14
template<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}
template<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}
template<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }
void print() { std::cout << std::endl; }
template <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << " ";} print(std::forward<Tail>(tail)...); }
template <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << " ";} }std::cout << std::endl;}
template <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}
void debug() { std::cerr << std::endl; }
template <class Head, class... Tail> void debug(Head&& head, Tail&&... tail) { std::cerr << head; if (sizeof...(tail) != 0) {std::cerr << " ";} print(std::forward<Tail>(tail)...); }
template <class T> void debug(std::vector<T> &v) {for (auto& a : v) { std::cerr << a; if (&a != &v.back()) {std::cerr << " ";} }std::cerr << std::endl;}
template <class T> void debug(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}
inline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }
template<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }
template<class T> inline T manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }
template<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }
template<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }
bool is_bit_on(const unsigned long long bit, const unsigned int i) { return (bit >> i) & 1u; }
unsigned long long bit_set(const unsigned long long bit, const unsigned int i, const unsigned int b) {
assert(b == 0 or b == 1);
if (b == 0) { return bit & ~(1ull << i); }
else        {return bit | (1ull << i); }
}

template<class T> inline std::vector<T> unique(std::vector<T> v) {
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
return v;
}

// 初項s交差d長さnの数列の和
long long sum_of_arithmetic_progression(long long s, long long d, long long n) {
return n * (2 * s + (n - 1) * d) / 2;
}

// xが2の階乗かどうか判定
bool is_power_of_two(long long x) {
return !(x & (x - 1));
}

long long gcd(long long a, long long b) {
if (b == 0) { return a; }
return gcd(b, a % b);
}

long long gcd(std::vector<long long> &v) {
long long ans = v[0];
for (int i = 1; i < (int) v.size(); ++i) {
ans = gcd(ans, v[i]);
}
return ans;
}

long long lcm(long long a, long long b) {
long long g = gcd(a, b);
return a / g * b;
}

const int INF = 1u << 30u;  // 1,073,741,824
const long long LINF = 1ull << 60u;
const double EPS = 1e-9;
const long double PI = acos(-1.0);
const std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下
const std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};
const std::vector<int> dy6 = {0, -1, 0, 1, 1, 1}, dx6 = {1, 0, -1, 0, 1, -1};
const std::vector<int> dy8 = {0, -1, 0, 1, 1, -1, -1, 1}, dx8 = {1, 0, -1, 0, 1, 1, -1, -1};

using namespace std;

#include <vector>
#include <cassert>

template<typename T> class CumulativeSum {
public:
std::vector<T> memo;

CumulativeSum() {}

CumulativeSum(const std::vector<T> &line) {
this->build(line);
}

void build(const std::vector<T> &line) {
this->memo = std::vector<T>(line.size() + 1, 0);
for (int i = 0; i < line.size(); ++i) {
this->memo[i + 1] = this->memo[i] + line[i];
}
}

// sum[left, right)
T sum(int left, int right) {
assert(right >= left);
return this->memo[right] - this->memo[left];
}
};

int main() {
LL N;
cin >> N;

auto A = make_v<LL>(N);
FOR(i, 0, N) {
cin >> A[i];
if (i % 2 == 1) {
A[i] *= -1;
}
}

CumulativeSum cs(A);
LL ans = 0;
unordered_map<LL, LL> m;
FOR(i, 0, N) {
ans += m[cs.memo[i + 1]];
m[cs.memo[i]]++;
}
print(ans);

return 0;
}

#include <bits/stdc++.h>
using namespace std;
string to_string(const string& s) {
return '"' + s + '"';
}
string to_string(const char* s) {
return to_string((string) s);
}
string to_string(const char & ch) {
return "'" + string(1, ch) + "'";
}
string to_string(bool b) {
return (b ? "true" : "false");
}
template <typename A, typename B> string to_string(pair<A, B> p) {
return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

string to_string(vector<bool> v) {
bool first = true;
string res = "{";
for (int i = 0; i < static_cast<int>(v.size()); i++) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(v[i]);
}
res += "}";
return res;
}
template <size_t N> string to_string(bitset<N> v) {
string res = "";
for (size_t i = 0; i < N; i++) {
res += static_cast<char>('0' + v[i]);
}
return res;
}
template <typename A> string to_string(A v) {
bool first = true;
string res = "{";
for (const auto &x : v) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(x);
}
res += "}";
return res;
}
template <typename A> string to_string(A a[]) {
bool first = true, beg = false;
string res = "{";
for (int i = 0; i < 10; i++) {
if(a[i] == -1) if(beg) break; else continue;
beg = true;
if (!first) {
res += ", ";
}
first = false;
res += to_string(a[i]);
}
res += "}";
return res;
}

void debug_out() { cerr << endl; } template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) {
cerr << " " << to_string(H);
debug_out(T...);
}

#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#define all(x) x.begin(), x.end()
#define mem(a, b) memset(a, b, sizeof(a))
#define min(a, b) (a < b ? a : b)
#define max(a, b) (a > b ? a : b)
#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}

void solve()
{
int n, m;
cin >> n >> m;
vector<string> s(n);
for(int i = 0; i < n; i++) {
cin >> s[i];
}
auto check = [&](int x, int y) {
vector<bool> c(6, 0);
if(x > 0 && s[x - 1][y] != '.') c[s[x - 1][y] - '0'] = 1;
if(y > 0 && s[x][y - 1] != '.') c[s[x][y - 1] - '0'] = 1;
if(x < n - 1 && s[x + 1][y] != '.') c[s[x + 1][y] - '0'] = 1;
if(y < m - 1 && s[x][y + 1] != '.') c[s[x][y + 1] - '0'] = 1;
for(int i = 1; i <= 5; i++) {
if(!c[i]) return i;
}
return 114514;
};
for(int i = 0; i < n; i++) {
for(int j = 0; j < m; j++) {
if(s[i][j] == '.') {
s[i][j] = '0' + check(i, j);
}
}
}
for(auto& x : s) cout << x << '\n';
}



signed main()
{
ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
// freopen("in.txt", "r", stdin); freopen("std.txt", "w", stdout);
int T = 1; // cin >> T;
while (T --> 0) solve();
return 0;
}

#include <bits/stdc++.h>
typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
typedef pair<int, int> P;
int main() {
vector<ll> a(3);
for (ll i = 0; i < 3; i++) {
cin >> a[i];
}
ll l = a[1] - a[0];
ll r = a[2] - a[1];
if (l == r) {
cout << 0 << endl;
return 0;
}
if (l > r) {
cout << l - r << endl;
return 0;
}
ll d = r - l;
if (d % 2 == 0) {
cout << d / 2 << endl;
return 0;
}
cout << (d + 1) / 2 + 1 << endl;
return 0;
}

/// Zengy MANGA
#pragma GCC optimize("O3")
#pragma GCC optimize ("unroll-loops")
#pragma GCC target("avx,avx2,fma")

#include "bits/stdc++.h"

using namespace std;

#define pb push_back
#define F first
#define S second
#define f(i, a, b)  for(int i = a; i < b; i++)
#define all(a)  a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define sz(x) (int)(x).size()
#define mp(x,y) make_pair(x,y)
#define popCnt(x) (__builtin_popcountll(x))

using ll = long long;
using ii = pair<int,int>;
using ull = unsigned long long;
using db = long double;

const int N = 1e5+5, LG = 18, MOD = 998244353;
const long double PI = acos(-1);
int dp[13][5005];
int n, m;
int C[5005][5005];
int solve(int bit, int sum) {
if(sum < 0)return 0;
if(bit == 13)
return !sum;
int &ret = dp[bit][sum];
if(~ret)
return ret;
ret = 0;
for(int cnt = 0; cnt <= n; cnt += 2) {
ret =(ret + 1ll * solve(bit + 1, sum - (1 << bit) * cnt) * C[n][cnt]) % MOD;
}
return ret;
}
void doWork() {
f(i,0,5005)
f(j,0,i+1)if(i==j||j==0)
C[i][j] = 1;
else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
memset(dp,-1,sizeof dp);
cin >> n >> m;
cout << solve(0,m) << '\n';
}

int32_t main() {
#ifdef ONLINE_JUDGE
ios_base::sync_with_stdio(0);
cin.tie(0);
#endif

int t = 1;
//    cin >> t;
while(t--) {
doWork();
}

return 0;
}

/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

int n, m;
cin >> n >> m;
LL even = 0, odd = 0;
rep(i, n) {
string s;
cin >> s;
int cnt = 0;
rep(j, m) if (s[j] == '1') ++cnt;
if (cnt%2) {
++odd;
} else {
++even;
}
}
cout << odd*even << endl;

cout << flush;
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
// your code goes here
int n;
cin>>n;
int a[n];
for(int i=0; i<n; i++){
cin>>a[i];
}
int k=0;
for(int i=0; i<n; i++){
if(a[i]>=k){
k=a[i];
}
else break;
}
for(int i=0; i<n; i++){
if(a[i]!=k){
cout<<a[i]<<" ";
}

}


return 0;
}
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using VI = vector<int>;
using P = pair<int, int>;

#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for (ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

template< typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true); }
template< typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true); }

const ll MOD = 1000000007;

int main() {
int N, K;
cin >> N >> K;
vector<int> A(K), ans(0);
vector<bool> B(N, false);
REP(i, K) {
cin >> A[i];
if (i < K - 1) B[A[i] - 1] = true;
}
int idx = 0;
REP(i, K - 1) {
ans.push_back(A[i]);
while (idx < N && B[idx]) idx++;
if (idx + 1 > A[i]) continue;
ans.push_back(idx + 1);
B[idx] = true;
idx++;
}
for (int i = N - 1; i >= 0; i--) {
if (!B[i]) ans.push_back(i + 1);
}
REP(i, N) {
cout << ans[i];
if (i < N - 1) cout << " ";
}
cout << endl;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int t;
ll n;

ll check(ll x)
{
int bit[30]={0},cnt=0;
while(n>0)
{
bit[++cnt]=n%10,n/=10;
}
int ans=0;
while(1)
{
int m=0,k=1;
while(bit[cnt]==0)cnt--;
for(int i=cnt;i && k;i--)
{
if(bit[i]<m)
{
bit[i]+=10;
bit[i+1]--;
k=0;
}
m=max(m,(bit[i]+2)/3);
}
if(k==1)
{
ans=m;
break;
}
}
return ans;
}

int main()
{
scanf("%d",&t);
while(t--)
{
scanf("%lld",&n);
if(n==0)
{
cout<<0<<endl;
continue;
}
if(n<10)
{
printf("%lld\n",(n-1)/3+1);
continue;
}
printf("%lld\n",check(n));
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/convolution>
#include <atcoder/lazysegtree>
#include <atcoder/modint>
using namespace atcoder;

//基本的にこれがなくてもうまくいくコードを心がけるが、念の為。時間ギリギリアウトの時は消してみる
#define int long long

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef pair<int, int> pi;
typedef pair<long long, long long> pl;
typedef vector<int> vi;
typedef vector<long long> vl;
typedef vector<vector<int> > vvi;
typedef vector<vector<long long> > vvl;
typedef priority_queue<int> pq;
typedef priority_queue<int, vector<int>, greater<int> > pqg;
typedef priority_queue<long long> pql;
typedef priority_queue<long long, vector<long long>, greater<long long> > pqgl;

#define pb push_back
#define eb emplace_back
#define mp make_pair

#define elif else if

#define all(obj) (obj).begin(), (obj).end()

#define reps(i, n, m) for (int i = (int)(n); i < (int)(m); i++)
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = n; i >= 0; i--)

#define cbit(x) __builtin_popcountll(x)

#define minv(v) *min_element(v.begin(), v.end())
#define maxv(v) *max_element(v.begin(), v.end())

#define print(v)                       \
for (auto k : v) cout << k << " "; \
cout << endl;

#define yesno(bool)            \
if (bool) {                \
cout << "Yes" << endl; \
} else {                   \
cout << "No" << endl;  \
}

//既存値aより新規値bが大きければ更新
template <class T>
bool chmax(T &a, const T &b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
//既存値aより新規値bが小さければ更新
template <class T>
bool chmin(T &a, const T &b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}

#define ednl endl  //打ち間違え用
#define enld endl
#define Endl endl

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
// int dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};
// int dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};

// const int MOD = 998244353;  //素数(223*119+1)
// const int MOD = 1000000007;  //素数

// using mint = modint998244353;
// using mint = modint1000000007;
// using mint = static_modint<1000000009>;
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////

signed main() {
int n, l;
cin >> n >> l;
int k = 1, cnt = 0;

while (k < n) {
cnt++;
k *= 3;
}
vector<string> s(3 * n);
for (int i = 0; i < l - cnt; i++) {
for (int j = 0; j < 3 * n; j++) {
if (i == 0) {
if (j / n == 0) s[j].pb('0');
if (j / n == 1) s[j].pb('1');
if (j / n == 2) s[j].pb('2');
} else {
if (j / n == 0) s[j].pb('2');
if (j / n == 1) s[j].pb('1');
if (j / n == 2) s[j].pb('0');
}
}
}
vector<string> ss(n);
for (int i = 0; i < n; i++) {
int p = i;
for (int j = 0; j < cnt; j++) {
int m = p % 3;
p /= 3;
ss[i].pb('0' + m);
}
reverse(all(ss[i]));
}
for (int i = 0; i < n; i++) {
s[2 * n + i] += ss[i];
}
for (int i = 0; i < n; i++) {
for (int j = 0; j < cnt; j++) {
if (ss[i][j] == '0')
ss[i][j] = '1';
else if (ss[i][j] == '1')
ss[i][j] = '2';
else
ss[i][j] = '0';
}
}
for (int i = 0; i < n; i++) {
s[n + i] += ss[i];
}
for (int i = 0; i < n; i++) {
for (int j = 0; j < cnt; j++) {
if (ss[i][j] == '0')
ss[i][j] = '1';
else if (ss[i][j] == '1')
ss[i][j] = '2';
else
ss[i][j] = '0';
}
}
for (int i = 0; i < n; i++) {
s[i] += ss[i];
}
for (int i = 0; i < n; i++) {
for (int j = 0; j < cnt; j++) {
if (ss[i][j] == '0')
ss[i][j] = '1';
else if (ss[i][j] == '1')
ss[i][j] = '2';
else
ss[i][j] = '0';
}
}
rep(i, 3 * n) cout << s[i] << endl;
}
#include<bits/stdc++.h>
#define maxn
#define ll long long
#define put() putchar('\n')
using namespace std;
inline void read(int &x){
int f=1;x=0;char c=getchar();
while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
x*=f;
}
signed main(void){
//	freopen("1.in","r",stdin);
ll sum=0,Max=0,ans=0;
int i,n,x;
read(n);
for (i=1;i<=n;i++) {
read(x);
sum+=x;Max=max(Max,(ll)x);ans+=sum-x;
printf("%lld\n",sum+Max*i+ans);
}
return 0;
}

/*#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include <iomanip>//fixed,setprecision
#include <limits.n>//INT_MAX
#include <math.n>//M_PI
#include <random>
#include <regex> // 正規表現
#include <time.h>*/
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
//using mint = modint1000000007;
using mint = modint998244353;
//std::chrono::time_point<std::chrono::steady_clock> start;
template <typename T> bool chmax(T &u, const T z) { if (u < z) {u = z; return true;} else return false; }
template <typename T> bool chmin(T &u, const T z) { if (u > z) {u = z; return true;} else return false; }
#define ll long long
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)
typedef pair<int, int> P;
ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }
ll lcm(ll a, ll b){return a * b / gcd(a, b);}

struct Student {
int sum,no, sugaku, eigo;

// 演算子オーバーロードで比較関数を定義
bool operator<(const Student& another) const {
if(sum!=another.sum)return sum>another.sum;
if (sugaku != another.sugaku)
return sugaku > another.sugaku; // 高い順に並べたいので演算子を逆に
if (eigo != another.eigo)
return eigo > another.eigo; // 同様に比較演算子を反転
return no < another.no;
}
};

int main(){
int t;
cin>>t;
while(t--){
ll n;
cin>>n;
if(n%2==1){
cout<<"Odd"<<endl;
}else {
if(n%4==0){
cout<<"Even"<<endl;
}else{
cout<<"Same"<<endl;
}
}
}
return 0;
}
#include <iostream>
#include <algorithm>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <iomanip>
#include <cmath>
#include <numeric>
using namespace std;
using ll = long long;

const long long BASE_NUM = 1000000007;
//https://scrapbox.io/pocala-kyopro/%E6%8B%A1%E5%BC%B5%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95
// https://ei1333.github.io/luzhiled/snippets/math/combination.html
template< int mod >
struct ModInt {
int x;

ModInt() : x(0) {}

ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}

ModInt &operator+=(const ModInt &p) {
if((x += p.x) >= mod) x -= mod;
return *this;
}

ModInt &operator-=(const ModInt &p) {
if((x += mod - p.x) >= mod) x -= mod;
return *this;
}

ModInt &operator*=(const ModInt &p) {
x = (int) (1LL * x * p.x % mod);
return *this;
}

ModInt &operator/=(const ModInt &p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt &p) const { return x == p.x; }

bool operator!=(const ModInt &p) const { return x != p.x; }

ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while(b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(int64_t n) const {
ModInt ret(1), mul(x);
while(n > 0) {
if(n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream &operator<<(ostream &os, const ModInt &p) {
return os << p.x;
}

friend istream &operator>>(istream &is, ModInt &a) {
int64_t t;
is >> t;
a = ModInt< mod >(t);
return (is);
}

static int get_mod() { return mod; }
};
using modint = ModInt< BASE_NUM >;

int solve()
{
ll n;
scanf("%lld", &n);
vector<pair<ll,ll>> A(2*n);
vector<bool> pm(2*n);
for(int i = 0;i< 2*n;i++){
cin >> A[i].first;
A[i].second = i;
}
sort(A.begin(),A.end());
for(int i = 0;i < n;i++){
pm[A[i].second] = false;
}
for(int i = n;i < 2*n;i++){
pm[A[i].second] = true;
}
string ans = "";
ll count = 0;
bool positive = true;
for(int i = 0; i < 2*n;i++){
if(count == 0){
positive = pm[i];
}
if (pm[i] == positive){
count++;
ans += '(';
}else{
count--;
ans += ')';
}
}
cout << ans << endl;
return 0;
}
int main()
{
// int t;
// cin >> t;
// for (size_t i = 0; i < t; i++)
// {
solve();
// }
cout << flush;
return 0;
}
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(x) (x).begin(),(x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define uniq(v) (v).erase(unique(all(v)),(v).end())
#define sz(x) (int)((x).size())
#define fo(x) cout<<x<<endl
#define int long long
#define vi vector<int>
#define vvi vector<vector<int>>
using namespace std;
using ll = long long;
using P = pair<int,int>;
#define ppcll __builtin_popcountll
using Graph = vector<vector<int>>;
int my_ceil(int a, int b){return (a+(b-1))/b;}
auto my_max(auto a, auto b){return a<b?b:a;}
auto my_min(auto a, auto b){return a<b?a:b;}
template <typename T> bool chmin(T &a, const T& b){if(a>b){a=b; return true;}return false;}
template <typename T> bool chmax(T &a, const T& b){if(a<b){a=b; return true;}return false;}
template<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;

const long long INF=1e18;
const int32_t Mod=1e9+7;
const int32_t MMod=998244353;

signed main() {
int N;
cin >> N;

int l_base=1;
int h_base=2;
int ans=0;

rep(i,0,16){
int l=l_base; // 1,11,111
int h=h_base; // 2,12,112

rep(j,0,16){
int dif=my_min(h-1,N)-my_min(l-1,N);
if(dif==0) break;
ans+=dif;
l*=10;
h*=10;
}

l_base=l_base*10+1; // 1->11
h_base=l_base+1; // 2->12
}

fo(ans);
}
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <vector>
#define setIO(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)
#define closefile fclose(stdin), fclose(stdout)
#define m_p make_pair
#define sz(x) (int)x.size()
#define see(x) cerr << x << " "
#define seeln(x) cerr << x << endl
#define out(x) cerr << #x << " = " << x << " "
#define outln(x) cerr << #x << " = " << x << endl
#define outarr(x, l, r) {cerr << #x"[" << l << " ~ " << r << "] = "; for (int _i = l; _i <= r; ++_i) cerr << x[_i] << " "; cerr << endl;}
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define gc() getchar()
//#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template <class T> void read(T &x) {
x = 0; int c = gc(); int flag = 0;
while (c < '0' || c > '9') flag |= (c == '-'), c = gc();
while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = gc();
if (flag) x = -x;
}
template <class T> bool checkmax(T &a, T b) {return a < b ? a = b, 1 : 0;}
template <class T> bool checkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}
ll n, l, r;
void init() {
scanf("%lld%lld%lld", &n, &l, &r);
}

void solve() {
ll ans = 0;
for (int i = 60; i >= 0; --i) {
if (n >> i & 1) {
ll A = 1LL << i, B = A + A - 1;
ans += max(min(B, r) - max(A, l) + 1, 0LL);
}
}
printf("%lld\n", ans);
}

int main() {
init();
solve();
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


// Editorial AC

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N; input(N);
string S; input(S);
string T; input(T);

ll S1 = 0;
ll T1 = 0;
VLL A, B;
REP(i,N) {
if (S[i] == '1') S1++;
if (T[i] == '1') T1++;
if (S[i] == '0') A.push_back(i);
if (T[i] == '0') B.push_back(i);
}
if (S1 != T1) {
print(-1); exit(0);
}

ll ans = 0;
REP(i,SZ(A)) ans += (A[i] != B[i]);
print(ans);

return 0;
}

#include <bits/stdc++.h>

#include <atcoder/all>
using namespace std;
using namespace atcoder;
#define rep(i, n) for (int i = 0; i < n; i++)
typedef long long ll;
const ll mod = 998244353;

int main() {
ll n;
cin >> n;
ll ans = 0;
ll flag = 1;
while (1) {
ll temp =
floor((double(n) + double(flag) * double(flag)) / (2 * double(flag)));
if (temp < flag) {
cout << ans << endl;
return 0;
}
ans = (ans + temp - flag + 1) % mod;
flag++;
}
}
#include <bits/stdc++.h>
#define rep(i, n)  for (int i = 0; i < (n); ++i)
using namespace std;
using ll = long long;
using P = pair<ll, ll>;
using Graph = vector<vector<int>>;

template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }

const int INF = INT_MAX / 2;
const ll INFL = 1LL << 60;
const double PI = acos(-1);
const ll mod = 1000000007;

int main() {
ll N;
cin >> N;

vector<ll> a(N), b(N);
rep(i,N) cin >> a[i];
rep(i,N) cin >> b[i];

sort(b.begin(), b.end());

vector<ll> x(N);
rep(i,N) x[i] = a[0] ^ b[i];

set<ll> ans;

rep(i,N) {
vector<ll> c(N);
rep(j,N) c[j] = a[j] ^ x[i];
sort(c.begin(), c.end());
bool ok = true;
rep(j,N) {
if(c[j] != b[j]) ok = false;
}
if(ok) ans.emplace(x[i]);
}

cout << ans.size() << endl;
for(auto el : ans) {
cout << el << endl;
}

}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m, r, c;
cin >> n >> m >> r >> c;
VLL fac(n + m + 1), ifac(n + m + 1);
fac[0] = 1;
for(int i = 1; i <= n + m; i++)
fac[i] = fac[i - 1] * i % mod;
auto qpow = [&](ll x, ll y = mod - 2)
{
ll res = 1;
while(y)
{
if(y & 1)
res = res * x % mod;
x = x * x % mod;
y >>= 1;
}
return res;
};
ifac[n + m] = qpow(fac[n + m]);
for(int i = n + m - 1; i >= 0; i--)
ifac[i] = ifac[i + 1] * (i + 1) % mod;
auto C = [&](ll x, ll y)
{
if(x < y)
return 0LL;
if(y < 0)
return 0LL;
return fac[x] * ifac[y] % mod * ifac[x - y] % mod;
};
++c;
r = n - r + 1;
ll ans = 0;
for(int i = c; i <= m; i++)
{
ll tmp = C(r + i - 3, i - 1);
tmp = tmp * C(n - r + m - i, n - r) % mod;
//	cerr << r << ' ' << i << ' ' << tmp << '\n';
ans = (ans + tmp) % mod;
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+1;
int v[10]; 
int n,k;
int main(){
cin >> n >> k;
for(int i = 0;i < k;i ++){
int x;
cin >> x;
v[x] = 1;
}
for(int i = n;i <= 10 * n;i ++){
int x = i;
while(x != 0){
int t = x % 10;
if(v[t] == 1)break;
x /= 10;
}
if(x == 0){
cout<<i<<endl;
return 0;
}
}
return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,n) for (int i = 0; i < (n); i++)
typedef long long ll;
typedef pair<int,int> P;



int main() {
int n, q;
cin >> n;
vector<int> R(n), C(n);
rep(i,n) cin >> R[i];
rep(i,n) cin >> C[i];
cin >> q;
vector<int> r(q), c(q);
rep(i,q) cin >> r[i] >> c[i];

rep(i,q) {
r[i]--; c[i]--;
if(R[r[i]]+C[c[i]] > n) {
cout << '#';
}
else {
cout << '.';
}
}
cout << endl;


return 0;
}

#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC optimization ("unroll-loops")
#include<bits/stdc++.h>
#include<string>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define umap unordered_map
#define lb lower_bound
#define ub upper_bound
#define nl "\n"
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
const ll M = 1e9 + 7; //const ll M=998244353;
const int N = 1e6;
ll z[N] = {}, seg[N];
void build(int v, int tl, int tr) {
if (tl == tr) {
seg[v] = z[tl];
} else {
int tm = (tl + tr) / 2;
build(v * 2 + 1, tl, tm);
build(v * 2 + 2, tm + 1, tr);
seg[v] = max(seg[v * 2 + 2], seg[v * 2 + 1]);
}
}
int MAX(int v, int tl, int tr, int l, int r) {
if (l > r)
return 0;
if (l == tl && r == tr) {
return seg[v];
}
int tm = (tl + tr) / 2;
return max(MAX(v * 2 + 1, tl, tm, l, min(r, tm))
, MAX(v * 2 + 2, tm + 1, tr, max(l, tm + 1), r));
}
void update(int v, int tl, int tr, int pos, int new_val) {
if (tl == tr) {
seg[v] = new_val;
} else {
int tm = (tl + tr) / 2;
if (pos <= tm)
update(v * 2 + 1, tl, tm, pos, new_val);
else
update(v * 2 + 2, tm + 1, tr, pos, new_val);
seg[v] = max(seg[v * 2 + 2], seg[v * 2 + 1]);
}
}
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
cout << fixed << setprecision(15);
ll T = 1;
//	cin>>T;
while (T--)
{
int n, m;
cin >> n >> m;
vector<vector<int>> xx(n + 1);
for (int i = 0; i < m; i++)
{
int uu, vv;
cin >> uu >> vv;
uu--;
vv--;
xx[uu].pb(vv);
}

ll dp[n + 1] = {};
ll mx = 0;
for (int i = 0; i < n; i++)
{
vector<pair<int, int>> upd;
for (int j = 0; j < (int)xx[i].size(); j++)
{
ll g;
if (xx[i][j] == 0)
g = 0;
else
g = MAX(0, 0, n - 1, 0, xx[i][j] - 1);
if (g >= dp[xx[i][j]])
{
upd.pb({xx[i][j], g + 1});
dp[xx[i][j]] = g + 1;
mx = max(mx, g + 1);
}
}
for (auto yy : upd)
{
update(0, 0, n - 1, yy.fi, yy.se);
}
upd.clear();
}
cout << mx << nl;
}
}
#include <bits/stdc++.h>
#define ll long long
#define maxn 200005
#define inf 0x3f3f3f3f
#define mod 998244353
using namespace std;
int n;
char s[maxn];
ll ans = 0;
ll cnt[maxn][26];
int main () {
cin >> (s+1);
n = strlen(s+1);
for (int i = 1; i <= n; i++)
for (int j = 0; j < 26; j++)
cnt[i][j] = cnt[i-1][j] + (s[i] == 'a' + j);
ll lst = n; char lsc = '#';
for (int i = n-1; i >= 2; i--) {
if (s[i] == s[i-1]) {
if (s[i] == lsc) ans += lst - (i+1) + 1 - (cnt[lst][s[i]-'a'] - cnt[i][s[i]-'a']);
else ans += (n - (i+1) + 1) - (cnt[lst][s[i]-'a'] - cnt[i][s[i]-'a']); 
lst = i-2, lsc = s[i];
}
}
printf ("%lld\n", ans);
return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define endl '\n'
#define ll long long
#define pi pair<int, int>
#define f first
#define s second

const int m = 300001;
ll n, k;
ll a[m], b[m];

int main(){
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n >> k;

for(int i = 0, x; i < n; i++) cin >> x, a[x]++, b[x] += x;

for(int i = 1; i < m; i++) a[i] += a[i - 1], b[i] += b[i - 1];

//try small gcd
ll ret = 0;
for(int i = 1; i < m; i++){
ll x = 0;
for(int j = 0; j < m; j += i){
int y = min(m - 1, j + i);
x += (j + i) * (a[y] - a[j]) - (b[y] - b[j]);
}
if(x <= k) ret = i;
}

//try large gcd
ll x = m * a[m - 1] - b[m - 1];
if(x <= k) ret = max(ret, m + (k - x) / n);

cout << ret << endl;

return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int mx = 2e5 + 9;
const ll MOD = 1e9 + 7;

inline void normal(ll &a) { a %= MOD; (a < 0) && (a += MOD); }
inline ll modMul(ll a, ll b) {return (a*b)%MOD; }
inline ll modAdd(ll a, ll b) {return (a+b)%MOD; }
inline ll modSub(ll a, ll b) {normal(a), normal(b); a -= b; normal(a); return a; }
inline ll modPow(ll b, ll p) { ll r = 1; while(p) { if(p&1) r = modMul(r, b); b = modMul(b, b); p >>= 1; } return r; }
inline ll modInverse(ll a) { return modPow(a, MOD-2); }
inline ll modDiv(ll a, ll b) { return modMul(a, modInverse(b)); }

ll f[mx];

ll ncr(ll n, ll r) {
if(r > n) return 0;
return modDiv(f[n], modMul(f[r], f[n - r]));
}

ll solve(ll x, ll y) {
return ncr(x + y - 2, x - 1);
}

int main() {
f[0] = 1;
for(ll i = 1; i < mx; i++) {
f[i] = modMul(f[i - 1], i);
}

ll h, w, a, b; cin >> h >> w >> a >> b;
ll ans = 0;
for(ll i = 0; i < (h - a); i++) {
ans = modAdd(ans, modMul(solve(h - i, w - b), solve(i + 1, b)));
}
cout << ans << '\n';
return 0;
}

#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 998244353;//1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m;
cin >> n >> m;
VI ban(10, 0);
for(int i = 1; i <= m; i++)
{
int x;
cin >> x;
ban[x] = 1;
}
for( ; ; n++)
{
int nw = n;
bool ok = 1;
while(nw)
{
if(ban[nw % 10])
ok = 0;
nw /= 10;
}
if(ok)
break;
}
cout << n << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include <bits/stdc++.h>

using i64 = long long;

int main() {
std::ios::sync_with_stdio(false);
std::cin.tie();

int n;
std::cin >> n;

std::vector<int> a(n), b(n);
for (int i = 0; i < n; i++) {
std::cin >> a[i] >> b[i];
}

auto check = [&](int x, int y) {
for (int i = 0; i < n; i++) {
if (a[i] % x == 0 && b[i] % y == 0 || a[i] % y == 0 && b[i] % x == 0) {
continue;
}
return false;
}
return true;
};

std::vector<int> A, B;
for (int i = 1; i * i <= a[0]; i++) {
if (a[0] % i == 0) {
A.push_back(i);
A.push_back(a[0] / i);
}
}
for (int i = 1; i * i <= b[0]; i++) {
if (b[0] % i == 0) {
B.push_back(i);
B.push_back(b[0] / i);
}
}

i64 ans = 0;

for (int x : A) {
for (int y : B) {
if (check(x, y)) {
ans = std::max(ans, std::lcm(1LL * x, y));
}
}
}

std::cout << ans << "\n";

return 0;
}

#include<bits/stdc++.h>

using namespace std;
using ll = int64_t;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>

// Use ordered_set s to define a set and use insert, erase, upper_bound, lower_bound, find, end as usual.
// Use s.order_of_key(x) to find how many elements in the set are less than the current element to be inserted.
// Use s.find_by_order(x) to find element in set at xth index(when arranged linearly).#include<bits/stdc++.h>

class Solution{
public:
ll mod = 998244353;
void solve(){
ll n;
cin>>n;
ll total = 0;
for(ll i = 1;i*i <= n;i++){
ll j = n/i;
if(j >= i){
total = (total + 1 + (j-i)/2) % mod;
}
}
cout<<total<<"\n";
}
};

int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

Solution* a = new Solution();
a->solve();

return 0;
}

#include<bits/stdc++.h>
using namespace std;
int main(){
int n;
cin>>n;
string s,t;
cin>>s>>t;
vector<int> sind,tind;
for(int i=0;i<n;i++){
if(s[i]=='0') sind.push_back(i);
if(t[i]=='0') tind.push_back(i);
}
if(sind.size()!=tind.size()){
cout<<-1<<endl;
return 0;
}
int cnt=0;
for(int i=0;i<sind.size();i++){
if(sind[i]!=tind[i]) cnt++;
}
cout<<cnt<<endl;
}
#include <bits/stdc++.h>

using namespace std;

// long longの省略
typedef long long ll;

// rep(先頭にRで逆からループ、末尾にSで「1～n」となる)
#define rep(i, a, n) for(int i = a; i < n; i++)
#define reps(i, a, n) for(int i = a; i <= n; i++)
#define rrep(i, a, n) for(int i = n - 1; i >= a; i--)
#define rreps(i, a, n) for(int i = n; i >= a; i--)

// ソートなどに対象を入れる場合
#define all(x) (x).begin(),(x).end()

// ソートされた配列から重複を削除して詰めなおす
#define UNIQUE(x) x.erase( unique(x.begin(), x.end()), x.end() );

// bfs等で4方向調べるときの配列(上下左右の順番)
int d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

// 余りを答えとして出す時の割る値(デフォルト値)
int MOD = 1e9 + 7;

// ユークリッド互除法
int __gcd(int a, int b){
int c;

while((c = a % b) != 0){
a = b;
b = c;
}

return b;
}

// 「number」の「n」ビット目が「1」であるか「0」か
// ビット目の数え方は配列の添え字と同じ
bool __bit(int number, int n){
if(number & (1 << n))
return true;

return false;
}

// aよりもbが大きいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmax(T &a, const T& b) {
if (a < b) {
a = b;  // aをbで更新
return true;
}

return false;
}
// aよりもbが小さいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmin(T &a, const T& b) {
if (a > b) {
a = b;  // aをbで更新
return true;
}

return false;
}

// 累乗をmodで計算
ll mod_pow(ll a, ll n, ll mod) {
ll res = 1;
while (n > 0) {
if (n & 1) res = res * a % mod;
a = a * a % mod;
n >>= 1;
}
return res;
}

// nCrをmodで計算
// COMinit(取りうるnの最大値)を実行してから、COM(n, r)を使用すること)
vector<ll> fac, finv, inv;

void COMinit(int MAX) {
fac.resize(MAX); finv.resize(MAX); inv.resize(MAX);

fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++){
fac[i] = fac[i - 1] * i % MOD;
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
finv[i] = finv[i - 1] * inv[i] % MOD;
}
}

long long COM(int n, int k){
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
}

int main(){
int N; cin >> N;

vector<int> L(N), R(N);
rep(i, 0, N) cin >> L[i] >> R[i];

int R_min = INT_MAX;
int L_max = INT_MIN;
rep(k, 0, N){
chmax(L_max, L[k]);
chmin(R_min, R[k]);

if(L_max <= R_min)
cout << 0 << endl;
else{
int x = (L_max + R_min) / 2;
cout << max({0, L_max - x, x - R_min}) << endl;
}
}

return 0;
}
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;
typedef long long ll;

int n, a[N], dp[N];

int main() {
scanf("%d", &n);
for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
a[0] = a[1], a[n + 1] = a[n], dp[2] = a[2] - a[1];
for (int i = 3; i <= n + 1; i++) {
dp[i] = max(dp[i - 2], a[i] - a[i - 3]);
if (i > 3) dp[i] = min(dp[i], max(dp[i - 3], a[i] - a[i - 4]));
}
return printf("%d\n", dp[n + 1] / 2) * 0;
}
#line 2 "/home/defineprogram/Desktop/Library/template/template.cpp"
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i, n) for (int i = 0; i < n; i++)
#define REP(i, n) for (int i = 1; i < n; i++)
#define rev(i, n) for (int i = n - 1; i >= 0; i--)
#define REV(i, n) for (int i = n - 1; i > 0; i--)
#define all(v) v.begin(), v.end()
#define PL pair<ll, ll>
#define PI pair<int, int>
#define len(s) (int)s.size()
#define compress(v) \
sort(all(v));   \
v.erase(unique(all(v)), v.end());
#define comid(v, x) lower_bound(all(v), x) - v.begin()

template<class T>
using prique=priority_queue<T,vector<T>,greater<>>;

template <class T, class U>
inline bool chmin(T &a, U b) {
if (a > b) {
a = b;
return true;
}
return false;
}
template <class T, class U>
inline bool chmax(T &a, U b) {
if (a < b) {
a = b;
return true;
}
return false;
}
constexpr ll inf = 3e18;
constexpr double pi = acos(-1);
#line 2 "main.cpp"

ll ten[16];
int main() {
ten[0]=1;
REP(i,16)ten[i]=ten[i-1]*10;
ll N;cin>>N;
ll ele=1,ans=0;
rep(i,16){
ll x=ele;
rep(j,16){
ll l=x*ten[j],r=x*ten[j]+ten[j]-1;
if(l>N)break;
ans+=min(r,N)-l+1;
}
ele=ele*10+1;
}
cout<<ans<<endl;
}

#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using VI = vector<int>;
using P = pair<int, int>;

#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for (ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

template< typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true); }
template< typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true); }

int main() {
int T;
cin >> T;
while(T-- > 0) {
ll N;
cin >> N;
if (N % 4 == 0) {
cout << "Even" << endl;
} else if (N % 2 == 0) {
cout << "Same" << endl;
} else {
cout << "Odd" << endl;
}
}
}
#include <bits/stdc++.h>
using namespace std;

const int mod = 998'244'353;

int main() {
cin.tie(0)->sync_with_stdio(0);

int h, w;
cin >> h >> w;

vector<string> vs(h);
for (auto& s : vs) {
cin >> s;
}

vector<vector<int>> cnt(2, vector<int>(h + w - 1));
for (int i = 0; i < h; ++i) {
for (int j = 0; j < w; ++j) {
if (vs[i][j] == 'R') {
++cnt[0][i + j];
} else if (vs[i][j] == 'B') {
++cnt[1][i + j];
}
}
}

int ans = 1;
for (int sum = 0; sum < h + w - 1; ++sum) {
if (cnt[0][sum] && cnt[1][sum]) {
ans = 0;
} else if (!cnt[0][sum] && !cnt[1][sum]) {
ans <<= 1;
ans %= mod;
}
}

cout << ans << "\n";


return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
using mint = atcoder::modint998244353;
int h, w;
cin >> h >> w;
vc<string> s(h);
rep(i, h) cin >> s[i];
mint ans = 1;
int p = h + w - 2;
for (int i = 0; i <= p; i++) {
int rcnt = 0, bcnt = 0, ocnt = 0;
for (int hh = 0; hh < h; hh++) {
int j = i - hh;
if (0 <= j && j < w) {
if (s[hh][j] == 'R') rcnt++;
if (s[hh][j] == 'B') bcnt++;
if (s[hh][j] == '.') ocnt++;
}
}
if (rcnt > 0 && bcnt > 0) ans *= 0;
if (rcnt > 0 || bcnt > 0)
ans *= 1;
else
ans *= 2;
}
cout << ans.val() << endl;
}
#include <algorithm>
#include <chrono>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <random>
#include <ratio>
#include <set>
#include <variant>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <iomanip>
#include <random>
#include <algorithm>
#include <thread>
#include <mutex>
#include <atomic>
#include <future>

#include <cassert>

using namespace std;

/////////////////////////////////////////////////////////////////////////////////////////

const int MAX_LENGTH = 15;

vector<long long> threePowers;

void Prepare()
{
threePowers.resize(MAX_LENGTH + 1);
threePowers[0] = 1;
for (int i = 1; i <= MAX_LENGTH; ++i) {
threePowers[i] = threePowers[i - 1] * 3;
}
}

/////////////////////////////////////////////////////////////////////////////////////////

void Increment(vector<int>& s)
{
for (int i = (int) s.size() - 1; i >= 0; --i) {
if (s[i] < 2) {
++s[i];
for (int j = i + 1; j < s.size(); ++j) {
s[j] = 0;
}
return;
}
}
assert(false);
}

void Rotate(vector<int>& s)
{
assert(s.size() > 0);
int first = s[0];
for (int i = 1; i < s.size(); ++i) {
s[i - 1] = s[i];
}
s[s.size() - 1] = first;
}

/////////////////////////////////////////////////////////////////////////////////////////

long long n, l;

void Run()
{
vector<int> mapping(3);
mapping[0] = 0;
mapping[1] = 1;
mapping[2] = 2;

for (int i = 0; i < 3; ++i) {
vector<int> result(l, 0);
result[0] = 2;

for (int j = 0; j < n; ++j) {
for (int k = 0; k < l; ++k) {
cout << mapping[result[k]];
}
cout << '\n';

if (j + 1 < n) {
Increment(result);
}
}

Rotate(mapping);
}

cout.flush();
}

bool Read()
{
if (!(cin >> n >> l)) {
return false;
}
return true;
}

/////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
ios_base::sync_with_stdio(false);
cin.tie(nullptr);

// freopen("input.txt", "r", stdin);

Prepare();

while (Read()) {
Run();
}

return 0;
}

#include<bits/stdc++.h>
using namespace std;
int n,c[105],m=7,t;
char s[2000005];
int main()
{
cin>>n;
int nw=n;
for(int i=0;i<7;i++)
{
c[i]=1;
while(nw>=c[i])
{
nw-=c[i];
c[i]++;
}
if(nw==0) break;
}
c[0]--;
int las=0,mul=1;
for(int i=0;i<7;i++)
{
for(int j=1;j<=c[i];j++)
{
s[++t]=(i-las)*mul%7+'0';
if(s[t]=='0') s[t]='7';
las=i;
mul=mul*5%7;
}
}
reverse(s+1,s+t+1);
printf("%s",s+1);
}
#include <bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;

signed main() {
cin.tie(0);
std::ios::sync_with_stdio(false);
int n,ans=(int)(2e18); cin>>n;
for(int a=0;(1ll<<a)<=n;a++) {
/*int l=0,r=n/(1ll<<a);
while(l<=r) {
int mid=(l+r)
}*/
int b=n/(1ll<<a); ans=min(ans,a+b+n-b*(1ll<<a));
} 
cout<<ans;
return 0;
}
/**
* @Author:51D
**/

#include <iostream>
#include <string>
#include <utility>
#include <cstdlib>
#include <limits>
#include <cmath>
#include <climits>
#include <vector>
#include <bits/stdc++.h>
#include <set>
#include <map>
#include <iomanip>
#include <unordered_set>
#include <unordered_map>
#include <iterator>
#include <algorithm>
#include <sstream>
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

typedef long long ll;

#define mod 998244353
#define inf 1e9
#define f(i,n) for(int i=0;i<n;i++)
#define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define w(t) ll tt;cin>>tt;while(tt--)
#define pb push_back
#define endl "\n"
#define read(arr,n) for(ll i=0;i<n;i++){cin>>arr[i];};
#define pi pair<ll,ll>
#define all(arr) arr.begin(),arr.end()

// template <typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
//options: less,greater_equal,less_equal,greater

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\"' << x << '\"';}
void __print(const string &x) {cerr << '\"' << x << '\"';}
void __print(bool x) {cerr << (x ? "true" : "false");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
void _print() {cerr << "]\n";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}

#ifndef ONLINE_JUDGE
#define debug(x...) cerr << "[" << #x << "] = ["; _print(x)
#else
#define debug(x...)
#endif

const int N=3e5+5;
const long long infll = 0x3f3f3f3f3f3f3f3fLL;
int p[N];

ll modulo(ll a, ll b, ll n){
ll x=1, y=a; 
while (b > 0) {
if (b%2 == 1) {
x = (x*y) % n; // multiplying with base

}
y = (y*y) % n; // squaring the base
b /= 2;
}
return x % n;
}

ll modmod(ll a,ll b,ll c){
// Fermats Little Theorem
// A^(M-1) = 1 (mod M) if M is a prime.
// So write B^C as x*(M-1) + y

ll y = modulo(b,c,mod-1);

return modulo(a,y,mod);
}

ll value[1000001];
void fillNumberOfDivisorsArray(){
for(ll i=1;i<=1000000;i++){
for(ll j=1;i*j<=1000000;j++){
value[i*j]++;
}
}
}

vector<ll> prime;
bool is_composite[N];

void sieve(ll n) {

fill(is_composite,is_composite + n,false);

for (ll i=2;i<n;i++){

if(!is_composite[i]){
prime.push_back(i);
}

for (int j=2;i*j < n;j++){
is_composite[i * j] = true;
}
}
}

void addEdge(vector<ll> adj[],ll u,ll v){
adj[u].pb(v);
adj[v].pb(u);
}

ll __lcm(ll a,ll b){
return a*b/(__gcd(a,b));
}

vector<ll> fact;
void factorialFill(){
fact.pb(1);
fact.pb(1);
for(ll i=2;i<=1000000;i++){
fact.pb((i%mod * fact.back()%mod)%mod);
}
}
ll getfact(ll num){
return fact[num]%mod;
}

ll getBits(ll num){
return log2(num) + 1;
}


struct cmp {
bool operator() (const pair<int, int> &a, const pair<int, int> &b) const {
return a.first < b.first;
}
};

ll evenR(ll left,ll right){
if(left == 0){
right++;
return (ll)ceil(right/(double)2);
}
right++;

return (ll)ceil(right/(double)2)  - (ll)ceil(left/(double)2);;
}

ll oddR(ll left,ll right){
if(left == 0){
right++;
return (right/2);
}
right++;

return (right/2)  - (left/2);
}

void solve(ll tc){
ll n;
cin>>n;

ll ans = 0;
for(ll q=1;(q*q)<=n;q++){
ll left = q;
ll right = n/q;

if(q%2 == 0){
ans += evenR(left,right)%mod;
ans = ans%mod;
}
else{
ans += oddR(left,right)%mod;
ans = ans%mod;
}
}

cout<<ans%mod<<endl;

}

int main() {

FIO;
#ifndef ONLINE_JUDGE
freopen("debug.txt", "w", stderr);
#endif
ll tt = 1;
for(ll i=1;i<=tt;i++){
solve(i);
}

return 0;
}

#include <bits/stdc++.h>

using namespace std ;

const int MAX = 2e5 + 10 ;

int arr[MAX] ;
int n , m ;

int vis[MAX] ;
int cnt ;
bool flag1 , flag2 ; 

void dfs(int node)
{
if(vis[node])
return ;
vis[node] = 1 ;
flag1 |= (node <= n) , flag2 |= (node > n) ;
cnt++ ;
dfs(arr[node]) ;
}

int main()
{
ios_base::sync_with_stdio(0) ;
cin.tie(0) ;
cin>>n>>m ;
for(int i = 1 ; i <= n+m ; ++i)
cin>>arr[i] ;
int ans = 0 ;
int cnt1 = 0 , cnt2 = 0 ;
for(int i = 1 ; i <= n+m ; ++i)
{
if(vis[i] || arr[i] == i)
continue ;
flag1 = flag2 = false ;
cnt = 0 ;
dfs(i) ;
ans += cnt-1 ;
if(!flag1)
cnt1++ ;
if(!flag2)
cnt2++ ;
}
ans += max(cnt1 , cnt2) * 2 ;
return cout<<ans<<"\n" , 0 ;
}		
// Version 2.6.2 by Eason_AC
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <map>
#include <vector>
#include <stack>
#include <ctime>
#include <set>
#include <queue>
#include <cctype>
#include <cassert>
#include <cinttypes>
#include <climits>
#define Tl template<typename T>
#define Tla template<typename T, typename... args>
#define F(T, i, a, b) for(T (i) = (a); (i) <= (b); ++(i))
#define R(T, i, a, b) for(T (i) = (a); (i) >= (b); --(i))
#define Fo(T, i, a, b, c) for(T (i) = (a); (i) <= (b); (i) += (c))
#define Re(T, i, a, b, c) for(T (i) = (a); (i) >= (b); (i) -= (c))
#define For(T, i, a, b, c) for(T (i) = (a); (i) <= (b); (i) *= (c))
#define Rep(T, i, a, b, c) for(T (i) = (a); (i) >= (b); (i) /= (c))
#define mes(a, x) memset((a), (x), sizeof((a)))
#define mec(a, b) memcpy((a), (b), sizeof((b)))
#define ll long long //No long long see your ancestor!!!
#define ull unsigned long long //Have long long see your ancestor!!!
#define lll __int128 //Have unsigned long long see your ancestor!!!
#define ld long double
#define YES puts("YES")
#define NO puts("NO")
#define Yes puts("Yes")
#define No puts("No")
#define yes puts("yes")
#define no puts("no")
#define no1 puts("-1")
#define iv inline void
#define ii inline int
#define ill inline ll
#define iull inline ull
#define i128 inline lll
#define ib inline bool
#define iT inline T
#define ilf inline double
#define ild inline ld
#define pii pair<int, int>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pll pair<ll, ll>
#define mp make_pair
#define pub push_back
#define pob pop_back()
#define fi first
#define se second
#define pq priority_queue
#define iinf 0x3f3f3f3f
#define linf 0x3f3f3f3f3f3f3f3f
using namespace std;

namespace FullPre {
Tl iv read(T &x) {T f = 1; x = 0; char c = getchar(); while(!isdigit(c)) {if(c == '-') f = -1; c = getchar();} while(isdigit(c)) {x = x * 10 + c - '0'; c = getchar();} x *= f;}
Tla iv read(T& x, args &...Args) {read(x), read(Args...);}
Tl iv write(T x) {if(x < 0) {putchar('-'); x = -x;} if(x > 9) write(x / 10); putchar(x % 10 + '0');}
Tl iv print_char(T x, char ch) {write(x), putchar(ch);}
Tl iv char_print(char ch, T x) {putchar(ch), write(x);}
Tl iv print_space(T x) {print_char(x, ' ');}
Tl iv print_space_mul(T x) {print_space(x);}
Tla iv print_space_mul(T x, args ...Args) {print_space(x), print_space_mul(Args...);}
Tl iv space_print(T x) {char_print(' ', x);}
Tl iv space_print_mul(T x) {space_print(x);}
Tla iv space_print_mul(T x, args ...Args) {space_print(x), space_print_mul(Args...);}
Tl iv println(T x) {print_char(x, '\n');}
Tl iv println_mul(T x) {println(x);}
Tla iv println_mul(T x, args ...Args) {println(x), println_mul(Args...);}
Tl iv lnprint(T x) {char_print('\n', x);}
Tl iv lnprint_mul(T x) {lnprint(x);}
Tla iv lnprint_mul(T x, args ...Args) {lnprint(x), lnprint_mul(Args...);}
iv filein(string s) {freopen((s + ".in").c_str(), "r", stdin);}
iv fileout(string s) {freopen((s + ".out").c_str(), "w", stdout);}
iv file(string s) {filein(s), fileout(s);}
Tl iT mymin(T a, T b) {return a < b ? a : b;}
Tla iT mymin(T a, T b, args ...Args) {return mymin(mymin(a, b), Args...);}
Tl iT mymax(T a, T b) {return a > b ? a : b;}
Tla iT mymax(T a, T b, args ...Args) {return mymax(mymax(a, b), Args...);}
Tl iT myabs(T a) {return a < 0 ? -a : a;}
Tl iT mysq(T a) {return a * a;}
Tl iT mygcd(T a, T b) {return !b ? a : mygcd(b, a % b);}
Tla iT mygcd(T a, T b, args ...Args) {return mygcd(mygcd(a, b), Args...);}
Tl iT mylcm(T a, T b) {return a / mygcd(a, b) * b;}
Tla iT mylcm(T a, T b, args ...Args) {return mylcm(mylcm(a, b), Args...);}
Tl iT myswap(T &a, T &b) {a ^= b ^= a ^= b;}
}
using namespace FullPre;
#define MT int Test; read(Test); while(Test--)
#define MCase int Test; read(Test); F(int, kase, 1, Test)

namespace Solution {
int n, k, x, d[17];

ib check() {
int p = n;
while(p) {
if(d[p % 10]) return 0;
p /= 10;
}
return 1;
}

iv Main() {
#ifdef LOCAL
double st = clock();
#endif
read(n, k);
F(int, i, 1, k) read(x), d[x] = 1;
for(; !check(); ++n); println(n);
#ifdef LOCAL
double ed = clock();
printf("\nTime: %.3lfs", (ed - st) / 1000000.0);
#endif
return;
}
}

int main() {
#ifdef LOCAL
file("1");
#endif
Solution :: Main();
return 0;
}
/*

*/
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+1;
int v[10]; 
int n,k;
int main(){
cin >> n >> k;
for(int i = 0;i < k;i ++){
int x;
cin >> x;
v[x] = 1;
}
for(int i = n;i <= 10 * n;i ++){
int x = i;
while(x != 0){
int t = x % 10;
if(v[t] == 1)break;
x /= 10;
}
if(x == 0){
cout<<i<<endl;
return 0;
}
}
return 0;
}

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define fore(i, a, b) for (int i = (a), _b = (b); i < b; ++i)
#define fort(i, a, b) for (int i = (a), _b = (b); i <= _b; ++i)
#define fordt(i, a, b) for (int i = (a), _b = (b); i >= _b; --i)
#define forde(i, a, b) for (int i = (a), _b = (b); i > _b; --i)
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define x first
#define y second

using namespace std;
using namespace __gnu_pbds;

template<class A, class B> bool maxi(A &a, const B &b) {return (a < b) ? (a = b, true):false;};
template<class A, class B> bool mini(A &a, const B &b) {return (a > b) ? (a = b, true):false;};

typedef int64_t i64;
typedef pair<int,int> _ii;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int maxn=2e5+7;
const i64 oo=1e9+7;
vector <int> st;

bool cmp(_ii &a, _ii &b) {
if(a.x==b.x) return a.y>b.y;
return a.x<b.x;
}

void build(int id, int l, int r, int i, int k) {
if(i<l||i>r||l>r) return;
if(l==r) {
st[id]=k;
return;
}

int mid=(l+r)>>1;
build(id<<1, l, mid, i, k);
build(id<<1|1, mid+1, r, i, k);
st[id]=max(st[id<<1], st[id<<1|1]);
}

int get(int id, int l, int r, int u, int v) {
if(v<l||u>r||l>r||u>v) return 0;
if(u<=l&&v>=r) return st[id];

int mid=(l+r)>>1;
return max(get(id<<1, l, mid, u, v), get(id<<1|1, mid+1, r, u, v));
}

void solve() {
int n, m;
cin >> n >> m;

vector <_ii> a(m);
for(auto &i: a) cin >> i.x >> i.y;

sort(all(a), cmp);
st.clear(); st.resize(n<<2|3, 0);

int ans=0;
for(auto &i: a) {
ans=max(ans, get(1, 1, n, 1, i.y-1)+1);
build(1, 1, n, i.y, get(1, 1, n, 1, i.y-1)+1);
}

cout << ans;
}

#define NAME "test."
int main() {
ios_base::sync_with_stdio(false);
cin.tie(0); cout.tie(0);

if(fopen(NAME"inp", "r")) {
freopen(NAME"inp", "r", stdin);
freopen(NAME"out", "w", stdout);
}

int t=1;
while(t--) solve();
}
#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int t; cin >> t; while (t--) {
int64_t n2, n3, n4;
cin >> n2 >> n3 >> n4;

int64_t x = min(n3 / 2, n4);
n3 -= 2 * x;
n4 -= x;

int64_t y = min(n3 / 2, n2 / 2);
n3 -= 2 * y;
n2 -= 2 * y;

int64_t z = min(n4 / 2, n2);
n4 -= 2 * z;
n2 -= z;

int64_t w = min(n4, n2 / 3);
n4 -= w;
n2 -= 3 * w;

int64_t v = n2 / 5;
n2 -= 5 * v;

cout << x + y + z + w + v << "\n";
}

return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>
#include <bitset>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, N = 3e5, bb = 16;

int n, X, Y, Z, M = 1ll << bb;
vector <int> getArr(int mask) {
vector <int> res;
for (int i = 0; i < bb; ++i) {
int j = i;
while (!(mask & (1ll << j)) and j < bb) ++j;
if (j == bb) break;
res.push_back(j - i + 1);
i = j;
}
return res;
}

bool check(vector <int> arr) {
for (int i = 0; i < arr.size(); ++i) {
int sum = 0, id = i;
while (id < arr.size() and sum < X) 
sum += arr[id], id++;
if (sum != X) continue;
sum = 0;
while (id < arr.size() and sum < Y)
sum += arr[id], id++;
if (sum != Y) continue;
sum = 0;
while (id < arr.size() and sum < Z)
sum += arr[id], id++;
if (sum != Z) continue;
return false;
}
return true;
}

int makeMask(vector <int> arr) {
int sum = 0;
for (auto& x : arr) sum += x;
reverse(arr.begin(), arr.end());
while (sum > bb) {
sum -= arr.back();
arr.pop_back();
}
int res = 0;
for (auto& x : arr) {
res <<= 1, res++;
res <<= x - 1;
}
return res;
}

int bpow(int a, int b) {
if (!b) return 1ll;
if (b & 1) return a * bpow(a, b - 1) % mod;
int t = bpow(a, b / 2);
return t * t % mod;
}
signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

cin >> n >> X >> Y >> Z;

vector <vector <int>> g(M);
for (int i = 0; i < M; ++i) {
for (int j = 1; j <= 10; ++j) {
vector <int> cur = getArr(i);
cur.push_back(j);
if (check(cur)) {
g[i].push_back(makeMask(cur));
}
}
}

vector <vector <int>> dp(n + 1, vector <int>(M, 0));
dp[0][0] = 1;
for (int i = 0; i < n; ++i) {
for (int j = 0; j < M; ++j) {
for (auto& x : g[j])
dp[i + 1][x] = (dp[i + 1][x] + dp[i][j]) % mod;
}
}
int ans = 0;
for (auto& x : dp.back())
ans = (ans + x) % mod;
ans = (bpow(10, n) - ans + mod) % mod;
cout << ans << '\n';


return 0;
}
#include <bits/stdc++.h>

#define For(i, a, b) for (int i = a; i <= b; ++i)
#define rFor(i, b, a) for (int i = b; i >= a; --i)
#define eFor(i, u, v) for (int i = head[u], v = e[i].to; i; i = e[i].next, v = e[i].to)

typedef long long ll;

using std::cin;
using std::cout;
using std::endl;

typedef std::pair<int, int> pii;
#define fi first
#define se second

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename T> T myrand(T l, T r) {
return std::uniform_int_distribution<T>(l, r)(rnd);
}

void close_stdio() {
std::ios::sync_with_stdio(false);
std::cerr << "DO NOT use scanf/printf!\n";
}

const int kN = 2005;
const int kK = 1e4 + 4;

int n, k;
std::string s[kN];

std::bitset<kK> ds[kN];

int z[kK], ext[kK];

void getZ(std::string &s) { // LCP(s[i...len - 1], s)
z[0] = -1;
for (int i = 1, id = 0; i < s.size(); ++i) {
z[i] = 0;
if (i < id + z[id]) z[i] = std::min(id + z[id] - i, z[i - id]);
while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) ++z[i];
if (z[i] && i + z[i] > id + z[id]) id = i;
}
}

void exkmp(std::string &s, std::string &t) { // LCP(s[i...len - 1], t), z(t) is given
ext[0] = 0;
while (ext[0] < std::min(s.size(), t.size()) && s[ext[0]] == t[ext[0]])
++ext[0];
for (int i = 1, id = 0; i < s.size(); ++i) {
ext[i] = 0;
if (i - id < t.size() && i < id + ext[id]) ext[i] = std::min(id + ext[id] - i, z[i - id]);
while (i + ext[i] < s.size() && ext[i] < t.size() && s[i + ext[i]] == t[ext[i]]) ++ext[i];
if (i + ext[i] > id + ext[id]) id = i; 
}
}

std::string str;
bool has[kK];
int st[kN], top = 0;

int cmp(int i, int j) {
// str[i...] vs s[j], ext(str, s[j]) given
if (i >= str.size()) return 1;
if (ext[i] >= std::min(str.size() - i, s[j].size())) return 0;
return str[i + ext[i]] < s[j][ext[i]] ? -1 : 1;
}

int main() {
close_stdio();
cin >> n >> k;
For(i, 1, n) cin >> s[i];
ds[n + 1][0] = 1;
rFor(i, n, 1) {
ds[i] = ds[i + 1] << s[i].size() | ds[i + 1];
}
has[0] = true;
// str = s[1];
For(i, 1, n) {
getZ(s[i]);
// cout << "getZ" << i << endl;
exkmp(str, s[i]);
// cout << "exkmp" << i << endl;
top = 0;
int l = -1, pos = str.size() + 1; // str[pos...] is deleted
For(j, 0, k - (int)s[i].size()) if (has[j] && ds[i + 1][k - j - s[i].size()]) {
if (j >= pos) break;
if (cmp(j, i) == 1) {
pos = std::min(pos, j + ext[j] + 1);
st[++top] = j + s[i].size();
}
else if (cmp(j, i) == 0 && !has[j + s[i].size()]) {
st[++top] = j + s[i].size();
}
if (st[top] == j + s[i].size() && j + s[i].size() >= pos) {
if (l == -1) {
l = j;
continue;
}
assert(j - l < s[i].size());
if (z[j - l] == s[i].size() - j + l) l = j;
else if (s[i][z[j - l]] < s[i][z[j - l] + j - l]) l = j;
}
}
For(j, pos, k) has[j] = false;
pos = 0;
for (int j = 0; j <= str.size(); ++j) if (has[j]) pos = j;
For(j, 1, top) has[st[j]] = true;
str.resize(pos);
if (l != -1) {
assert(l <= pos && l + s[i].size() > pos);
str += s[i].substr(pos - l, s[i].size() - pos + l);
}
}
cout << str << endl;
return 0;
}
/* PAY ATTENTION TO: */
/* 1. Memory Limit, Array Size */
/* 2. Integer Overflow */
/* 3. Multi-test */
/* 4. Potential Constant-speedup */
/* Stay organized and write things down. */

#include <bits/stdc++.h>
using namespace std;

int main()
{
int N;
cin >> N;
map<int, int> a, b;
for( int i = 0; i < N; i++ ) {
int A;
cin >> A;
a[A]++;
}
for( int i = 0; i < N; i++ ) {
int B;
cin >> B;
b[B]++;
}

set<int> st;
int A = a.begin()->first;
for( auto it = b.begin(); it != b.end(); it++ ) {
int B = it->first;
st.insert( A ^ B );
}
set<int> ans;
for( auto it = st.begin(); it != st.end(); it++ ) {
int x = *it;
int f = 0;
for( auto it1 = a.begin(); it1 != a.end(); it1++ ) {
if( b[it1->first ^ x] != it1->second ) {
f = 1;
break;
}
}
if( f == 0 ) ans.insert( x );
}

int n = ans.size();
cout << n << endl;
if( n ) {
for( int e : ans ) cout << e << endl;
}
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
int n;
cin >> n;
using mint = atcoder::modint998244353;
mint ans = 0;
for (int q = 1; q * q <= n; q++) {
int p = n / q;
ans += (p - q) / 2 + 1;
}
cout << ans.val() << endl;
}
#include <bits/stdc++.h>
typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
const int MOD = 1e9 + 7;
int main() {
ull n;
cin >> n;
ull b = 1;
ull minv = ULLONG_MAX;
for (int i = 0; i < 64; i++) {
ull tmp = i + n / b + n % b;
if (minv > tmp) {
minv = tmp;
}
b *= 2;
}
cout << minv << endl;
return 0;
}

#define ll long long
#define se second
#define fi first
#define pb push_back
#define in insert
#define MX INT_MAX
#define MAX LLONG_MAX
#include<bits/stdc++.h>
using namespace std;
const int mod = 1000000007;
template<typename T> 
void print(T &v){
cout << v.size() << '\n';
for(auto i : v) cout << i << ' ';
cout << '\n';
}

void solve(){
int n;
cin >> n;
int ans = 0;
pair<int,int> prevMax, prevMin;
int minR, maxL;
for(int i = 0; i < n; ++i){
int l,r;
cin >> l >> r;
if(i == 0){
prevMax = {l,r};
prevMin = prevMax;
minR = r;
maxL = l;
}
else{
if(r < minR){
minR = r;
prevMin = {l,r};
}
if(l > maxL){
maxL = l;
prevMax = {l,r};
}
}
int x = (maxL + minR) / 2;
if(prevMin.se < prevMax.fi){
cout << max(x - prevMin.se, prevMax.fi - x) << '\n';
}
else cout << 0 << '\n';
//		printf("%d %d %d %d\n", prevMin.fi,prevMin.se,prevMax.fi,prevMax.se);
}	
}

int main(){
ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
ll t = 1;
//	cin >> t;
while(t--) solve();
}

#include <algorithm>
#include <chrono>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <random>
#include <ratio>
#include <set>
#include <variant>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <iomanip>
#include <random>
#include <algorithm>
#include <thread>
#include <mutex>
#include <atomic>
#include <future>

#include <cassert>

using namespace std;

/////////////////////////////////////////////////////////////////////////////////////////

const int MAX_LENGTH = 16;

vector<long long> tenPowers;

void Prepare()
{
tenPowers.resize(MAX_LENGTH + 1);
tenPowers[0] = 1;
for (int i = 1; i <= MAX_LENGTH; ++i) {
tenPowers[i] = tenPowers[i - 1] * 10;
}
}

/////////////////////////////////////////////////////////////////////////////////////////

long long n;

vector<int> GetDigits(long long x)
{
vector<int> result;
while (x > 0) {
result.push_back(x % 10);
x /= 10;
}
reverse(result.begin(), result.end());
return result;
}

void Run()
{
auto digits = GetDigits(n);
int m = digits.size();

vector<long long> remaining(m + 1);
remaining[m] = 1;
for (int i = m - 1; i >= 0; --i) {
remaining[i] = remaining[i + 1] + tenPowers[m - 1 - i] * digits[i];
}

long long result = 0;
for (int len = 1; len < m; ++len) {
for (int k = 1; k < len; ++k) {
result += 9LL * tenPowers[len - k - 1] * k;
}
result += 1 * len;
}

bool equal = true;
for (int k = 1; k <= m; ++k) {
if (digits[k - 1] == 0) {
if (equal) {
break;
}
} else if (digits[k - 1] > 1) {
equal = false;
}
if (equal) {
if (k == m) {
result += k;
} else {
for (int nextDigit = 0; nextDigit <= digits[k]; ++nextDigit) {
if (nextDigit != 1) {
if (nextDigit < digits[k]) {
result += tenPowers[m - k - 1] * k;
} else {
result += remaining[k + 1] * k;
}
}
}
}
} else {
if (k == m) {
result += k;
} else {
result += 9LL * tenPowers[m - k - 1] * k;
}
}
}

cout << result << endl;
}

bool Read()
{
if (!(cin >> n)) {
return false;
}
return true;
}

/////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
ios_base::sync_with_stdio(false);
cin.tie(nullptr);

// freopen("input.txt", "r", stdin);

Prepare();

while (Read()) {
Run();
}

return 0;
}

#include<iostream>
#include<vector>
using namespace std;
using ll = long long;

constexpr ll mod = 998244353;

int main() {
int h,w;cin>>h>>w;
vector<string>ss(h);
for(auto&&x:ss)cin>>x;

ll ans = 1;
for(int i=1;i<h+w-1;i++){
bool rflag=false, bflag=false;
for(int j=0;j<w;j++){
if(i-j<0||i-j>h-1)continue;

if(ss[i-j][j]=='R')rflag=true;
else if(ss[i-j][j]=='B')bflag=true;
}
if(rflag&&bflag){
cout << 0 << endl;
return 0;
}
else if(!rflag&&!bflag){
ans*=2;
}
ans%=mod;
}
if(ss[0][0]=='.')ans*=2;
cout << ans % mod << endl;

return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <math.h>
#include <numeric>
#include <list>
#include <queue>
#include <string>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <string>   


using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<vector<int>> vvi;
typedef vector<vector<int>> vi;
typedef pair<pair<int,int>, int> ppiii;
typedef pair<int, pair<int,int>> pipii;
typedef pair<int,char> pic;
typedef pair<char,int> pci;
typedef pair<string,string> pss;



vector<ll> gen(vector<ll>& in, ll exclude) {
vector<ll> res;
for(auto it : in) {
if (it == exclude) continue;
res.push_back(it);
}
return res;
}
void solve() {
int n;
cin >> n;
vector<ll> in(n);

for(auto& it : in) {
cin >> it;
}
vector<ll> comp;
for(auto& it : in) {
if (comp.empty() || it != comp.back()) {
comp.push_back(it);
}
}
ll res = -1;
for (int i = 0; i + 1 < comp.size(); i++) {
if (comp[i] > comp[i + 1]) {
res = comp[i];
break;
}
}
if (res == -1) {
res = comp.back();
}
auto cac = gen(in, res);
for(ll i : cac) {
cout << i << " ";
}
cout << endl;


}




int main() {
ios_base::sync_with_stdio(0);
cin.tie(0);
int t = 1;
//cin >> t;
while(t--) {
solve();
}
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
// constexpr ll MOD = 1000000007;
constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


// References:
//   mint:
//     <https://github.com/atcoder/live_library/blob/master/mint.cpp>
//     <https://noshi91.hatenablog.com/entry/2019/03/31/174006>
//     <https://ei1333.github.io/luzhiled/snippets/math/mod-int.html>
//     <https://gist.github.com/MiSawa/dc78c3eb3ca16051818759ea069e8ccb>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>
//   combination:
//     <https://github.com/atcoder/live_library/blob/master/comb.cpp>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>

struct mint {
ll x;
constexpr mint(ll x = 0) noexcept : x((x % MOD + MOD) % MOD) {}

constexpr mint& operator+=(const mint& a) noexcept {
if ((x += a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator-=(const mint& a) noexcept {
if ((x += MOD - a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator*=(const mint& a) noexcept { (x *= a.x) %= MOD; return *this; }
constexpr mint& operator/=(const mint& a) noexcept { return *this *= a.inv(); }

constexpr mint operator-() const noexcept { return mint(-x); }
constexpr mint operator+(const mint& a) const noexcept { return mint(*this) += a; }
constexpr mint operator-(const mint& a) const noexcept { return mint(*this) -= a; }
constexpr mint operator*(const mint& a) const noexcept { return mint(*this) *= a; }
constexpr mint operator/(const mint& a) const noexcept { return mint(*this) /= a; }
constexpr bool operator==(const mint& a) const noexcept { return x == a.x; }
constexpr bool operator!=(const mint& a) const noexcept { return x != a.x; }

constexpr mint pow(ll n) const {
if (n == 0) return 1;
mint res = pow(n >> 1);
res *= res;
if (n & 1) res *= *this;
return res;
}
constexpr mint inv() const { return pow(MOD - 2); }

friend istream& operator>>(istream& is, mint& a) noexcept {
ll v; is >> v;
a = mint(v);
return is;
}
friend ostream& operator<<(ostream& os, const mint& a) noexcept {
return os << a.x;
}
};
using VM = vector<mint>;
using VVM = vector<VM>;
using VVVM = vector<VVM>;
using VVVVM = vector<VVVM>;


struct combination {
vector<mint> fact_, ifact_, inv_;
int n_;
combination() {}
combination(int n) : fact_(n+1,0), ifact_(n+1,0), inv_(n+1,0) {
assert(n != 0);
assert(n < MOD);
n_ = n;
fact_[0] = 1; fact_[1] = 1;
ifact_[0] = 1; ifact_[1] = 1;
inv_[1] = 1;
for(int i = 2; i <= n; ++i) {
fact_[i] = fact_[i-1] * i;
inv_[i] = -inv_[MOD%i] * (MOD/i);
ifact_[i] = ifact_[i-1] * inv_[i];
}
}

mint P(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k];
}
mint C(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k] * ifact_[k];
}
mint H(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0) return 0;
assert(n + k - 1 <= n_);
return C(n + k - 1, k);
}
mint fact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return fact_[n];
}
mint ifact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return ifact_[n];
}
mint inv(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return inv_[n];
}
};


int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll H, W; cin >> H >> W;
VS S(H); REP(h,H) cin >> S[h];

mint ans = 1;
REP(k,H+W-1) {
debug(k);
ll R = 0, B = 0;
REP(h,H) {
ll w = k - h;
if (not (0 <= w && w < W)) continue;
if (S[h][w] == 'R') R++;
if (S[h][w] == 'B') B++;
}
if (B > 0 && R > 0) { ans = 0; break; }
if (B == 0 && R == 0) ans *= 2;
}
print(ans);

return 0;
}

#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <vector>
#define setIO(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)
#define closefile fclose(stdin), fclose(stdout)
#define m_p make_pair
#define sz(x) (int)x.size()
#define see(x) cerr << x << " "
#define seeln(x) cerr << x << endl
#define out(x) cerr << #x << " = " << x << " "
#define outln(x) cerr << #x << " = " << x << endl
#define outarr(x, l, r) {cerr << #x"[" << l << " ~ " << r << "] = "; for (int _i = l; _i <= r; ++_i) cerr << x[_i] << " "; cerr << endl;}
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define gc() getchar()
//#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template <class T> void read(T &x) {
x = 0; int c = gc(); int flag = 0;
while (c < '0' || c > '9') flag |= (c == '-'), c = gc();
while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = gc();
if (flag) x = -x;
}
template <class T> bool checkmax(T &a, T b) {return a < b ? a = b, 1 : 0;}
template <class T> bool checkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}
constexpr int N = 1000005;
int n;
int a[2005];

void init() {
scanf("%d", &n);
for (int i = 1; i <= 2000; ++i) {
a[i] = i * (i - 1) / 2;
}
}

int seq[N], l = 0;
void solve() {
int cur = n;
vector<int> lis;
while (cur) {
int p = upper_bound(a + 1, a + 2000 + 1, cur) - a - 1;
lis.push_back(p);
cur -= a[p];
}
outarr(lis, 0, sz(lis) - 1);
for (int i = 0; i < sz(lis); ++i) {
for (int j = 0; j < lis[i]; ++j) {
seq[++l] = i;
}
}
for (int i = l; i >= 2; --i) {
seq[i] -= seq[i - 1];
if (seq[i] < 0) seq[i] += 7;
}
int w = 1;
for (int i = 2; i <= l; ++i) {
seq[i] = seq[i] * w % 7;
if (seq[i] == 0) seq[i] = 7;
w = w * 5 % 7;
}
for (int i = l; i >= 2; --i) printf("%d", seq[i]);
printf("\n");
}

int main() {
init();
solve();
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
string N;
cin >> N;
vector<long long> a(16);
a = {0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111, 
11111111111, 111111111111, 1111111111111, 11111111111111, 111111111111111};
for (int i = 1; i <= 15; i++) {
if (stoll(N) == a.at(i)) {
long long ans = 0;
for (int j = 0; j < i; j++) {
ans += a.at(j);
}
ans *= 2;
ans += i;
cout << ans << endl;
return 0;
}
}
if (N.at(0) != '1') {
long long ans = 0;
for (int i = 0; i <= N.size(); i++) {
ans += a.at(i);
}
cout << ans << endl;
return 0;
}
else {
int count = 1;
long long ans = 0;
for (int i = 1; i < N.size(); i++) {
if (N.at(i) == '1') {
count++;
}
else {
if (N.at(i) == '0') {
ans -= a.at(N.size() - count);
}
break;
}
}
long long n = stoll(N);
for (int i = N.size() - 1; i >= N.size() - count; i--) {
n -= pow(10, i);
}

ans += (n + 1) * count;
ans += a.at(N.size() - count);
if (count >= 2) {
for (int i = 1; i < count; i++) {
ans += pow(10, N.size() - 1 - i) * i;
}
}
for (int i = 0; i < N.size(); i++) {
ans += a.at(i);
}
cout << ans << endl;
return 0;
}
}
#include <atcoder/all>
using namespace atcoder;
#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define all(v) v.begin(),v.end()
#define inc(x,l,r) ((l)<=(x)&&(x)<(r)) 
#define Unique(x) sort(all(x)), x.erase(unique(all(x)), x.end())
typedef long long ll;
#define int ll
using ld = long double;
using vi = vector<int>;
using vs = vector<string>;
using P = pair<int,int>;
using vp = vector<P>;
template<typename T> using priority_queue_greater = priority_queue<T, vector<T>, greater<T>>;
template<typename T> ostream &operator<<(ostream &os,const vector<T> &v){rep(i,v.size())os<<v[i]<<(i+1!=v.size()?" ":"");return os;}
template<typename T> istream &operator>>(istream& is,vector<T> &v){for(T &in:v)is>>in;return is;}
template<class... T> void in(T&... a){(cin>> ... >> a);}
template<class T> void out(T& a){cout <<a<< '\n';}
template<class T,class... Ts> void out(const T&a, const Ts&... b){cout<< a;(cout<<...<<(cout<<' ',b));cout<<'\n';}
#define INT(...) int __VA_ARGS__; in(__VA_ARGS__)
#define STR(...) string __VA_ARGS__; in(__VA_ARGS__)
#define pcnt __builtin_popcount
int ceil(int x,int y){return x/y+!!(x%y);}
bool ins(string s,string t){return s.find(t)!=string::npos;}
P operator+ (const P &p, const P &q){ return P{p.first+q.first,p.second+q.second};}
P operator- (const P &p, const P &q){ return P{p.first-q.first,p.second-q.second};}
ostream &operator<< (ostream &os, const P &p){os << p.first <<" "<<p.second;return os;}
ostream &operator<< (ostream &os, const modint1000000007 &m){os << m.val();return os;}
ostream &operator<< (ostream &os, const modint998244353 &m){os << m.val();return os;}
template<typename T> bool chmax(T &a, const T b) {if (a < b) {a = b; return true;} else return false; }
template<typename T> bool chmin(T &a, const T b) {if (a > b) {a = b; return true;} else return false; }
void yesno(bool ok){ cout<<(ok?"Yes":"No")<<endl;}
vector<P> dxdy{{1,0},{0,1},{-1,0},{0,-1}};
const int INF = 1e18;
//using mint = modint1000000007;
//using mint = modint998244353;

signed main() {
cin.tie(0);
ios_base::sync_with_stdio(false);
cout << fixed << setprecision(20);

int n;cin>>n;
string s,t;cin>>s>>t;
vi s0,t0;
rep(i,n){
if(s[i]=='0')s0.push_back(i);
if(t[i]=='0')t0.push_back(i);
}
if(s0.size()!=t0.size()){
cout<<-1<<endl;
return 0;
}
int ans = 0;
int x = s0.size();
rep(i,x){
if(s0[i]!=t0[i])ans++;
}

cout << ans <<endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
int N, K;
cin >> N >> K;
vector<int> a(N + 2, K);
vector<int> b(K);

for (int i = 0; i < K; i++) {
string c;
int k;
cin >> c >> k;
b.at(i) = k;
if (c == "L") {
for (int j = 0; j < k; j++) {
a.at(j)--;
}
}
else {
for (int j = N + 1; j > k; j--) {
a.at(j)--;
}
}
}
for (int i = 0; i < K; i++) {
a.at(b.at(i)) = 1;
}

long long ans = 1;
for (int i = 1; i <= N; i++) {
ans *= a.at(i);
ans = ans % 998244353;
}
cout << ans << endl;
}
# include <bits/stdc++.h>
// # include <atcoder/all>

typedef long long ll;

using namespace std;
// using namespace atcoder;

#define rep(i,n) for (ll i=0; i<(ll)(n);i++)
#define ALL(a)  (a).begin(),(a).end()

ll gcd(ll x, ll y) { return (x==0)? y : gcd(y%x,x); }
ll lcm(ll x, ll y) { return x/gcd(x,y)*y; }
ll P(ll n, ll k) { return (k==1) ? n : n*(P(n-1,k-1)); }

ll mod=1000000007;
ll comb[2000][2000];
ll nCr(ll n, ll r) {
if(n==r) return comb[n][r] = 1;
if(r==0) return comb[n][r] = 1;
if(r==1) return comb[n][r] = n;
// if(comb[n][r]) return comb[n][r]%mod;
if(comb[n][r]) return comb[n][r];
// return comb[n][r] = (nCr(n-1,r) + nCr(n-1,r-1))%mod;
return comb[n][r] = (nCr(n-1,r) + nCr(n-1,r-1));
}

ll inv(ll x) {
ll res=1, k=mod-2;
while(k>0) {
if(k&1 == 1) res=(res*x)%mod;
x=(x*x)%mod;
k/=2;
}
return res;
}

ll nCr_mod_memo[1010101];

void nCr_mod_init() {
nCr_mod_memo[0]=1;
for(ll i=1;i<1010101;i++) nCr_mod_memo[i]=(nCr_mod_memo[i-1]*i)%mod;
}

ll nCr_mod(ll n, ll k) {
// ll a=1,b=1;
// for(int i=0;i<k;i++) a=(a*(n-i))%mod;
// for(int i=0;i<k;i++) b=(b*(k-i))%mod;

ll a=nCr_mod_memo[n];
ll b=nCr_mod_memo[n-k];
ll c=nCr_mod_memo[k];
ll bc=(b*c)%mod;

return (a*inv(bc))%mod;
}


/*
ll binpower(ll a, ll b) {
ll ans=1;
while (b != 0) {
if (b%2 == 1) ans = (ans*a)%mod;
a=(a*a)%mod;
b/=2;
}
return ans;
}
*/


ll binpower(ll a, ll b, ll m) {
ll ans=1;

a%=m;

while (b != 0) {
if (b%2 == 1) ans = (ans*a)%m;
a=(a*a)%m;
b/=2;
}
return ans;
}


bool judgeIentersected
(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy) {

ll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
ll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
ll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
ll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

return tc * td < 0 && ta * tb < 0;
// return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合
};



int main() {
ll n;
cin>>n;

mod=998244353;

ll ans=0;

for(ll a=1;a*a<=n;a++) {

ll ok=-1,ng=1e18;
while(abs(ok-ng) > 1) {
ll mid=(ok+ng)/2;
if(a+2*mid <= n/a) ok=mid;
else ng=mid;

// cout<<mid<<endl;
}

ans=(ans+ok+1)%mod;

/*
for(ll b=a;a*b<=n;b+=2) {
ans++;
}
*/

}

cout<<ans<<endl;

return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll         = long long;
constexpr ll MOD = 1000000007;
#define REP(i, n) for (ll i = 0; i < (n); i++)
#define REP2(i, x, n) for (ll i = x; i < (n); i++)
#define PR(x) cout << (x) << "\n"
#define PS(x) cout << (x) << " "
#define PRYES(x) PR((x) ? "Yes" : "No")
#define PR_DOUBLE(var) cout << fixed << std::setprecision(16) << (var) << endl
const long long INF          = numeric_limits<long long>::max();
const long long DP_INF       = 1 << 29;
template <class T> using arr = vector<vector<T>>;
using vint                   = vector<int>;
using vll                    = vector<ll>;
#ifdef SOURCE_TEST
#define TEST_CODE
#define SPR(x) PR(x)
#define SPS(x) PS(x)
#define STRACE(var) cout << #var << "=" << var << endl;
#else
#define SPR(x) \
{}
#define SPS(x) \
{}
#define STRACE(var) \
{}
#endif

template <class T> void dump(const vector<T>& vec) {
#ifdef SOURCE_TEST
for (ll i = 0; i < vec.size(); ++i) {
cout << vec[i] << ",";
}
cout << endl;
#endif
}
template <class T, class U> void dump_plane(const pair<T, U>& v) {
#ifdef SOURCE_TEST
cout << "{" << v.first << ":" << v.second << "},";
#endif
}
template <class T, class U> void dump(const pair<T, U>& v) {
#ifdef SOURCE_TEST
dump_plane(v);
cout << endl;
#endif
}
template <class T> void dump(const vector<vector<T>>& vecs) {
#ifdef SOURCE_TEST
for (const auto& v : vecs) {
dump(v);
}
#endif
}
template <class T> void dump(const set<T>& vec) {
#ifdef SOURCE_TEST
for (const auto& v : vec) {
cout << v << ",";
}
cout << endl;
#endif
}
void dump(const set<pair<ll, ll>>& vec) {
#ifdef SOURCE_TEST
for (const auto& v : vec) {
dump_plane(v);
}
cout << endl;
#endif
}
template <class T, class U> void dump(const vector<pair<T, U>>& vecs) {
#ifdef SOURCE_TEST
for (ll i = 0; i < vecs.size(); ++i) {
dump_plane(vecs[i]);
}
cout << endl;
#endif
}
void dump(const map<ll, ll>& mm) {
#ifdef SOURCE_TEST
for (const auto& m : mm) {
dump_plane(m);
}
cout << endl;
#endif
}
#include <regex>
// cout << regex_replace(str, regex("[aiueo]"), "") << endl;
bool isOk(ll K, const set<ll> ng) {
while (K != 0) {
ll n = K % 10;
if (ng.find(n) != ng.end()) return false;
K /= 10;
}
return true;
}
int main() {
ll N, K;
cin >> K >> N;
ll n;
set<ll> ng;
map<ll, ll> counter;
REP(i, N) {
cin >> n;
ng.insert(n);
}
while (!isOk(K, ng)) {
K++;
}
PR(K);
return 0;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

int n, X, Y, Z;

ll pw[50];

bool chk(string x)
{
int nw = X;
int flg = 0;
for(int i = 0; i < x.length(); i++)
{
int v = x[i];
nw -= v;
if(nw < 0)
return 0;
if(nw == 0)
{
if(flg)
return 1;
flg = 1;
nw = Y;
}
}
return 0;
}

int tot = 0;
map<string, int> idx;
int to[1 << 17][11];
bool ifok[1 << 17];

ll may[1 << 17], nmay[1 << 17];
string nw = "";int sum;

void dfs(int x)
{
if(nw != "" && sum <= X + Y + Z)
idx[nw] = ++tot;
for(int i = 1; i + sum <= X + Y + Z; i++)
nw += i, sum += i, dfs(x + 1), sum -= i, nw.pop_back();
}

void sol()
{
cin >> n >> X >> Y >> Z;
pw[0] = 1;
for(int i = 1; i <= n; i++)
pw[i] = pw[i - 1] * 10 % mod;
sum = 0;
dfs(1);
//	cerr << "!!" << tot << '\n';
for(int i = 1; i <= 10; i++)
nw = "", nw += (char)(i), may[idx[nw]]++, to[0][i] = idx[nw];
trav(v, idx)
{
int sum = 0;
trav(vv, v.fi)
sum += vv;
if(sum != X + Y + Z)
continue;
if(chk(v.fi))
ifok[v.sc] = 1;
}
trav(v, idx)
{
if(ifok[v.sc])
continue;
for(int j = 1; j <= 10; j++)
{
nw = v.fi;
nw += j;
int sum = 0;
trav(vv, nw)
sum += vv;
while(sum > X + Y + Z)
sum -= nw[0], nw = nw.substr(1, nw.length() - 1);
to[v.sc][j] = idx[nw];
}
}
ll ans = 0;
for(int i = 2; i <= n; i++)
{
memset(nmay, 0, sizeof nmay);
for(int v = 0; v <= tot; v++)
{
if(!may[v])
continue;
for(int j = 1; j <= 10; j++)
{
int nw = to[v][j];
//				if(ifok[nw])
//					cerr << i << ' ' << v << ' ' << j << '\n';
if(ifok[nw])
ans = (ans + pw[n - i] * may[v]) % mod;
else (nmay[nw] += may[v]) %= mod;
}
}
memcpy(may, nmay, sizeof nmay);
//cerr << nmay.size() << ' ' << may.size() << '\n';
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
#define endl '\n'
#define ll long long
#define pi pair<int, int>
#define f first
#define s second

const int mxn = 200001;
int n, m;
int b[mxn];
vector<int> v[mxn];

void add(int x, int y){ for(x++; x <= n; x += x & -x) b[x] = max(b[x], y);}

int qry(int x){ 
int ret = 0; 
for(x++; x; x -= x & -x) ret = max(ret, b[x]); 
return ret;
}

int main(){
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n >> m;

for(int i = 0, x, y; i < m; i++) cin >> x >> y, v[--x].push_back(--y);

for(int i = 0; i < n; i++){
sort(v[i].begin(), v[i].end(), greater<int>());
for(int j : v[i]) add(j, qry(j - 1) + 1);
}

cout << qry(n - 1) << endl;

return 0;
}
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define endl '\n'
#define ll long long
#define pi pair<int, int>
#define f first
#define s second

ll a, b, c;

void answer(){
cin >> a >> b >> c;

ll ret = 0, x;

//match 3-3-4
x = min(b / 2, c);
b -= 2 * x, c -= x, ret += x;

//match 2-2-3-3
x = min(a / 2, b / 2);
a -= 2 * x, b -= 2 * x, ret += x;

//match 2-4-4
x = min(a, c / 2);
a -= x, c -= 2 * x, ret += x;

//match 2-2-2-4
x = min(a / 3, c);
a -= 3 * x, c -= x, ret += x;

//match 2-2-2-2-2
x = a / 5;
a -= 5 * x, ret += x;

cout << ret << endl;
}

int main(){
ios::sync_with_stdio(0);
cin.tie(0);

int t;
cin >> t;

while(t--) answer();

return 0;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

int n, X, Y, Z;

ll pw[50];

bool chk(string x)
{
int nw = X;
int flg = 0;
for(int i = 0; i < x.length(); i++)
{
int v = x[i];
nw -= v;
if(nw < 0)
return 0;
if(nw == 0)
{
if(flg)
return 1;
flg = 1;
nw = Y;
}
}
return 0;
}

void sol()
{
cin >> n >> X >> Y >> Z;
pw[0] = 1;
for(int i = 1; i <= n; i++)
pw[i] = pw[i - 1] * 10 % mod;
unordered_map<string, ll> may;
unordered_map<string, ll> nmay;
string nw;
for(int i = 1; i <= 10; i++)
nw = "", nw += (char)(i), may[nw] = 1;
ll ans = 0;
for(int i = 2; i <= n; i++)
{
nmay.clear();
trav(v, may)
{
for(int j = 1; j <= 10; j++)
{
nw = v.fi;
nw += j;
int sum = 0;
trav(vv, nw)
sum += vv;
while(sum > X + Y + Z)
sum -= nw[0], nw = nw.substr(1, nw.length() - 1);
if(sum == X + Y + Z && chk(nw))
ans = (ans + pw[n - i] * v.sc) % mod;
else if(sum == X + Y + Z)
{
nw = nw.substr(1, nw.length() - 1);
(nmay[nw] += v.sc) %= mod;
}
else (nmay[nw] += v.sc) %= mod;
}
}
may = nmay;
//cerr << nmay.size() << ' ' << may.size() << '\n';
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define all(x) x.begin(),x.end()

int main(){
int n,k,d;
bool che[10] = {false};
cin>>n>>k;
for(int i=0; i<k; i++){
cin>>d;
che[d] = true;
}
while(1){
int x = n;
while(x > 0){
if(che[x%10]){
n++;
break;
}else{
x /= 10;
}
}
if(x <= 0){
cout<<n<<endl;
return 0;
}
}
return 0;
}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
template <typename T> using oset = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;

void test_case() {
int N, M; std::cin >> N >> M;
std::vector<int> S(N), T(M);
for (auto &v : S) std::cin >> v;
for (auto &v : T) std::cin >> v;
bool ze = false, on = false;
for (auto v : T) {
if (v) on = true;
if (!v) ze = true;
}
bool zze = false, oon = false;
for (auto v : S) {
if (v) oon = true;
if (!v) zze = true;
}
if (on && !oon) {
std::cout << -1 << "\n";
return;
}
if (ze && !zze) {
std::cout << -1 << "\n";
return;
}
if (on && ze) {
auto solve = [&] (int change) -> int {
int answer = 0;
for (int i = 0; i < M; ++i) {
if (T[i] && change) ++answer;
else if (T[i] && !change) {
change ^= 1;
answer += 2;
} else if (!T[i] && change) {
change ^= 1;
answer += 2;
} else ++answer;
}
return answer;
};
int answer = int(1e9);
if (S[0] == 0 && S.back() == 1) answer = std::min(answer, solve(0));
if (S[0] == 1 && S.back() == 0) answer = std::min(answer, solve(1));
int Min01 = int(1e9);
int Min10 = int(1e9);
int Max01 = -1;
int Max10 = -1;
for (int i = 0; i < N - 1; ++i) {
if (S[i] == 0 && S[i + 1] == 1) {
Min01 = std::min(Min01, i);
Max01 = std::max(Max01, i);
}
if (S[i] == 1 && S[i + 1] == 0) {
Min10 = std::min(Min10, i);
Max10 = std::max(Max10, i);
}
}
if (Min01 != int(1e9)) answer = std::min(answer, Min01 + solve(0));
if (Min10 != int(1e9)) answer = std::min(answer, Min10 + solve(1));
if (Max01 != -1) answer = std::min(answer, N - Max01 - 1 + solve(1));
if (Max10 != -1) answer = std::min(answer, N - Max10 - 1 + solve(0));
std::cout << answer << "\n";
} else if(on) {
if (S[0] == 1) std::cout << M << "\n";
else {
int Min = int(1e9);
int Max = -1;
for (int i = 0; i < N; ++i) {
if (S[i]) {
Min = std::min(Min, i);
Max = std::max(Max, i);
}
}
std::cout << std::min(Min, N - Max) + M << "\n";
}
} else {
if (S[0] == 0) std::cout << M << "\n";
else {
int Min = int(1e9);
int Max = -1;
for (int i = 0; i < N; ++i) {
if (!S[i]) {
Min = std::min(Min, i);
Max = std::max(Max, i);
}
}
std::cout << std::min(Min, N - Max) + M << "\n";
}
}
}

int main() {
std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr);
int test = 1;
//std::cin >> test;
while (test--) {
test_case();
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;

const int MOD=998244353;

int main(){
int N,K; cin >> N >> K;

int a[N+1]={0};
bool b[N+1]={false};

for(int i=0;i<K;i++){
char c; cin >> c;
int x; cin >> x;
b[x]=true;
if(c=='L') a[x+1]++;
else{
a[0]++;
a[x]--;
}
}
for(int i=1;i<=N;i++) a[i]+=a[i-1];

long long ans=1;
for(int i=1;i<=N;i++){
if(!b[i]) ans=(ans*a[i])%MOD;
}
printf("%lld\n",ans);
return 0;
}
#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;
typedef long long ll;
using mint = modint;
//using mint = modint998244353;
//using mint = modint1000000007;
//constexpr ll MOD = 998244353;
//constexpr ll MOD = 1000000007;


ll INF = 1LL << 60;


int main(){

ll N;
string S, T;
cin >> N >> S >> T;

if( S.size() != T.size() ){
cout << -1 << endl;
return 0;
}

vector<ll> S0, T0;
for( int i = 0; i < S.size(); i++ ){
if( S[i] == '0' ) S0.push_back(i);
if( T[i] == '0' ) T0.push_back(i);
}

if( S0.size() != T0.size() ){
cout << -1 << endl;
return 0;
}

ll ans = 0;
for( int i = 0; i < S0.size(); i++ ){
if( S0[i] != T0[i] ) ans++;
}

cout << ans << endl;

return 0;

}

#include<bits/stdc++.h>
#include <iterator>
#include <iostream>
#include <numeric>
#include <math.h>
#define ll long long
#define ull long
#define mpa make_pair
#define pb push_back
#define ff first
#define pii pair<ll,ll>
#define dd long double
#define trace(x) cerr << #x << " : " << x << endl
#define ss second
#define boost ios_base::sync_with_stdio(0)
#define forp(i,a,b) for(ll i=a;i<=b;i++)
#define rep(i,n)    for(ll i=0;i<n;++i)
#define ren(i,n)    for(ll i=n-1;i>=0;i--)
#define forn(i,a,b) for(ll i=a;i>=b;i--)
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end();
#define sc(x) scanf("%lld",&x)
#define clr(x,val) memset(x,val,sizeof(x))
#define pr(x) printf("%lld\n",x) 
#define gc getchar
#define pdd pair<dd,dd>
#define prec(x) cout<<fixed<<setprecision(x)
#define fre freopen("input.txt","r",stdin),freopen("output.txt","w",stdout)
#define arr array 
using namespace std;
ll get_len(ll n){
ll s=0;
while(n){
s++;
n/=10;
}
return s;
}
void solve(ll tc){

ll n;
cin>>n;


ll ans=0;
ll len=get_len(n);


for(ll l=1;l<=len;l++){

for(ll i=1;i<=l;i++){

ll lo=0,hi=0;

for(ll k=1;k<=i;k++){
lo=lo*10+1;
hi=hi*10+1;
}

for(ll k=i+1;k<=l;k++){
lo=lo*10;
hi=hi*10+9;
}

lo=max(lo,1ll);
hi=min(hi,n);
ans=ans+max(0ll,hi-lo+1);
}
}


cout<<ans<<endl;

}
int main(){
boost;

//pre_cum();
//prec(20);
//fre;






ll t=1;
ll tc=1;
//cin>>t;

while(t--){
solve(tc);
tc++;
}

return 0;


}

#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <vector>
#define setIO(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)
#define closefile fclose(stdin), fclose(stdout)
#define m_p make_pair
#define sz(x) (int)x.size()
#define see(x) cerr << x << " "
#define seeln(x) cerr << x << endl
#define out(x) cerr << #x << " = " << x << " "
#define outln(x) cerr << #x << " = " << x << endl
#define outarr(x, l, r) {cerr << #x"[" << l << " ~ " << r << "] = "; for (int _i = l; _i <= r; ++_i) cerr << x[_i] << " "; cerr << endl;}
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define gc() getchar()
//#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template <class T> void read(T &x) {
x = 0; int c = gc(); int flag = 0;
while (c < '0' || c > '9') flag |= (c == '-'), c = gc();
while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = gc();
if (flag) x = -x;
}
template <class T> bool checkmax(T &a, T b) {return a < b ? a = b, 1 : 0;}
template <class T> bool checkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}
int n, A, B;

void init() {
scanf("%d%d%d", &n, &A, &B);
}

void print() {
int x = A > B ? (A + B) / 2 : A;
int ans = max(A - x, x - B);
printf("%d\n", ans);
}

void solve() {
print();
for (int i = 2, l, r; i <= n; ++i) {
scanf("%d%d", &l, &r);
checkmax(A, l);
checkmin(B, r);
print();
}
}

int main() {
init();
solve();
return 0;
}

#include <algorithm>
#include <iostream>
#include <iomanip>
#include <limits.h>
#include <map>
#include <math.h>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <stack>

using namespace std;
#define rep(i, n) for (int i = 0; i < n; i++)
#define rep1(i, n) for (int i = 1; i < n + 1; i++)
#define all(A) A.begin(), A.end()
#define itr(A, l, r) A.begin() + l, A.begin() + r
#define debug(var) cout << #var << " = " << var << endl;
typedef long long ll;

const ll mod = 1e9 + 7;

ll rpow(ll a, ll r, ll mod)
{
if (r == 0)
return 1;
ll ans = rpow(a, r / 2, mod);
ans *= ans;
ans %= mod;
if (r % 2 == 1)
ans *= a;
ans %= mod;
return ans;
}

int main(void)
{
int n;
cin >> n;
vector<ll> a(n + 1);
rep1(i, n)
{
cin >> a[i];
}
sort(all(a));
ll ans = 1;
rep(i, n)
{
ans *= a[i + 1] - a[i] + 1;
ans %= mod;
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N; input(N);
VLL A(N); REP(i,N) input(A[i]);

ll sum = 0;
ll tot = 0;
ll mx = 0;
REP(i,N) {
sum += A[i];
tot += sum;
chmax(mx, A[i]);
ll ans = tot + (i+1) * mx;
print(ans);
}

return 0;
}

#include <algorithm>
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;


void solve() {
int n;
cin >> n;
vector<int> p(n + 1), q(n + 1);
for (int i = 1; i <= n; i++) cin >> p[i];
for (int i = 1; i <= n; i++) cin >> q[i];

vector<vector<int>> mults(n + 1);
for (int i = 1; i <= n; i++) {
for (int j = i; j <= n; j += i) {
mults[i].push_back(j);
}
}
vector<int> invq(n + 1);
for (int i = 1; i <= n; i++) {
invq[q[i]] = i;
}
vector<vector<int>> a(n + 1);
for (int i = 1; i <= n; i++) {
for (int j: mults[p[i]]) {
a[i].push_back(invq[j]);
} 
sort(a[i].begin(), a[i].end(), greater<int>());
}
vector<int> b;
for (int i = 1; i <= n; i++) {
for (int j: a[i]) {
b.push_back(j);
}
}
vector<int> res;
for (int x: b) {
auto it = lower_bound(res.begin(), res.end(), x);
if (it == res.end()) res.push_back(x);
else *it = x;
}
cout << res.size() << '\n';
}   

int main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);

int t = 1;
//cin >> t;
while (t--) {
solve();
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
#include <atcoder/fenwicktree>
using namespace atcoder;


int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N; input(N);
VLL A(N); REP(i,N) input(A[i]);
VLL B(N); REP(i,N) input(B[i]);

auto output = [&](ll ans) -> void { cout << ans << '\n'; exit(0); };

ll sumA = SUMLL(A);
ll sumB = SUMLL(B);
if (sumA != sumB) output(-1);

REP(i,N) A[i] += i;
REP(i,N) B[i] += i;
map<ll,queue<ll>> mp;
REP(i,N) mp[A[i]].push(i);

fenwick_tree<ll> fw(N);

ll ans = 0;
REP(i,N) {
ll b = B[i];
auto& q = mp[b];
if (q.empty()) output(-1);
ll idx = q.front(); q.pop();
ans += fw.sum(idx, N);
fw.add(idx, 1);
}
print(ans);

return 0;
}

#include <bits/stdc++.h>
#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <math.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
using ll = long long;
#define rep(i, n) for(int i = 0; i < (int)(n); i++)
const double PI =acos(-1);

int main()
{
ll N, M;
cin >> N >> M;
ll odd = 0, even = 0;
rep(i, N){
string S;
cin >> S;
ll cnt = 0;
rep(j, S.size()){
if(S[j] == '1'){
cnt++;
}
}
if(cnt % 2 == 1){
odd++;
}else{
even++;
}
}
cout << odd * even << endl;
}
#include <bits/stdc++.h>
typedef long long int ll;
using namespace std;
int main() {
ll n;
string s;
cin >> n >> s;
ll sm = 0;
for (ll i = 0; i < n; i++) {
ll count = 1;
while (i < n - 1 && s[i] == s[i + 1]) {
count++;
i++;
}
sm += count * (count - 1) / 2;
}
cout << sm << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int i,j,k,n,m,t;
string res;
vector<int> v;

int main() {
ios::sync_with_stdio(0);
cin>>n;
while(n){
for(i=1;i<=n;i++){
res+="7";n-=i;
for(auto &j:v){j=j*10%7;}
}
if(n)for(i=1;i<=6;i++){
for(auto j:v){
if(!((j*10+i)%7))goto aaa;
}
for(auto &j:v){
j=(j*10+i)%7;
}
res+=to_string(i);
v.push_back(i);
break;
aaa:;
}
}
cout<<res;
}
// #include <atcoder/all>
// using namespace atcoder;
// using mint = modint998244353;
// using mint = modint1000000007;
#include <bits/stdc++.h>
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define rep2(i,k,n) for (int i = (k); i < (n); ++i)
using namespace std;
using ll = long long;
// using P = pair<ll,ll>;
using P = pair<int,int>;
using vint = vector<int>;
using vll = vector<ll>;
using vvint = vector<vector<int>>;
using vvll = vector<vector<ll>>;

// const ll INF = (ll)2e18+9;
const int INF = (int)2e9+7;
// const ll MOD = (ll)1e9+9;
template<typename T>
void chmin(T &a, T b) { a = min(a, b); }
template<typename T>
void chmax(T &a, T b) { a = max(a, b); }

template<typename T>
void print(vector<T> v) {
int n = v.size();
rep(i,n) {
if (i == 0) cout << v[i];
else cout << ' ' << v[i];
}
cout << endl;
}

void solve() {
ll n;
cin >> n;

ll ans = 0;
rep(i,16) {
ll base = 1;
rep(j,i) {
base *= 10;
base += 1;
}
ll fin = base+1;
while (fin <= (ll)2e15) {
ll mn = min(fin, n+1);
if (mn - base > 0) ans += mn - base;
base *= 10;
fin *= 10;
}
}
cout << ans << endl;
}

int main() {
solve();
return 0;
}

#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;
typedef long long ll;
using mint = modint;
//using mint = modint998244353;
//using mint = modint1000000007;
//constexpr ll MOD = 998244353;
//constexpr ll MOD = 1000000007;


ll INF = 1LL << 60;

void ruisekiwa( vector<ll> P, vector<ll>& sum ){

ll size = P.size();
for( int i = 1; i <= size; i++ ){
sum[i] = sum[i-1] + P[i-1];
}

}

// [left, right]
ll Getruisekiwa( vector<ll>& sum, ll left, ll right ){
return sum[right+1] - sum[left];
}


int main(){

ll N;
cin >> N;
vector<ll> A(N,0), B(N,0);
for( int i = 0; i < N; i++ ){
cin >> A[i];
if( i%2 == 0 ){
B[i] = A[i];
}
else{
B[i] = -A[i];
}
}

ll ans = 0;

// +-
vector<ll> sumB(N+1,0);
ruisekiwa( B, sumB );
map<ll,ll> mpB;
for( int i = 0; i < N+1; i++ ){
mpB[sumB[i]]++;
}
for( auto itr = mpB.begin(); itr != mpB.end(); itr++ ){
ll n = itr->second;
ans += n*(n-1)/2;
}

cout << ans << endl;

return 0;

}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }

vector<int> enum_divisors(int N) {
vector<long long> res;
for (long long i = 1; i * i <= N; ++i) {
if (N % i == 0) {
res.push_back(i);
if (N / i != i) res.push_back(N / i);
}
}
sort(res.begin(), res.end());
return res;
}
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
int n;
cin >> n;
vc<pi> cs;
rep(i, n) {
int a, b;
cin >> a >> b;
cs.emplace_back(a, b);
}
//何にせよ，1つめのカードはどちらかに入る．
// gcdはそこに含まれる約数が候補となる．
auto x = enum_divisors(cs[0].first);
auto y = enum_divisors(cs[0].second);
int ans = 0;
for (auto u : x) {
for (auto v : y) {
bool f = true;
for (int i = 0; i < n; i++) {
auto [c, d] = cs[i];
if ((c % u == 0 && d % v == 0) || (c % v == 0 && d % u == 0)) {
} else {
f = false;
}
}
if (f) {
chmax(ans, lcm(u, v));
}
}
}
cout << ans << endl;
}
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <deque>
#include <cstdio>
#include <set>
#include <map>
#include <bitset>
#include <stack>
#include <cctype>
using namespace std;
int s[200020],t[200020];
int main() {
int n, m;
cin >> n >> m;
for (int i = 0; i < n; i++) {
cin >> s[i];
}
for (int i = 0; i < m; i++) {
cin >> t[i];
}
int mi = n + 10;
for (int i = 0; i < n; i++) {
if (s[0] != s[i]) {
mi = min({ mi,i,n - i });
}
}
int ans = 0;
bool bo = false;
for (int i = 0; i < m; i++) {
if (!bo && s[0] != t[i]) {
if (mi == n + 10) {
cout << -1 << endl;
return 0;
}
ans += mi;
bo = true;
}
else if (bo && t[i - 1] != t[i]) {
ans++;
}
}
cout << ans + m << endl;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, N = 3e5;

vector <int> fact(N), rfact(N);
int binp(int a, int b) {
if (!b) return 1ll;
if (b & 1) return a * binp(a, b - 1) % mod;
int t = binp(a, b / 2);
return t * t % mod;
}
int getC(int n, int k) {
if (n < 0 or k > n) return 0;
return fact[n] * rfact[n - k] % mod * rfact[k] % mod;
}

int calcRect(int n, int m) {
return getC(n + m - 2, n - 1);
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

fact[0] = rfact[0] = 1;
for (int i = 1; i < N; ++i) {
fact[i] = fact[i - 1] * i % mod;
rfact[i] = binp(fact[i], mod - 2);
}

int n, m, a, b; cin >> n >> m >> a >> b;
int ans = calcRect(n, m);

for (int i = 1; i <= a; ++i) {
int curN = n - a + i, curM = b;
int curN2 = a - i + 1, curM2 = m - b;
ans -= calcRect(curN, curM) * calcRect(curN2, curM2) % mod - mod;
ans %= mod;
}

cout << ans << '\n';

return 0;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, A, B, C;
cin >> n >> A >> B >> C;
//	--A, --B, --C;
int ok = (1 << C - 1) | (1 << B + C - 1) | (1 << A + B + C - 1);
VLL pw(n + 1);
pw[0] = 1;
for(int i = 1; i <= n; i++)
pw[i] = pw[i - 1] * 10 % mod;
int lim = (1 << A + B + C);
VLL nw(lim, 0), nxt(lim, 0);
nw[0] = 1;
ll ans = 0;
for(int i = 1; i <= n; i++)
{
fill(all(nxt), 0);
for(ll sta = 0; sta < lim; sta++)
{
if(!nw[sta])
continue;
for(int j = 1; j <= 10; j++)
{
int nsta;
nsta = sta << j | (1 << j - 1);
nsta = nsta & (lim - 1);
//cerr << sta << ' ' << j << ' ' << nsta << '\n';
if((nsta & ok) == ok)
ans = (ans + pw[n - i] * nw[sta]) % mod;
else
nxt[nsta] = (nxt[nsta] + nw[sta]) % mod;
}
}
nw = nxt;
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include <iostream>
#include <string>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <functional>
#include <cstdlib>
#include <list>
#include <iomanip>
#include <unordered_map>
#include <chrono>
#define ll long long
#define ull unsigned long long
#define ld long double
#define MOD 998244353
#define INF 0x3f3f3f3f
#define INF_MIN LLONG_MIN
#define MAX 200000
using namespace std;

int lengthOfLIS(vector<int>& nums) {
vector<int> lisCache;
for (int i = 0; i < nums.size(); i++) {
auto it = lower_bound(lisCache.begin(), lisCache.end(), nums[i]);
if (it == lisCache.end()) {
lisCache.push_back(nums[i]);
}
else {
(*it) = nums[i];
}
}
return lisCache.size();
}

bool comparePair(const pair<int, int>& a, const pair<int, int>& b) {
if (a.first != b.first) {
return a.first < b.first;
}
else {
return a.second > b.second;
}
}

int main() {
int N, M;
cin >> N >> M;

vector<pair<int, int>> v;
for (int i = 0; i < M; i++) {
int a, b;
cin >> a >> b;
v.push_back({ a,b });
}

sort(v.begin(), v.end(), comparePair);

vector<int> B;
for (int i = 0; i < v.size(); i++) {
B.push_back(v[i].second);
}

cout << lengthOfLIS(B) << endl;
}
#include<bits/stdc++.h>
#define MAXN 200000
using namespace std;
int n,m,f[MAXN+5],ln;
vector<int>p[MAXN+5];
bool cmp(int x,int y){return x>y;}
signed main(){
scanf("%d%d",&n,&m);
for(int i=1,ui,vi;i<=m;i++) scanf("%d%d",&ui,&vi),p[ui].push_back(vi);
for(int i=1;i<=n;i++){
if(!p[i].size()) continue;
sort(p[i].begin(),p[i].end(),cmp);
for(int j=0,u;j<p[i].size();j++){
int k=lower_bound(f,f+ln+1,p[i][j])-f;
f[k]=p[i][j]; if(k>ln) ++ln;
}
}printf("%d\n",ln);
return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

inline int rd() {
int res = 0; char ch = getchar();
while (ch < '0' || ch > '9') ch = getchar();
while (ch >= '0' && ch <= '9') res = res * 10 + ch - '0', ch = getchar();
return res;
}
void wr(int x) {
if (x > 9) wr(x / 10);
putchar(x % 10 + '0');
}

int m, n, tag[11], ans;

inline bool f(int x) {
while (x) {
if (tag[x % 10]) return false;
x /= 10;
}
return true;
}

int main() {
m = rd(); n = rd();
for (int i = 1; i <= n; ++i) {
int t = rd(); tag[t] = 1;
}
for (int i = m; ; ++i) {
if (f(i)) { ans = i; break; }
}
wr(ans);
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, cc = 1e8;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n, k; cin >> n >> k;
set <int> ban;
for (int i = 0, x; i < k; ++i) {
cin >> x;
ban.insert(x);
}

while (true) {
string cur = to_string(n);
bool ok = false;
for (auto& x : cur)
if (ban.find(x - '0') != ban.end())
ok = true;
if (!ok) break;
n++;
}
cout << n << '\n';
return 0;
}
#include <bits/stdc++.h>
#define re register
using namespace std;
const int M=200005,inf=1e9;
int RD(){
int x=0,f=1;char c=getchar();
while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
while(c<='9'&&c>='0'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
return x*f;
}
int n,m;
int s[M],t[M];
int a[2],b[2];
int main() {
n=RD(),m=RD();int ans=m;
for(int i=1;i<=n;i++)s[i]=RD(),a[s[i]]=1;
for(int i=1;i<=m;i++)
{
t[i]=RD(),b[t[i]]=1;
ans+=(t[i]!=t[i-1]);
}if(t[1])ans--;
if((b[1]&&(!a[1]))||(b[0]&&(!a[0]))){puts("-1");return 0;}
int i1=2,i2=n,k=0;
while(s[i1]==s[1]&&s[i2]==s[1]&&i1!=i2) k++,i1++,i2--;
if(b[1]+b[0]<2) printf("%d",ans+(s[1]==t[1]?0:(k+1)));
else printf("%d",ans+k+(s[1]!=t[1]));
return 0;
}
/*
3 8
1 0 1
0 0 0 0 1 0 1 0
*/
#include <iostream>
#include <vector>
using namespace std;
const int MAX_N = 2000 + 10;
int a[MAX_N];
int b[MAX_N];
int c[MAX_N];

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);

int N;
cin >> N;

for (int i = 0; i < N; i++) cin >> a[i];
for (int i = 0; i < N; i++) cin >> b[i];

// bはソートしても変わらない.
// cとの一致を確認しやすいように先に昇順にしておく.
sort(b, b + N);

vector<int> vans;

for (int i = 0; i < N; i++) {
int x = a[0]^b[i];

for (int j = 0; j < N; j++) c[j] = a[j]^x;
sort(c, c + N);

bool flag = true;
for (int j = 0; j < N; j++) {
if(b[j] != c[j]) flag = false;
}

if(flag) vans.push_back(x);
}

// 注意1. vansをソート(昇順)
sort(vans.begin(), vans.end());

// 注意2. vansから重複を削除.
vans.erase(unique(vans.begin(), vans.end()), vans.end());

cout << vans.size() << endl;
for (auto x : vans) cout << x << endl;

return 0;
}





#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <cmath>
#include <queue>
#include <deque>
typedef long long LL;
using namespace std;

int main() {
LL N;
cin >> N;
LL a, b = 1, c;

LL ans = N;

for (int i = 1; b <= N; i++) {
b *= 2;
a = N / b;
c = N % b;
ans = min(a + i + c, ans);
}
cout << ans << endl;
}
// #include <atcoder/all>
// using namespace atcoder;
// using mint = modint998244353;
// using mint = modint1000000007;
#include <bits/stdc++.h>
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define rep2(i,k,n) for (int i = (k); i < (n); ++i)
using namespace std;
using ll = long long;
// using P = pair<ll,ll>;
using P = pair<int,int>;
using vint = vector<int>;
using vll = vector<ll>;
using vvint = vector<vector<int>>;
using vvll = vector<vector<ll>>;

// const ll INF = (ll)2e18+9;
const int INF = (int)2e9+7;
// const ll MOD = (ll)1e9+9;
template<typename T>
void chmin(T &a, T b) { a = min(a, b); }
template<typename T>
void chmax(T &a, T b) { a = max(a, b); }

template<typename T>
void print(vector<T> v) {
int n = v.size();
rep(i,n) {
if (i == 0) cout << v[i];
else cout << ' ' << v[i];
}
cout << endl;
}

void solve() {
ll n;
cin >> n;

ll ans = 0;
rep(i,16) {
ll base = 1;
rep(j,i) {
base *= 10;
base += 1;
}
ll fin = base+1;
while (fin <= (ll)1e16) {
ll mn = min(fin, n+1);
if (mn - base > 0) ans += mn - base;
base *= 10;
fin *= 10;
}
}
cout << ans << endl;
}

int main() {
solve();
return 0;
}

#include<iostream>

using namespace std;

int main()
{
long a,b,c=1e9; cin>>a>>b;
printf("%ld\n",c/2*b+a);
}
#include "cstdio"
#include <bits/stdc++.h>

using namespace std;

#define ll long long
inline ll min1(ll l1, ll l2) {
return l1 < l2 ? l1 : l2;
}

inline ll max1(ll l1, ll l2) {
return l1 > l2 ? l1 : l2;
}

int main() {
ll n, l, r;
ll res = 0;
cin >> n >> l >> r;
int i = 0;
ll ntemp = n;
while(ntemp > 0) {
ntemp = ntemp >> 1;
i++;
}

ll filter = 1ll << (i-1);
do {
ll ltemp = max1(filter, l);
ll rtemp = min1(filter << 1, r+1);
res += max1(rtemp - ltemp, 0);
do {
filter = filter >> 1;
}while(filter != 0 && ((filter & n) == 0));
}while(filter != 0);
cout << res << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main(){
long long n,c=0,ans=0;
string s;
cin>>n>>s;

for(int i=1; i<n; i++){
if(s[i-1]==s[i]) c++;
else c=0;

ans+=c;
}

cout<<ans<<endl;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
int n;
cin >> n;

vector<vector<int>> c(n, vector<int> (n));
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
cin >> c[i][j];
}
}

for (int i = 1; i < n; i++) {
for (int j = 0; j < n; j++) {
c[i][j] -= c[0][j];
}
}

for (int j = 1; j < n; j++) {
for (int i = 0; i < n; i++) {
c[i][j] -= c[i][0];
}
}

bool check = true;
for (int i = 1; i < n; i++) {
for (int j = 1; j < n; j++) {
if (c[i][j]) {
check = false;
}
}
}

int x, y;
if (n == 1) {
x = 0;
y = 0;
} else {
x = c[1][0];
y = c[0][1];
for (int i = 1; i < n; i++) {
x = min(x, c[i][0]);
y = min(y, c[0][i]);
}
}

int a = max(-x, 0), b = max(-y, 0);
if (check && c[0][0] >= a+b) {
b = c[0][0]-a;
} else {
check = false;
}

if (check) {
cout << "Yes" << endl;
cout << a;
for (int i = 1; i < n; i++) {
cout << " " << c[i][0]+a;
}
cout << endl;
cout << b;
for (int i = 1; i < n; i++) {
cout << " " << c[0][i]+b;
}
cout << endl;
} else {
cout << "No" << endl;
}
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


// Editorial AC

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N; input(N);
ll N2 = 2*N;
VLL A(N2); REP(i,N2) input(A[i]);

VLL C(N2,0);
VP X(N2); REP(i,N2) X[i] = {A[i], i};
SORT(X);
REP(i,N) C[X[i].second] = 1;

string ans(N2,'x');
stack<P> st;  // (color, idx)
REP(i,N2) {
if (st.empty()) {
st.emplace(C[i], i);
} else {
auto [c, idx] = st.top();
if (c == C[i]) {
st.emplace(C[i], i);
} else {
ans[idx] = '(';
ans[i] = ')';
st.pop();
}
}
}
print(ans);

return 0;
}

#include <iostream>

using namespace std;

int n;
int main(){
ios_base::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);

cin >> n;

int arr[200000] = {};

int maxi = 0;

bool ya = false;

for(int i = 0; i < n; i++){
cin >> arr[i];
maxi = max(maxi, arr[i]);
}

for(int i = 1; i < n; i++){
if(arr[i-1] > arr[i]){
maxi = arr[i-1];
ya = true;
break;
}
}
if(!ya)maxi = arr[n-1];

for(int i = 0; i<  n; i++){
if(arr[i] != maxi)cout << arr[i] <<' ';
}


return 0;
}
#include<bits/stdc++.h>
using namespace std;
int main(){
int n;
cin>>n;
vector<int> p(n+1);
for(int i=2;i<=n;i++){
if(p[i])continue;
for(int j=i;j<=n;j+=i)p[j]=i;
}
for(int i=1;i<=n;i++){
int cnt=0;
for(int j=i;j!=1;j/=p[j])cnt++;
cout<<cnt+1<<" ";
}
cout<<endl;
}
#include<iostream>
#include<algorithm>
#include<string.h>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<cmath>

#define ll long long
#define P pair<int,int>
#define rep(i,l,r) for(ll i=(l);i<(r);++i)
#define drep(i,l,r) for(ll i=(r-1);i>=(l);--i)
#define debug(a) cout<<#a<<"="<<a<<endl;
#define EPS 1e-8
#define INF 0x7fffffff
#define MOD 1e9+7
using namespace std;
//ios::sync_with_stdio(0);
//if((double)clock()/CLOCKS_PER_SEC >= 1.98) cout << ans << "\n", exit(0);

/*inline int readd () {
int f = 1,x = 0, ch = getchar();
while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
return x * f;
}*/

int main()
{
string s;
ll ans=0, n, a=1;
cin >> n >> s;
rep(i, 1, n){
if(s[i]==s[i-1]) ans += a++;
else a=1;
}
cout << ans << endl;
return 0;
}

/*

*/

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
int main(){
ll t;
cin >> t;
for (int i = 0; i < t; i++)
{
ll c;
cin >> c;
if (c%4==0)
{
cout << "Even" << endl;
}else{
if (c%2==0)
{
cout << "Same" << endl;
}else{
cout << "Odd" << endl;
}

}

}


}
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back
#define em emplace
#define all(v) v.begin(), v.end()
#define reset(x) memset(x, 0, sizeof(x))

using namespace std;
typedef long long ll;
typedef long double ld;
typedef complex <double> cpx;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;

const int MAX = 101010;
const int INF = 1e9;
const ll LINF = 1e18;

struct SegmentTree {
vector <pii> tree;
vector <int> lazy;
int sz;
void Init(int n, string &S) {
sz = n;
tree.resize(4*n+10);
lazy.resize(4*n+10);
init(1, 0, sz-1, S);
}
void init(int node, int s, int e, string &S) {
if(s == e) {
if(S[s] == '0') tree[node] = {1, 0};
else tree[node] = {0, 1};
return;
}
int m = s + e >> 1;
init(node<<1, s, m, S), init(node<<1|1, m+1, e, S);
tree[node].fi = tree[node<<1].fi + tree[node<<1|1].fi;
tree[node].se = tree[node<<1].se + tree[node<<1|1].se;
}

void update_lazy(int node, int s, int e) {
if(lazy[node]) swap(tree[node].fi, tree[node].se);
if(s != e) {
lazy[node<<1] ^= lazy[node];
lazy[node<<1|1] ^= lazy[node];
}
lazy[node] = 0;
}

void update(int node, int s, int e, int l, int r) {
update_lazy(node, s, e);
if(s > r || e < l) return;
if(s >= l && e <= r) {
lazy[node] ^= 1;
update_lazy(node, s, e);
return;
}
int m = s + e >> 1;
update(node<<1, s, m, l, r);
update(node<<1|1, m+1, e, l, r);
tree[node].fi = tree[node<<1].fi + tree[node<<1|1].fi;
tree[node].se = tree[node<<1].se + tree[node<<1|1].se;
}
void update(int l, int r) {update(1, 0, sz-1, l, r);}

bool get(int node, int s, int e, int k) {
update_lazy(node, s, e);
if(s == e) return tree[node].se > 0;
int m = s + e >> 1;
if(k <= m) return get(node<<1, s, m, k);
else return get(node<<1|1, m+1, e, k);
}
bool get(int k) {return get(1, 0, sz-1, k);}

int search() {return search(1, 0, sz-1);}
int search(int node, int s, int e) {
update_lazy(node, s, e);
if(s == e) {
if(tree[node].se > 0) return s;
else return -1;
}
int m = s + e >> 1;
update_lazy(node<<1|1, m+1, e);
if(tree[node<<1|1].se == 0) return search(node<<1, s, m);
else return search(node<<1|1, m+1, e);
}

bool modify() {
int k = search();
if(k < 0) return false;
update(k, sz-1);
return true;
}
};

int main() {
ios::sync_with_stdio(false); cin.tie(nullptr);

int n; string s;
cin >> n >> s;
string temp;
for(int i = 0; i < n - s.size(); i++) {
temp += "0";
}
s = temp + s;
SegmentTree ST;
ST.Init(n, s);
ST.modify();

string ans = "1";
for(int i = 0; i < n; i++) {
if(ST.get(i)) ans += "1", ST.update(i, i);
else if(ST.modify()) ans += "0";
else break;
}
cout << ans;
}
// Problem: A - Max Add
// Contest: AtCoder - AtCoder Regular Contest 120
// URL: https://atcoder.jp/contests/arc120/tasks/arc120_a
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#pragma GCC optimize("Ofast,unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2")
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;

template<typename F>
void multitest(F func) {
int t;
cin >> t;
while(t--) func();
}
void report(int ok) {
cout << (ok?"YES":"NO") << '\n';
}

int main() {
cin.tie(0)->sync_with_stdio(0);
//multitest([&](){});
int n;
cin >> n;
vector<ll> a(n);
ll su = 0, pu = 0, mx = 0;
for(int i = 0; i < n; i++) {
cin >> a[i];
mx = max(mx, a[i]);
su += a[i];
pu += su;
cout << mx*(i+1)+pu << '\n';
}
}

#ifdef __LOCAL
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
using P = pair<int,int>;
using PIL = pair<int,ll>;
using PLI = pair<ll,int>;
using PLL = pair<ll,ll>;
template<class T> using Matrix = vector<vector<T>>;
template <class T> using PQmax = priority_queue<T>;
template <class T> using PQmin = priority_queue<T, std::vector<T>, std::greater<T>>;
#define REP(i,n) for(int i=0;i<int(n);i++)
#define foa(s,v) for (auto &s : v)

const int inf = 1001001001;
const ll INF = 1LL << 60;
const ll MOD = 1000000007LL;
// const ll MOD = 998244353LL;
const ld pi = 3.14159265358979;
const ld eps = 1e-10;
const ld dinf = 1e12;
inline bool dequal(const double &a, const double &b) {return fabs(a - b) < eps;}
inline int sgn(const ld &r) {return ((r > eps) - (r < -eps));}
inline int sgn(const ld &a, const ld &b) {return sgn(a - b);}
ld degtorad(ld deg) {return deg * pi / 180.0;}
ld radtodeg(ld rad) {return rad * 180 / pi;}
const vector<int> h_idx4 = {-1, 0,0,1};
const vector<int> w_idx4 = { 0,-1,1,0};
const vector<int> h_idx8 = {-1,-1,-1, 0,0, 1,1,1};
const vector<int> w_idx8 = {-1, 0, 1,-1,1,-1,0,1};

template<class T> void show_vec(T v) {for (int i = 0; i < v.size(); i++) cout << v[i] << endl;}
template<class T> void show_pair(T p) {cout << p.first << " " << p.second << endl;}
void YESNO(bool f) {cout << ((f) ? "YES" : "NO") << endl;}
void YesNo(bool f) {cout << ((f) ? "Yes" : "No") << endl;}
void yesno(bool f) {cout << ((f) ? "yes" : "no") << endl;}

template<class T> bool chmin(T &a, T b) {if (a > b){a = b; return 1;} return 0;}
template<class T> bool chmax(T &a, T b) {if (a < b){a = b; return 1;} return 0;}
template<class T> bool judge_digit(T bit,T i) {return (((bit & (1LL << i)) != 0) ? 1 : 0);}
template<class T> T ROUNDUP(T a, T b) {return ((a + b - 1) / b);}
template<class T> T tousa_sum1(T a, T l, T n) {return n * (a + l) / 2;}
template<class T> T tousa_sum2(T a, T d, T n) {return n * ((2 * a) + ((n - 1) * d)) / 2;}
template<class T> T tousa_sum3(T a, T l, T d) {assert(a <= l); return tousa_sum2(a,d,((l - a) / d) + 1);}
ll intpow(ll a, ll n) {ll res = 1; while (n > 0){if (n & 1){res *= a;} a = a * a; n >>= 1;} return res;}
ll modpow(ll a, ll n) {ll res = 1; while (n > 0){if (n & 1){res = res * a % MOD;} a = a * a % MOD; n >>= 1;} return res;}
ll eachmodpow(ll a, ll n,ll mod){
ll res = 1; while (n > 0){if (n & 1){res = res * a % mod;} a = a * a % mod; n >>= 1;} return res;
}

template<class T> T GCD(T a, T b) {if (b == 0) return a; return (GCD(b, a % b));}
template<class T> T LCM(T a, T b) {if (b == 0) return (0); return ((a / GCD(a, b)) * b);}
template<class T> T extGCD(T a, T b, T &x, T &y){ // ax + by = GCD(a,b)
if (b == 0){ x = 1; y = 0; return a;}
T d = extGCD(b, a % b, y, x); y -= ((a / b) * x); return d;
}
template<class T> T modinv(T a,T mod){ // only GCD(a,mod) = 1
T x,y; extGCD(a,mod,x,y); return ((x % mod) + mod) % mod;
}

template<class T> vector<int> sort_with_index(vector<T> &v){
vector<pair<T,int>> p(v.size()); vector<int> res(v.size());
for (int i = 0; i < v.size(); i++){ p[i].first = v[i]; p[i].second = i; }
sort(p.begin(), p.end());
for (int i = 0; i < v.size(); i++){ v[i] = p[i].first; res[i] = p[i].second;}
return res;
}

ll ceilsqrt(ll n,ll r = 2){ // nのr乗根を切り上げた整数
assert(n >= 0);
ll res = (ll)floor(pow((double)n, 1.0 / r)) - 1; while (res < 0 || intpow(res,r) < n) res++; return res;
}
ll floorsqrt(ll n,ll r = 2){ // nのr乗根を切り捨てた整数
assert(n >= 0); 
ll res = (ll)ceil(pow((double)n, 1.0 / r)) + 1; while (intpow(res,r) > n) res--; return res;
}

// min_it s.t. vec[it] >(=) key [0,n]
template<class T>
int higher_minindex(vector<T> &vec,T key,bool equal = false){
int ok = (int)vec.size(),ng = -1;
while (abs(ok - ng) > 1){
int mid = (ok + ng) / 2;
if (equal){(vec[mid] >= key) ? (ok = mid) : (ng = mid);}
else {(vec[mid] > key) ? (ok = mid) : (ng = mid);}
}
return ok;
}
// max_it s.t. vec[it] <(=) key [-1,n-1]
template<class T>
int lower_maxindex(vector<T> &vec,T key,bool equal = false){
int ok = -1,ng = (int)vec.size();
while (abs(ok - ng) > 1){
int mid = (ok + ng) / 2;
if (equal){(vec[mid] <= key) ? (ok = mid) : (ng = mid);}
else {(vec[mid] < key) ? (ok = mid) : (ng = mid);}
}
return ok;
}



int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(15);

int n;
cin >> n;
vector<ll> a(n);
for (int i = 0; i < n; i++){
cin >> a[i];
}
vector<ll> b(n);
for (int i = 0; i < n; i++){
if (i % 2 == 1) b[i] = a[i] * -1;
else b[i] = a[i];
}

vector<ll> s(n + 1,0);
for (int i = 0; i < n; i++){
s[i + 1] = s[i] + b[i];
}

map<ll,ll> mp;
for (int i = 0; i < n + 1; i++){
mp[s[i]]++;
}

ll cnt = 0;
for (int i = 0; i < n; i++){
mp[s[i + 1]]--;
cnt += mp[s[i + 1]];
}

cout << cnt << endl;
}
/**
*	author:	social_chameleon
*	created:	2022/01/19
*/

#pragma region MACROS

#pragma region HEADER
#pragma GCC optimize("O3")
#ifdef LOCAL
#include <debug_print.hpp>
#define debug(...) debug_print::multi_print(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...) (static_cast<void>(0))
#endif
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#pragma endregion
#pragma region TYPES
using ll = long long;
#define int ll
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pil = pair<int, ll>;
using pli = pair<ll, int>;
using ld = long double;
template <typename T>
using vc = vector<T>;
template <typename T>
using vvc = vector<vc<T>>;
template <typename T>
using vvvc = vector<vvc<T>>;
using vi = vc<int>;
using vl = vc<ll>;
using vb = vc<bool>;
using vpi = vc<pii>;
using vpl = vc<pll>;
template <class T>
using pq = priority_queue<T>;
template <class T>
using pqg = priority_queue<T, vector<T>, greater<T>>;
#pragma endregion
#pragma region UTILITY_FUNCTIONS
template <typename T>
int si(const T& x) { return x.size(); }
template <class T>
inline bool chmax(T& a, const T& b) { return (a < b ? a = b, 1 : 0); }
template <class T>
inline bool chmin(T& a, const T& b) { return (a > b ? a = b, 1 : 0); }
#define overload2(a, b, name, ...) name
#define overload4(a, b, c, d, name, ...) name
#define overload5(a, b, c, d, e, name, ...) name
#pragma endregion
#pragma region WORDS
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define ppb pop_back
#define ppf pop_front
#define eb emplace_back
#define ef emplace_front
#pragma endregion
#pragma region LOOPS
#define rep0(n) for (int _ = 0; _ < n; ++_)
#define rep1(i, n) for (ll i = 0; i < (n); ++i)
#define rep2(i, a, b) for (ll i = (a); i < (b); ++i)
#define rep3(i, a, b, c) for (ll i = (a); i < (b); i += (c))
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1, rep0)(__VA_ARGS__)
#define rrep0(n) for (int jidlsjf = 0; jidlsjf < n; ++jidlsjf)
#define rrep1(i, n) for (ll i = (n)-1; i >= 0; --i)
#define rrep2(i, a, b) for (ll i = (a)-1; i >= b; --i)
#define rrep3(i, a, b, c) for (ll i = (a)-1; i >= b; i -= c)
#define rrep(...) overload4(__VA_ARGS__, rrep3, rrep2, rrep1, rrep0)(__VA_ARGS__)
#define fore0(v) rep(a.size())
#define fore1(a, v) for (auto&& a : v)
#define fore2(a, b, v) for (auto&& [a, b] : v)
#define fore3(a, b, c, v) for (auto&& [a, b, c] : v)
#define fore4(a, b, c, d, v) for (auto&& [a, b, c, d] : v)
#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)
#pragma endregion
#pragma region CONTAINER_METHODS
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
template <typename T>
int closest(vector<T>& v, T x) {
int n = (int)v.size();
int pos = lower_bound(v.begin(), v.end(), x) - v.begin();
if (pos == 0) return pos;
if (pos == n) return n - 1;
return (v[pos] - x <= x - v[pos - 1]) ? pos : pos - 1;
}
#define all(c) begin(c), end(c)
#define rall(c) rbegin(c), rend(c)
#define SORT(v) sort(all(v))
#define REV(v) reverse(all(v))
#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())
template <typename T = ll, typename S>
T SUM(const S& v) { return accumulate(all(v), T(0)); }
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
template <typename T = int>
T mex(unordered_set<T> st) {
T ret = T(0);
while (st.count(ret) != 0) ++ret;
return ret;
}
#pragma endregion
#pragma region VECTOR_DEFINITIONS
#define vec(type, name, ...) vector<type> name(__VA_ARGS__)
#define vec2(type, name1, name2, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__)
#define vec3(type, name1, name2, name3, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__)
#define vec4(type, name1, name2, name3, name4, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__), name4(__VA_ARGS__)
#define vv(type, name, a, ...) vector<vector<type>> name(a, vector<type>(__VA_ARGS__))
#define vvv(type, name, a, b, ...) vector<vector<vector<type>>> name(a, vector<vector<type>>(b, vector<type>(__VA_ARGS__)))
#define vvvv(type, name, a, b, c, ...) vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))
constexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};
constexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
#pragma endregion
#pragma region TYPICAL_OUTPUT
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
const string firstsecond[2] = {"second", "first"};
const string FirstSecond[2] = {"Second", "First"};
const string possiblestr[2] = {"impossible", "possible"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
void first(bool t = 1) { cout << firstsecond[t] << endl; }
void First(bool t = 1) { cout << FirstSecond[t] << endl; }
void possible(bool t = 1) { cout << possiblestr[t] << endl; }
#pragma endregion
#pragma region INPUT
int scan() { return getchar(); }
void scan(signed& a) { cin >> a; }
void scan(long long& a) { cin >> a; }
void scan(char& a) { cin >> a; }
void scan(double& a) { cin >> a; }
void scan(string& a) { cin >> a; }
template <class T, class S>
void scan(pair<T, S>& p) { scan(p.first), scan(p.second); }
template <class T>
void scan(vector<T>& a) {
for (auto& i : a) scan(i);
}
template <class T>
void scan(T& a) { cin >> a; }
void IN() {}
template <class Head, class... Tail>
void IN(Head& head, Tail&... tail) {
scan(head);
IN(tail...);
}
#define INT(...)   \
int __VA_ARGS__; \
IN(__VA_ARGS__)
#define LL(...)   \
ll __VA_ARGS__; \
IN(__VA_ARGS__)
#define STR(...)      \
string __VA_ARGS__; \
IN(__VA_ARGS__)
#define CHR(...)    \
char __VA_ARGS__; \
IN(__VA_ARGS__)
#define DBL(...)      \
double __VA_ARGS__; \
IN(__VA_ARGS__)
#define VEC(type, name, size) \
vector<type> name(size);    \
IN(name)
#define VEC2(type, name1, name2, size)   \
vector<type> name1(size), name2(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i])
#define VEC3(type, name1, name2, name3, size)         \
vector<type> name1(size), name2(size), name3(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])
#define VEC4(type, name1, name2, name3, name4, size)               \
vector<type> name1(size), name2(size), name3(size), name4(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i])
#define VV(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
IN(name)
#pragma endregion
#pragma region MATH
static constexpr int inf = numeric_limits<int>::max() / 2;
static constexpr ll infll = numeric_limits<ll>::max() / 2;
static constexpr double infdbl = numeric_limits<double>::max() / 2;
template <typename T, typename S>
T ceil(T x, S y) {
assert(y);
return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S>
T floor(T x, S y) {
assert(y);
return (y < 0 ? floor(-x, -y)
: (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
template <class T>
ll POW(T x, int n) {
ll res = 1;
for (; n; n >>= 1, x *= x)
if (n & 1) res *= x;
return res;
}
template <class T, class S>
ll POW(T x, S n, const ll& mod) {
ll res = 1;
x %= mod;
for (; n; n >>= 1, x = x * x % mod)
if (n & 1) res = res * x % mod;
return res;
}
template <typename T>
map<T, int> factor(T n) {
map<T, int> ret;
for (T i = 2; i * i <= n; i++) {
while (n % i == 0) {
ret[i]++;
n /= i;
}
}
if (n != 1) ret[n] = 1;
return ret;
}
template <class T>
vector<T> divisor(T x) {
vector<T> ret;
for (T i = 1; i * i <= x; i++)
if (x % i == 0) {
ret.pb(i);
if (i * i != x) ret.pb(x / i);
}
return ret;
}
vector<int> cumsum(const vector<bool>& v) {
vector<int> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<T> cumsum(const vector<T>& v) {
vector<T> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<vector<T>> cumsum2d(const vector<vector<T>>& v) {
vector<vector<T>> ret = v;
for (int i = 0; i < (int)v.size(); ++i) {
for (int j = 0; j < (int)v[0].size(); ++j) {
if (i > 0) ret[i][j] += ret[i - 1][j];
if (j > 0) ret[i][j] += ret[i][j - 1];
if (i > 0 && j > 0) ret[i][j] -= ret[i - 1][j - 1];
}
}
return ret;
}
template <typename T>
T parsum2d(const vector<vector<T>>& cum, int i1, int i2, int j1, int j2) {
if (i1 > i2 || j1 > j2) return 0;
T ret = cum[i2][j2];
if (i1 > 0) ret -= cum[i1 - 1][j2];
if (j1 > 0) ret -= cum[i2][j1 - 1];
if (i1 > 0 && j1 > 0) ret += cum[i1 - 1][j1 - 1];
return ret;
}
template <typename T, typename S, typename U>
bool inc(const T& x, const S& l, const U& r) {
return l <= x and x < r;
}
constexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }
template <typename T>
T arith_sum_from_range(T first, T last, T diff = T(1)) {
assert((last - first) % diff == 0);
return ((last - first) / 2 + 1) * (first + last) / 2;
}
template <typename T, typename S>
T arith_sum_from_term(T first, S n, T diff = T(1)) {
return (2 * first + (n - 1) * diff) * n / 2;
}
#pragma endregion
#pragma region BIT_FUNCTIONS
ll pow2(int i) { return 1LL << i; }
#define bit(n, k) (((n) >> (k)) & 1)
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
constexpr ll mask(int n) { return (1LL << n) - 1; }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
template <typename T>
T inv_all_bit(T a) {
T ret = 0;
int n = topbit(a);
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_all_bit(T a, int n) {
T ret = 0;
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_bit(T a, int k) { return a ^ (1 << k); }
#pragma endregion
#pragma region PAIR_OPERATORS
template <class T, class S>
pair<T, S> operator-(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi - y.fi, x.se - y.se);
}
template <class T, class S>
pair<T, S> operator+(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi + y.fi, x.se + y.se);
}
template <class T>
pair<T, T> operator&(const pair<T, T>& l, const pair<T, T>& r) {
return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se));
}
template <class T, class S>
pair<T, S> operator+=(pair<T, S>& l, const pair<T, S>& r) {
return l = l + r;
}
template <class T, class S>
pair<T, S> operator-=(pair<T, S>& l, const pair<T, S>& r) {
return l = l - r;
}
template <class T>
bool intersect(const pair<T, T>& l, const pair<T, T>& r) {
return (l.se < r.se ? r.fi < l.se : l.fi < r.se);
}
#pragma endregion
#pragma region SEARCH
template <class F>
void bit_search(int n, const F& f) {
for (int i = 0; i < (1 << n); ++i) {
set<int> st;
for (int j = 0; j < n; ++j) {
if ((i >> j & 1) == 1) {
st.insert(j);
}
}
f(st);
}
}
template <class T, class F>
T bin_search(T ok, T ng, const F& f) {
while (abs(ok - ng) > 1) {
T mid = ok + ng >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search_double(T ok, T ng, const F& f, int iter = 80) {
while (iter--) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
#pragma endregion
#pragma region STRING
void ERASE(string& s, char c) { s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const string& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const vector<char>& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
template <typename T>
void ERASE(vector<T>& v, T x) { v.erase(remove(all(v), x), v.end()); }
template <typename T>
void ERASE(vector<T>& v, const vector<T>& list) { fore(x, list) v.erase(remove(all(v), x), v.end()); }
#pragma endregion
#pragma region OUTPUT
template <typename T, typename S>
ostream& operator<<(ostream& os, const pair<T, S>& p) {
os << p.first << " " << p.second;
return os;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < (int)v.size(); i++) {
os << v[i] << (((i + 1) != v.size()) ? " " : "");
}
return os;
}
void OUT() { cout << endl; }
template <class Head, class... Tail>
void OUT(const Head& head, const Tail&... tail) {
cout << head;
if (sizeof...(tail)) cout << ' ';
OUT(tail...);
}
template <typename T>
string pad(T n, int d, char c) {
ostringstream sout;
sout << setfill(c) << setw(d) << n;
return sout.str();
}
#pragma endregion
#pragma region GRAPH
template <typename T = int>
struct Edge {
int from, to;
T cost;
int id;

Edge() = default;
Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}

operator int() const {
return to;
}
};

template <typename T = int>
struct Graph {
vector<vector<Edge<T>>> g;
int edge_id;

Graph() = default;
explicit Graph(int n) : g(n), edge_id(0) {}

size_t size() const {
return g.size();
}

void add_directed_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id++);
}

void add_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id);
g[to].emplace_back(to, from, cost, edge_id++);
}

void read(int m, int padding = -1, bool weighted = false, bool directed = false) {
for (int i = 0; i < m; ++i) {
int a, b;
cin >> a >> b;
a += padding;
b += padding;
T c = T(1);
if (weighted) {
cin >> c;
}
if (directed) {
add_directed_edge(a, b, c);
} else {
add_edge(a, b, c);
}
}
}

inline vector<Edge<T>>& operator[](const int& k) {
return g[k];
}

inline const vector<Edge<T>>& operator[](const int& k) const {
return g[k];
}
};
#pragma endregion
#pragma region PARSE
inline int toi(char c) { return c - '0'; }
int toi(string s) { return stoi(s); }
ll toll(string s) { return stoll(s); }
template <typename T>
string tos(T x) {
return to_string(x);
}
inline char toc(int i) { return '0' + i; }
template <typename T>
string tobit(T x, size_t d) {
if (d <= 2)
return bitset<2>(x).to_string();
else if (d <= 4)
return bitset<4>(x).to_string();
else if (d <= 8)
return bitset<8>(x).to_string();
else if (d <= 16)
return bitset<16>(x).to_string();
else if (d <= 32)
return bitset<32>(x).to_string();
else
return bitset<64>(x).to_string();
}
#pragma endregion

#pragma endregion
constexpr signed MOD = 1e9 + 7;
// constexpr signed MOD = 998244353;
#pragma region MOD
template <signed mod>
struct ModInt {
signed x;

ModInt() : x(0) {}

ModInt(long long y) : x((y >= 0) ? (y % mod) : (mod - ((-y) % mod)) % mod) {}

ModInt& operator++() {
++x;
if (x == mod) {
x = 0;
}
return *this;
}

ModInt& operator--() {
if (x == 0) {
x = mod;
}
--x;
return *this;
}

ModInt operator++(signed) {
ModInt ret = *this;
++*this;
return ret;
}

ModInt operator--(signed) {
ModInt ret = *this;
--*this;
return ret;
}

ModInt& operator+=(const ModInt& p) {
if ((x += p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator-=(const ModInt& p) {
if ((x += mod - p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator*=(const ModInt& p) {
x = (int)(1LL * x * p.x % mod);
return *this;
}

ModInt& operator/=(const ModInt& p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt& p) const { return x == p.x; }

bool operator!=(const ModInt& p) const { return x != p.x; }

/**
*  拡張ユークリッドの互除法を用いた逆元計算
*  - time: O(logx)
*/
ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while (b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(long long n) const {
ModInt ret(1), mul(x);
while (n > 0) {
if (n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream& operator<<(ostream& os, const ModInt& p) { return os << p.x; }

friend istream& operator>>(istream& is, ModInt& a) {
long long t;
is >> t;
a = ModInt<mod>(t);
return (is);
}

static signed get_mod() { return mod; }
};

using mint = ModInt<MOD>;
using vmi = vc<mint>;
#pragma endregion

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(9);
cerr << fixed << setprecision(9);

INT(n);
VEC(int, a, n);
VEC(int, b, n);
vi ans;
rep(i, n) {
int x = a[0] ^ b[i];
map<int, int> mp;
rep(j, n) {
if (j == i) continue;
++mp[b[j]];
}
bool valid = true;
rep(j, 1, n) {
if (!mp[a[j] ^ x]) {
valid = false;
break;
;
}
--mp[a[j] ^ x];
}
if (valid) ans.pb(x);
}
UNIQUE(ans);
SORT(ans);
OUT(si(ans));
if (si(ans)) fore(a, ans) OUT(a);

return 0;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 998244353;//1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m;
cin >> n >> m;
vector<string> a(n);
for(int i = 0; i < n; i++)
cin >> a[i];
vector<vector<bool>> can(n, vector<bool>(m + 1, 0));
for(int i = n - 1; i >= 0; i--)
{
if(i == n - 1)
{
can[i][m] = 1;
continue;
}
for(int j = 0; j <= m; j++)
{
if(can[i + 1][j] || (j + (int)a[i + 1].length() <= m && can[i + 1][j + a[i + 1].length()]))
can[i][j] = 1;
}
}
string s = "", t = "", ans = "";
VI Z, mat;
vector<pii> stk;
vector<bool> ed(m + 1, 0);
ed[0] = 1;
for(int i = 0; i < n; i++)
{
t = a[i];
stk.clear();
int ls, lt;
ls = s.length();
lt = t.length();
Z.resize(lt);
mat.resize(ls);
int lp, rp;
lp = rp = -1;
for(int j = 1; j < lt; j++)
{
if(j <= rp && j + Z[j - lp] - 1 < rp)
Z[j] = Z[j - lp];
else
{
int k = max(rp - j + 1, 0);
while(j + k < lt && t[k] == t[j + k])
++k;
Z[j] = k;
}
if(j + Z[j] - 1 > rp)
lp = j, rp = j + Z[j] - 1;
}
lp = rp = -1;
for(int j = 0; j < ls; j++)
{
if(j <= rp && j + Z[j - lp] - 1 < rp)
mat[j] = Z[j - lp];
else
{
int k = max(0, rp - j + 1);
while(k < lt && j + k < ls && t[k] == s[j + k])
++k;
mat[j] = k;
}
if(j + mat[j] - 1 > rp)
lp = j, rp = j + mat[j] - 1;
}
auto small = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return (bool)0;
return t[len] < s[x + len];
};
auto big = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return (bool)0;
return t[len] > s[x + len];
};
auto same = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return 1;
return 0;
};
auto cmp = [&](pii x, pii y)
{
if(y.sc == 0)
{
if(x.sc == 0 || x.fi >= y.fi)
return 0;
int len = mat[x.fi];
if(x.fi + len >= y.fi)
return 0;
if(small(x.fi))
return -1;
return 1;
}
if(x.sc == 0)
{
if(big(y.fi))
return -1;
if(same(y.fi))
return 0;
return 1;
}
int len = mat[y.fi];
if(y.fi + len > x.fi)
{
int ex = y.fi + len - x.fi;
int le = Z[lt - ex];
if(le == ex)
return 0;
if(t[le] < t[lt - ex + le])
return -1;
return 1;
}
else
{
if(big(y.fi))
return -1;
if(same(y.fi))
return 0;
return 1;
}
};
for(int j = 1; j <= m; j++)
{
if(!can[i][j])
continue;
if(ed[j] || (j - lt >= 0 && ed[j - lt]))
{
int op = -1;
if(ed[j] && j - lt >= 0 && ed[j - lt])
{
if(small(j - lt))
op = 1;
else op = 0;
}
else
{
if(ed[j])
op = 0;
else op = 1;
}
pii cur = pii(j - op * lt, op);
while(!stk.empty() && cmp(cur, stk.back()) < 0)
stk.pop_back();
if(stk.empty() || cmp(cur, stk.back()) == 0)
stk.pb(cur); 
}
}
fill(all(ed), 0);
ed[0] = 1;
if(!stk.empty())
{
pii cur = stk.back();
s = s.substr(0, cur.fi);
if(cur.sc == 1)
s += t;
if(s.length() == m)
ans = s;
trav(v, stk)
{
int len = v.fi + v.sc * lt;
ed[len] = 1;
}
}
else
s = "";
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 998244353;//1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m;
cin >> n >> m;
vector<string> a(n);
for(int i = 0; i < n; i++)
cin >> a[i];
vector<vector<bool>> can(n, vector<bool>(m + 1, 0));
for(int i = n - 1; i >= 0; i--)
{
if(i == n - 1)
{
can[i][m] = 1;
continue;
}
for(int j = 0; j <= m; j++)
{
if(can[i + 1][j] || (j + (int)a[i + 1].length() <= m && can[i + 1][j + a[i + 1].length()]))
can[i][j] = 1;
}
}
string s = "", t = "", ans = "";
VI Z, mat;
vector<pii> stk;
vector<bool> ed(m + 1, 0);
ed[0] = 1;
for(int i = 0; i < n; i++)
{
//		cerr << i << ' ' << s << '\n';
//		for(int j = 0; j <= m;j++)
//			if(ed[j])cerr << j << ' ';
//		cerr << '\n';
t = a[i];
stk.clear();
int ls, lt;
ls = s.length();
lt = t.length();
Z.resize(lt);
mat.resize(ls);
int lp, rp;
lp = rp = -1;
for(int j = 1; j < lt; j++)
{
if(rp < j)
{
int k = 0;
while(j + k < lt && t[k] == t[j + k])
++k;
Z[j] = k;
}
else
{
if(j + Z[j - lp] - 1 < rp)
Z[j] = Z[j - lp];
else
{
int k = rp - j + 1;
while(j + k < lt && t[k] == t[j + k])
++k;
Z[j] = k;
}
}
if(j + Z[j] - 1 > rp)
lp = j, rp = j + Z[j] - 1;
}
lp = rp = -1;
for(int j = 0; j < ls; j++)
{
if(rp < j)
{
int k = 0;
while(k < lt && j + k < ls && t[k] == s[j + k])
++k;
mat[j] = k;
}
else
{
if(j + Z[j - lp] - 1 < rp)
mat[j] = Z[j - lp];
else
{
int k = rp - j + 1;
while(k < lt && j + k < ls && t[k] == s[j + k])
++k;
mat[j] = k;
}
}
if(j + mat[j] - 1 > rp)
lp = j, rp = j + mat[j] - 1;
}
auto small = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return (bool)0;
return t[len] < s[x + len];
};
auto big = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return (bool)0;
return t[len] > s[x + len];
};
auto same = [&](int x)
{
int len = mat[x];
if(len == lt || x + len == ls)
return 1;
return 0;
};
auto cmp = [&](pii x, pii y)
{
if(y.sc == 0)
{
if(x.sc == 0 || x.fi >= y.fi)
return 0;
int len = mat[x.fi];
if(x.fi + len >= y.fi)
return 0;
if(small(x.fi))
return -1;
return 1;
}
if(x.sc == 0)
{
if(big(y.fi))
return -1;
if(same(y.fi))
return 0;
return 1;
}
int len = mat[y.fi];
//	cerr << "pp" << len << '\n';
if(y.fi + len > x.fi)
{
int ex = y.fi + len - x.fi;
int le = Z[lt - ex];
if(le == ex)
return 0;
if(t[le] < t[lt - ex + le])
return -1;
return 1;
}
else
{
if(big(y.fi))
return -1;
if(same(y.fi))
return 0;
return 1;
}
};
for(int j = 1; j <= m; j++)
{
if(!can[i][j])
continue;
//	cerr << "??" << j << '\n';
if(ed[j] || (j - lt >= 0 && ed[j - lt]))
{
int op = -1;
if(ed[j] && j - lt >= 0 && ed[j - lt])
{
if(small(j - lt))
op = 1;
else op = 0;
}
else
{
if(ed[j])
op = 0;
else op = 1;
}
//		cerr << "!!" << j << ' ' << j - op * lt << ' ' << op << '\n';
pii cur = pii(j - op * lt, op);
while(!stk.empty() && cmp(cur, stk.back()) < 0)
stk.pop_back();
if(stk.empty() || cmp(cur, stk.back()) == 0)
stk.pb(cur); 
}
}
fill(all(ed), 0);
ed[0] = 1;
if(!stk.empty())
{
pii cur = stk.back();
s = s.substr(0, cur.fi);
if(cur.sc == 1)
s += t;
if(s.length() == m)
ans = s;
trav(v, stk)
{
int len = v.fi + v.sc * lt;
ed[len] = 1;
}
}
else
{
s = "";
}
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}
/*
4 5
zzzzz
zz
aaa
zz
*/
// made by https://github.com/094-gengar/add_lib_to_templ

#line 2 "cpplib/_other/bit.cpp"
#define LL long long

#define bitfor(bit, n) for (LL bit = 0; bit < (1 << n); bit++)
#define bitif(bit, a) if (bit & (1 << a))
LL bitsum(LL bit)
{
LL r = 0;
for(LL i = 1; i <= bit; i <<= 1)
if(i & bit)
r++;
return r;
}

#line 2 "cpplib/_other/caesar.hpp"
#include <iostream>

struct caesar
{
char c = 'a';
int to_i() { return (caesar::c - 'a'); }
int absolute(caesar& d) { return (d.c - caesar::c + 26) % 26; }
friend std::istream& operator>>(std::istream& is, caesar& c) { is >> c.c; return is; }
friend std::ostream& operator<<(std::ostream& os, caesar& c) { return os << c.c; }
};

struct Caesar
{
char c = 'A';
int to_i() { return (Caesar::c - 'A'); }
int absolute(Caesar& d) { return (d.c - Caesar::c + 26) % 26; }
friend std::istream& operator>>(std::istream& is, Caesar& c) { is >> c.c; return is; }
friend std::ostream& operator<<(std::ostream& os, Caesar& c) { return os << c.c; }
};


#line 2 "cpplib/_other/template.hpp"
#include <cstdlib>
#include <cmath>
#include <climits>
#include <cfloat>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <deque>
#include <complex>
#include <stack>
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <ctime>
#include <iterator>
#include <bitset>
#include <numeric>
#include <list>
#include <iomanip>
#include <cassert>
#include <array>
#include <tuple>
#include <initializer_list>
#include <unordered_set>
#include <unordered_map>
#include <forward_list>
#include <random>
//#define INCLUDE_BOOST
#ifdef INCLUDE_BOOST
#if __has_include(<boost/range/irange.hpp>)
#include <boost/range/irange.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/classification.hpp>
#endif

#endif
#pragma GCC target("avx512f")
#pragma GCC optimize("O3")
//#define int long long
#define LL long long
#define UL unsigned long long
#define itn int
#define INT(...)     \
int __VA_ARGS__; \
in(__VA_ARGS__)
#define LLL(...)    \
LL __VA_ARGS__; \
in(__VA_ARGS__)
#define I32(...)     \
i32 __VA_ARGS__; \
in(__VA_ARGS__)
#define I64(...)     \
i64 __VA_ARGS__; \
in(__VA_ARGS__)
#define U32(...)     \
u32 __VA_ARGS__; \
in(__VA_ARGS__)
#define U64(...)     \
u64 __VA_ARGS__; \
in(__VA_ARGS__)
#define STR(...)        \
string __VA_ARGS__; \
in(__VA_ARGS__)
#define CHR(...)      \
char __VA_ARGS__; \
in(__VA_ARGS__)
#define DBL(...)        \
double __VA_ARGS__; \
in(__VA_ARGS__)
#define all(x) (x).begin(), (x).end()
#define Sort(x) sort(all(x))
#define rSort(x)  \
sort(all(x)); \
reverse(all(x))
#define UNIQUE(v) v.erase(unique(all(v)), v.end())
#define uniq(v)   \
sort(all(v)); \
UNIQUE(v)
#define l_b(c, x) distance(c.begin(), lower_bound(all(c), (x)))
#define u_b(c, x) distance(c.begin(), upper_bound(all(c), (x)))
#define fi first
#define se second
#define mkpr make_pair
#define pb push_back
#define eb emplace_back
#define pass
#define aauto auto &&
#define cauto const auto &
#define _overload3(_1, _2, _3, name, ...) name
#define _rep(i, n) repi(i, 0, n)
#define repi(i, a, b) for (usize i = (a), __B_SIZE__ = (b); i < __B_SIZE__; i++)
#define _per(i, n) peri(i, n, 0)
#define peri(i, a, b) for (int i = (a), __B_SIZE__ = (b); i >= __B_SIZE__; i--)
#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)
#define per(...) _overload3(__VA_ARGS__, peri, _per, )(__VA_ARGS__)
#define bitshift(n) (1LL << (n))
#define myceil(a, b) ((a) + ((b)-1)) / (b)

using i32 = std::int32_t;
using i64 = std::int64_t;
using u32 = std::uint32_t;
using u64 = std::uint64_t;
using isize = std::ptrdiff_t;
using usize = std::size_t;
using vi = std::vector<int>;
using vvi = std::vector<vi>;
using vLL = std::vector<LL>;
using vvLL = std::vector<vLL>;
using vb = std::vector<bool>;
using vvb = std::vector<vb>;
using vd = std::vector<double>;
using vvd = std::vector<vd>;
using vc = std::vector<char>;
using vvc = std::vector<vc>;
using vs = std::vector<std::string>;
using P = std::pair<int, int>;
using vp = std::vector<P>;
using pi32 = std::pair<i32, i32>;
using pLL = std::pair<LL, LL>;
using vpi32 = std::vector<pi32>;
using vpLL = std::vector<pLL>;

template <class T>
inline bool chmin(T& a, const T& b)
{
if(b < a)
{
a = b;
return true;
}
return false;
}
template <class T>
inline bool chmax(T& a, const T& b)
{
if(a < b)
{
a = b;
return true;
}
return false;
}
int Scan() { return getchar(); }
void Scan(signed& a) { scanf("%d", &a); }
void Scan(unsigned& a) { scanf("%u", &a); }
void Scan(long& a) { scanf("%ld", &a); }
void Scan(long long& a) { scanf("%lld", &a); }
void Scan(unsigned long long& a) { scanf("%llu", &a); }
void Scan(char& a)
{
do
{
a = getchar();
} while(a == ' ' || a == '\n');
}
void Scan(float& a) { scanf("%f", &a); }
void Scan(double& a) { scanf("%lf", &a); }
void Scan(long double& a) { scanf("%Lf", &a); }
void Scan(std::string& a) { std::cin >> a; }
template <class T>
void Scan(std::vector<T>&);
template <class T, class U>
void Scan(std::pair<T, U>&);
template <class T>
void Scan(std::vector<T>& a)
{
for(auto&& i : a)
Scan(i);
}
template <class T, class U>
void Scan(std::pair<T, U>& a)
{
Scan(a.first);
Scan(a.second);
}
template <class T>
void Scan(T& a) { std::cin >> a; }
void in() {}
template <class Car, class... Cdr>
void in(Car&& car, Cdr &&...cdr)
{
Scan(car);
in(std::forward<Cdr>(cdr)...);
}

void Print() { putchar(' '); }
void Print(signed a) { printf("%d", a); }
void Print(bool a) { printf("%d", a); }
void Print(unsigned a) { printf("%u", a); }
void Print(long a) { printf("%ld", a); }
void Print(long long a) { printf("%lld", a); }
void Print(unsigned long long a) { printf("%llu", a); }
void Print(char a) { printf("%c", a); }
void Print(float a) { printf("%f", a); }
void Print(double a) { printf("%lf", a); }
void Print(long double a) { printf("%Lf", a); }
void Print(const std::string& a)
{
for(auto&& i : a)
Print(i);
}
template <class T>
void Print(const std::vector<T>&);
template <class T, class U>
void Print(const std::pair<T, U>&);
template <class T>
void Print(const std::vector<T>& a)
{
if(a.empty())
return;
Print(a[0]);
for(auto i = a.begin(); ++i != a.end();)
{
putchar(' ');
Print(*i);
}
}
template <class T, class U>
void Print(const std::pair<T, U>& a)
{
Print(a.first);
putchar(' ');
Print(a.second);
}
template <class T>
void Print(const T& a) { std::cout << a; }
void out() { putchar('\n'); }
template <class T>
void out(const T& t)
{
Print(t);
putchar('\n');
}
template <class Car, class... Cdr>
void out(Car& car, Cdr &...cdr)
{
Print(car);
putchar(' ');
out(std::forward<Cdr>(cdr)...);
}

void println() { printf("\n"); }
void println(signed x) { printf("%d\n", x); }
void println(bool x) { printf("%d\n", x); }
void println(unsigned x) { printf("%u\n", x); }
void println(long x) { printf("%ld\n", x); }
void println(long long x) { printf("%lld\n", x); }
void println(unsigned long long x) { printf("%llu\n", x); }
void println(char x) { printf("%c\n", x); }
void println(float x) { printf("%.15f\n", x); }
void println(double x) { printf("%.15lf\n", x); }
template <class T>
void println(T x) { std::cout << x << '\n'; }

#define writeln(x) println(x)

void yn(bool fl = true)
{
out(fl ? "Yes" : "No");
}
template <class T>
void drop(T x)
{
std::cout << (x) << std::endl;
exit(0);
}
void dYes()
{
std::flush(std::cout);
puts("Yes");
fflush(stdout);
exit(0);
}
void dNo()
{
std::flush(std::cout);
puts("No");
fflush(stdout);
exit(0);
}
LL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }
LL lcm(LL a, LL b) { return a / gcd(a, b) * b; }
LL fact(LL n, LL m)
{
LL f = n;
for(LL i = n - 1; i >= 1; i--)
{
f *= i;
f %= m;
}
return f;
}
constexpr LL inf = 0x1fffffffffffffff;
constexpr LL mod = 1000000007LL;
constexpr LL mod2 = 998244353LL;
constexpr double eps = 1e-8;
constexpr double pi = 3.141592653589793238462643383279;


#line 2 "cpplib/Graph/LCA.cpp"
#include <vector>
struct LCA
{
std::vector<std::vector<int>> par;
std::vector<int> dis;
LCA(const std::vector<std::vector<int>>& g, int root = 0) { init(g, root); }
void init(const std::vector<std::vector<int>>& g, int root = 0)
{
int v = g.size(), k = 1;
for(; 1 << k < v; k++)
;
par.assign(k, std::vector<int>(v, -1));
dis.assign(v, -1);
dfs(g, root, -1, 0);
for(int i = 0; i < k - 1; i++)
for(int j = 0; j < v; j++)
{
if(par[i][j] < 0)
par[i + 1][j] = -1;
else
par[i + 1][j] = par[i][par[i][j]];
}
}
void dfs(const std::vector<std::vector<int>>& g, int v, int p, int d)
{
par[0][v] = p;
dis[v] = d;
for(int e : g[v])
if(e != p)
dfs(g, e, v, d + 1);
}
int run(int u, int v)
{
if(dis[u] < dis[v])
std::swap(u, v);
int k = par.size();
for(int i = 0; i < k; i++)
if(dis[u] - dis[v] >> i & 1)
u = par[i][u];
if(u == v)
return u;
for(int i = k - 1; i >= 0; i--)
if(par[i][u] != par[i][v])
{
u = par[i][u];
v = par[i][v];
}
return par[0][u];
}
int getdis(int u, int v) { return dis[u] + dis[v] - dis[run(u, v)] * 2; }
bool isonpath(int u, int v, int a) { return getdis(u, a) + getdis(a, v) == getdis(u, v); }
};


#line 2 "cpplib/Graph/oreore_graph.hpp"
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
/*
template <class T>
inline bool chmin(T& a, const T& b)
{
if(b < a)
{
a = b;
return true;
}
return false;
}
*/
template <class T>
struct oreore_graph
{
int _n;
bool _idx;
bool _drc;
std::vector<std::vector<T>> _g;
oreore_graph(int n, bool drc = false, bool idx = 1)
: _n(n), _drc(drc), _idx(idx), _g(n)
{
}
void init(int m)
{
T a, b;
for(int i = 0; i < m; i++)
{
scanf("%d %d", &a, &b);
a -= _idx;
b -= _idx;
_g[a].emplace_back(b);
if(!_drc)
_g[b].emplace_back(a);
}
}
std::vector<T> bfs(T s, T t = -1)
{
std::vector<T> dis(_n, 1ll << 29);
std::vector<bool> vis(_n, false);
dis[s] = 0;
std::queue<T> q;
q.emplace(s);
while(q.size())
{
T cur = q.front();
q.pop();
for(auto e : _g[cur])
if(chmin(dis[e], dis[cur] + 1))
q.emplace(e);
}
if(t == -1)
return dis;
else
return std::vector<T>{dis[t]};
}
};

template <class T>
struct oreore_weighted_graph
{
using ptt = std::pair<T, T>;
int _n;
bool _idx;
bool _drc;
std::vector<std::vector<ptt>> _g;
oreore_weighted_graph(int n, bool drc = false, bool idx = 1)
: _n(n), _drc(drc), _idx(idx), _g(n)
{
}
void init(int m, bool cst = true)
{
T a, b, c = 1;
for(int i = 0; i < m; i++)
{
if(cst)
scanf("%d %d %d", &a, &b, &c);
else
scanf("%d %d", &a, &b);
a -= _idx;
b -= _idx;
_g[a].emplace_back(c, b);
if(!_drc)
_g[b].emplace_back(c, a);
}
}
std::vector<T> bfs(T s, T t = -1)
{
std::vector<T> dis(_n, 1ll << 29);
std::vector<bool> vis(_n, false);
dis[s] = 0;
std::queue<ptt> q;
q.emplace(0, s);
while(q.size())
{
ptt cur = q.front();
q.pop();
if(cur.first > dis[cur.second])
continue;

for(auto e : _g[cur.second])
if(chmin(dis[e.second], dis[cur.second] + e.first))
q.emplace(dis[e.second], e.second);
}
if(t == -1)
return dis;
else
return std::vector<T>{dis[t]};
}

std::vector<T> dijkstra(T s, T t = -1)
{
std::vector<T> dis(_n, 1ll << 29);
std::vector<bool> vis(_n, false);
dis[s] = 0;
std::priority_queue<ptt, std::vector<ptt>, std::greater<>> pq;
pq.emplace(0, s);
while(pq.size())
{
ptt cur = pq.top();
pq.pop();
if(cur.first > dis[cur.second])
continue;
for(auto e : _g[cur.second])
if(chmin(dis[e.second], dis[cur.second] + e.first))
pq.emplace(dis[e.second], e.second);
}
if(t == -1)
return dis;
else
return std::vector<T>{dis[t]};
}
};


#line 2 "cpplib/math/argsort.hpp"
#include <vector>
#include <algorithm>

struct Ray
{
long long x, y;
bool operator<(const Ray& r) const { return x * r.y > y * r.x; }
bool operator<=(const Ray& r) const { return x * r.y >= y * r.x; }
};

std::vector<std::pair<Ray, Ray>> argSort(std::vector<std::pair<long long, long long>> xy)
{
std::vector<std::pair<Ray, Ray>> p;
for(auto [x, y] : xy)
p.push_back(std::make_pair(Ray{x - 1, y}, Ray{x, y - 1}));
std::sort(p.begin(), p.end());
return p;
}


#line 2 "cpplib/math/comb.hpp"
#include <vector>

template <class T>
struct COMB
{
long long n;
std::vector<T> fa, ifa;
COMB(long long n_) : n(n_)
{
fa.resize(n + 1);
ifa.resize(n + 1);
fa[0] = 1;
for(long long i = 1; i <= n; i++)
fa[i] = fa[i - 1] * i;
ifa[n] = (T)(1) / fa[n];
for(long long i = n - 1; i >= 0; i--)
ifa[i] = ifa[i + 1] * (i + 1);
}
T comb(long long n, long long r)
{
return n < 0 || r < 0 || n < r ? (T)(0) : fa[n] * ifa[r] * ifa[n - r];
}
};

#line 2 "cpplib/math/ksb.hpp"
#include <vector>
#include <map>

std::map<long long, long long> ksb(std::vector<long long> ns)
{
std::map<long long, long long> m;
for(auto n : ns)
{
for(long long i = 2; i * i <= n; i++)
{
long long tmp = 0;
while(n % i == 0)
{
tmp++;
n /= i;
}
if(0 != tmp)
m[i]++;
if(n == 1)
break;
}
if(1 != n)
m[n]++;
}
return m;
}

#line 2 "cpplib/math/modint.hpp"
template <long long Mod>
struct modInt
{
long long x;
constexpr modInt() noexcept : x() {}
template <class T>
constexpr modInt(T v = 0) noexcept : x(v% Mod)
{
if(x < 0)
x += Mod;
}
constexpr long long getval() const noexcept { return x; }
constexpr modInt operator-() const noexcept { return x ? Mod - x : 0; }
constexpr modInt operator+(const modInt& r) const noexcept { return modInt(*this) += r; }
constexpr modInt operator-(const modInt& r) const noexcept { return modInt(*this) -= r; }
constexpr modInt operator*(const modInt& r) const noexcept { return modInt(*this) *= r; }
constexpr modInt operator/(const modInt& r) const noexcept { return modInt(*this) /= r; }
constexpr modInt& operator+=(const modInt& r) noexcept
{
x += r.x;
if(x >= Mod)
x -= Mod;
return *this;
}
constexpr modInt& operator-=(const modInt& r) noexcept
{
x -= r.x;
if(x < 0)
x += Mod;
return *this;
}
constexpr modInt& operator*=(const modInt& r) noexcept
{
x = x * r.x % Mod;
return *this;
}
constexpr modInt& operator/=(const modInt& r) noexcept
{
x = x * r.inv().getval() % Mod;
return *this;
}
constexpr modInt powm(long long n) noexcept
{
if(n < 0)
return powm(-n).inv();
modInt x = *this, r = 1;
for(; n; x *= x, n >>= 1)
if(n & 1)
r *= x;
return r;
}
constexpr modInt inv() const noexcept
{
long long a = x, b = Mod, u = 1, v = 0;
while(b)
{
long long t = a / b;
a -= t * b;
std::swap(a, b);
u -= t * v;
std::swap(u, v);
}
return modInt(u);
}
constexpr modInt comb(long long a) noexcept
{
modInt n = *this, s = 1;
for(int i = 0; i < a; i++)
s *= (n - modInt(i));
modInt m = 1;
for(int i = 1; i <= a; i++)
m *= modInt(i);
return s * m.powm(Mod - 2); //Fermat's little thm
}
constexpr bool operator==(const modInt& r) { return this->x == r.x; }
constexpr bool operator!=(const modInt& r) { return this->x != r.x; }
friend std::ostream& operator<<(std::ostream& os, const modInt<Mod>& a) { return os << a.x; }
friend std::istream& operator>>(std::istream& is, modInt<Mod>& a)
{
long long v;
is >> v;
a = modInt<Mod>(v);
return is;
}
};

//const long long mod=1000000007;
//using mint=modInt<mod>;
using mint = modInt<1000000007>;
using mint2 = modInt<998244353>;

#line 2 "cpplib/math/modinv.hpp"
long long modpow(long long a, long long b, long long mod)
{
a %= mod;
long long r = 1;
while(b)
{
r = r * ((b % 2) ? a : 1) % mod;
a = a * a % mod;
b >>= 1;
}
return r;
}

long long modinv(long long a, long long mod)
{
return modpow(a, mod - 2, mod);
}


#line 2 "cpplib/math/primefact.hpp"
#include <vector>

template <class T>
std::vector<std::pair<T, T>> prime_factor(T n)
{
std::vector<std::pair<T, T>> ret;
for(T i = 2; i * i <= n; i++)
{
if(n % i != 0)
continue;
T tmp = 0;
while(n % i == 0)
{
tmp++;
n /= i;
}
ret.push_back(make_pair(i, tmp));
}
if(n != 1)
ret.push_back(make_pair(n, 1));
return ret;
}


#line 2 "cpplib/Structure/binaryheap.hpp"

#include <vector>
//bheap
struct bheap
{
std::vector<long> _a;
bheap() { _a.push_back(0L); }
void push(long _x)
{
_a.push_back(_x);
long pos = _a.size() - 1;
for(; pos > 1 && _a[pos] < _a[pos / 2]; std::swap(_a[pos], _a[pos / 2]), pos /= 2)
;
}
void pop()
{
_a[1] = _a[_a.size() - 1];
_a.pop_back();
if(_a.size() == 1)
return;
long pos = 1, lc, rc;
for(; (lc = pos * 2) < _a.size();)
{
rc = lc + 1;
if(lc == _a.size() - 1)
{
if(_a[pos] > _a[lc])
{
std::swap(_a[pos], _a[lc]);
pos = lc;
}
else
{
break;
}
}
else
{
if(_a[lc] < _a[rc])
{
if(_a[lc] < _a[pos])
{
std::swap(_a[pos], _a[lc]);
pos = lc;
}
else
{
break;
}
}
else
{
if(_a[rc] < _a[pos])
{
std::swap(_a[pos], _a[rc]);
pos = rc;
}
else
{
break;
}
}
}
}
}
long getmin() { return _a[1]; }
long siz() { return _a.size() - 1; }
void cl()
{
_a.clear();
_a.push_back(0L);
}
};


#line 2 "cpplib/Structure/BinaryIndexedTree.hpp"
#include <vector>
//BinaryIndexedTree(1-indexed)
template <class T>
struct BIT
{
int n;
std::vector<T> B_I_T;
BIT(int n_ = 0, T init = 0) : n(n_), B_I_T(n_ + 1, init) {}
T sum(int i)
{
T ans = 0;
for(; i > 0; i -= i & -i)
ans += B_I_T[i];
return ans;
}
void add(int i, T a)
{
if(!i)
return;
for(; i <= n; i += i & -i)
B_I_T[i] += a;
}
int l_b_B_I_T(T k)
{
if(k <= 0)
return 0;
int ret = 0, i = 1;
for(; (i << 1) <= n; i <<= 1)
;
for(; i; i >>= 1)
if(ret + i <= n && B_I_T[ret + i] < k)
k -= B_I_T[ret += i];
return (ret + 1);
}
};

#line 2 "cpplib/Structure/compress_vector.hpp"
template <class T>
struct compress_vector
{
int n;
std::vector<T> a;
compress_vector(int n_) : n(n_), a(n_) {};
void compress()
{
std::map<T, T> mp;
for(int i = 0; i < n; i++)
mp[a[i]] = -1;
int c = 0;
for(auto& p : mp)
p.second = c++;
for(int i = 0; i < n; i++)
a[i] = mp[a[i]];
}
};

#line 2 "cpplib/Structure/dynamic_connectivity.hpp"
#include <iostream>
#include <vector>
#include <functional>
#include <unordered_set>
#include <unordered_map>

#define LL long long

template<class T>
class dynamic_connectivity
{
class euler_tour_tree
{
public:
struct node;
using nodeP = node*;

struct node
{
nodeP ch[2] = {nullptr, nullptr};
nodeP p = nullptr;
int l, r, sz;
T val = et, sum = et;
bool exact;
bool child_exact;
bool edge_connected = false;
bool child_edge_connected = false;
node() {}
node(int l, int r) : l(l), r(r), sz(l == r), exact(l < r), child_exact(l < r) {}
bool is_root() { return !p; }
};

std::vector<std::unordered_map<int, nodeP>> ptr;

nodeP get_node(int l, int r)
{
if(ptr[l].find(r) == ptr[l].end()) ptr[l][r] = new node(l, r);
return ptr[l][r];
}

nodeP root(nodeP t)
{
if(!t) return t;
while(t->p) t = t->p;
return t;
}

bool same(nodeP s, nodeP t)
{
if(s) splay(s);
if(t) splay(t);
return root(s) == root(t);
}

nodeP reroot(nodeP t)
{
auto s = split(t);
return merge(s.second, s.first);
}

std::pair<nodeP, nodeP> split(nodeP s)
{
splay(s);
nodeP t = s->ch[0];
if(t) t->p = nullptr;
s->ch[0] = nullptr;
return std::make_pair(t, update(s));
}

std::pair<nodeP, nodeP> split2(nodeP s)
{
splay(s);
nodeP t = s->ch[0];
nodeP u = s->ch[1];
if(t) t->p = nullptr;
s->ch[0] = nullptr;
if(u) u->p = nullptr;
s->ch[1] = nullptr;
return std::make_pair(t, u);
}

std::tuple<nodeP, nodeP, nodeP> split(nodeP s, nodeP t)
{
auto u = split2(s);
if(same(u.first, t))
{
auto r = split2(t);
return std::make_tuple(r.first, r.second, u.second);
}
else
{
auto r = split2(t);
return std::make_tuple(u.first, r.first, r.second);
}
}

template<class Car, class... Cdr>
nodeP merge(Car car, Cdr... cdr)
{
return merge(car, merge(cdr...));
}

nodeP merge(nodeP s, nodeP t)
{
if(!s) return t;
if(!t) return s;
while(s->ch[1]) s = s->ch[1];
splay(s);
s->ch[1] = t;
if(t) t->p = s;
return update(s);
}

int size(nodeP t) { return t ? t->sz : 0; }

nodeP update(nodeP t)
{
t->sum = et;
if(t->ch[0]) t->sum = fn(t->sum, t->ch[0]->sum);
if(t->l == t->r) t->sum = fn(t->sum, t->val);
if(t->ch[1]) t->sum = fn(t->sum, t->ch[1]->sum);

t->sz = size(t->ch[0]) + (int)(t->l == t->r) + size(t->ch[1]);
t->child_edge_connected = (
t->ch[0] ? t->ch[0]->child_edge_connected : 0
) | (t->edge_connected) | (
t->ch[1] ? t->ch[1]->child_edge_connected : 0
);
t->child_exact = (
t->ch[0] ? t->ch[0]->child_exact : 0
) | (t->exact) | (
t->ch[1] ? t->ch[1]->child_exact : 0
);

return t;
}

void push(nodeP t) {}

void rot(nodeP t, bool b)
{
nodeP x = t->p, y = x->p;
if(x->ch[1 - b] = t->ch[b]) t->ch[b]->p = x;
t->ch[b] = x, x->p = t;
update(x);
update(t);
if(t->p = y)
{
if(y->ch[0] == x) y->ch[0] = t;
if(y->ch[1] == x) y->ch[1] = t;
update(y);
}
}

void splay(nodeP t)
{
push(t);
while(!t->is_root())
{
nodeP q = t->p;

if(q->is_root())
{
push(q);
push(t);
rot(t, (q->ch[0] == t));
}
else
{
nodeP r = q->p;
push(r);
push(q);
push(t);
bool b = (r->ch[0] == q);
if(q->ch[1 - b] == t)
{
rot(q, b);
rot(t, b);
}
else
{
rot(t, 1 - b);
rot(t, b);
}
}
}
}

void debug(nodeP t)
{
if(!t) return;
debug(t->ch[0]);
std::cerr << t->l << '-' << t->r << ' ';
debug(t->ch[1]);
}

public:
euler_tour_tree() {}
euler_tour_tree(int sz)
{
ptr.resize(sz);
for(int i = 0; i < sz; i++) ptr[i][i] = new node(i, i);
}

int size(int s)
{
nodeP t = get_node(s, s);
splay(t);
return t->sz;
}

bool same(int s, int t) { return same(get_node(s, s), get_node(t, t)); }

void set_size(int sz)
{
ptr.resize(sz);
for(int i = 0; i < sz; i++) ptr[i][i] = new node(i, i);
}

void update(int s, T x)
{
nodeP t = get_node(s, s);
splay(t);
t->val = fn(t->val, x);
update(t);
}

void edge_update(int s, auto g)
{
nodeP t = get_node(s, s);
splay(t);

std::function<void(nodeP)> dfs = [&](nodeP t)
{
assert(t);
if(t->l < t->r && t->exact)
{
splay(t);
t->exact = 0;
update(t);
g(t->l, t->r);
return;
}

if(t->ch[0] && t->ch[0]->child_exact) dfs(t->ch[0]);
else dfs(t->ch[1]);
};

while(t && t->child_exact)
{
dfs(t);
splay(t);
}
}

bool try_reconnect(int s, auto f)
{
nodeP t = get_node(s, s);
splay(t);
std::function<bool(nodeP)> dfs = [&](nodeP t) -> bool
{
assert(t);
if(t->edge_connected)
{
splay(t);
return f(t->l);
}

if(t->ch[0] && t->ch[0]->child_edge_connected) return dfs(t->ch[0]);
else return dfs(t->ch[1]);
};

while(t->child_edge_connected)
{
if(dfs(t)) return true;
splay(t);
}

return false;
}

void edge_connected_update(int s, bool b)
{
nodeP t = get_node(s, s);
splay(t);
t->edge_connected = b;
update(t);
}

bool link(int l, int r)
{
if(same(l, r)) return false;
merge(reroot(get_node(l, l)), get_node(l, r), reroot(get_node(r, r)), get_node(r, l));
return true;
}

bool cut(int l, int r)
{
if(ptr[l].find(r) == ptr[l].end()) return false;
nodeP s, t, u;
std::tie(s, t, u) = split(get_node(l, r), get_node(r, l));
merge(s, u);
nodeP p = ptr[l][r];
nodeP q = ptr[r][l];
ptr[l].erase(r);
ptr[r].erase(l);

delete p;
delete q;

return true;
}

T get_sum(int p, int v)
{
cut(p, v);
nodeP t = get_node(v, v);
splay(t);
T res = t->sum;
link(p, v);
return res;
}

T get_sum(int s)
{
nodeP t = get_node(s, s);
splay(t);
return t->sum;
}
};
int dep = 1;
std::vector<euler_tour_tree> ett;
std::vector<std::vector<std::unordered_set<int>>> edges;
int sz;

public:
dynamic_connectivity(int sz) : sz(sz)
{
ett.emplace_back(sz);
edges.emplace_back(sz);
}

bool link(int s, int t)
{
if(s == t) return false;
if(ett[0].link(s, t)) return true;
edges[0][s].insert(t);
edges[0][t].insert(s);
if(edges[0][s].size() == 1) ett[0].edge_connected_update(s, 1);
if(edges[0][t].size() == 1) ett[0].edge_connected_update(t, 1);

return false;
}

bool same(int s, int t) { return ett[0].same(s, t); }

int size(int s) { return ett[0].size(s); }

std::vector<int> get_vertex(int s) { return ett[0].vertex_list(s); }

void update(int s, T x) { ett[0].update(s, x); }

T get_sum(int s) { return ett[0].get_sum(s); }

bool cut(int s, int t)
{
if(s == t) return false;
for(int i = 0; i < dep; i++)
{
edges[i][s].erase(t);
edges[i][t].erase(s);
if(edges[i][s].size() == 0) ett[i].edge_connected_update(s, 0);
if(edges[i][t].size() == 0) ett[i].edge_connected_update(t, 0);
}

for(int i = dep - 1; i >= 0; i--)
{
if(ett[i].cut(s, t))
{
if(i == dep - 1)
{
dep++;
ett.emplace_back(sz);
edges.emplace_back(sz);
}

return !try_reconnect(s, t, i);
}
}

return false;
}

bool try_reconnect(int s, int t, int k)
{
for(int i = 0; i < k; i++) ett[i].cut(s, t);

for(int i = k; i >= 0; i--)
{
if(ett[i].size(s) > ett[i].size(t)) std::swap(s, t);
auto g = [&](int s, int t) { ett[i + 1].link(s, t); };
ett[i].edge_update(s, g);
auto f = [&](int x) -> bool
{
for(auto itr = edges[i][x].begin(); itr != edges[i][x].end();)
{
auto y = *itr;
itr = edges[i][x].erase(itr);
edges[i][y].erase(x);

if(edges[i][x].size() == 0) ett[i].edge_connected_update(x, 0);
if(edges[i][y].size() == 0) ett[i].edge_connected_update(y, 0);

if(ett[i].same(x, y))
{
edges[i + 1][x].insert(y);
edges[i + 1][y].insert(x);
if(edges[i + 1][x].size() == 1) ett[i + 1].edge_connected_update(x, 1);
if(edges[i + 1][y].size() == 1) ett[i + 1].edge_connected_update(y, 1);
}
else
{
for(int j = 0; j <= i; j++) ett[j].link(x, y);
return true;
}
}

return false;
};

if(ett[i].try_reconnect(s, f)) return true;
}
return false;
}

constexpr static T et = T();
constexpr static T fn(T s, T t) { return s + t; }
};


#line 2 "cpplib/Structure/HashMap.hpp"
#include <vector>
#include <string>
//hmap
struct hmap
{
std::vector<std::vector<std::pair<std::string, int>>> l_;
hmap() { l_.resize(10000, std::vector<std::pair<std::string, int>>(0)); }
int gethash(std::string key)
{
int r = 0;
for(int i = 0; i < key.length(); i++)
r += key[i];
return r % 10000 * 17 % 10000;
}
void put(std::string key, int val)
{
int id = gethash(key);
if(l_[id].empty())
l_[id].push_back(make_pair(key, val));
else
{
auto& ar = l_[id];
for(int i = 0; i < ar.size(); i++)
{
auto pr = ar[i];
if(pr.first == key)
{
ar.erase(ar.begin() + i);
break;
}
}
ar.push_back(make_pair(key, val));
}
}
int get(std::string key)
{
int id = gethash(key);
if(l_[id].empty())
return -1;
else
{
auto& ar = l_[id];
for(int i = 0; i < ar.size(); i++)
{
auto pr = ar[i];
if(pr.first == key)
return pr.second;
}
return -1;
}
}
void rm(std::string key)
{
int id = gethash(key);
if(l_[id].empty())
return;
auto& ar = l_[id];
for(int i = 0; i < ar.size(); i++)
{
auto pr = ar[i];
if(pr.first == key)
{
ar.erase(ar.begin() + i);
break;
}
}
}
};

#line 2 "cpplib/Structure/lazysegtree.hpp"
/*
TODO: 完成させる

//lazysegtree
template<typename X,typename M>struct lazyseg
{
int n;
std::function<X(X,X)>fx;
std::function<X(X,M)>fa;
std::function<X(M,M)>fm;
const X ex;
const M em;
std::vector<X>d;
std::vector<M>lazy;
lazyseg
(
int n_,
std::function<X(X,X)>fx_,
std::function<X(X,M)>fa_,
std::function<X(M,M)>fm_,
X ex_,
M em_
):n(),fx(fx_),fa(fa_),fm(fm_),ex(ex_),em(em_),d(n_*4,ex),lazy(n_*4,em)
{
int x=1;
while(n_>x)x*=2;
n=x;
}

void set(int i,X x){d[i+n-1]=x;}
void build(){for(int k=n-2;k>=0;k--)d[k]=fx(d[2*k+1],d[2*k+2]);}
void eval(int k)
{
if(lazy[k]==em)return;
if(k<n-1)
{
lazy[k*2+1]=fm(lazy[k*2+1],lazy[k]);
lazy[k*2+2]=fm(lazy[k*2+2],lazy[k]);
}
d[k]=fa(d[k],lazy[k]);
lazy[k]=em;
}
void update(int a,int b,M x,int k,int l,int r)
{
eval(k);
if(a<=l&&r<=b)lazy[k]=fm(lazy[k],x),eval(k);
else if(a<r&&l<b)
{
update(a,b,x,k*2+1,l,(l+r)/2);
update(a,b,x,k*2+2,(l+r)/2,r);
d[k]=fx(d[k*2+1],d[k*2+2]);
}
}
void update(int a,int b,M x){update(a,b,x,0,0,n);}
X qsub(int a,int b,int k,int l,int r)
{
eval(k);
if(r<=a||b<=l)return ex;
else if(a<=l&&r<=b)return d[k];
else
{
X vl=qsub(a,b,k*2+1,l,(l+r)/2);
X vr=qsub(a,b,k*2+2,(l+r)/2,r);
return fx(vl,vr);
}
}
X query(int a,int b){return qsub(a,b,0,0,n);}
};

//RMQ :
//int n=**size**
//auto fx=[](int a,int b)->int{return min(a,b);};
//auto fa=[](int x,int m)->int{return m;};
//auto fm=[](int m1,int m2)->int{return m2;};
//int ex=inf;
//int em=inf;
//lazyseg<int,int>rmq(n,fx,fa,fm,ex,em);
*/

#line 2 "cpplib/Structure/segtree.hpp"
// Segtree
template <class T>
struct segtree
{
using F = std::function<T(T, T)>;
int sz;
std::vector<T> seg;
const F f;
const T m1;
segtree(int n, const F f, const T& m1) : f(f), m1(m1)
{
for(sz = 1; sz < n; sz <<= 1)
;
seg.assign(2 * sz, m1);
}
void update(int k, const T& x)
{
k += sz;
seg[k] = x;
for(; k >>= 1;)
seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
}
void set(int k, const T& x) { seg[k + sz] = x; }
void build()
{
for(int k = sz - 1; k > 0; k--)
seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
}
T query(int a, int b)
{
T L = m1, R = m1;
for(a += sz, b += sz; a < b; a >>= 1, b >>= 1)
{
if(a & 1)
L = f(L, seg[a++]);
if(b & 1)
R = f(seg[--b], R);
}
return f(L, R);
}
T operator[](const int& k) const { return seg[k + sz]; }
template <class C>
int find_subtree(int a, const C& check, T& M, bool type)
{
for(; a < sz;)
{
T nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);
if(check(nxt))
a = 2 * a + type;
else
M = nxt, a = 2 * a + 1 - type;
}
return a - sz;
}
template <class C>
int find_first(int a, const C& check)
{
T L = m1;
if(a <= 0)
return check(f(L, seg[1])) ? find_subtree(1, check, L, false) : -1;
int b = sz;
for(a += sz, b += sz; a < b; a >>= 1, b >>= 1)
{
if(a & 1)
{
T nxt = f(L, seg[a]);
if(check(nxt))
return find_subtree(a, check, L, false);
L = nxt;
a++;
}
}
return -1;
}
template <class C>
int find_last(int b, const C& check)
{
T R = m1;
if(b >= sz)
return check(f(seg[1], R)) ? find_subtree(1, check, R, true) : -1;
int a = sz;
for(b += sz; a < b; a >>= 1, b >>= 1)
{
if(b & 1)
{
T nxt = f(seg[--b], R);
if(check(nxt))
return find_subtree(b, check, R, true);
R = nxt;
}
}
return -1;
}
};

// SegmentTree(n, f, M1):= サイズ n の初期化。
// f : 2つの区間の要素をマージする二項演算,
// M1 はモノイドの単位元である。
// set(k, x):= k 番目の要素に x を代入する。
// build():= セグメント木を構築する。
// query(a, b):= 区間 [a, b) に対して二項演算した結果を返す。
// update(k, x):= k 番目の要素を x に変更する。
// operator[k] := k 番目の要素を返す。
// find_first(a, check) := [a,x) が check を満たす最初の要素位置 x を返す。
// find_last(b, check) := [x,b) が check を満たす最後の要素位置 x を返す。
// for example : segtree<int>seg(n,[](int a,int b){return min(a,b);},INT32_MAX);


#line 2 "cpplib/Structure/union-find.hpp"
#include <vector>
#include <algorithm>
//union-find
struct uni
{
int n_;
std::vector<int> par, siz;
uni(int n) : n_(n), par(n), siz(n, 1LL)
{
for(int i = 0; i < n; i++)
par[i] = i;
}
void init(int n)
{
par.resize(n);
siz.assign(n, 1LL);
for(int i = 0; i < n; i++)
par[i] = i;
}
void merge(int x, int y)
{
int rx = root(x);
int ry = root(y);
if(rx == ry)
return;
if(siz[rx] < siz[ry])
std::swap(rx, ry);
siz[rx] += siz[ry];
par[ry] = rx;
return;
}
int root(int x) { return par[x] == x ? x : par[x] = root(par[x]); }
bool same(int x, int y) { return root(x) == root(y); }
int size(int x) { return siz[root(x)]; }
std::vector<std::vector<int>> groups()
{
std::vector<int> rbuf(n_), grsiz(n_);
for(int i = 0; i < n_; i++)
grsiz[(rbuf[i] = root(i))]++;
std::vector<std::vector<int>> res(n_);
for(int i = 0; i < n_; i++)
res[i].reserve(grsiz[i]);
for(int i = 0; i < n_; i++)
res[rbuf[i]].push_back(i);
res.erase(remove_if(res.begin(), res.end(), [&](const std::vector<int>& v)
{ return v.empty(); }),
res.end());
return res;
}
};

#line 2 "Main.cpp"

void solve()
{
using namespace std;
INT(N,K);
vi a(N,0),b(N,0);
rep(_,K)
{
CHR(c);
INT(k);k--;
b[k]=1;
rep(i,N)
{
if((c=='L'&&k<=i)||(c=='R'&&k>=i))a[i]++;
}
}
modInt<mod2>ans{1};
rep(i,N)if(b[i]==0)ans*=a[i];
println(ans);
}

std::int32_t main()
{
// std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
std::cout << std::fixed << std::setprecision(15);
solve();
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i = a;i<b; i++)
#define rrep(i,a,b) for(int i = a;i>b-1; i--)
#define INF 100000000
typedef long long ll;
int main(){
long long n,a,b,c,answer=(1LL<< 60);
cin >> n;
rep(i,0,61){
a = n/(1LL<<i);
b = i;
c = n -a *(1LL<<i);
answer = min(answer,a+b+c);
}
cout << answer << endl;
}

#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define pf push_front
#define pob pop_back
#define pof pop_front
#define ff first
#define ss second
#define SetBit(x, k) (x |= (1LL << k))
#define ClearBit(x, k) (x &= ~(1LL << k))
#define CheckBit(x, k) (x & (1LL << k))
#define scn(n) scanf("%d",&n)
#define scnll(n) scanf("%lld",&n)
#define nl printf("\n")
#define YES printf("YES\n")
#define Yes printf("Yes\n")
#define yes printf("yes\n")
#define NO printf("NO\n")
#define No printf("No\n")
#define no printf("no\n")
#define mod 1000000007LL
#define mod1 1000000007LL
#define mod2 1000000009LL
#define inf 1000000000000000LL
#define N 1000005
#define fastio std::ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
using namespace std;

int a[N];

int main()
{
fastio;
ll n;cin>>n;
ll x=1,y=9,xx=1;
ll val[20],a[20],v[20];
for(ll i=1;i<=18;i++){
val[i]=y;
a[i]=x;
y*=10LL;
y+=9LL;
x*=10LL;
x+=1LL;
v[i]=xx;
xx*=10LL;
}
ll ans=0,ps;
for(ll i=1;i<=18;i++){
ps=i;
if(n>=val[i]){
ans+=a[i];
}
else{
break;
}
}
for(ll i=ps;i>0;i--){
ll x=n/v[i];
//110cout<<x<<"\n";
if(x>1LL){
ans+=a[i];
break;
}
else if(x==1LL){
ans+=(n%v[i]+1LL);
n%=v[i];
}
else{
break;
}
}
cout<<ans<<"\n";

}
// Problem: B - Uniformly Distributed
// Contest: AtCoder - AtCoder Regular Contest 120
// URL: https://atcoder.jp/contests/arc120/tasks/arc120_b
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#pragma GCC optimize("Ofast,unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2")
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;

template<typename F>
void multitest(F func) {
int t;
cin >> t;
while(t--) func();
}
void report(int ok) {
cout << (ok?"YES":"NO") << '\n';
}

int main() {
cin.tie(0)->sync_with_stdio(0);
//multitest([&](){});
int n, m;
cin >> n >> m;
vector<int> a(n+m-1), b(n+m-1);
for(int i = 0; i < n; i++) {
string s;cin >> s;
for(int j = 0; j < m; j++) {
if(s[j]=='R') a[i+j]++;
if(s[j]=='B') b[i+j]++;
}
}
int ans = 1;
for(int i = 0; i < n+m-1; i++)
if(a[i] && b[i]) ans =0;
else {
if(!a[i] && !b[i]) ans = (ans+ans)%998244353;
}
cout << ans << '\n';
}

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <deque>
#include <map>
#include <cmath>
typedef long long LL;
using namespace std;
const int Mod = 1000000007;

int main() {
LL A, B;
cin >> A >> B;
LL x = 500000000*B + A;
cout << x << endl;
}
#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <tuple>
#include <vector>

using namespace std;

#define endl "\n"

// clang-format off
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }
#ifdef MIPPON_LOCAL
#define dbg(...) cerr <<"\e[38;5;214m" << "(" << #__VA_ARGS__ << "):" << "\e[39m", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif


template<const int &MOD>
struct modint {
int64_t n;
modint() : n(0) { ; }
modint(int64_t m) : n(m) {
if (n >= MOD) n %= MOD;
if (n < 0) n = (n % MOD + MOD) % MOD;
}
modint(uint64_t m) : n(m) {
if (n >= MOD) n %= MOD;
}
modint(int v) : modint(int64_t(v)) {}
modint(unsigned v) : modint(uint64_t(v)) {}

explicit operator int() const { return n; }
explicit operator unsigned() const { return n; }
explicit operator int64_t() const { return n; }
explicit operator uint64_t() const { return n; }
explicit operator double() const { return n; }
explicit operator long double() const { return n; }
modint& operator++() {
n = n == MOD - 1 ? 0 : n + 1;
return *this;
}
modint& operator--() {
n = n == 0 ? MOD - 1 : n - 1;
return *this;
}
modint operator++(int) {
modint before = *this;
++*this;
return before;
}
modint operator--(int) {
modint before = *this;
--*this;
return before;
}
modint operator-() const { return n == 0 ? 0 : MOD - n; }
friend bool operator==(const modint& a, const modint& b) { return a.n == b.n; }
friend bool operator!=(const modint& a, const modint& b) { return a.n != b.n; }
friend bool operator<(const modint& a, const modint& b) { return a.n < b.n; }
friend bool operator>(const modint& a, const modint& b) { return a.n > b.n; }
friend bool operator<=(const modint& a, const modint& b) { return a.n <= b.n; }
friend bool operator>=(const modint& a, const modint& b) { return a.n >= b.n; }
modint& operator+=(const modint& a) {
n += a.n;
if (n >= MOD) n -= MOD;
return *this;
}
modint& operator-=(const modint& a) {
n -= a.n;
if (n < 0) n += MOD;
return *this;
}
modint& operator*=(const modint& a) {
n = ((int64_t)n * a.n) % MOD;
return *this;
}
modint& operator/=(const modint& a) { return *this *= a.inv(); }
modint inv() const { return pow(MOD - 2); }

friend modint operator/(const modint& a, const modint& b) { return modint(a) /= b; }
friend modint operator+(const modint& a, const modint& b) { return modint(a) += b; }
friend modint operator-(const modint& a, const modint& b) { return modint(a) -= b; }
friend modint operator*(const modint& a, const modint& b) { return modint(a) *= b; }
friend modint operator^(modint a, int64_t n) {
if (n == 0) return modint(1);
modint res = (a * a) ^ (n / 2);
if (n % 2) res = res * a;
return res;
}

modint pow(int64_t p) const {
if (p < 0) return inv().pow(-p);
modint a = *this, result = 1;
while (p > 0) {
if (p & 1) result *= a;
p >>= 1;
if (p > 0) a *= a;
}
return result;
}
friend ostream& operator<<(ostream& os, const modint& a) { return os << a.n; }
};

extern const int MOD = int(1e9) + 7;
using mod_int = modint<MOD>;

// clang-format on
int64_t ceil_divison(int64_t a, int64_t b) {
return a / b + ((a ^ b) > 0 && a % b != 0);
}
int64_t floor_divison(int64_t a, int64_t b) {
return a / b - ((a ^ b) < 0 && a % b != 0);
}

void run_case() {
int64_t N;
cin >> N;
if (N % 2 == 1) {
cout << "Odd" << endl;
} else if ((N / 2) % 2 == 0) {
cout << "Even" << endl;
} else {
cout << "Same" << endl;
}
}
int main() {
ios::sync_with_stdio(false);
#ifndef MIPPON_LOCAL
cin.tie(nullptr);
#endif

int tests;
cin >> tests;
while (tests-- > 0)
run_case();

return 0;
}

#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep(i,n) for(int i=0;i<(n);++i)
#define all(a)  (a).begin(),(a).end()
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }

void YN(bool a){
if(a == true){
cout<<"Yes"<<endl;
}else{
cout<<"No"<<endl;
}

}

string toBinary(ll n)
{
string r;
while (n != 0){
r += ( n % 2 == 0 ? "0" : "1" );
n /= 2;
}
return r;
}
int main(){
ll n;
cin >> n;
string s;
cin >> s;

vector<ll> arr;
char c=s[0];
ll cnt=0,ans=0;
rep(i,n){
if(c!=s[i]){
arr.push_back(cnt);
cnt=1;
c=s[i];
}else{
cnt++;
}
}
arr.push_back(cnt);

rep(i,arr.size())ans+=arr[i]*(arr[i]-1)/2;

cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main(){
int n;
cin>>n;
vector<vector<int>> c(n,vector<int>(n));
for(int i=0;i<n;i++){
for(int j=0;j<n;j++){
cin>>c[i][j];
}
}
bool yn=true;
int mn=c[0][0],idx=0;
for(int i=1;i<n;i++){
if(mn>c[i][0]){
idx=i;
mn=c[i][0];
}
for(int j=1;j<n;j++){
if(c[i][j]-c[i][j-1]!=c[i-1][j]-c[i-1][j-1]) yn=false;
if(c[i][j]-c[i-1][j]!=c[i][j-1]-c[i-1][j-1]) yn=false;
}
}
if(!yn){
cout<<"No"<<endl;
return 0;
}
vector<int> a(n),b(n);
for(int i=0;i<n;i++) b[i]=c[idx][i];
for(int i=0;i<n;i++) a[i]=c[i][0]-b[0];
cout<<"Yes"<<endl;
for(int i=0;i<n;i++) cout<<a[i]<<" ";
cout<<endl;
for(int i=0;i<n;i++) cout<<b[i]<<" ";
cout<<endl;
}
#include<bits/stdc++.h>

using namespace std;

#define  GODSPEED       ios:: sync_with_stdio(0);cin.tie(0);cout.tie(0);cout<<fixed;cout<<setprecision(15);
#define  f              first
#define  s              second
#define  newl           cout<<"\n";
#define  pb             push_back
#define  mset(a,x)      memset(a,x,sizeof(a))
#define  debv(a)        for(auto it: a)cout<<it<<" ";newl;
#define  deb1(a)        cout<<a<<"\n";
#define  deb2(a,b)      cout<<a<<" "<<b<<"\n";
#define  deb3(a,b,c)    cout<<a<<" "<<b<<" "<<c<<"\n";
#define  deb4(a,b,c,d)  cout<<a<<" "<<b<<" "<<c<<" "<<d<<"\n";
#define  uniq(a)        a.resize(unique(a.begin(), a.end()) - a.begin());
#define  all(a)         a.begin(),a.end()

typedef  long long             ll;
typedef  long double           ld;

const ll   N     =  1e6 + 5;
const ll   mod   =  1e9 + 7;
const ll   INF   =  0x7f7f7f7f7f7f7f7f;
const int  INFi  =  0x7f7f7f7f;
const int  LEVEL =  log2(N) + 1;

template<typename T, typename F = std::function<T(const T&, const T&)>>
struct segment_tree {
int n;
std::vector<T> tree;
T e;
F f;

segment_tree() : n(), e(), f() {}

template<typename U>
segment_tree(const std::vector<U> &v, int n, T e, F &&f): n(n), tree(4 * n), e(e), f(f) {
build(v, 1, 0, n - 1);
}

template<typename U>
void build(const std::vector<U> &v, int node, int start, int end) {
if (start == end) {
tree[node] = T(v[start]);
} else {
int mid = (start + end) / 2;
build(v, 2 * node, start, mid);
build(v, 2 * node + 1, mid + 1, end);
tree[node] = f(tree[2 * node], tree[2 * node + 1]);
}
}

template<typename U>
void update(int idx, U val) {
update_helper(1, 1, n, idx, val);
}

template<typename U>
void update_helper(int node, int start, int end, int idx, U val) {
if (start == end) {
tree[node] = T(val);
} else {
int mid = (start + end) / 2;
if (start <= idx and idx <= mid)
update_helper(2 * node, start, mid, idx, val);
else
update_helper(2 * node + 1, mid + 1, end, idx, val);
tree[node] = f(tree[2 * node], tree[2 * node + 1]);
}
}

T query(int l, int r) {
return query_helper(1, 1, n, l, r);
}

T query_helper (int node, int start, int end, int l, int r) {
if (start > end or start > r or end < l)
return e;
if (l <= start and end <= r)
return tree[node];
int mid = (start + end) / 2;
T p1 = query_helper(2 * node, start, mid, l, r);
T p2 = query_helper(2 * node + 1, mid + 1, end, l, r);
return f(p1, p2);
}
};

struct node {
int ans;
node(): ans(0) {}
node(int v): ans(v) {}
};

int n, a[N], b[N], ind[N], dp[N];

void solve() {
cin >> n;
for (int i = 1; i <= n; i++) cin >> a[i];
for (int i = 1; i <= n; i++) cin >> b[i], ind[b[i]] = i;

segment_tree st(vector <int> (n + 1, 0), n, node(), [&](const node &a, const node &b){
node c;
c.ans = max(a.ans, b.ans);
return c;
});

for (int i = 1; i <= n; i++) {
vector <int> v;
for (int j = a[i]; j <= n; j += a[i]) v.pb(ind[j]);
sort(all(v), greater<>());
for (auto it : v) {
dp[it] = max(dp[it], st.query(1, it - 1).ans + 1);
st.update(it, dp[it]);
}
}
deb1(*max_element(dp + 1, dp + n + 1))
}

int main() {
GODSPEED;
int test = 1;
// cin >> test;
for (int i = 1; i <= test; i++) {
solve();
}
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

//long long
using ll = long long;

//円周率
const double PI = acos(-1);

// pair<int, int>
using PII = pair<int, int>;


//最大値、mod
const int MOD = 1000000007;
const int mod = 1000000007;
// const int MOD = 998244353;
// const int mod = 998244353;
const int INF = 1000000000;
const double DINF = 1LL<<60;
const long long LINF = 1LL<<60;
const int MAX = 510000;

//出力系
#define print(x) cout << x << endl
#define prints(x) cout << fixed << setprecision(12) << x << endl
#define printc(x) cout << setw(6) << setfill('0') << x << endl;
#define yes cout << "Yes" << endl
#define YES cout << "YES" << endl
#define no cout << "No" << endl
#define NO cout << "NO" << endl

//配列入力
vector<long long>vecin(ll n){
vector<long long>res(n);
for(int i = 0; i < n; i++) cin >> res[i];
return res;
}

// begin() end()
#define all(x) (x).begin(),(x).end()

//for
#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define rrep(i,a,b) for(int i=(a);i>(b);i--)
#define rep(i,a,b) for(int i=(a);i<(b);i++)

//最大公約数 
ll gcd(ll x, ll y) { return y ? gcd(y,x%y) : x;}

// 最小公倍数
unsigned lcm(unsigned a, unsigned b){
return a / gcd(a, b) * b; 
}

// a = max(a, b), a = min(a, b)


template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

// template<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}
// template<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}

// num ^ pow(mod取る)
ll pow_mod(ll num, ll pow, ll mod) {
ll prod = 1;
num %= mod;
while (pow > 0) {
if (pow & 1) prod = prod * num % mod;
num = num * num % mod;
pow >>= 1;
}
return prod;
}




// UnionFind
struct UnionFind {
vector<int> par;
vector<int> rank;
vector<ll> Size;
UnionFind(int n = 1) {
init(n);
}

void init(int n = 1) {
par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);
for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;
}

int root(int x) {
if (par[x] == x) {
return x;
}
else {
int r = root(par[x]);
return par[x] = r;
}
}

bool issame(int x, int y) {
return root(x) == root(y);
}

bool merge(int x, int y) {
x = root(x); y = root(y);
if (x == y) return false;
if (rank[x] < rank[y]) swap(x, y);
if (rank[x] == rank[y]) ++rank[x];
par[y] = x;
Size[x] += Size[y];
return true;
}

ll size(int x){
return Size[root(x)];
}
};


//modint構造体 
struct Mint {
int val;
Mint inv() const{
int tmp,a=val,b=mod,x=1,y=0;
while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);
return Mint(x);
}
public:
Mint():val(0){}
Mint(ll x){if((val=x%mod)<0)val+=mod;}
Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}
Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}
Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}
Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}
Mint& operator/=(const Mint& x){return *this*=x.inv();}
bool operator==(const Mint& x) const{return val==x.val;}
bool operator!=(const Mint& x) const{return val!=x.val;}
bool operator<(const Mint& x) const{return val<x.val;}
bool operator<=(const Mint& x) const{return val<=x.val;}
bool operator>(const Mint& x) const{return val>x.val;}
bool operator>=(const Mint& x) const{return val>=x.val;}
Mint operator+(const Mint& x) const{return Mint(*this)+=x;}
Mint operator-(const Mint& x) const{return Mint(*this)-=x;}
Mint operator*(const Mint& x) const{return Mint(*this)*=x;}
Mint operator/(const Mint& x) const{return Mint(*this)/=x;}
};
struct factorial {
vector<Mint> Fact, Finv;
public:
//factorial fact(10000010);
//fact.nCr(a, b)
//「fact」の部分は自由に名前変更可能
factorial(int maxx){
Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);
Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;
}
Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}
Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}
Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}
};


// 1 * 2 * 3 .... * n (mod)
ll modfact(ll n) { 
if (n <= 1) return 1;
return (n * modfact(n - 1)) % MOD;
}


// kが角度だった場合:cos(k * (PI / 180));
//const double PI = acos(-1);のまま使うと円周率(M_PIもあるよ)
//const double PI = acos(-1);


// 多次元 vector 生成   例: auto dp = make_vec<long long>(N+1, 5, 5, 5); 
template<class T>
vector<T> make_vec(size_t a){
return vector<T>(a);
}
template<class T, class... Ts>
auto make_vec(size_t a, Ts... ts){
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

//素因数分解
vector<pair<long long, int>>factorize(long long n){
vector<pair<long long, int>> res;
for(long long i = 2; i * i <= n; ++i){
if(n % i) continue;
res.emplace_back(i, 0);
while(n % i == 0){
n /= i;
res.back().second++;
}
}
if(n != 1) res.emplace_back(n, 1);
return res;
}

// 素数判定
bool primejudge(long long a){
if(a <= 1) return false;
for(long long i = 2; i * i <= a; i++){
if(a % i == 0) return false;
}
return true;
}

//lca_tree
// https://drken1215.hatenablog.com/entry/2021/06/19/175900
// https://atcoder.jp/contests/abc014/submissions/28234866
struct Tree_lca{

Tree_lca(int V, int root) : V(V), root(root){
T.resize(V);
for(int i = 0; i < MAXLOGV; i++) parent[i].resize(V);
depth.resize(V);

}

void unite(int u, int v){
T[u].push_back(v);
T[v].push_back(u);
}

void init(){
dfs(root, -1, 0);
for(int k = 0; k + 1 < MAXLOGV; k++){
for(int v = 0; v < V; v++){
if(parent[k][v] < 0) parent[k + 1][v] = -1;
else parent[k + 1][v] = parent[k][parent[k][v]];
}
}
}

int lca(int u, int v) const{
if(depth[u] > depth[v]) swap(u, v);
for(int k = 0; k < MAXLOGV; k++){
if((depth[v] - depth[u]) >> k & 1) v = parent[k][v];
}

if(u == v) return u;

for(int k = MAXLOGV - 1; k >= 0; k--){
if(parent[k][u] != parent[k][v]){
u = parent[k][u];
v = parent[k][v];
}
}

return parent[0][u];

}

int dist(int u, int v) const{
int p = lca(u, v);
return(depth[u] - depth[p]) + (depth[v] - depth[p]);
}

void dfs(int v, int p, int d){
parent[0][v] = p;
depth[v] = d;
for(int next : T[v]){
if(next != p) dfs(next, v, d + 1);
}
}

static const int MAXLOGV = 25;
vector<vector<int>>T;
int V;
int root;
vector<int> parent[MAXLOGV];
vector<int>depth;
};




//ループ用のベルマンフォード　距離は*-1に変換して入力してください
// E.add_edge(a, b, -c);
template<typename T>
struct BellmanFord{
struct Edge{
int  from,to; ll cost;
Edge(){}
Edge(int from,int to,ll cost):from(from),to(to),cost(cost){}
};

int n;
vector<vector<int> >G;
vector<int> used,reach;
BellmanFord(int n):n(n),G(n),used(n,0),reach(n,0){}

vector<Edge> es;
void add_edge(int from,int to,ll cost){
es.push_back(Edge(from,to,cost));
G[from].push_back(to);
}

void dfs(int v){
if(used[v])return ;
used[v]=1;
for(int u:G[v]){
dfs(u);
}
}

// int nl;
//ll res = E.build(0, n - 1, nl);
//とするとループの場合はnl = 1,ループしない場合はnl = 0
// resはループしなければ距離が入る
// ループする場合は1e18が入る
ll build(int from,int to,int &neg_loop){
for(int i=0;i<n;i++){
fill(used.begin(),used.end(),0);
dfs(i);
reach[i]=used[to];
}
vector<ll> ds(n,1e18);
ds[from]=0;
for(int i=0;i<n;i++){
bool update=0;
for(auto e:es){
if(!reach[e.from]||!reach[e.to]||ds[e.from]==1e18) continue;
if(ds[e.to]>ds[e.from]+e.cost){
ds[e.to]=ds[e.from]+e.cost;
update=1;
}
}
if(!update)break;
if(i==n-1){
neg_loop=1;
return 1e18;
}
}
neg_loop=0;
return -ds[to];
}
};



//BIT
template <class Abel> struct BIT {
Abel UNITY_SUM = 0;
vector<Abel> dat;

// [0, n)
BIT(int n, Abel unity = 0) : UNITY_SUM(unity), dat(n, unity) { }
void init(int n) {
dat.assign(n, UNITY_SUM);
}

// a is 0-indexed
inline void add(int a, Abel x) {
for (int i = a; i < (int)dat.size(); i |= i + 1)
dat[i] = dat[i] + x;
}

// [0, a), a is 0-indexed
inline Abel sum(int a) {
Abel res = UNITY_SUM;
for (int i = a - 1; i >= 0; i = (i & (i + 1)) - 1)
res = res + dat[i];
return res;
}

// [a, b), a and b are 0-indexed
inline Abel sum(int a, int b) {
return sum(b) - sum(a);
}

// debug
void printdd() {
for (int i = 0; i < (int)dat.size(); ++i)
cout << sum(i, i + 1) << ",";
cout << endl;
}
};

//lazzy_seg
class segment_tree {
private:
int sz;
std::vector<int> seg;
std::vector<int> lazy;
void push(int k) {
if (k < sz) {
lazy[k * 2] = max(lazy[k * 2], lazy[k]);
lazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);
}
seg[k] = max(seg[k], lazy[k]);
lazy[k] = 0;
}
void update(int a, int b, int x, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = x;
push(k);
return;
}
update(a, b, x, k * 2, l, (l + r) >> 1);
update(a, b, x, k * 2 + 1, (l + r) >> 1, r);
seg[k] = max(seg[k * 2], seg[k * 2 + 1]);
}
int range_max(int a, int b, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return 0;
if (a <= l && r <= b) return seg[k];
int lc = range_max(a, b, k * 2, l, (l + r) >> 1);
int rc = range_max(a, b, k * 2 + 1, (l + r) >> 1, r);
return max(lc, rc);
}
public:
segment_tree() : sz(0), seg(), lazy() {};
segment_tree(int N) {
sz = 1;
while (sz < N) {
sz *= 2;
}
seg = std::vector<int>(sz * 2, 0);
lazy = std::vector<int>(sz * 2, 0);
}
void update(int l, int r, int x) {
update(l, r, x, 1, 0, sz);
}
int range_max(int l, int r) {
return range_max(l, r, 1, 0, sz);
}
};


// Mint dp[200100];
// ll dp[200100];
//ダイクストラ
vector<pair<long long, long long>>DG[200100];
vector<long long>dijkstra(int s){
vector<long long>dist(200100, LINF);
dist[s] = 0;
priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>>que;
que.push({0, s});
// dp[s] = 1;
while(!que.empty()){
long long cost, to;
cost = que.top().first; to = que.top().second;
que.pop();
if(dist[to] < cost) continue;
for(auto x : DG[to]){
long long v = x.first, time = x.second;
if(dist[v] > dist[to] + time){
dist[v] = dist[to] + time;
que.push({dist[v], v});
// dp[v] = dp[to];
}
// else if(dist[v] == dist[to] + time){
//     dp[v] += dp[to];
// }
}
}
return dist;
}


ll fa(ll n) { 
if (n <= 1) return 1;
return (n * fa(n - 1));
}

//modintに注意
Mint NCR(int N, int i){
Mint x = 1, y = 1;
REP(j, i){
x *= N - j;
y *= j + 1;
}
return x / y;
}


ll ncr(int N, int i){
ll x = 1, y = 1;
REP(j, i){
x *= N - j;
y *= j + 1;
}
return x / y;
}

ll powers(ll i, ll N){
if(N == 0) return 1;
if(N == 1) return i;
ll tmp = powers(i, N / 2);
ll res = tmp * tmp;
if(N % 2) res *= i;
return res;
}


//sort(all(ids), [&](int i, int j) {return x[i] < x[j];});

vector<vector<int>> G;
// vector<vector<int>> G2;
//G.assign(N, vector<int>());
vector<vector<pair<ll, ll>>>E;
//E.assign(N, vector<pair<ll, ll>>());

int dy[2] = {0, 1}, dx[2] = {1, 0}; 
// int dy[4] = {0, 1, 0, -1}, dx[4] = {1, 0, -1, 0};
// int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
// int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};



//segtree用(ACL)
//vector<int>a(n); segtree<int, op, e> seg(a); とか　segtree<int, op, e> seg(300010)
ll op(ll a, ll b){
return a + b;
}

ll e(){
return 0LL;
}



int main(){
int N, M;
cin >> N >> M;
ll odd = 0, even = 0;
REP(i, N){
string S;
cin >> S;
if(count(all(S), '1') % 2) odd++;
else even++;
}

ll ans = odd * even;
print(ans);
}

#include "bits/stdc++.h"
using namespace std;

void IO(){
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
ios_base::sync_with_stdio(false);
cin.tie(NULL);
}

int main(){
IO();

int n;
cin>>n;
vector<int> p(n+1),q(n+1);
for(int i=1;i<=n;++i) cin>>p[i];
for(int i=1;i<=n;++i) cin>>q[i];

vector<vector<int>> multiples(n+1);
for(int i=1;i<=n;++i){
for(int j=i;j<=n;j+=i){
multiples[i].push_back(j);
}
}

vector<int> invq(n+1);
for(int i=1;i<=n;++i){
invq[q[i]] = i;
}

vector<vector<int>> a(n+1);

for(int i=1;i<=n;++i){
for(int j:multiples[p[i]]){
a[i].emplace_back(invq[j]);
}
sort(rbegin(a[i]),rend(a[i]));
}

vector<int> b;
for(int i=1;i<=n;++i){
for(int j:a[i]){
b.push_back(j);
}
}

//now finding longest increasing subsequence
vector<int> res;
for(int x:b){
auto it = lower_bound(begin(res),end(res),x);
if(it == res.end()) res.push_back(x);
else *it = x;
}

cout<< res.size() <<"\n";

return 0;
}

#include <bits/stdc++.h>

using namespace std; const int maxn = 2e5 + 5;

char a[maxn], b[maxn]; int n, m, ta[15], tb[15], as[15][15];

char oa[maxn], ob[maxn]; int l1, l2;

void insa(int x, int k) { while (k--) oa[++l1] = x + '0'; }

void insb(int x, int k) { while (k--) ob[++l2] = x + '0'; }

void print()
{
insa(0, ta[0]), insb(0, tb[0]);
for (int i = 1; i <= 9; i++) while (ta[i] && l1 < l2) insa(i, 1), ta[i]--;
for (int i = 1; i <= 9; i++) while (tb[i] && l2 < l1) insb(i, 1), tb[i]--;
insa(0, as[0][9]), insb(9, as[0][9]);
insa(9, as[9][0]), insb(0, as[9][0]);
for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (i + j == 9) insa(i, as[i][j]), insb(j, as[i][j]);
for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (i + j > 9) insa(i, as[i][j]), insb(j, as[i][j]);
for (int i = 1; i <= 9; i++) insa(i, ta[i]);
for (int i = 1; i <= 9; i++) insb(i, tb[i]);
//	cerr << l1 << ' ' << l2 << endl;
for (int i = 1 + (n < m ? m - n : 0); i <= max(n, m); i++) putchar(oa[i]); puts("");
for (int i = 1 + (m < n ? n - m : 0); i <= max(n, m); i++) putchar(ob[i]); puts("");
//	printf("%s\n%s\n", oa + (n < m ? m - n : 0) + 1, ob + (m < n ? n - m : 0) + 1);
}

int main()
{
// freopen("xxx.in", "r", stdin), freopen("xxx.out", "w", stdout);
scanf("%s%s", a + 1, b + 1), n = strlen(a + 1), m = strlen(b + 1);
for (int i = 1; i <= n; i++) ta[a[i] - '0']++;
for (int i = 1; i <= m; i++) tb[b[i] - '0']++;
if (n < m) ta[0] += m - n; else tb[0] += n - m;
bool can = false;
for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (i + j > 9 && ta[i] && tb[j]) can = true;
if (!can) { print(); return 0; }
for (int i = 9; i >= 0; i--)
{
for (int j = 0; j <= 9; j++) if (i + j >= 9)
{
int t = min(ta[i], tb[j]);
as[i][j] += t, ta[i] -= t, tb[j] -= t;
}
}
bool flag = false;
for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (i + j > 9 && as[i][j]) flag = true;
if (!flag)
for (int i = 9; i >= 1; i--) if (tb[i])
{
for (int j = 9; j >= 1; j--)
{
for (int k = 9; k >= 1; k--) if (as[j][k] && j + i > 9) { as[j][i]++, as[j][k]--, tb[i]--, tb[k]++; goto _BREAK_; }
}
_BREAK_ : break;
}
print();
return 0;
}



#include <bits/stdc++.h>
using namespace std;
#include<atcoder/all>
using namespace atcoder;
using ll = long long;
#define FOR(i,a,b) for(ll i=a;i<b;i++)
#define FORD(i,a,b) for(ll i=a;i>b;i--)
#define ALL(a)  (a).begin(),(a).end()
#define SZ(a) int((a).size())
#define SORT(c) sort((c).begin(),(c).end()) //昇順(小さい順)に並び替える
#define SORTD(c) sort((c).rbegin(),(c).rend()) //降順(大きい順)に並び替える
#define MEMSET(v, h) memset((v), h, sizeof(v))
#define sqr(x) ((x) * (x))
#define bit(n) (1LL<<(n))
#define pcnt(x) __builtin_popcountll(x)
#define PB push_back
#define MP make_pair
#define endl "\n"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！
using Edge = pair<int,int>;
using Graph = vector<vector<Edge>>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

int main() {
int T;
cin >> T;
FOR(i,0,T){
ll n;
cin >> n;
if(n%4==0) cout << "Even" << endl;
else if(n%2==0) cout << "Same" << endl;
else if(n%2!=0) cout << "Odd" << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i, k, n) for(int i = k; i < n; i++)
#define MAX_N 110000
typedef long long ll;
typedef pair<ll, ll> P;
const ll INF = 100000000000;
using Graph = vector<vector<ll>>;
using Field = vector<vector<char>>;

int main(void) {
int h, w;
cin >> h >> w;
Field g(h, vector<char>(w));
rep(i, 0, h) {
rep(j, 0, w) {
cin >> g[i][j];
}
}

int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};
rep(i, 0, h) {
rep(j, 0, w) {
int c[6] = {};
if(g[i][j] == '.') {
rep(k, 0, 4) {
int nx = i+dx[k], ny = j+dy[k];
if(0 <= nx && nx < h && 0 <= ny && ny < w && g[nx][ny] != '.') {
c[g[nx][ny]-'0'] = 1;
}
}

rep(l, 1, 6) {
if(c[l] == 0) {
g[i][j] = l + '0';
break;
}
}
}
}
}

rep(i, 0, h) {
rep(j, 0, w) {
cout << g[i][j];
}
cout << endl;
}

return 0;
}
#include <atcoder/all>
using namespace atcoder;
#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define all(v) v.begin(),v.end()
#define inc(x,l,r) ((l)<=(x)&&(x)<(r)) 
#define Unique(x) sort(all(x)), x.erase(unique(all(x)), x.end())
typedef long long ll;
#define int ll
using ld = long double;
using vi = vector<int>;
using vs = vector<string>;
using P = pair<int,int>;
using vp = vector<P>;
template<typename T> using priority_queue_greater = priority_queue<T, vector<T>, greater<T>>;
template<typename T> ostream &operator<<(ostream &os,const vector<T> &v){rep(i,v.size())os<<v[i]<<(i+1!=v.size()?" ":"");return os;}
template<typename T> istream &operator>>(istream& is,vector<T> &v){for(T &in:v)is>>in;return is;}
template<class... T> void in(T&... a){(cin>> ... >> a);}
template<class T> void out(T& a){cout <<a<< '\n';}
template<class T,class... Ts> void out(const T&a, const Ts&... b){cout<< a;(cout<<...<<(cout<<' ',b));cout<<'\n';}
#define INT(...) int __VA_ARGS__; in(__VA_ARGS__)
#define STR(...) string __VA_ARGS__; in(__VA_ARGS__)
#define pcnt __builtin_popcount
int ceil(int x,int y){return x/y+!!(x%y);}
bool ins(string s,string t){return s.find(t)!=string::npos;}
P operator+ (const P &p, const P &q){ return P{p.first+q.first,p.second+q.second};}
P operator- (const P &p, const P &q){ return P{p.first-q.first,p.second-q.second};}
ostream &operator<< (ostream &os, const P &p){os << p.first <<" "<<p.second;return os;}
ostream &operator<< (ostream &os, const modint1000000007 &m){os << m.val();return os;}
ostream &operator<< (ostream &os, const modint998244353 &m){os << m.val();return os;}
template<typename T> bool chmax(T &a, const T b) {if (a < b) {a = b; return true;} else return false; }
template<typename T> bool chmin(T &a, const T b) {if (a > b) {a = b; return true;} else return false; }
void yesno(bool ok){ cout<<(ok?"Yes":"No")<<endl;}
vector<P> dxdy{{1,0},{0,1},{-1,0},{0,-1}};
const int INF = 1e18;
//using mint = modint1000000007;
using mint = modint998244353;

signed main() {
cin.tie(0);
ios_base::sync_with_stdio(false);
cout << fixed << setprecision(20);

int h,w;cin>>h>>w;
vs s(h);
cin>>s;
string t = ".RB";
vi b(h+w);
rep(i,h)rep(j,w){
rep(k,3)if(s[i][j]==t[k]){
b[i+j]|=(1<<k);
}
}
mint ans = 1;
for(auto e:b){
if((e&6)==6)ans=0;
else if(e==1)ans*=2;
}

cout << ans <<endl;
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
#define rep(i, t) for(long long i = (0); i < (t); i++)
#define repd(i, s, t) for(long long i = (s); i <= (t); i++)
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define isin(x, l, r) ((l) <= (x) && (x) < (r));
#define uni(x) x.erase(unique(all(x)), x.end())
#define show(x) cerr<<#x<<" = "<<x<<endl;
#define priv(x) for(int i = 0; i < (x.size()); i++) if(i == x.size()-1) cout << x[i] << endl; else cout << x[i] << " ";
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
template<typename T> bool chmax(T &a, T b) {if(a < b) {a = b; return true;} return false;}
template<typename T> bool chmin(T &a, T b) {if(a > b) {a = b; return true;} return false;}
#define dame { puts("-1"); return 0; }
const ll MOD = 1e9+7;
const ll INF = 1e18;
const int iINF = 1001001001;


int main() {
int n; ll k; cin >> n >> k;
vector<ll> a(n);
rep(i, n) cin >> a[i];

sort(all(a));

ll s = 0;
for(ll v : a) s += a.back() - v;

if(s <= k) {
ll ans = a.back();
k -= s;
ans += k / n;
cout << ans << endl;
} else {
ll ans = 1;

ll tot = 0;
for(ll v : a) tot += v;

for(ll x = 2; x <= a.back(); x++) {
ll del = tot;
ll sum = 0;
for(ll k = a[0] / x; k <= a.back() / x; k++) {
int c = lower_bound(all(a), (k + 1) * x) - lower_bound(all(a), k * x);
int d = upper_bound(all(a), k * x) - lower_bound(all(a), k * x);
del -= k * x * d;
sum += (k + 1) * x * (c - d);
}
if(sum - del <= k) {
// cout << x << " " <<sum - tot << endl;
ans = x;
}
}

cout << ans << endl;
}
}
#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <tuple>
#include <vector>

using namespace std;

#define endl "\n"

// clang-format off
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }
#ifdef MIPPON_LOCAL
#define dbg(...) cerr <<"\e[38;5;214m" << "(" << #__VA_ARGS__ << "):" << "\e[39m", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif

// clang-format on

template <typename T, typename T_compare>
int longest_increasing_subsequence(const vector<T> &values, T_compare &&compare) {
vector<T> best_ending;
for (T value : values) {
auto it = lower_bound(best_ending.begin(), best_ending.end(), value, compare);
if (it == best_ending.end())
best_ending.push_back(value);
else
*it = value;
}
dbg(best_ending);

return int(best_ending.size());
}
void run_case() {

int N, M;
cin >> N >> M;

vector<pair<int, int>> P;
for (int i = 0; i < M; i++) {
int p1, p2;
cin >> p1 >> p2;
P.push_back({p1, -p2});
}
sort(P.begin(), P.end());

vector<int> LIS;
for (int i = 0; i < (int)P.size(); i++) {
LIS.push_back(P[i].second);
}
cout << longest_increasing_subsequence(LIS, greater<int>()) << endl;
dbg(P);
}
int main() {
ios::sync_with_stdio(false);
#ifndef MIPPON_LOCAL
cin.tie(nullptr);
#endif

// int tests;
// cin >> tests;
// while (tests-- > 0)
run_case();

return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(ll i=0;i<n;i++)
#define repl(i,l,r) for(ll i=(l);i<(r);i++)
#define per(i,n) for(ll i=(n)-1;i>=0;i--)
#define perl(i,r,l) for(ll i=r-1;i>=l;i--)
#define fi first
#define se second
#define pb push_back
#define ins insert
#define pqueue(x) priority_queue<x,vector<x>,greater<x>>
#define all(x) (x).begin(),(x).end()
#define CST(x) cout<<fixed<<setprecision(x)
#define vtpl(x,y,z) vector<tuple<x,y,z>>
#define rev(x) reverse(x);
using ll=long long;
using vl=vector<ll>;
using vvl=vector<vector<ll>>;
using pl=pair<ll,ll>;
using vpl=vector<pl>;
using vvpl=vector<vpl>;
const ll MOD=1000000007;
const ll MOD9=998244353;
const int inf=1e9+10;
const ll INF=4e18;
const ll dy[9]={0,1,-1,0,1,1,-1,-1,0};
const ll dx[9]={1,0,0,-1,1,-1,1,-1,0};
template<class T> inline bool chmin(T& a, T b) {
if (a > b) {
a = b;
return true;
}
return false;
}
template<class T> inline bool chmax(T& a, T b) {
if (a < b) {
a = b;
return true;
}
return false;
}
int main(){
ll n;cin >> n;
//if(n>=5000)return 0;
vl v(n);rep(i,n)cin >> v[i];
ll ok=inf,ng=0;
if(n==2){
cout << (v[1]-v[0]+1)/2 << endl;
return 0;
}
while(ok-ng>1){
ll mid=(ok+ng)/2;
vl dp(n);
set<ll> st;
rep(i,n)st.insert(i);
rep(i,n){
if(i>=2&&v[i]-v[0]<=mid*2){
dp[i]=1;
st.erase(i);
}
}
rep(i,n-1){
if(!dp[i+1])continue;
/*for(int j=i+3;j<n;j++){
if(v[j]-v[i]<=mid*2)dp[j]=1;
}*/
if(i+3<n){
auto itr=st.lower_bound(i+3);
while(itr!=st.end()){
ll idx=*itr;
if(v[idx]-v[i]<=mid*2){
dp[idx]=1;
itr=st.erase(itr);
}
else break;
}
}
}
bool flag=dp[n-1];
repl(i,1,n){
if(dp[i]&&v[n-1]-v[i-1]<=mid*2)flag=true;
}
if(flag)ok=mid;
else ng=mid;
}
cout << ok << endl;
} 

#line 1 "Contests/AtCoder_arc116/arc116_a/main.cpp"
/* #define aclmodint */
/* #define aclsegtree */
/* #include <atcoder/all> */
/* using namespace atcoder; */

#line 1 "library/me/template.cpp"
// This is a dummy line
#ifndef ONLINE_JUDGE
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()
#define END(...) { print(__VA_ARGS__); return; }

#ifdef ONLINE_JUDGE
#define DBG(...) {}
#else
#define DBG(a) { cerr << #a << ": "; dbg(a); }
#endif

using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using ll = long long;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VS = vector<string>;
using VVS = vector<VS>;
using VVVS = vector<VVS>;
using VC = vector<char>;
using VVC = vector<VC>;
using VVVC = vector<VVC>;
using P = pair<int, int>;
using VP = vector<P>;
using VVP = vector<VP>;
using VVVP = vector<VVP>;
using LP = pair<ll, ll>;
using VLP = vector<LP>;
using VVLP = vector<VLP>;
using VVVLP = vector<VVLP>;
constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

#ifdef aclmodint

using MI7 = modint1000000007;
using V7 = vector<MI7>;
using VV7 = vector<V7>;
using VVV7 = vector<VV7>;
using MI3 = modint998244353;
using V3 = vector<MI3>;
using VV3 = vector<V3>;
using VVV3 = vector<VV3>;

ostream &operator<<(ostream &os, const modint &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI3 &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI7 &x) {
os << x.val();
return os;
}

istream &operator>>(istream &is, modint &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI3 &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI7 &x) {
int y; is >> y;
x = y;
return is;
}

#endif

void print() { cout << '\n'; }
template<typename T>
void print(const T &t) { cout << t << '\n'; }
template<typename Head, typename... Tail>
void print(const Head &head, const Tail &... tail) {
cout << head << ' ';
print(tail...);
}

#ifdef ONLINE_JUDGE
template<typename... Args>
void dbg(const Args &... args) {}
#else
void dbg() { cerr << '\n'; }
template<typename T>
void dbg(const T &t) { cerr << t << '\n'; }
template<typename Head, typename... Tail>
void dbg(const Head &head, const Tail &... tail) {
cerr << head << ' ';
dbg(tail...);
}
#endif

template< typename T1, typename T2 >
ostream &operator<<(ostream &os, const pair< T1, T2 >& p) {
os << p.first << " " << p.second;
return os;
}

template< typename T1, typename T2 >
istream &operator>>(istream &is, pair< T1, T2 > &p) {
is >> p.first >> p.second;
return is;
}

template< typename T >
ostream &operator<<(ostream &os, const vector< T > &v) {
for(int i = 0; i < (int) v.size(); i++) {
os << v[i] << (i + 1 != (int) v.size() ? " " : "");
}
return os;
}

template< typename T >
istream &operator>>(istream &is, vector< T > &v) {
for(T &in : v) is >> in;
return is;
}

template< typename T1, typename T2 >
inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

template< typename T1, typename T2 >
inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

template <typename T>
pair<VI, vector<T>> compress(const vector<T> &a) {
int n = a.size();
vector<T> x;
REP(i, n) x.push_back(a[i]);
sort(ALL(x)); x.erase(unique(ALL(x)), x.end());
VI res(n);
REP(i, n) res[i] = lower_bound(ALL(x), a[i]) - x.begin();
return make_pair(res, x);
}

#ifdef aclsegtree

template<typename S>
struct value_size { S value; int size; };

template<typename S>
S min_op(S l, S r) { return min(l, r); };
template<typename S>
S max_op(S l, S r) { return max(l, r); };
template<typename S>
S sum_op(S l, S r) { return l + r; };
template<typename S>
value_size<S> sum_op_size(value_size<S> l, value_size<S> r) {
return {l.value + r.value, l.size + r.size};
};

template<typename S>
S min_e() { return  numeric_limits<S>::max(); };
template<typename S>
S max_e() { return numeric_limits<S>::min(); };
template<typename S>
S sum_e() { return 0; }
template<typename S>
value_size<S> sum_e_size() { return {0, 0}; }
template<typename S>
value_size<S> min_e_size() { return {numeric_limits<S>::max(), 0}; }
template<typename S>
value_size<S> max_e_size() { return {numeric_limits<S>::min(), 0}; }

template<typename S, typename F>
S chmin_mapping(F f, S x) { return min(x, f); }
template<typename S, typename F>
S chmax_mapping(F f, S x) { return max(x, f); }
template<typename S, typename F>
S add_mapping(F f, S x) { return x + f; }
template<typename S, typename F>
value_size<S> add_mapping_size(F f, value_size<S> x) {
return {x.value + x.size * f, x.size};
}
template <typename S,typename F, F ID>
S change_mapping(F f, S x) { return (f == ID? x : f); }
template <typename S,typename F, F ID>
S change_mapping_size(F f, value_size<S> x) { return (f == ID? x : value_size<S>(f, x.size)); }
template <typename S, typename F1, typename F2>
S linear_mapping(pair<F1, F2> f, S x) { return x * f.first + f.second; }
template <typename S, typename F1, typename F2>
value_size<S> linear_mapping_size(pair<F1, F2> f, value_size<S> x) { return {x.value * f.first + x.size * f.second, x.size}; }

template<typename F>
F chmin_composition(F f, F g) { return min(f, g); }
template<typename F>
F chmax_composition(F f, F g) { return max(f, g); }
template<typename F>
F add_composition(F f, F g) { return f + g; }
template <typename F, F ID>
F change_composition(F f, F g) { return (f == ID? g : f); }
template<typename F1, typename F2>
pair<F1, F2> linear_composition(pair<F1, F2> f, pair<F1, F2> g) { return {f.first * g.first, f.first * g.second + f.second}; }

template<typename F>
F chmin_id() { return numeric_limits<F>::max(); }
template<typename F>
F chmax_id() { return numeric_limits<F>::min(); }
template<typename F>
F add_id() { return 0; }
template<typename F, F ID>
F change_id() { return ID; }
template<typename F1, typename F2>
pair<F1, F2> linear_id() { return {1, 0}; }

template<typename S>
using RSumQ = segtree<S, sum_op<S>, sum_e<S>>;
template<typename S>
using RMaxQ = segtree<S, max_op<S>, max_e<S>>;
template<typename S>
using RMinQ = segtree<S, min_op<S>, min_e<S>>;

template<typename S, typename F>
using RAddSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, add_mapping_size<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RMinMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, chmin_mapping<S, F>, chmin_composition<F>, chmin_id<F>>;
template<typename S, typename F>
using RMaxMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, chmax_mapping<S, F>, chmax_composition<F>, chmax_id<F>>;
template<typename S, typename F, F ID>
using RChangeMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, change_mapping_size<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F1, typename F2>
using RLinearMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
pair<F1, F2>, linear_mapping_size<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
#endif
#line 7 "Contests/AtCoder_arc116/arc116_a/main.cpp"

void solve(){
ll n; cin >> n;
int cnt = 0;
while(n % 2 == 0) {
cnt++;
n /= 2;
}
if(cnt == 0) print("Odd");
else if(cnt == 1) print("Same");
else print("Even");
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

#include <iostream>
#include <string>

int main()
{
int N;
long sum, sum_s, count;
sum = 0;
sum_s = 0;
count = 0;
std::string S;
std::cin >> N >> S;
for (int i = 0; i < N - 1; i++)
{
if (S.at(i) == S.at(i + 1))
{
if (count >= 1)
{
count++;
sum_s += count;
}
else
{
sum_s = 1;
count = 1;
}
if (i == N - 2)
{
sum += sum_s;
std::cout << sum << std::endl;
return 0;
}
}
else
{
sum += sum_s;
count = 0;
sum_s = 0;
}
}
std::cout << sum << std::endl;
}
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <deque>
#include <queue>
#include <iomanip>
#include <random>
#include <stack>
#include <chrono>
#include <ctime>
#include <unordered_set>
#include <unordered_map>
#include <cstring>
#include <bitset>
#include <numeric>
#include <cassert>
using namespace std;

typedef long long ll;
typedef long double ldb;
typedef double db;

#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sqr(a) ((a) * (a))
#define un(a) a.resize(unique(all(a)) - a.begin())
#define fixed fixed << setprecision(21)
#define sz(a) (int)a.size()

const int INF = 1e9;
const ll lINF = 1e18;
const int Mod = (int)(1e9) + 7;
const int atMod = 998244353;

//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
//uniform_int_distribution<int> gen(1, 10000); // change

template <typename T>
istream& operator>> (istream &in, vector<T>& v) {
for (auto& i : v)
cin >> i;
return in;
}

template <typename T>
ostream& operator<< (ostream &out, vector<T>& v) {
for (auto& i : v)
out << i << ' ';
return out;
}

// I WISH YOU GOODLUCK)

void solve() {
int n;
cin >> n;
vector<int> a(n);
cin >> a;

vector<int> u = a;
un(u);
if (sz(u) == 1)
return;

int i = 0;
while (i + 1 < n && a[i] <= a[i + 1])
i++;

if (i == n - 2 && a[i] <= a[i + 1])
i++;

int del = a[i];
for (int i = 0; i < n; i++)
if (a[i] != del)
cout << a[i] << ' ';
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);

int t = 1;
//cin >> t;
while (t--) {
solve();
}

//system("pause");
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main(){
int n,m;
cin>>n>>m;
vector<string> s(n);
for (int i = 0; i < n; ++i) cin >> s[i];
vector<int> vec(n, 0);
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
if (s[i][j] == '1') vec[i]++;
}
}
ll even=0,odd=0;
for (int i=0;i<n;++i){
if(vec[i]%2 == 0) even++;
else odd++;
}
cout << odd*even << endl;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define all(x) x.begin(),x.end()

int main(){
int n, x;
string s;
cin>>n>>s;
ll sum = 0;
for(int i=0; i<n-1; i++){
x = 1;
while(s[i] == s[i+x]){
sum+=x;
x++;
}
i+=x-1;
}
cout<<sum<<endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll inf=10010010011001001;
ll mod=1000000007;
int main(){
ll n,m;
cin >> n >> m;
ll ki=0,gu=0;
ll ans=0;
for (ll i = 0; i < n; i++)
{
string s;
cin >> s;
ll z=0;
for (ll j = 0; j < s.size(); j++)
{
if (s[j]=='0')
{
z+=1;
}
}
if (z%2==0)
{
ans+=ki;
gu+=1;
}else{
ans+=gu;
ki+=1;
}
}
cout << ans << endl;
}
#include <stdio.h>
#include <sstream>
#include <string.h>
#include <vector>
#include <map>
#include <algorithm>
#include <utility>
#include <set>
#include <cctype>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <deque>
#include <limits>
#include <iomanip>
#include <ctype.h>
#include <unordered_map>
#include <random>
#include <numeric>
#include <iostream>
#include <array>

#define _USE_MATH_DEFINES
#include <iostream>
#include <math.h>
#include <bitset>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ll, double> pld;
typedef pair<double, double> pdd;
typedef pair<double, ll> pdl;
typedef pair<int, char> pic;
typedef vector<ll> vl;
typedef vector<pll> vpll;
typedef vector<int> vi;
typedef vector<string> table;
typedef priority_queue<ll, vector<ll>, greater<ll>> llgreaterq;
typedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;
typedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;
typedef priority_queue<vi, vector<vi>, greater<vi>> vigreaterq;
typedef priority_queue<vl, vector<vl>, greater<vl >> vlgreaterq;
typedef vector<vl> mat;
typedef vector<mat> thd;
template <class o, class p, class q>
using tuple3q = priority_queue<tuple<o, p, q>, vector<tuple<o, p, q>>, greater<tuple<o, p, q>>>;
template <class o, class p, class q, class r>
using tuple4q = priority_queue<tuple<o, p, q, r>, vector<tuple<o, p, q, r>>, greater<tuple<o, p, q, r>>>;
template <class o, class p, class q, class r, class s>
using tuple5q = priority_queue<tuple<o, p, q, r, s>, vector<tuple<o, p, q, r, s>>, greater<tuple<o, p, q, r, s>>>;
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
#define bit(x,v) ((ll)x << v)
#define rep(x,n) for(ll x = 0;x < n;x++)
#define rep2(x,f,v) for(ll x=f;x<v;x++)
#define repe(v,x) for(auto v : x)
// 許容する誤差ε
#define EPS (1e-10)
// 2つのスカラーが等しいかどうか
#define EQ(a,b) (std::abs(a-b) < EPS)
// 2つのベクトルが等しいかどうか
#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )
#define all(a) a.begin(),a.end()
#define all0(a) memset(a,0,sizeof(a))
#define allm1(a) memset(a,-1,sizeof(a))
#define set_float() cout << fixed << setprecision(10);
#define coutl(s) cout <<s <<endl;
#define pln(s) cout<<s<<"\n";
#define put_float(v) 	set_float() \
pln(v)
#define vinsert(v,p,x) v.insert(v.begin() + p,x)
#define vsort(v) sort(all(v));
#define vdesc(v) vsort(v); \
reverse(all(v))
#define dup(v) v.erase(unique(all(v)),v.end())
#define ion(i,j) ((i & (1LL << j)) > 0)
#define next(i) i++;i%=2
#define Len size()
#define psp(a,b) push_back(make_pair(a,b))
#define psp2(a,b) push(make_pair(a,b))
#define cini(a) a; cin >> a
#define infa(a,b) (a + b) % INF
#define infm(a,b) (a * b) % INF
#define infd(a,b) (a * INFinv(b)) % INF
#define infs(a,b) (a + INF - inff(b)) % INF
#define inf(a) (a) %= INF
#define inff(a) ((a + INF) % INF)
#define No cout << "No" << endl
#define Yes cout << "Yes" << endl
#define NO cout << "NO" << endl
#define YES cout << "YES" << endl
#define smal -INF*INF
#define big INF*INF
#define frontpop(q) q.front();q.pop()
#define toppop(q) q.top();q.pop()
#define arr(a,s) a[s]; all0(a);
#define nxt(cu) (cu+1) % 2 
#define chkover(x,y,h,w) (x<0||y<0||x>=h||y>=w)
ll n, m;

bool chmin(ll& a, ll b) { if (a > b) { a = b; return 1; } return 0; }
ll INF = 1000000007;
const int MAX = 2000010;
void cout2(ll val) {
if (val == big) {
pln(-1);
}
else {
pln(val);
}
}
string padleft(string x, ll dig, char c) {
ll si = x.size();
for (ll i = 0; i < dig - si; i++)
{
x = c + x;
}
return x;
}
long long fac[MAX], finv[MAX], inv[MAX];
void COMinit() {
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++) {
fac[i] = fac[i - 1] * i % INF;
inv[i] = INF - inv[INF % i] * (INF / i) % INF;
finv[i] = finv[i - 1] * inv[i] % INF;
}
}

// 二項係数計算
long long COM(int n, int k) {
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % INF) % INF;
}

ll getpow(ll b, ll x, ll md) {
ll t = b % md;
ll res = 1;
while (x > 0)
{
if (x & 1) {
res *= t;
res %= md;
}
x >>= 1;
t *= t;
t %= md;
}
return res % md;
}
ll getpow(ll b, ll x) {

return getpow(b, x, INF);
}
/// 素数を法とする場合
ll modinv(ll x) {
return getpow(x, INF - 2);
}

ll extgcd(ll a, ll b, ll& x, ll& y) {
ll d = a;
if (b != 0) {
d = extgcd(b, a % b, y, x);
y -= (a / b) * x;
}
else {
x = 1; y = 0;
}
return d;
}

/// <summary>
/// 素数を法としない場合
/// </summary>
/// <param name="a"></param>
/// <param name="m"></param>
/// <returns></returns>
ll modinv(ll a, ll m) {
ll x, y;
extgcd(a, m, x, y);
return (m + x % m) % m;
}

ll gcd(ll a, ll b) {
if (b == 0) return a;
return gcd(b, a % b);
}

class mint {
public:
long long x = 0;
mint(ll x = 0) {
this->x = (x % INF + INF) % INF;
}
mint operator-() const {
return mint(-x);
}
mint& operator+=(const mint& a) {
if ((x += a.x) >= INF) x -= INF;
return *this;
}
mint& operator-=(const mint& a) {
if ((x += INF - a.x) >= INF) x -= INF;
return *this;
}
mint& operator*=(const  mint& a) {
(x *= a.x) %= INF;
return *this;
}
mint operator+(const mint& a) const {
mint res(*this);
return res += a;
}
mint operator-(const mint& a) const {
mint res(*this);
return res -= a;
}
mint operator*(const mint& a) const {
mint res(*this);
return res *= a;
}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t >> 1);
a *= a;
if (t & 1) a *= *this;
return a;
}
// for prime INF
mint inv() const {
return pow(INF - 2LL);
}
mint& operator/=(const mint& a) {
return (*this) *= a.inv();
}
mint operator/(const mint& a) const {
mint res(*this);
return res /= a;
}

friend ostream& operator<<(ostream& os, const mint& m) {
os << m.x;
return os;
}
};
typedef vector<mint> vml;
typedef vector<vml> matm;
// Union find
vl pr;
vl lank;
vl udpt;
void uini(int _n) {
_n++; // 一個拡張しておく
pr = vl(_n + 1);
lank = vl(_n + 1);
udpt = vl(_n + 1, 0);
for (ll i = 0; i <= _n; i++)
{
pr[i] = i;
lank[i] = 1;
}
}

int parent(int x) {
if (x == pr[x]) return x;
auto paren = parent(pr[x]);
udpt[x] = udpt[paren] + 1;
return pr[x] = paren;
}

int same(int x, int y) {
return parent(x) == parent(y);
}

bool unit(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}

bool unitm(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
/// <summary>
/// 数字の小さい方を親にするように処理
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
bool unitlow(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;

if (py < px) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
ll wit[500010];
map<ll, ll> mp[100010];
ll parent2(ll x) {
if (x == pr[x]) return x;
// 元々の親から変わっている時、wit[pr[x]]には親からの距離が入っている
// 同じところを二度通らないので大丈夫なはず
ll o = pr[x];
pr[x] = parent2(o);
wit[x] += wit[o]; // 親の重みを足す
return pr[x];
}
int same2(int x, int y) {
return parent2(x) == parent2(y);
}
bool relate(int x, int y, int v) {

auto px = parent2(x);
auto py = parent2(y);
// 自分の距離が取れる
ll xd = wit[x];
ll yd = wit[y];
// ↑のydにvを足した値とxdを比較する
// yd+v> xdであれば、pyが親となる
// yの直接の親はxとしてしまう?
// wit[y] = v;
if (px == py)
return false;
if (xd + v > yd) {
pr[py] = px;

wit[py] = xd + v - yd; // 親同士の距離を入れておく
}
else {
pr[px] = py;
wit[px] = yd - (xd + v);
}
return true;
}

int ci = 0;
struct Node {
int key = 0;
int priority;
Node* parent, * left, * right;
Node(int key, int priority);
Node() {}
};
Node NIL;
Node::Node(int key, int priority) : key(key), priority(priority) {
left = &NIL;
right = &NIL;
}
Node* root = new Node();
void cenrec(Node* k) {
if (k->key == NIL.key) return;
cenrec(k->left);
cout << " " << k->key;
cenrec(k->right);
}
void fastrec(Node* k)
{
if (k->key == NIL.key) return;
cout << " " << k->key;
fastrec(k->left);
fastrec(k->right);
}
void insert(Node* v) {
Node* y = &NIL;
Node* x = root;
while (x->key != NIL.key)
{
y = x;
if (v->key < x->key) {
x = x->left;
}
else {
x = x->right;
}
}
v->parent = y;
if (y->key == NIL.key) {
root = v;
}
else if (v->key < y->key) {
y->left = v;
}
else {
y->right = v;
}

}

Node* find(Node* k, ll v)
{
if (k->key == NIL.key) return &NIL;
if (k->key == v) return k;
if (v < k->key) return find(k->left, v);
return find(k->right, v);
}
void delp12(Node* x) {
if (x->key == NIL.key)  return;
Node* l = x->left;
Node* r = x->right;
Node* pr = x->parent;

if (l->key == NIL.key
&& r->key == NIL.key) {
if (pr->left == x) {
pr->left = &NIL;
}
else pr->right = &NIL;
}
else if (l->key != NIL.key) {
if (pr->left == x) {
pr->left = l;
}
else pr->right = l;
l->parent = pr;
}
else if (r->key != NIL.key) {
if (pr->left == x) {
pr->left = r;
}
else pr->right = r;
r->parent = pr;
}
}
Node* get_next(Node* k) {
if (k->key == NIL.key) return &NIL;
Node* res = get_next(k->left);
if (res->key != NIL.key) return res;
return k;
}
void del(Node* x) {

if (x->key == NIL.key) return;
Node* l = x->left;
Node* r = x->right;

if (l->key != NIL.key && r->key != NIL.key) {
Node* nex = get_next(r);
x->key = nex->key;
delp12(nex);
}
else {
delp12(x);
}
}
Node* rightRotate(Node* t) {
Node* s = t->left;
t->left = s->right;
s->right = t;
return s;
}
Node* leftRotate(Node* t) {
Node* s = t->right;
t->right = s->left;
s->left = t;
return s;
}
Node* _insert(Node* t, int key, int priority) {
if (t->key == NIL.key) {
return new Node(key, priority);
}
if (key == t->key) {
return t;
}

if (key < t->key) {
t->left = _insert(t->left, key, priority);
if (t->priority < t->left->priority) {
t = rightRotate(t);
}
}
else {
t->right = _insert(t->right, key, priority);
if (t->priority < t->right->priority) {
t = leftRotate(t);
}
}
return t;
}
Node* delete1(Node* t, int key);
Node* _delete(Node* t, int key) {
if (t->left->key == NIL.key && t->right->key == NIL.key) {
return &NIL;
}
else if (t->left->key == NIL.key) {
t = leftRotate(t);
}
else if (t->right->key == NIL.key) {
t = rightRotate(t);
}
else
{
if (t->left->priority > t->right->priority) {
t = rightRotate(t);
}
else
t = leftRotate(t);
}
return delete1(t, key);
}
Node* delete1(Node* t, int key) {
if (t->key == NIL.key) {
return &NIL;
}
if (key < t->key) {
t->left = delete1(t->left, key);
}
else if (key > t->key) {
t->right = delete1(t->right, key);
}
else return _delete(t, key);
return t;
}
int H;
int left(int i) {
return i * 2 + 1;
}
int right(int i) {
return i * 2 + 2;
}
class edge {
public:
int from, to, i;
ll val;
ll cap, rev;
edge() {}
edge(ll to) : to(to) {}
edge(ll to, ll i) : to(to), i(i) {}
edge(ll from, ll to, ll val) : from(from), to(to), val(val) {}
void flowEdge(ll _to, ll _cap, ll _rev) {
to = _to;
cap = _cap;
rev = _rev;
}
};
typedef vector<vector<edge>> vve;

class LCA {
private:
vector<vector<edge>> v;
vector<vector<int>> parent;
vector<int> depth;
ll root;
void dfs(int n, int m, int d) {
parent[0][n] = m;
depth[n] = d;
for (auto x : v[n]) {
if (x.to != m) dfs(x.to, n, d + 1);
}
}
public:
LCA(ll N, ll root, vector<vector<edge>>& tree) {
v = tree;
this->root = root;
parent = vector<vector<int>>(21, vector<int>(N + 1, 0));
depth = vector<int>(N + 1, 0);
dfs(root, -1, 0);
for (int j = 0; j + 1 < 20; j++) {
for (int i = 1; i <= N; i++) {
if (parent[j][i] < 0) parent[j + 1][i] = -1;
else parent[j + 1][i] = parent[j][parent[j][i]];
}
}
}
int lca(int n, int m) {
if (depth[n] > depth[m]) swap(n, m);
if (n == root)
return root;
for (int j = 0; j < 20; j++) {
if ((depth[m] - depth[n]) >> j & 1) m = parent[j][m];
}
if (n == m) return n;
for (int j = 19; j >= 0; j--) {
if (parent[j][n] != parent[j][m]) {
n = parent[j][n];
m = parent[j][m];
}
}
return parent[0][n];
}
int dep(int n) { return depth[n]; }
};
ll k;
int _rank[1010];
int temp[1010];
bool compare_sa(int i, int j) {
if (_rank[i] != _rank[j]) return _rank[i] < _rank[j];
else {
int ri = i + k <= n ? _rank[i + k] : -1;
int rj = j + k <= n ? _rank[j + k] : -1;
return ri < rj;
}
}
void construct_sa(string S, int* sa) {
n = S.length();

for (ll i = 0; i <= n; i++)
{
sa[i] = i;
_rank[i] = i < n ? S[i] : -1;
}

for (k = 1; k <= n; k *= 2)
{
sort(sa, sa + n + 1, compare_sa);

// saはソート後の接尾辞の並びになっている、rankは元の位置のindexを保持したまま、更新されている。
// ピンとこなかった部分
temp[sa[0]] = 0;
for (ll i = 1; i <= n; i++)
{
temp[sa[i]] = temp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);
}
for (ll i = 0; i <= n; i++)
{
_rank[i] = temp[i];
}
}
}
bool contain(string S, int* sa, string T) {
int a = 0, b = S.length();
// sa は 接尾辞が辞書順に並んでいる、入っているのはその位置のインデックス
while (b - a > 1) {
int c = (a + b) / 2;
if (S.compare(sa[c], T.length(), T) < 0) a = c;
else b = c;
}
return S.compare(sa[b], T.length(), T) == 0;
}


#define bit(x,v) ((ll)x << v)

class BIT {

static const int MAX_N = 500010;
public:
BIT() { memset(bit, 0, sizeof(bit)); }
ll bit[MAX_N + 1], n;
ll sum(int i) {
ll s = 0;
while (i > 0)
{
s += bit[i];
i -= i & -i;
}
return s;
}

void add(int i, int x) {
while (i <= n)
{
bit[i] += x;
i += i & -i;
}
}


};
struct UnionFind {
vector<int> A;
UnionFind(int n) : A(n, -1) {}
int find(int x) {
if (A[x] < 0) return x;
return A[x] = find(A[x]);
}
void unite(int x, int y) {
x = find(x), y = find(y);
if (x == y) return;
if (A[x] > A[y]) swap(x, y);
A[x] += A[y];
A[y] = x;
}
int ngroups() {
int ans = 0;
for (auto a : A) if (a < 0) ans++;
return ans;
}
};
vector<ll> getp(ll n) {

vector<ll> res;
if (n % 2 == 0) {
res.push_back(2);
while (n % 2 == 0)n /= 2;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(i);
while (n % i == 0)n /= i;
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<ll> getp2(ll n) {

vector<ll> res;
if (n % 2 == 0) {

while (n % 2 == 0) { n /= 2; res.push_back(2); }
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {

while (n % i == 0) { n /= i; res.push_back(i); }
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<pll> getp3(ll n) {
vector<pll> res;
int si = 0;
if (n % 2 == 0) {

res.push_back(make_pair(2, 0));
while (n % 2 == 0) { n /= 2; res[si].second++; }
si++;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(make_pair(i, 0));
while (n % i == 0) { n /= i; res[si].second++; }
si++;
}
}
if (n != 1) { res.push_back(make_pair(n, 1)); }
return res;
}

vector<ll> getDivisors(ll n) {

vector<ll> res;
res.push_back(1);
for (ll i = 2; i * i <= n; i++)
{

if (n % i == 0) {
res.push_back(i);
if (n / i != i)
res.push_back(n / i);
}
}
return res;
}

struct ve {
public:
vector<ve> child;
int _t = INF;
ve(int t) :_t(t) {}
ve(ve _left, ve _right) {
_t = _left._t + _right._t;
child.push_back(_left);
child.push_back(_right);
}
bool operator<(const ve& t) const {
return _t > t._t;
}
};

vector<bool> elas(ll n) {
n++;
vector<bool> r(n, 1);
r[0] = 0;
r[1] = 0;
ll tw = 4;
while (tw < n) {
r[tw] = false;
tw += 2;
}
ll th = 6;
while (th < n) {
r[th] = false;
th += 3;
}
ll fv = 10;
while (fv < n) {
r[fv] = false;
fv += 5;
}

for (ll i = 6; i * i < n; i += 6)
{
ll bf = i - 1;
if (r[bf]) {
ll ti = bf * 2;
while (ti < n)
{
r[ti] = false;
ti += bf;
}
}
ll nx = i + 1;
if (r[nx]) {
ll ti = nx * 2;
while (ti < n)
{
r[ti] = false;
ti += nx;
}
}
}
return r;
}
bool isPrime(ll v) {
for (ll i = 2; i * i <= v; i++)
{
if (v % i == 0) return false;
}
return true;
}


class SegTree {

public:
const static int MAX_N = 1000100;
const static int DAT_SIZE = (1 << 20) - 1;
int N, Q;
int A[MAX_N];
ll MAX = big;

ll data[DAT_SIZE], datb[DAT_SIZE];
void init(int _n) {
N = 1;
while (N < _n) N <<= 1;
memset(data, 0, sizeof(data));
memset(datb, 0, sizeof(datb));
}
void init(int _n, ll iv) {
N = 1;
while (N < _n) N <<= 1;
rep(i, DAT_SIZE) {
data[i] = iv;
datb[i] = iv;
}
}
void initRMQ(int _n) {
N = 1;
while (N < _n) N *= 2;
// 全ての値をbigに
rep(i, 2 * N - 1)
data[i] = MAX;
}
void updateRMQ(int k, ll a) {
k += N - 1;
data[k] = a;
while (k > 0) {
k = (k - 1) / 2;
data[k] = min(data[k * 2 + 1], data[k * 2 + 2]);
}
}
ll RMQ(int a, int b) {

return queryRMQ(a, b + 1, 0, 0, N);
}
ll queryRMQ(int a, int b, int k, int l, int r) {
if (r <= a || b <= l)
return MAX;

// [a,b)が[l,r)を完全に含んでいれば
if (a <= l && r <= b)
return data[k];

// そうでなければ２つの子の最小値
// n=16
// 0,16→0,8 8,16
// 0,4 4,8 8,12 12,16
ll vl = queryRMQ(a, b, k * 2 + 1, l, (l + r) / 2);
ll vr = queryRMQ(a, b, k * 2 + 2, (l + r) / 2, r);
return min(vl, vr);
}

void add(int a, int b, int x) {
add(a, b + 1, x, 0, 0, N);
}
void add(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] += x;
}
else if (l < b && a < r) {
datb[k] += (min(b, r) - max(a, l)) * x;
add(a, b, x, k * 2 + 1, l, (l + r) / 2);
add(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

void change(int a, int b, int x) {
change(a, b + 1, x, 0, 0, N);
}
void change(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] = x;
}
else if (l < b && a < r) {
datb[k] = x;
change(a, b, x, k * 2 + 1, l, (l + r) / 2);
change(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

ll sum(int a, int b) {
return sum(a, b + 1, 0, 0, N);
}
ll sum(int a, int b, int k, int l, int r) {
if (b <= l || r <= a) {
return 0;
}
if (a <= l && r <= b) {
return data[k] * (r - l) + datb[k];
}

ll res = (min(b, r) - max(a, l)) * data[k];
res += sum(a, b, k * 2 + 1, l, (l + r) / 2);
res += sum(a, b, k * 2 + 2, (l + r) / 2, r);
return res;
}
};

class Segment;
class Circle;

class Point {
public:
double x, y;

Point(double x = 0, double y = 0) :x(x), y(y) {}

Point operator + (Point p) { return Point(x + p.x, y + p.y); }
Point operator - (Point p) { return Point(x - p.x, y - p.y); }
Point operator * (double a) { return Point(a * x, a * y); }
Point operator / (double a) { return Point(x / a, y / a); }

double abs() { return sqrt(norm()); }
double norm() { return x * x + y * y; }

bool operator < (const Point& p)const {
return x != p.x ? x < p.x : y < p.y;
}
bool operator == (const Point& p) const {
return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;
}
// 内積
static double dot(Point a, Point b) {
return a.x * b.x + a.y * b.y;
}
// 外積
static double cross(Point a, Point b) {
return a.x * b.y - a.y * b.x;
}
static bool isOrthogonal(Point a, Point b) {
return EQ(dot(a, b), 0.0);
}
static bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {
return isOrthogonal(a1 - a2, b1 - b2);
}
static bool isOrthogonal(Segment s1, Segment s2);

static bool isPalallel(Point a, Point b) {
return EQ(cross(a, b), 0.0);
}
static bool isPalallel(Point a1, Point a2, Point b1, Point b2) {
return isPalallel(a1 - a2, b1 - b2);
}
static bool isPalallel(Segment s1, Segment s2);

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;
static const int ONLINE_BACK = 2;
static const int ONLINE_FRONT = -2;
static const int ON_SEGMENT = 0;
static int ccw(Point p0, Point p1, Point p2) {
// 線分はp0とp1でp2がどこにあるかを探る
Point a = p1 - p0;
Point b = p2 - p0;
if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;
if (cross(a, b) < -EPS) return CLOCKWISE;
if (dot(a, b) < -EPS) return ONLINE_BACK;
if (a.norm() < b.norm()) return ONLINE_FRONT;
return ON_SEGMENT;
}

// 交差しているか
static bool intersect(Point p1, Point p2, Point p3, Point p4) {
return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0
&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);
}
static bool intersect(Segment s1, Segment s2);
static Point project(Segment s, Point p);

static Point reflect(Segment s, Point p);

static Point getDistance(Point a, Point b) {
return (a - b).abs();
}

static double getDistanceLP(Segment s, Point p);

static double getDistanceSP(Segment s, Point p);

static double getDistance(Segment s1, Segment s2);

static Point getIntersection(Segment s1, Segment s2);

static pair<Point, Point> crossPoints(Circle c, Segment s);

static int contains(vector<Point> g, Point p) {
int n = g.size();
bool x = false;
rep(i, n) {
Point a = g[i] - p, b = g[(i + 1) % n] - p;
// 線の上に載っているか
if (std::abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;

// pを基準として上下にあるか
// または外積が正か?(→にあるか)
if (a.y > b.y) swap(a, b);
if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;
}
return x ? 2 : 0;
}

static vector<Point> andrewScan(vector<Point> s) {
vector<Point> u, l;
ll si = s.size();
if (si < 3) return s;
sort(all(s));
u.push_back(s[0]);
u.push_back(s[1]);
l.push_back(s[si - 1]);
l.push_back(s[si - 2]);
for (int i = 2; i < si; i++) {

for (int _n = u.size(); _n >= 2 && ccw(u[_n - 2], u[_n - 1], s[i]) > CLOCKWISE; _n--) {
u.pop_back();
}
u.push_back(s[i]);
}

for (int i = s.size() - 3; i >= 0; i--) {

for (int _n = l.size(); _n >= 2 && ccw(l[_n - 2], l[_n - 1], s[i]) > CLOCKWISE; _n--) {
l.pop_back();
}
l.push_back(s[i]);
}

reverse(all(l));
for (int i = u.size() - 2; i >= 1; i--)
{
l.push_back(u[i]);
}

return l;
}
void get_cin() {
cin >> x >> y;
}

static Point rotate(double r, Point p) {
Point ret;
ret.x = cos(r) * p.x - sin(r) * p.y;
ret.y = sin(r) * p.x + cos(r) * p.y;
return ret;
}
};

class Segment {
public:
Point p1, p2;
Segment() {}
Segment(Point p1, Point p2) :p1(p1), p2(p2) {}
void get_cin() {
cin >> p1.x >> p1.y >> p2.x >> p2.y;
}
Point p1tp2() {
return p2 - p1;
}
Point p2tp1() {
return p1 - p2;
}
double abs() {
return (p2 - p1).abs();
}
double norm() {
return (p2 - p1).norm();
}
};

// 直行
bool Point::isOrthogonal(Segment s1, Segment s2) {
return EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}

// 平行
bool Point::isPalallel(Segment s1, Segment s2) {
return EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}
// 交差しているか
bool Point::intersect(Segment s1, Segment s2) {
return intersect(s1.p1, s1.p2, s2.p1, s2.p2);
}
Point Point::project(Segment s, Point p) {
Point base = s.p2 - s.p1;
double r = Point::dot(p - s.p1, base) / base.norm();
return s.p1 + base * r;
}
Point Point::reflect(Segment s, Point p) {
return (project(s, p) * 2) - p;
}
double Point::getDistanceLP(Segment s, Point p) {
return std::abs(cross(s.p2 - s.p1, p - s.p1) / (s.p2 - s.p1).abs());
}
double Point::getDistanceSP(Segment s, Point p) {
if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();
if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();
return getDistanceLP(s, p);
}
double Point::getDistance(Segment s1, Segment s2) {
if (intersect(s1, s2)) return 0.0;
return min({ getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)
,getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2) });
}

Point Point::getIntersection(Segment s1, Segment s2) {
// (s1.p1 - s2.p1).norm()
auto bs = s1.p2 - s1.p1;
auto n1 = s2.p1 - s1.p1;
auto n2 = s2.p2 - s1.p1;
auto c1 = std::abs(cross(n1, bs)) / bs.norm();
auto c2 = std::abs(cross(n2, bs)) / bs.norm();
return s2.p1 + (s2.p2 - s2.p1) * (c1 / (c1 + c2));
// c1:c2=t:1-t
// c2t=(1-t)c1
// t/(1-t)=c1/(c1+c2)
// 
}

double arg(Point p) { return atan2(p.y, p.x); }
Point polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }
class Circle {
public:
Point c;
double r;
Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}
void get_cin() {
cin >> c.x >> c.y >> r;
}
static pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {
double d = (c1.c - c2.c).abs(); // 中心点どうしの距離
double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
double t = arg(c2.c - c1.c);
return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));

}
};

pair<Point, Point> Point::crossPoints(Circle c, Segment s) {
auto pp = project(s, c.c);
auto f = (pp - c.c).norm();
auto mu = sqrt(c.r * c.r - f);

// 単位ベクトル
auto e = s.p1tp2() / s.p1tp2().abs();
return make_pair(pp + e * mu, pp - e * mu);

}

ll divRm(string s, ll x) {

ll r = 0;
for (ll i = 0; i < s.size(); i++)
{
r *= 10;
r += s[i] - '0';
r %= x;
}
return r;
}
ll cmbi(ll x, ll b) {

ll res = 1;
for (size_t i = 0; i < b; i++)
{
res *= x - i;
res %= INF;
res *= inv[b - i];
res %= INF;
}
return res;
}

ll digsum(ll x) {
ll res = 0;
while (x > 0)
{
res += x % 10;
x /= 10;
}
return res;
}
bool check_parindrome(string s) {
int n = s.size();
rep(i, n / 2) {
if (s[i] != s[n - i - 1]) {
return false;
}

}
return true;
}
ll npr(ll n, ll r) {
if (r == 0)
return 1;
return inff(fac[n] * modinv(fac[n - r]));
}

vl zalgo(string s) {
ll c = 0;
vl a(s.size());
ll si = s.size();
rep2(i, 1, s.size()) {
if (i + a[i - c] < c + a[c])
{
a[i] = a[i - c];
}
else {
ll j = max(0LL, a[c] - (i - c));
while (i + j < si && s[j] == s[i + j])
{
j++;
}

a[i] = j;
c = i;
}

}
a[0] = s.size();
return a;
}
// 数値文字列の除算
string divStrNum(string s, ll v) {
ll si = s.size();
ll val = 0;
string res = "";
for (ll i = 0; i < si; i++)
{
val *= 10;
val += s[i] - '0';
ll add = val / v;
val %= v;
if (add == 0 && res == "")
continue;
res += add + '0';
}
if (res == "")
return "0";

return res;
}

// 数値文字列の減算
string difStrNum(string s, ll v) {
ll si = s.size();
bool dec = false;
for (ll i = si - 1; i >= 0; i--)
{
if (v == 0)
break;
ll t = v % 10;
v /= 10;
ll u = (s[i] - '0');
if (dec) {
if (u == 0) {
s[i] = 9 - t;
dec = true;
continue;
}
u--;
}
if (u < t) {
s[i] = 10 - (t - u);
dec = true;
}
else {
s[i] -= t;
dec = false;
}

}
return s;
}
// 数値文字列を1減らした数
string decStrNum(string s) {
ll si = s.size();
for (int i = si - 1; i >= 0; i--)
{
if (s[i] == '0') {
s[i] = '9';
continue;
}
s[i] = s[i] - 1;

break;
}
return s;
}
void dateCal(int x) {
int lp = x / 7;
string date[] = { "月曜日","火曜日","水曜日","木曜日","金曜日","土曜日","日曜日" };
rep(i, 7) {
int st = i;
rep(j, lp) {
cout << "\t" << date[i] << x << "-" << st << "\t" << "NULL" << "\t" << x << "\t" << st << "\t" << 0 << endl;
st += 7;
}
}
}
// 行列べき乗計算
mat mul(mat& A, mat& B) {
ll as = A.size();
ll bs = B.size();
mat C(A.size(), vl(B[0].size()));
rep(i, as) {
rep(t, bs) {
ll bz = B[0].size();
rep(j, bz) {
C[i][j] = inff(C[i][j] + A[i][t] * B[t][j]);
}
}
}
return C;
}

mat pow(mat A, ll x) {
mat B(A.size(), vl(A.size()));
rep(i, A.size()) {
B[i][i] = 1;
}
while (x > 0)
{
if (x & 1)B = mul(B, A);
A = mul(A, A);
x >>= 1;
}
return B;
}

class dinic {
public:
vve G;

vl level;
vl iter;
dinic(int _n) : dinic(vve(_n + 1)) {

}
dinic(vve g) {
G = g;
level = vl(g.size());
iter = vl(g.size());
}

void add_edge(ll from, ll to, ll cap) {
auto e1 = edge();
auto e2 = edge();

e1.flowEdge(to, cap, G[to].size());
G[from].push_back(e1);
e2.flowEdge(from, 0, G[from].size() - 1);
G[to].push_back(e2);
}

void bfs(ll s) {
fill(all(level), -1);
queue<ll> q;
level[s] = 0;
q.push(s);
while (!q.empty())
{
ll v = frontpop(q);
for (auto e : G[v]) {
if (e.cap > 0 && level[e.to] < 0) {
level[e.to] = level[v] + 1;
q.push(e.to);
}
}
}
}

ll dfs(ll v, ll t, ll f) {
if (v == t)
return f;
for (ll& i = iter[v]; i < G[v].size(); i++) {
edge& e = G[v][i];
if (e.cap > 0 && level[v] < level[e.to]) {
ll d = dfs(e.to, t, min(f, e.cap));
if (d > 0) {
e.cap -= d;
G[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}

ll max_flow(ll s, ll t) {
ll flow = 0;
for (;;) {
bfs(s);
if (level[t] < 0)
return flow;
fill(all(iter), 0);
ll f;
while ((f = dfs(s, t, big)) > 0)
{
flow += f;
}
}
}
};
const ull BS = 1000000007;
// aはbに含まれているか？
bool rolling_hash(string a, string b) {
int al = a.size(), bl = b.size();
if (al > bl)
return false;

// BSのal乗を計算
ull t = 1;
rep(i, al)t *= BS;

// aとbの最初のal文字に関するハッシュ値を計算
ull ah = 0, bh = 0;
rep(i, al) ah = ah * BS + a[i];
rep(i, al) bh = bh * BS + b[i];

// bの場所を一つずつ進めながらハッシュ値をチェック
for (ll i = 0; i + al <= bl; i++)
{
if (ah == bh)
return true;
if (i + al < bl)bh = bh * BS + b[i + al] - b[i] * t;
}
return false;
}

mat sans(9, vl(9, -1));
bool srec(ll x, ll y) {
if (x == 9)
return true;
vl use(10, 0);
rep(i, 9) {
if (sans[i][y] == -1)
continue;
use[sans[i][y]] = 1;
}
rep(j, 9) {
if (sans[x][j] == -1)
continue;
use[sans[x][j]] = 1;
}
ll px = x % 3;
ll py = y % 3;
ll tx = x - px + 3;
ll ty = y - py + 3;
rep2(i, x - px, tx) {
rep2(j, y - py, ty) {
if (sans[i][j] == -1)
continue;
use[sans[i][j]] = 1;
}
}
ll nx, ny;
if (y == 8) {
nx = x + 1;
ny = 0;
}
else {
nx = x;
ny = y + 1;
}

if (sans[x][y] != -1) {
if (srec(nx, ny)) {
return true;
}
return false;
}

rep2(i, 1, 10) {
if (use[i])
continue;
sans[x][y] = i;
if (srec(nx, ny)) {
return true;
}
sans[x][y] = -1;
}
return false;
}
void sudoku() {
vector<string> tb;

rep(i, 9) {
string s;
cin >> s;
tb.push_back(s);
rep(j, 9) {
if (tb[i][j] != '.') {
sans[i][j] = tb[i][j] - '0';
}
}
}
srec(0, 0);
rep(i, 9) {
rep(j, 9) {
cout << sans[i][j];
}
cout << endl;
}
}

//　ここまでライブラリ
// ここからコード

void solv() {
cin >> n;
vl p(n),q(n);
rep(i, n) {
cin >> p[i];
}
vl t(n + 1, 0);
rep(i, n) {
cin >> q[i];
t[q[i]] = i;
}
vpll v;
rep(i, n) {
ll u = p[i];
while (u <= n) {
v.push_back({ i,-t[u] });
u += p[i];
}
}
vsort(v);
vl e(n + 1, big);
ll res = 0;
rep(i, v.size()) {
ll p = lower_bound(all(e), -v[i].second) - e.begin();
res = max(p + 1, res);
e[p] = -v[i].second;

}
pln(res);
}

int main()
{
cin.tie(0);
ios::sync_with_stdio(false);

COMinit();
solv();
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main()
{
int T;
cin >> T;
for(int t = 0; t < T; t++){
long long a;
cin >> a;
if(a % 2 == 0 && a % 4 != 0) cout << "Same" << endl;
else if(a % 4 == 0) cout << "Even" << endl;
else cout << "Odd" << endl;
}
}

/*	author:  Kite_kuma
created: 2022.01.20 23:14:27 */

// #ifdef LOCAL
// #define _GLIBCXX_DEBUG
// #endif
#include <bits/stdc++.h>
using namespace std;

#pragma region macros

#define foa(s, v) for(auto &s : v)
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define popcnt(n) __builtin_popcountll((long long)n)

#define REPname(a, b, c, d, e, ...) e
#define rep(...) REPname(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)
#define REP0(x) for(int Counter_in_rep_macro = 0; Counter_in_rep_macro < (x); ++Counter_in_rep_macro)
#define REP1(i, x) for(int i = 0; i < (x); ++i)
#define REP2(i, l, r) for(int i = (l); i < (r); ++i)
#define REP3(i, l, r, c) for(int i = (l); i < (r); i += (c))

#define DREPname(a, b, c, d, e, ...) e
#define drep(...) DREPname(__VA_ARGS__, DREP3, DREP2, DREP1)(__VA_ARGS__)
#define DREP1(i, x) for(int i = (x)-1; i >= 0; --i)
#define DREP2(i, l, r) for(int i = (r)-1; i >= (l); --i)
#define DREP3(i, l, r, c) for(int i = (r)-1; i >= (l); i -= (c))

#pragma endregion

#pragma region aliases

using ll = long long;
using ld = long double;
using ull = unsigned long long;
using vi = std::vector<int>;
using vvi = std::vector<std::vector<int>>;
using vvvi = std::vector<std::vector<std::vector<int>>>;
using vll = std::vector<ll>;
using vvll = std::vector<vll>;
using vvvll = std::vector<vvll>;
using pii = std::pair<int, int>;
using pll = std::pair<long long, long long>;
template <class T = ll>
using V = std::vector<T>;
template <class T = ll>
using VV = V<V<T>>;
template <class T = ll>
using VVV = V<V<V<T>>>;
template <class T = ll>
using pqup = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T = ll>
using pqdn = std::priority_queue<T>;

#pragma endregion

#pragma region constants

const int inf = 1e9;
const long long INF = 1e18;
const long double pi = acos(-1);
const char dl = '\n';
const char sp = ' ';
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};

const int mod_1000000007 = 1000000007;
const int mod_998244353 = 998244353;

#pragma endregion

#pragma region basic_operation

template <class T0, class T1, class T2>
inline bool in_range(T0 x, T1 lef, T2 rig) {
return ((lef <= x) && (x < rig));
}

template <class T>
inline bool chmin(T &a, T b) {
if(a > b) {
a = b;
return true;
}
return false;
}
template <class T>
inline bool chmax(T &a, T b) {
if(a < b) {
a = b;
return true;
}
return false;
}

void Yes(bool f = 1) { std::cout << (f ? "Yes" : "No") << '\n'; }
void No() { std::cout << "No\n"; }
void YES(bool f = 1) { std::cout << (f ? "YES" : "NO") << '\n'; }
void NO() { std::cout << "NO\n"; }

template <class T>
void drop(T answer) {
std::cout << answer << '\n';
exit(0);
}

void err(bool flag = true) {
if(!flag) return;
std::cout << -1 << '\n';
exit(0);
}

template <class T>
void vout(std::vector<T> const &v, bool vertically = 0) {
if(vertically) {
for(auto const &a : v) {
std::cout << a << '\n';
}
return;
}
for(auto it = v.begin(); it != v.end(); it++) {
std::cout << (*it);
if(it != v.end() - 1) {
std::cout << ' ';
}
}
std::cout << '\n';
return;
}

inline void print() { std::cout << '\n'; }
template <class T>
inline void print(T x) {
std::cout << x << '\n';
return;
}
template <typename Head, typename... Tail>
void print(Head H, Tail... T) {
std::cout << H << " ";
print(T...);
}

template <class T>
void add(std::vector<T> &v, T val) {
for(auto &a : v) a += val;
return;
}

template <class T>
T dup(T a, T b) {
assert(b != 0);
return (a + b - 1) / b;
}

template <class T>
T greatest_lower_multiple(T x, T d) {
if(d == 0) return 0;
if(d < 0) d *= -1;
T y = x % d;
if(y < 0) y += d;
return x - y;
}

template <class T>
T least_upper_multiple(T x, T d) {
return -greatest_lower_multiple(-x, d);
}

long long POW(long long a, long long n) {
long long res = 1;
while(n > 0) {
if(n & 1) res = res * a;
a = a * a;
n >>= 1;
}
return res;
}

long long modpow(long long a, long long n, long long mod) {	 // a^n mod
assert(n >= 0 && mod);
if(mod == 1) return 0LL;
long long res = 1;
a %= mod;
while(n > 0) {
if(n & 1) res = res * a % mod;
a = a * a % mod;
n >>= 1;
}
return res < 0 ? res + mod : res;
}

// return x which satisfies a * x % mod == gcd(a, mod)
// not (mod | a)
long long modinv(long long a, long long mod) {
long long b = mod, u = 1, v = 0;
while(b) {
long long t = a / b;
a -= t * b;
std::swap(a, b);
u -= t * v;
std::swap(u, v);
}
u %= mod;
if(u < 0) u += mod;
return u;
}

template <class T>
int lb(const std::vector<T> &a, const T x) {
return std::distance(a.begin(), std::lower_bound(a.begin(), a.end(), x));
}
template <class T>
int ub(const std::vector<T> &a, const T x) {
return std::distance(a.begin(), std::upper_bound(a.begin(), a.end(), x));
}
template <class T>
void unq_sort(std::vector<T> &a) {
std::sort(a.begin(), a.end());
a.erase(std::unique(a.begin(), a.end()), a.end());
}
template <class T>
std::vector<int> press(std::vector<T> &a) {
auto vec = a;
unq_sort(vec);
std::vector<int> ret;
for(auto &v : a) ret.push_back(lb(vec, v));
return ret;
}

#pragma endregion

#pragma region input
#define VEC(type, name, size) \
vector<type> name(size);  \
scanner::INPUT(name)
#define VVEC(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
scanner::INPUT(name)
#define INT(...)     \
int __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define LL(...)            \
long long __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define STR(...)        \
string __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define CHR(...)      \
char __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define DBL(...)        \
double __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define LD(...)              \
long double __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define TPL3(type0, type1, type2, name)   \
std::tuple<type0, type1, type2> name; \
scanner::INPUT(name);
#define TPL4(type0, type1, type2, type3, name)   \
std::tuple<type0, type1, type2, type3> name; \
scanner::INPUT(name);

namespace scanner {
template <class T>
void scan(T &a) {
std::cin >> a;
}

template <class T, class L>
void scan(std::pair<T, L> &p) {
scan(p.first);
scan(p.second);
}

template <class T0, class T1, class T2>
void scan(std::tuple<T0, T1, T2> &p) {
T0 t0;
T1 t1;
T2 t2;
scan(t0);
scan(t1);
scan(t2);
p = std::make_tuple(t0, t1, t2);
}

template <class T0, class T1, class T2, class T3>
void scan(std::tuple<T0, T1, T2, T3> &p) {
T0 t0;
T1 t1;
T2 t2;
T3 t3;
scan(t0);
scan(t1);
scan(t2);
scan(t3);
p = std::make_tuple(t0, t1, t2, t3);
}

template <class T>
void scan(std::vector<T> &a) {
for(auto &i : a) scan(i);
}

void INPUT() {}
template <class Head, class... Tail>
void INPUT(Head &head, Tail &... tail) {
scan(head);
INPUT(tail...);
}
}  // namespace scanner

template <typename T1, typename T2>
std::istream &operator>>(std::istream &is, std::pair<T1, T2> &p) {
is >> p.first >> p.second;
return is;
}
#pragma endregion

#pragma region debug

#pragma region output
template <typename T1, typename T2>
std::ostream &std::operator<<(std::ostream &os, const std::pair<T1, T2> &p) {
os << p.first << " " << p.second;
return os;
}
template <class T>
std::ostream &std::operator<<(std::ostream &os, const std::vector<T> &v) {
for(int i = 0; i < (int)v.size(); i++) {
if(i) os << " ";
os << v[i];
}
return os;
}
#pragma endregion

#pragma region view

namespace viewer {
void view(const long long e) {
if(e == INF)
std::cerr << "INF";
else if(e == -INF)
std::cerr << "-INF";
else
std::cerr << e;
}

void view(const int e) {
if(e == inf)
std::cerr << "inf";
else if(e == -inf)
std::cerr << "-inf";
else
std::cerr << e;
}

template <typename T>
void view(const T e) {
std::cerr << e;
}

template <typename T, typename U>
void view(const std::pair<T, U> &p) {
std::cerr << "(";
view(p.first);
std::cerr << ", ";
view(p.second);
std::cerr << ")";
}

template <class T0, class T1, class T2>
void view(const std::tuple<T0, T1, T2> &p) {
std::cerr << "(";
view(std::get<0>(p));
std::cerr << ", ";
view(std::get<1>(p));
std::cerr << ", ";
view(std::get<2>(p));
std::cerr << ")";
}

template <class T0, class T1, class T2, class T3>
void view(const std::tuple<T0, T1, T2, T3> &p) {
std::cerr << "(";
view(std::get<0>(p));
std::cerr << ", ";
view(std::get<1>(p));
std::cerr << ", ";
view(std::get<2>(p));
std::cerr << ", ";
view(std::get<3>(p));
std::cerr << ")";
}

template <typename T>
void view(const std::set<T> &s) {
if(s.empty()) {
std::cerr << "{ }";
return;
}
std::cerr << "{ ";
for(auto &t : s) {
view(t);
std::cerr << ", ";
}
std::cerr << "\b\b }";
}

template <typename T>
void view(const std::unordered_set<T> &s) {
if(s.empty()) {
std::cerr << "{ }";
return;
}
std::cerr << "{ ";
for(auto &t : s) {
view(t);
std::cerr << ", ";
}
std::cerr << "\b\b }";
}

template <typename T>
void view(const std::vector<T> &v) {
if(v.empty()) {
std::cerr << "{ }";
return;
}
std::cerr << "{ ";
for(const auto &e : v) {
view(e);
std::cerr << ", ";
}
std::cerr << "\b\b }";
}

template <typename T>
void view(const std::vector<std::vector<T>> &vv) {
std::cerr << "{\n";
for(const auto &v : vv) {
std::cerr << "\t";
view(v);
std::cerr << '\n';
}
std::cerr << "}";
}

template <typename T, typename U>
void view(const std::vector<std::pair<T, U>> &v) {
std::cerr << "{\n";
for(const auto &c : v) {
std::cerr << "\t(";
view(c.first);
std::cerr << ", ";
view(c.second);
std::cerr << ")\n";
}
std::cerr << "}";
}

template <class T0, class T1, class T2>
void view(const std::vector<std::tuple<T0, T1, T2>> &v) {
if(v.empty()) {
std::cerr << "{ }";
return;
}
std::cerr << '{';
for(const auto &t : v) {
std::cerr << "\n\t";
view(t);
std::cerr << ",";
}
std::cerr << "\n}";
}

template <class T0, class T1, class T2, class T3>
void view(const std::vector<std::tuple<T0, T1, T2, T3>> &v) {
if(v.empty()) {
std::cerr << "{ }";
return;
}
std::cerr << '{';
for(const auto &t : v) {
std::cerr << "\n\t";
view(t);
std::cerr << ",";
}
std::cerr << "\n}";
}

template <typename T, typename U>
void view(const std::map<T, U> &m) {
std::cerr << "{\n";
for(const auto &t : m) {
std::cerr << "\t[";
view(t.first);
std::cerr << "] : ";
view(t.second);
std::cerr << '\n';
}
std::cerr << "}";
}

template <typename T, typename U>
void view(const std::unordered_map<T, U> &m) {
std::cerr << "{\n";
for(const auto &t : m) {
std::cerr << "\t[";
view(t.first);
std::cerr << "] : ";
view(t.second);
std::cerr << '\n';
}
std::cerr << "}";
}
}  // namespace viewer

#pragma endregion

// when debugging : g++ foo.cpp -DLOCAL
#ifdef LOCAL
void debug_out() {}
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
viewer::view(H);
std::cerr << ", ";
debug_out(T...);
}
#define debug(...)                                                \
do {                                                          \
std::cerr << __LINE__ << " [" << #__VA_ARGS__ << "] : ["; \
debug_out(__VA_ARGS__);                                   \
std::cerr << "\b\b]\n";                                   \
} while(0)
#define dump(x)                                      \
do {                                             \
std::cerr << __LINE__ << " " << #x << " : "; \
viewer::view(x);                             \
std::cerr << '\n';                           \
} while(0)

#else
#define debug(...) (void(0))
#define dump(x) (void(0))
#endif

#pragma endregion

// ll naive(int n, vector<ll> a){

// }

ll solve(int n, vector<ll> a) {
auto judge = [&n, &a](ll timelimit) -> bool {
ll leftplace = 0LL;
ll rightplace = 0LL;
ll midtime = 0LL;
rep(i, 1, n) {
const ll x = a[i];
ll midtime_after = timelimit - (x - leftplace);
ll rightplace_after = x;
ll leftplace_after = leftplace;
if(midtime >= x - rightplace) {
leftplace_after = rightplace;
} else if(midtime_after < 0) {
return false;
}

rightplace = rightplace_after;
leftplace = leftplace_after;
midtime = midtime_after;
}
return true;
};

long long ok = POW(10, 10);
long long ng = -1;
while(abs(ok - ng) > 1) {
long long med = (ok + ng) / 2;
if(judge(med)) {
ok = med;
} else {
ng = med;
}
}

return ok;
}

int main() {
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
std::cout << std::fixed << std::setprecision(15);
srand((unsigned)time(NULL));

int n;
cin >> n;
VEC(ll, a, n);

rep(i, 1, n) a[i] = (a[i] - a[0]) / 2;
a[0] = 0;

drop(solve(n, a));

// if(solve(n, a) != naive(n, a)){
// 	debug(a);
// 	exit(0);
// }

return 0;
}

#include<bits/stdc++.h>
#define ll long long
using namespace std;
template<typename T>void read(T&x){
x=0;int f=1;char c;
while(!isdigit(c=getchar()))if(c=='-')f=-1;
do x=x*10+c-'0';while(isdigit(c=getchar()));
x*=f;
}
template<typename T,typename...O>void read(T&x,O&...o){read(x),read(o...);}

signed main(){
#ifndef ONLINE_JUDGE
freopen("tmp.in","r",stdin);
freopen("tmp.out","w",stdout);
freopen("tmp.err","w",stderr);
#endif
int A,B;read(A,B);
cout<<B*5<<"0"<<A<<endl;
return 0;
}

#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
using namespace std;

typedef long long ll;
const int MAXN=1005;
const int MOD=998244353;
inline void ADD(int& x,int y){x+=y;if(x>=MOD)x-=MOD;}
inline void DEC(int& x,int y){x-=y;if(x<0)x+=MOD;}
inline int add(int x,int y){return x+y<MOD?x+y:x+y-MOD;}
inline int dec(int x,int y){return x<y?x-y+MOD:x-y;}

int N,D,a[MAXN];bool vis[MAXN];
int f[1<<11],g[1<<11];

int main(){
#ifndef ONLINE_JUDGE
freopen("classic1.in","r",stdin);
freopen("classic1.out","w",stdout);
#endif
scanf("%d%d",&N,&D);
int S=0;
for(int i=1;i<=N;++i){
scanf("%d",&a[i]);
if(a[i]!=-1)vis[a[i]]=1;
}
for(int i=1;i<=D+1;++i)if(vis[i]){
//printf("i=%d\n",i);
S|=1<<(D-1+i);
}
f[S]=1;
for(int i=1;i<=N;++i){
//printf("i=%d ===========\n",i);
for(int S=0;S<(1<<(2*D+1));++S)if(f[S]){
//printf("f[%d]=%d\n",S,f[S]);
int tS=(S>>1)|(vis[i+D+1]<<(2*D));
//printf("tS=%d\n",tS);
if(a[i]!=-1)ADD(g[tS],f[S]);
else{
//puts("qwq");
for(int x=-D;x<=D;++x)if(i+x>=1&&i+x<=N&&!(S&(1<<(x+D)))){
//printf("x=%d\n",x);
if(x+D-1>=0)tS^=1<<(x+D-1);
ADD(g[tS],f[S]);
if(x+D-1>=0)tS^=1<<(x+D-1);
}
}
}
for(int S=0;S<(1<<(2*D+1));++S)f[S]=g[S],g[S]=0;
}
printf("%d\n",f[(1<<D)-1]);
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <set>
#include <numeric>
#include <string>
#include <sstream>
#include <iomanip>
#define MOD (1000000007)
using namespace std;
typedef long long Int;
typedef long long ll;

int main() {
int H, W;
cin >> H >> W;
vector<string> S(H);
for (int i = 0; i < H; i++) cin >> S[i];
vector<string> cnt(H+W-1, "");
for (int i = 0; i < H; i++)
for (int j = 0; j < W; j++)
cnt[i+j].push_back(S[i][j]);
Int ans = 1;
//for (int k = 0; k < H+W-1; k++) cout << cnt[k] << endl;
//return 0;
for (int k = 0; k < H+W-1; k++) {
int N = (int)cnt[k].size();
bool red = false;
bool blue = false;
for (int i = 0; i < N; i++){
if (red && cnt[k][i] == 'B')
ans *= 0;
if (blue && cnt[k][i] == 'R')
ans *= 0;
if (cnt[k][i] == 'B') blue = true;
if (cnt[k][i] == 'R') red = true;
}
bool flag = true;
for (int i = 0; i < N; i++)
if (cnt[k][i] != '.') flag = false;
if (flag) ans = (ans * 2) % 998244353;
}
cout << ans << endl;
return 0;
}

/*
arc116_a
*/

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VC = vector<char>;
using VVC = vector<VC>;
using P = pair<int, int>;
#define sz(x) int(x.size())
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define all(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int dx[] = {1, 0, -1, 0};
constexpr int dy[] = {0, 1, 0, -1};

void print(bool ok) {
if (ok) cout << "Yes" << endl;
else cout << "No" << endl;
}

void solve() {
ll n;
cin >> n;
string ans;
if (n%4 == 0) ans = "Even";
else if (n%2 == 0) ans = "Same";
else ans = "Odd";
cout << ans << endl;
}

int main(){
int t;
cin >> t;
rep(_,t) solve();
} 
#include <stdio.h>
#include <sstream>
#include <string.h>
#include <vector>
#include <map>
#include <algorithm>
#include <utility>
#include <set>
#include <cctype>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <deque>
#include <limits>
#include <iomanip>
#include <ctype.h>
#include <unordered_map>
#include <random>
#include <numeric>
#include <iostream>
#include <array>

#define _USE_MATH_DEFINES
#include <iostream>
#include <math.h>
#include <bitset>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ll, double> pld;
typedef pair<double, double> pdd;
typedef pair<double, ll> pdl;
typedef pair<int, char> pic;
typedef vector<ll> vl;
typedef vector<pll> vpll;
typedef vector<int> vi;
typedef vector<string> table;
typedef priority_queue<ll, vector<ll>, greater<ll>> llgreaterq;
typedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;
typedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;
typedef priority_queue<vi, vector<vi>, greater<vi>> vigreaterq;
typedef priority_queue<vl, vector<vl>, greater<vl >> vlgreaterq;
typedef vector<vl> mat;
typedef vector<mat> thd;
template <class o, class p, class q>
using tuple3q = priority_queue<tuple<o, p, q>, vector<tuple<o, p, q>>, greater<tuple<o, p, q>>>;
template <class o, class p, class q, class r>
using tuple4q = priority_queue<tuple<o, p, q, r>, vector<tuple<o, p, q, r>>, greater<tuple<o, p, q, r>>>;
template <class o, class p, class q, class r, class s>
using tuple5q = priority_queue<tuple<o, p, q, r, s>, vector<tuple<o, p, q, r, s>>, greater<tuple<o, p, q, r, s>>>;
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
#define bit(x,v) ((ll)x << v)
#define rep(x,n) for(ll x = 0;x < n;x++)
#define rep2(x,f,v) for(ll x=f;x<v;x++)
#define repe(v,x) for(auto v : x)
// 許容する誤差ε
#define EPS (1e-10)
// 2つのスカラーが等しいかどうか
#define EQ(a,b) (std::abs(a-b) < EPS)
// 2つのベクトルが等しいかどうか
#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )
#define all(a) a.begin(),a.end()
#define all0(a) memset(a,0,sizeof(a))
#define allm1(a) memset(a,-1,sizeof(a))
#define set_float() cout << fixed << setprecision(10);
#define coutl(s) cout <<s <<endl;
#define pln(s) cout<<s<<"\n";
#define put_float(v) 	set_float() \
pln(v)
#define vinsert(v,p,x) v.insert(v.begin() + p,x)
#define vsort(v) sort(all(v));
#define vdesc(v) vsort(v); \
reverse(all(v))
#define dup(v) v.erase(unique(all(v)),v.end())
#define ion(i,j) ((i & (1LL << j)) > 0)
#define next(i) i++;i%=2
#define Len size()
#define psp(a,b) push_back(make_pair(a,b))
#define psp2(a,b) push(make_pair(a,b))
#define cini(a) a; cin >> a
#define infa(a,b) (a + b) % INF
#define infm(a,b) (a * b) % INF
#define infd(a,b) (a * INFinv(b)) % INF
#define infs(a,b) (a + INF - inff(b)) % INF
#define inf(a) (a) %= INF
#define inff(a) ((a + INF) % INF)
#define No cout << "No" << endl
#define Yes cout << "Yes" << endl
#define NO cout << "NO" << endl
#define YES cout << "YES" << endl
#define smal -INF*INF
#define big INF*INF
#define frontpop(q) q.front();q.pop()
#define toppop(q) q.top();q.pop()
#define arr(a,s) a[s]; all0(a);
#define nxt(cu) (cu+1) % 2 
#define chkover(x,y,h,w) (x<0||y<0||x>=h||y>=w)
ll n, m;

bool chmin(ll& a, ll b) { if (a > b) { a = b; return 1; } return 0; }
ll INF = 1000000007;
const int MAX = 2000010;
void cout2(ll val) {
if (val == big) {
pln(-1);
}
else {
pln(val);
}
}
string padleft(string x, ll dig, char c) {
ll si = x.size();
for (ll i = 0; i < dig - si; i++)
{
x = c + x;
}
return x;
}
long long fac[MAX], finv[MAX], inv[MAX];
void COMinit() {
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++) {
fac[i] = fac[i - 1] * i % INF;
inv[i] = INF - inv[INF % i] * (INF / i) % INF;
finv[i] = finv[i - 1] * inv[i] % INF;
}
}

// 二項係数計算
long long COM(int n, int k) {
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % INF) % INF;
}

ll getpow(ll b, ll x, ll md) {
ll t = b % md;
ll res = 1;
while (x > 0)
{
if (x & 1) {
res *= t;
res %= md;
}
x >>= 1;
t *= t;
t %= md;
}
return res % md;
}
ll getpow(ll b, ll x) {

return getpow(b, x, INF);
}
/// 素数を法とする場合
ll modinv(ll x) {
return getpow(x, INF - 2);
}

ll extgcd(ll a, ll b, ll& x, ll& y) {
ll d = a;
if (b != 0) {
d = extgcd(b, a % b, y, x);
y -= (a / b) * x;
}
else {
x = 1; y = 0;
}
return d;
}

/// <summary>
/// 素数を法としない場合
/// </summary>
/// <param name="a"></param>
/// <param name="m"></param>
/// <returns></returns>
ll modinv(ll a, ll m) {
ll x, y;
extgcd(a, m, x, y);
return (m + x % m) % m;
}

ll gcd(ll a, ll b) {
if (b == 0) return a;
return gcd(b, a % b);
}

class mint {
public:
long long x = 0;
mint(ll x = 0) {
this->x = (x % INF + INF) % INF;
}
mint operator-() const {
return mint(-x);
}
mint& operator+=(const mint& a) {
if ((x += a.x) >= INF) x -= INF;
return *this;
}
mint& operator-=(const mint& a) {
if ((x += INF - a.x) >= INF) x -= INF;
return *this;
}
mint& operator*=(const  mint& a) {
(x *= a.x) %= INF;
return *this;
}
mint operator+(const mint& a) const {
mint res(*this);
return res += a;
}
mint operator-(const mint& a) const {
mint res(*this);
return res -= a;
}
mint operator*(const mint& a) const {
mint res(*this);
return res *= a;
}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t >> 1);
a *= a;
if (t & 1) a *= *this;
return a;
}
// for prime INF
mint inv() const {
return pow(INF - 2LL);
}
mint& operator/=(const mint& a) {
return (*this) *= a.inv();
}
mint operator/(const mint& a) const {
mint res(*this);
return res /= a;
}

friend ostream& operator<<(ostream& os, const mint& m) {
os << m.x;
return os;
}
};
typedef vector<mint> vml;
typedef vector<vml> matm;
// Union find
vl pr;
vl lank;
vl udpt;
void uini(int _n) {
_n++; // 一個拡張しておく
pr = vl(_n + 1);
lank = vl(_n + 1);
udpt = vl(_n + 1, 0);
for (ll i = 0; i <= _n; i++)
{
pr[i] = i;
lank[i] = 1;
}
}

int parent(int x) {
if (x == pr[x]) return x;
auto paren = parent(pr[x]);
udpt[x] = udpt[paren] + 1;
return pr[x] = paren;
}

int same(int x, int y) {
return parent(x) == parent(y);
}

bool unit(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}

bool unitm(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
/// <summary>
/// 数字の小さい方を親にするように処理
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
bool unitlow(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;

if (py < px) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
ll wit[500010];
map<ll, ll> mp[100010];
ll parent2(ll x) {
if (x == pr[x]) return x;
// 元々の親から変わっている時、wit[pr[x]]には親からの距離が入っている
// 同じところを二度通らないので大丈夫なはず
ll o = pr[x];
pr[x] = parent2(o);
wit[x] += wit[o]; // 親の重みを足す
return pr[x];
}
int same2(int x, int y) {
return parent2(x) == parent2(y);
}
bool relate(int x, int y, int v) {

auto px = parent2(x);
auto py = parent2(y);
// 自分の距離が取れる
ll xd = wit[x];
ll yd = wit[y];
// ↑のydにvを足した値とxdを比較する
// yd+v> xdであれば、pyが親となる
// yの直接の親はxとしてしまう?
// wit[y] = v;
if (px == py)
return false;
if (xd + v > yd) {
pr[py] = px;

wit[py] = xd + v - yd; // 親同士の距離を入れておく
}
else {
pr[px] = py;
wit[px] = yd - (xd + v);
}
return true;
}

int ci = 0;
struct Node {
int key = 0;
int priority;
Node* parent, * left, * right;
Node(int key, int priority);
Node() {}
};
Node NIL;
Node::Node(int key, int priority) : key(key), priority(priority) {
left = &NIL;
right = &NIL;
}
Node* root = new Node();
void cenrec(Node* k) {
if (k->key == NIL.key) return;
cenrec(k->left);
cout << " " << k->key;
cenrec(k->right);
}
void fastrec(Node* k)
{
if (k->key == NIL.key) return;
cout << " " << k->key;
fastrec(k->left);
fastrec(k->right);
}
void insert(Node* v) {
Node* y = &NIL;
Node* x = root;
while (x->key != NIL.key)
{
y = x;
if (v->key < x->key) {
x = x->left;
}
else {
x = x->right;
}
}
v->parent = y;
if (y->key == NIL.key) {
root = v;
}
else if (v->key < y->key) {
y->left = v;
}
else {
y->right = v;
}

}

Node* find(Node* k, ll v)
{
if (k->key == NIL.key) return &NIL;
if (k->key == v) return k;
if (v < k->key) return find(k->left, v);
return find(k->right, v);
}
void delp12(Node* x) {
if (x->key == NIL.key)  return;
Node* l = x->left;
Node* r = x->right;
Node* pr = x->parent;

if (l->key == NIL.key
&& r->key == NIL.key) {
if (pr->left == x) {
pr->left = &NIL;
}
else pr->right = &NIL;
}
else if (l->key != NIL.key) {
if (pr->left == x) {
pr->left = l;
}
else pr->right = l;
l->parent = pr;
}
else if (r->key != NIL.key) {
if (pr->left == x) {
pr->left = r;
}
else pr->right = r;
r->parent = pr;
}
}
Node* get_next(Node* k) {
if (k->key == NIL.key) return &NIL;
Node* res = get_next(k->left);
if (res->key != NIL.key) return res;
return k;
}
void del(Node* x) {

if (x->key == NIL.key) return;
Node* l = x->left;
Node* r = x->right;

if (l->key != NIL.key && r->key != NIL.key) {
Node* nex = get_next(r);
x->key = nex->key;
delp12(nex);
}
else {
delp12(x);
}
}
Node* rightRotate(Node* t) {
Node* s = t->left;
t->left = s->right;
s->right = t;
return s;
}
Node* leftRotate(Node* t) {
Node* s = t->right;
t->right = s->left;
s->left = t;
return s;
}
Node* _insert(Node* t, int key, int priority) {
if (t->key == NIL.key) {
return new Node(key, priority);
}
if (key == t->key) {
return t;
}

if (key < t->key) {
t->left = _insert(t->left, key, priority);
if (t->priority < t->left->priority) {
t = rightRotate(t);
}
}
else {
t->right = _insert(t->right, key, priority);
if (t->priority < t->right->priority) {
t = leftRotate(t);
}
}
return t;
}
Node* delete1(Node* t, int key);
Node* _delete(Node* t, int key) {
if (t->left->key == NIL.key && t->right->key == NIL.key) {
return &NIL;
}
else if (t->left->key == NIL.key) {
t = leftRotate(t);
}
else if (t->right->key == NIL.key) {
t = rightRotate(t);
}
else
{
if (t->left->priority > t->right->priority) {
t = rightRotate(t);
}
else
t = leftRotate(t);
}
return delete1(t, key);
}
Node* delete1(Node* t, int key) {
if (t->key == NIL.key) {
return &NIL;
}
if (key < t->key) {
t->left = delete1(t->left, key);
}
else if (key > t->key) {
t->right = delete1(t->right, key);
}
else return _delete(t, key);
return t;
}
int H;
int left(int i) {
return i * 2 + 1;
}
int right(int i) {
return i * 2 + 2;
}
class edge {
public:
int from, to, i;
ll val;
ll cap, rev;
edge() {}
edge(ll to) : to(to) {}
edge(ll to, ll i) : to(to), i(i) {}
edge(ll from, ll to, ll val) : from(from), to(to), val(val) {}
void flowEdge(ll _to, ll _cap, ll _rev) {
to = _to;
cap = _cap;
rev = _rev;
}
};
typedef vector<vector<edge>> vve;

class LCA {
private:
vector<vector<edge>> v;
vector<vector<int>> parent;
vector<int> depth;
ll root;
void dfs(int n, int m, int d) {
parent[0][n] = m;
depth[n] = d;
for (auto x : v[n]) {
if (x.to != m) dfs(x.to, n, d + 1);
}
}
public:
LCA(ll N, ll root, vector<vector<edge>>& tree) {
v = tree;
this->root = root;
parent = vector<vector<int>>(21, vector<int>(N + 1, 0));
depth = vector<int>(N + 1, 0);
dfs(root, -1, 0);
for (int j = 0; j + 1 < 20; j++) {
for (int i = 1; i <= N; i++) {
if (parent[j][i] < 0) parent[j + 1][i] = -1;
else parent[j + 1][i] = parent[j][parent[j][i]];
}
}
}
int lca(int n, int m) {
if (depth[n] > depth[m]) swap(n, m);
if (n == root)
return root;
for (int j = 0; j < 20; j++) {
if ((depth[m] - depth[n]) >> j & 1) m = parent[j][m];
}
if (n == m) return n;
for (int j = 19; j >= 0; j--) {
if (parent[j][n] != parent[j][m]) {
n = parent[j][n];
m = parent[j][m];
}
}
return parent[0][n];
}
int dep(int n) { return depth[n]; }
};
ll k;
int _rank[1010];
int temp[1010];
bool compare_sa(int i, int j) {
if (_rank[i] != _rank[j]) return _rank[i] < _rank[j];
else {
int ri = i + k <= n ? _rank[i + k] : -1;
int rj = j + k <= n ? _rank[j + k] : -1;
return ri < rj;
}
}
void construct_sa(string S, int* sa) {
n = S.length();

for (ll i = 0; i <= n; i++)
{
sa[i] = i;
_rank[i] = i < n ? S[i] : -1;
}

for (k = 1; k <= n; k *= 2)
{
sort(sa, sa + n + 1, compare_sa);

// saはソート後の接尾辞の並びになっている、rankは元の位置のindexを保持したまま、更新されている。
// ピンとこなかった部分
temp[sa[0]] = 0;
for (ll i = 1; i <= n; i++)
{
temp[sa[i]] = temp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);
}
for (ll i = 0; i <= n; i++)
{
_rank[i] = temp[i];
}
}
}
bool contain(string S, int* sa, string T) {
int a = 0, b = S.length();
// sa は 接尾辞が辞書順に並んでいる、入っているのはその位置のインデックス
while (b - a > 1) {
int c = (a + b) / 2;
if (S.compare(sa[c], T.length(), T) < 0) a = c;
else b = c;
}
return S.compare(sa[b], T.length(), T) == 0;
}


#define bit(x,v) ((ll)x << v)

class BIT {

static const int MAX_N = 500010;
public:
BIT() { memset(bit, 0, sizeof(bit)); }
ll bit[MAX_N + 1], n;
ll sum(int i) {
ll s = 0;
while (i > 0)
{
s += bit[i];
i -= i & -i;
}
return s;
}

void add(int i, int x) {
while (i <= n)
{
bit[i] += x;
i += i & -i;
}
}


};
struct UnionFind {
vector<int> A;
UnionFind(int n) : A(n, -1) {}
int find(int x) {
if (A[x] < 0) return x;
return A[x] = find(A[x]);
}
void unite(int x, int y) {
x = find(x), y = find(y);
if (x == y) return;
if (A[x] > A[y]) swap(x, y);
A[x] += A[y];
A[y] = x;
}
int ngroups() {
int ans = 0;
for (auto a : A) if (a < 0) ans++;
return ans;
}
};
vector<ll> getp(ll n) {

vector<ll> res;
if (n % 2 == 0) {
res.push_back(2);
while (n % 2 == 0)n /= 2;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(i);
while (n % i == 0)n /= i;
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<ll> getp2(ll n) {

vector<ll> res;
if (n % 2 == 0) {

while (n % 2 == 0) { n /= 2; res.push_back(2); }
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {

while (n % i == 0) { n /= i; res.push_back(i); }
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<pll> getp3(ll n) {
vector<pll> res;
int si = 0;
if (n % 2 == 0) {

res.push_back(make_pair(2, 0));
while (n % 2 == 0) { n /= 2; res[si].second++; }
si++;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(make_pair(i, 0));
while (n % i == 0) { n /= i; res[si].second++; }
si++;
}
}
if (n != 1) { res.push_back(make_pair(n, 1)); }
return res;
}

vector<ll> getDivisors(ll n) {

vector<ll> res;
res.push_back(1);
for (ll i = 2; i * i <= n; i++)
{

if (n % i == 0) {
res.push_back(i);
if (n / i != i)
res.push_back(n / i);
}
}
return res;
}

struct ve {
public:
vector<ve> child;
int _t = INF;
ve(int t) :_t(t) {}
ve(ve _left, ve _right) {
_t = _left._t + _right._t;
child.push_back(_left);
child.push_back(_right);
}
bool operator<(const ve& t) const {
return _t > t._t;
}
};

vector<bool> elas(ll n) {
n++;
vector<bool> r(n, 1);
r[0] = 0;
r[1] = 0;
ll tw = 4;
while (tw < n) {
r[tw] = false;
tw += 2;
}
ll th = 6;
while (th < n) {
r[th] = false;
th += 3;
}
ll fv = 10;
while (fv < n) {
r[fv] = false;
fv += 5;
}

for (ll i = 6; i * i < n; i += 6)
{
ll bf = i - 1;
if (r[bf]) {
ll ti = bf * 2;
while (ti < n)
{
r[ti] = false;
ti += bf;
}
}
ll nx = i + 1;
if (r[nx]) {
ll ti = nx * 2;
while (ti < n)
{
r[ti] = false;
ti += nx;
}
}
}
return r;
}
bool isPrime(ll v) {
for (ll i = 2; i * i <= v; i++)
{
if (v % i == 0) return false;
}
return true;
}


class SegTree {

public:
const static int MAX_N = 1000100;
const static int DAT_SIZE = (1 << 20) - 1;
int N, Q;
int A[MAX_N];
ll MAX = big;

ll data[DAT_SIZE], datb[DAT_SIZE];
void init(int _n) {
N = 1;
while (N < _n) N <<= 1;
memset(data, 0, sizeof(data));
memset(datb, 0, sizeof(datb));
}
void init(int _n, ll iv) {
N = 1;
while (N < _n) N <<= 1;
rep(i, DAT_SIZE) {
data[i] = iv;
datb[i] = iv;
}
}
void initRMQ(int _n) {
N = 1;
while (N < _n) N *= 2;
// 全ての値をbigに
rep(i, 2 * N - 1)
data[i] = MAX;
}
void updateRMQ(int k, ll a) {
k += N - 1;
data[k] = a;
while (k > 0) {
k = (k - 1) / 2;
data[k] = min(data[k * 2 + 1], data[k * 2 + 2]);
}
}
ll RMQ(int a, int b) {

return queryRMQ(a, b + 1, 0, 0, N);
}
ll queryRMQ(int a, int b, int k, int l, int r) {
if (r <= a || b <= l)
return MAX;

// [a,b)が[l,r)を完全に含んでいれば
if (a <= l && r <= b)
return data[k];

// そうでなければ２つの子の最小値
// n=16
// 0,16→0,8 8,16
// 0,4 4,8 8,12 12,16
ll vl = queryRMQ(a, b, k * 2 + 1, l, (l + r) / 2);
ll vr = queryRMQ(a, b, k * 2 + 2, (l + r) / 2, r);
return min(vl, vr);
}

void add(int a, int b, int x) {
add(a, b + 1, x, 0, 0, N);
}
void add(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] += x;
}
else if (l < b && a < r) {
datb[k] += (min(b, r) - max(a, l)) * x;
add(a, b, x, k * 2 + 1, l, (l + r) / 2);
add(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

void change(int a, int b, int x) {
change(a, b + 1, x, 0, 0, N);
}
void change(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] = x;
}
else if (l < b && a < r) {
datb[k] = x;
change(a, b, x, k * 2 + 1, l, (l + r) / 2);
change(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

ll sum(int a, int b) {
return sum(a, b + 1, 0, 0, N);
}
ll sum(int a, int b, int k, int l, int r) {
if (b <= l || r <= a) {
return 0;
}
if (a <= l && r <= b) {
return data[k] * (r - l) + datb[k];
}

ll res = (min(b, r) - max(a, l)) * data[k];
res += sum(a, b, k * 2 + 1, l, (l + r) / 2);
res += sum(a, b, k * 2 + 2, (l + r) / 2, r);
return res;
}
};

class Segment;
class Circle;

class Point {
public:
double x, y;

Point(double x = 0, double y = 0) :x(x), y(y) {}

Point operator + (Point p) { return Point(x + p.x, y + p.y); }
Point operator - (Point p) { return Point(x - p.x, y - p.y); }
Point operator * (double a) { return Point(a * x, a * y); }
Point operator / (double a) { return Point(x / a, y / a); }

double abs() { return sqrt(norm()); }
double norm() { return x * x + y * y; }

bool operator < (const Point& p)const {
return x != p.x ? x < p.x : y < p.y;
}
bool operator == (const Point& p) const {
return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;
}
// 内積
static double dot(Point a, Point b) {
return a.x * b.x + a.y * b.y;
}
// 外積
static double cross(Point a, Point b) {
return a.x * b.y - a.y * b.x;
}
static bool isOrthogonal(Point a, Point b) {
return EQ(dot(a, b), 0.0);
}
static bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {
return isOrthogonal(a1 - a2, b1 - b2);
}
static bool isOrthogonal(Segment s1, Segment s2);

static bool isPalallel(Point a, Point b) {
return EQ(cross(a, b), 0.0);
}
static bool isPalallel(Point a1, Point a2, Point b1, Point b2) {
return isPalallel(a1 - a2, b1 - b2);
}
static bool isPalallel(Segment s1, Segment s2);

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;
static const int ONLINE_BACK = 2;
static const int ONLINE_FRONT = -2;
static const int ON_SEGMENT = 0;
static int ccw(Point p0, Point p1, Point p2) {
// 線分はp0とp1でp2がどこにあるかを探る
Point a = p1 - p0;
Point b = p2 - p0;
if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;
if (cross(a, b) < -EPS) return CLOCKWISE;
if (dot(a, b) < -EPS) return ONLINE_BACK;
if (a.norm() < b.norm()) return ONLINE_FRONT;
return ON_SEGMENT;
}

// 交差しているか
static bool intersect(Point p1, Point p2, Point p3, Point p4) {
return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0
&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);
}
static bool intersect(Segment s1, Segment s2);
static Point project(Segment s, Point p);

static Point reflect(Segment s, Point p);

static Point getDistance(Point a, Point b) {
return (a - b).abs();
}

static double getDistanceLP(Segment s, Point p);

static double getDistanceSP(Segment s, Point p);

static double getDistance(Segment s1, Segment s2);

static Point getIntersection(Segment s1, Segment s2);

static pair<Point, Point> crossPoints(Circle c, Segment s);

static int contains(vector<Point> g, Point p) {
int n = g.size();
bool x = false;
rep(i, n) {
Point a = g[i] - p, b = g[(i + 1) % n] - p;
// 線の上に載っているか
if (std::abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;

// pを基準として上下にあるか
// または外積が正か?(→にあるか)
if (a.y > b.y) swap(a, b);
if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;
}
return x ? 2 : 0;
}

static vector<Point> andrewScan(vector<Point> s) {
vector<Point> u, l;
ll si = s.size();
if (si < 3) return s;
sort(all(s));
u.push_back(s[0]);
u.push_back(s[1]);
l.push_back(s[si - 1]);
l.push_back(s[si - 2]);
for (int i = 2; i < si; i++) {

for (int _n = u.size(); _n >= 2 && ccw(u[_n - 2], u[_n - 1], s[i]) > CLOCKWISE; _n--) {
u.pop_back();
}
u.push_back(s[i]);
}

for (int i = s.size() - 3; i >= 0; i--) {

for (int _n = l.size(); _n >= 2 && ccw(l[_n - 2], l[_n - 1], s[i]) > CLOCKWISE; _n--) {
l.pop_back();
}
l.push_back(s[i]);
}

reverse(all(l));
for (int i = u.size() - 2; i >= 1; i--)
{
l.push_back(u[i]);
}

return l;
}
void get_cin() {
cin >> x >> y;
}

static Point rotate(double r, Point p) {
Point ret;
ret.x = cos(r) * p.x - sin(r) * p.y;
ret.y = sin(r) * p.x + cos(r) * p.y;
return ret;
}
};

class Segment {
public:
Point p1, p2;
Segment() {}
Segment(Point p1, Point p2) :p1(p1), p2(p2) {}
void get_cin() {
cin >> p1.x >> p1.y >> p2.x >> p2.y;
}
Point p1tp2() {
return p2 - p1;
}
Point p2tp1() {
return p1 - p2;
}
double abs() {
return (p2 - p1).abs();
}
double norm() {
return (p2 - p1).norm();
}
};

// 直行
bool Point::isOrthogonal(Segment s1, Segment s2) {
return EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}

// 平行
bool Point::isPalallel(Segment s1, Segment s2) {
return EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}
// 交差しているか
bool Point::intersect(Segment s1, Segment s2) {
return intersect(s1.p1, s1.p2, s2.p1, s2.p2);
}
Point Point::project(Segment s, Point p) {
Point base = s.p2 - s.p1;
double r = Point::dot(p - s.p1, base) / base.norm();
return s.p1 + base * r;
}
Point Point::reflect(Segment s, Point p) {
return (project(s, p) * 2) - p;
}
double Point::getDistanceLP(Segment s, Point p) {
return std::abs(cross(s.p2 - s.p1, p - s.p1) / (s.p2 - s.p1).abs());
}
double Point::getDistanceSP(Segment s, Point p) {
if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();
if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();
return getDistanceLP(s, p);
}
double Point::getDistance(Segment s1, Segment s2) {
if (intersect(s1, s2)) return 0.0;
return min({ getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)
,getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2) });
}

Point Point::getIntersection(Segment s1, Segment s2) {
// (s1.p1 - s2.p1).norm()
auto bs = s1.p2 - s1.p1;
auto n1 = s2.p1 - s1.p1;
auto n2 = s2.p2 - s1.p1;
auto c1 = std::abs(cross(n1, bs)) / bs.norm();
auto c2 = std::abs(cross(n2, bs)) / bs.norm();
return s2.p1 + (s2.p2 - s2.p1) * (c1 / (c1 + c2));
// c1:c2=t:1-t
// c2t=(1-t)c1
// t/(1-t)=c1/(c1+c2)
// 
}

double arg(Point p) { return atan2(p.y, p.x); }
Point polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }
class Circle {
public:
Point c;
double r;
Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}
void get_cin() {
cin >> c.x >> c.y >> r;
}
static pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {
double d = (c1.c - c2.c).abs(); // 中心点どうしの距離
double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
double t = arg(c2.c - c1.c);
return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));

}
};

pair<Point, Point> Point::crossPoints(Circle c, Segment s) {
auto pp = project(s, c.c);
auto f = (pp - c.c).norm();
auto mu = sqrt(c.r * c.r - f);

// 単位ベクトル
auto e = s.p1tp2() / s.p1tp2().abs();
return make_pair(pp + e * mu, pp - e * mu);

}

ll divRm(string s, ll x) {

ll r = 0;
for (ll i = 0; i < s.size(); i++)
{
r *= 10;
r += s[i] - '0';
r %= x;
}
return r;
}
ll cmbi(ll x, ll b) {

ll res = 1;
for (size_t i = 0; i < b; i++)
{
res *= x - i;
res %= INF;
res *= inv[b - i];
res %= INF;
}
return res;
}

ll digsum(ll x) {
ll res = 0;
while (x > 0)
{
res += x % 10;
x /= 10;
}
return res;
}
bool check_parindrome(string s) {
int n = s.size();
rep(i, n / 2) {
if (s[i] != s[n - i - 1]) {
return false;
}

}
return true;
}
ll npr(ll n, ll r) {
if (r == 0)
return 1;
return inff(fac[n] * modinv(fac[n - r]));
}

vl zalgo(string s) {
ll c = 0;
vl a(s.size());
ll si = s.size();
rep2(i, 1, s.size()) {
if (i + a[i - c] < c + a[c])
{
a[i] = a[i - c];
}
else {
ll j = max(0LL, a[c] - (i - c));
while (i + j < si && s[j] == s[i + j])
{
j++;
}

a[i] = j;
c = i;
}

}
a[0] = s.size();
return a;
}
// 数値文字列の除算
string divStrNum(string s, ll v) {
ll si = s.size();
ll val = 0;
string res = "";
for (ll i = 0; i < si; i++)
{
val *= 10;
val += s[i] - '0';
ll add = val / v;
val %= v;
if (add == 0 && res == "")
continue;
res += add + '0';
}
if (res == "")
return "0";

return res;
}

// 数値文字列の減算
string difStrNum(string s, ll v) {
ll si = s.size();
bool dec = false;
for (ll i = si - 1; i >= 0; i--)
{
if (v == 0)
break;
ll t = v % 10;
v /= 10;
ll u = (s[i] - '0');
if (dec) {
if (u == 0) {
s[i] = 9 - t;
dec = true;
continue;
}
u--;
}
if (u < t) {
s[i] = 10 - (t - u);
dec = true;
}
else {
s[i] -= t;
dec = false;
}

}
return s;
}
// 数値文字列を1減らした数
string decStrNum(string s) {
ll si = s.size();
for (int i = si - 1; i >= 0; i--)
{
if (s[i] == '0') {
s[i] = '9';
continue;
}
s[i] = s[i] - 1;

break;
}
return s;
}
void dateCal(int x) {
int lp = x / 7;
string date[] = { "月曜日","火曜日","水曜日","木曜日","金曜日","土曜日","日曜日" };
rep(i, 7) {
int st = i;
rep(j, lp) {
cout << "\t" << date[i] << x << "-" << st << "\t" << "NULL" << "\t" << x << "\t" << st << "\t" << 0 << endl;
st += 7;
}
}
}
// 行列べき乗計算
mat mul(mat& A, mat& B) {
ll as = A.size();
ll bs = B.size();
mat C(A.size(), vl(B[0].size()));
rep(i, as) {
rep(t, bs) {
ll bz = B[0].size();
rep(j, bz) {
C[i][j] = inff(C[i][j] + A[i][t] * B[t][j]);
}
}
}
return C;
}

mat pow(mat A, ll x) {
mat B(A.size(), vl(A.size()));
rep(i, A.size()) {
B[i][i] = 1;
}
while (x > 0)
{
if (x & 1)B = mul(B, A);
A = mul(A, A);
x >>= 1;
}
return B;
}

class dinic {
public:
vve G;

vl level;
vl iter;
dinic(int _n) : dinic(vve(_n + 1)) {

}
dinic(vve g) {
G = g;
level = vl(g.size());
iter = vl(g.size());
}

void add_edge(ll from, ll to, ll cap) {
auto e1 = edge();
auto e2 = edge();

e1.flowEdge(to, cap, G[to].size());
G[from].push_back(e1);
e2.flowEdge(from, 0, G[from].size() - 1);
G[to].push_back(e2);
}

void bfs(ll s) {
fill(all(level), -1);
queue<ll> q;
level[s] = 0;
q.push(s);
while (!q.empty())
{
ll v = frontpop(q);
for (auto e : G[v]) {
if (e.cap > 0 && level[e.to] < 0) {
level[e.to] = level[v] + 1;
q.push(e.to);
}
}
}
}

ll dfs(ll v, ll t, ll f) {
if (v == t)
return f;
for (ll& i = iter[v]; i < G[v].size(); i++) {
edge& e = G[v][i];
if (e.cap > 0 && level[v] < level[e.to]) {
ll d = dfs(e.to, t, min(f, e.cap));
if (d > 0) {
e.cap -= d;
G[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}

ll max_flow(ll s, ll t) {
ll flow = 0;
for (;;) {
bfs(s);
if (level[t] < 0)
return flow;
fill(all(iter), 0);
ll f;
while ((f = dfs(s, t, big)) > 0)
{
flow += f;
}
}
}
};
const ull BS = 1000000007;
// aはbに含まれているか？
bool rolling_hash(string a, string b) {
int al = a.size(), bl = b.size();
if (al > bl)
return false;

// BSのal乗を計算
ull t = 1;
rep(i, al)t *= BS;

// aとbの最初のal文字に関するハッシュ値を計算
ull ah = 0, bh = 0;
rep(i, al) ah = ah * BS + a[i];
rep(i, al) bh = bh * BS + b[i];

// bの場所を一つずつ進めながらハッシュ値をチェック
for (ll i = 0; i + al <= bl; i++)
{
if (ah == bh)
return true;
if (i + al < bl)bh = bh * BS + b[i + al] - b[i] * t;
}
return false;
}

mat sans(9, vl(9, -1));
bool srec(ll x, ll y) {
if (x == 9)
return true;
vl use(10, 0);
rep(i, 9) {
if (sans[i][y] == -1)
continue;
use[sans[i][y]] = 1;
}
rep(j, 9) {
if (sans[x][j] == -1)
continue;
use[sans[x][j]] = 1;
}
ll px = x % 3;
ll py = y % 3;
ll tx = x - px + 3;
ll ty = y - py + 3;
rep2(i, x - px, tx) {
rep2(j, y - py, ty) {
if (sans[i][j] == -1)
continue;
use[sans[i][j]] = 1;
}
}
ll nx, ny;
if (y == 8) {
nx = x + 1;
ny = 0;
}
else {
nx = x;
ny = y + 1;
}

if (sans[x][y] != -1) {
if (srec(nx, ny)) {
return true;
}
return false;
}

rep2(i, 1, 10) {
if (use[i])
continue;
sans[x][y] = i;
if (srec(nx, ny)) {
return true;
}
sans[x][y] = -1;
}
return false;
}
void sudoku() {
vector<string> tb;

rep(i, 9) {
string s;
cin >> s;
tb.push_back(s);
rep(j, 9) {
if (tb[i][j] != '.') {
sans[i][j] = tb[i][j] - '0';
}
}
}
srec(0, 0);
rep(i, 9) {
rep(j, 9) {
cout << sans[i][j];
}
cout << endl;
}
}

//　ここまでライブラリ
// ここからコード

void solv() {
ll h, w;
cin >> h >> w >> k;
vl a(h);
vl b(w);
ll ar = 0;
rep(i, h) {
cin >> a[i];
(ar += a[i])%=k;
a[i] = (w * (k - 1) - a[i]) % k;
}
ll br = 0;
rep(i, w) {
cin >> b[i];
(br += b[i]) %= k;
b[i] = (h * (k - 1) - b[i]) % k;
}
if (ar != br) {
pln(-1); return;
}
ll sa = 0; rep(i, h)sa += a[i];
ll sb = 0; rep(i, w)sb += b[i];
ll sm = h * w * (k - 1);
sm -= max(sa, sb);
pln(sm);

}

int main()
{
cin.tie(0);
ios::sync_with_stdio(false);

COMinit();
solv();
return 0;
}

#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int N = 5e3 + 5;
const int mod = (119 << 23) + 1;
vector<int> edges[N];

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

//~ freopen("case03", "r", stdin);
int n; cin>>n;
int m; cin>>m;
for(int i=0;i<m;i++){
int a, b; cin>>a>>b;
edges[a].push_back(b);
edges[b].push_back(a);
}

vector<int> tt, used(n + 1);
vector<ar<int, 2>> cmp;
function<void(int)> dfs = [&](int u){
used[u] = 1; tt.push_back(u);
for(auto x : edges[u]){
if(used[x]) continue;
dfs(x);
} 
};
int tmp = 1;
for(int i=1;i<=n;i++){
if(used[i]) continue;
dfs(i);
int M = 0, ok = 1;
for(auto x : tt){
M += edges[x].size();
if((int)edges[x].size()&1) ok = 0;
}

if(ok) tmp = tmp * 2ll % mod;
assert(M % 2 == 0);
cmp.push_back({(int)tt.size(), M / 2});
tt.clear();
}

auto bp = [&](int a, int b){
int c = 1;
while(b){
if(b&1) c = c * 1ll * a % mod;
a = a * 1ll * a % mod, b >>= 1;
} return c;
};
vector<int> f(N), inv(N), pw(N);
f[0] = inv[0] = pw[0] = 1;
for(int i=1;i<N;i++){
f[i] = f[i-1] * 1ll * i % mod;
inv[i] = bp(f[i], mod - 2);
pw[i] = pw[i-1] * 2ll % mod;
}
auto C = [&](int n, int k){
return f[n] * 1ll * inv[k] % mod * inv[n - k] % mod;
};

vector<vector<int>> dp(n + 1, vector<int>(n + 1));
dp[0][0] = 1;
int sz = 0, last = 0;
for(auto x : cmp){
int n = x[0], m = x[1];
assert(m >= n - 1);
for(int i=0;i<=sz;i++){
for(int j=0;j<=n;j+=2){
dp[last + 1][i + j] = (dp[last + 1][i + j] + dp[last][i] * 1ll * C(n, j) % mod * pw[m - n + 1]) % mod;
}
} sz += (n - (n&1));
last++;
}

//~ cout<<tmp<<"\n";
for(int i=0;i<=n;i++){
cout<<dp[last][i]<<"\n";
}
}

#include<iostream>
#include<algorithm>
#include<string.h>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<cmath>

#define ll long long
#define P pair<int,int>
#define rep(i,l,r) for(ll i=(l);i<(r);++i)
#define drep(i,l,r) for(ll i=(r-1);i>=(l);--i)
#define debug(a) cout<<#a<<"="<<a<<endl;
#define EPS 1e-8
#define INF 0x7fffffff
#define MOD 1e9+7
using namespace std;
//ios::sync_with_stdio(0);
//if((double)clock()/CLOCKS_PER_SEC >= 1.98) cout << ans << "\n", exit(0);

/*inline int readd () {
int f = 1,x = 0, ch = getchar();
while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
return x * f;
}*/

struct Pot{
ll t, n, c;
};

int main()
{
ll h, w, c, q;
cin >> h >> w >> c >> q;
vector<Pot> ve(q);
vector<ll> ans(c+1, 0);
map<ll, ll> row, col;
rep(i,0,q) cin >> ve[i].t >> ve[i].n >> ve[i].c;
drep(i,0,q){
if(ve[i].t==1 && row[ve[i].n]==0){
ans[ve[i].c] += (w-col.size());
row[ve[i].n] = ve[i].c;
} else if(ve[i].t==2 && col[ve[i].n]==0){
ans[ve[i].c] += (h-row.size());
col[ve[i].n] = ve[i].c;
}
}
rep(i,1,ans.size()) cout << ans[i] << " ";
return 0;
}

/*

*/

#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i = a;i<b; i++)
#define rrep(i,a,b) for(int i = a;i>b-1; i--)
#define INF 100000000
#define ooki 9,223,372,036,854,775,807
#define tii -9,223,372,036,854,775,808
typedef long long LL;
int main(){
LL n,count=0,sum=0;string s;
cin >> n >> s;
rep(i,0,n-1){
if(s[i]==s[i+1]){count++;}
if(s[i]!=s[i+1]){
sum+=count*(count+1)/2;
count=0;
}
}
sum+=count*(count+1)/2;
cout<<sum<<endl;

}

#include <bits/stdc++.h>
#include <atcoder/modint>

using namespace std;
using namespace atcoder;

using mint = modint998244353;

mint solve_sub(int64_t L, int64_t R, int64_t V) {
const int NBITS = 62;
vector<array<mint, 16>> dp(NBITS + 1);
fill(dp[NBITS].begin(), dp[NBITS].end(), 0);
dp[NBITS][0] = 1;
for (int bi = NBITS - 1; bi >= 0; --bi) {
fill(dp[bi].begin(), dp[bi].end(), 0);
int vi = (V >> bi) & 1;
int li = (L >> bi) & 1;
int ri = (R >> bi) & 1;
for (int j = 0; j < 16; ++j) {
int bl = j & 1;
int br = (j >> 1) & 1;
int bxl = (j >> 2) & 1;
int bxr = (j >> 3) & 1;
for (int x = 0; x < 2; ++x) {
if (!bl && (x < li)) continue;
if (!br && (x > ri)) continue;
int y = x ^ vi;
if (!bxl && (y < x)) continue;
if (!bxr && (y > ri)) continue;
int bl2 = bl || (x > li);
int br2 = br || (x < ri);
int bxl2 = bxl || (y > x);
int bxr2 = bxr || (y < ri);
int j2 = (bxr2 << 3) + (bxl2 << 2) + (br2 << 1) + bl2;
dp[bi][j2] += dp[bi + 1][j];
}
}
}
mint ans = 0;
for (int bl = 0; bl < 2; ++bl) {
for (int br = 0; br < 2; ++br) {
for (int bxr = 0; bxr < 2; ++bxr) {
ans += dp[0][(bxr << 3) + (1 << 2) + (br << 1) + bl];
}
}
}
return ans;
}

mint solve(int64_t L, int64_t R, int64_t V) {
mint ans = 0;
if ((V >> 1) == 0) {
int64_t L1 = (L & 1) ? (L + 1) : L;
int64_t R1 = (R & 1) ? R : (R - 1);
L1 >>= 1;
R1 >>= 1;
for (int b1 = 0; b1 < 2; ++b1) {
int b2 = b1 ^ 1 ^ (V & 1);
int64_t L2 = L1, R2 = R1;
if ((L2 & 1) != b1) {
L2++;
}
if ((R2 & 1) != b2) {
R2--;
}
if (R2 >= L2) {
int64_t D = (R2 >> 1) - (L2 >> 1);
if ((R2 & 1) < (L2 & 1)) {
--D;
}
ans += mint(D + 1) * mint(D + 2) / 2;
}
}
}
{
int64_t l1 = ((V >> 1) << 1) + 1;
if (l1 >= L) {
int r2 = ((V >> 1) & 1) ^ (V & 1) ^ 1;
int64_t R1 = (R & 1) ? R : (R - 1);
if (((R1 >> 1) & 1) != r2) {
R1 -= 2;
}
if (R1 >= l1) {
ans += ((R1 - l1) >> 2) + 1;
}
}
}
{
int64_t r1 = (V >> 1) << 1;
if (r1 <= R) {
int l2 = (((V >> 1) & 1) ^ (V & 1)) << 1;
int64_t L1 = (L & 1) ? (L + 1) : L;
if ((L1 & 3) != l2) {
L1 += 2;
}
if (r1 >= L1) {
ans += ((r1 - L1) >> 2) + 1;
}
}
}
if (((V >> 1) & 1) == (V & 1)) {
int64_t L1 = (L & 1) ? L : (L + 1);
int64_t R1 = (R & 1) ? (R - 1) : R;
ans += solve_sub(L1 >> 1, R1 >> 1, V >> 1);
}
return ans;
}

int main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);
int64_t L, R, V;
cin >> L >> R >> V;
cout << solve(L, R, V).val() << endl;
}

#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<11>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod = 1000000007;
const int mod998244353 = 998244353;

// 汎用構造体
struct edge { int to; long long cost; };

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;


int main()
{
ll n;
int m;
cin >> n >> m;
ll even = 0 , odd = 0;
rep(i, n) {
string s;
cin >> s;
if(bitset<21>(s).count()%2) ++odd;
else ++even;
}
ll ans = n*(n-1)/2 - odd*(odd-1)/2 - even*(even-1)/2;
cout << ans << endl;
}
// Problem: D - Bracket Score 2
// Contest: AtCoder - AtCoder Regular Contest 120
// URL: https://atcoder.jp/contests/arc120/tasks/arc120_d
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#pragma GCC optimize("Ofast,unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2")
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;

template<typename F>
void multitest(F func) {
int t;
cin >> t;
while(t--) func();
}
void report(int ok) {
cout << (ok?"YES":"NO") << '\n';
}

int main() {
cin.tie(0)->sync_with_stdio(0);
//multitest([&](){});
int n;
cin >> n;
vector<array<ll, 2>> a(2*n);
int pos = 0;
for(auto &[i, p] : a) cin >> i, p = pos++;
sort(all(a));
vector<int> s(2*n);
for(int i = 0; i < n; i++)
s[a[n+i][1]] = 1;
string ans(2*n, '.');
vector<int> st;
for(int i = 0; i < 2*n; i++) {
if(!st.empty() && s[st.back()] != s[i]) {
ans[st.back()] = '(';
ans[i] = ')';
st.pop_back();
} else
st.push_back(i);
}
cout << ans << '\n';
}

#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<11>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod = 1000000007;
const int mod998244353 = 998244353;

// 汎用構造体
struct edge { int to, idx; long long cost; };

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
int t;
cin >> t;
rep(I, t) {
ll n;
cin >> n;
if(n%2!=0) cout << "Odd" << endl;
else if(n%2==0&&n%4!=0) cout << "Same" << endl;
else cout << "Even" << endl;
}
}
#include<bits/stdc++.h>
using namespace std;
#define N 300030
typedef long long ll;
const int mod=998244353;
int n,K,D;
int fac[N],ifac[N],inv[N];
int qpow(int a,int b){
int ans=1;
while(b){
if(b&1)ans=1LL*ans*a%mod;
a=1LL*a*a%mod;
b>>=1;
}
return ans;
}	
void init(int n){
fac[0]=1;
for(int i=1;i<=n;++i){
fac[i]=1LL*fac[i-1]*i%mod;
}
ifac[n]=qpow(fac[n],mod-2);
for(int i=n-1;i>=0;--i){
ifac[i]=1LL*ifac[i+1]*(i+1)%mod;
}
inv[1]=1;
for(int i=2;i<=n;++i){
inv[i]=1LL*inv[mod%i]*(mod-mod/i)%mod;
}
}
inline int C(int n,int m){
if(n<0||m<0||n<m)return 0;
return 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
inline int calcline(int len,int k){
return C(len-k+1,k);
}
inline int calc(int len,int k){
int ans=0;
ans=2ll*calcline(len-3,k-1)%mod;
ans=(ans+calcline(len-2,k))%mod;
return ans;
}
int a[N],s[N];
int Solve(int l,int r,int K){
int len=r-l+1;
if(2*K>len+1||K<=0)return 0;
int ans=1LL*(s[r]-s[l-1]+mod)%mod*calc(len+1,K)%mod*inv[len+1]%mod*K%mod;
ans=(ans+mod-Solve(l+1,r-1,K-1))%mod;
return ans;
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n>>K>>D;
init(n+1);
for(int i=1;i<=n;++i){
cin>>a[i];
s[i]=(s[i-1]+a[i])%mod;
}
cout<<Solve(1,n,K)<<'\n';
return 0;
}



#define local
//#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fori(i,n) for(ll i=0;i<n;i++)
#define ford(i,n) for(ll i = n-1;i >= 0;i--)
#define pb push_back
#define ll long long int
#define mod 998244353
#define pi pair<int,int>
#define pll pair<ll,ll>
#define mp make_pair
#define fi first
#define se second
#ifdef local
#define debug(x) cout<<#x<<" = "<<x<<endl
#define debug2(x,y) cout<<#x<<" = "<<x<<", "<<#y<<" = "<<y<<endl
#define debug3(x,y,z) cout<<#x<<" = "<<x<<", "<<#y<<" = "<<y<<", "<<#z<<" = "<<z<<endl
#define debug4(x,y,z,q) cout<<#x<<" = "<<x<<", "<<#y<<" = "<<y<<", "<<#z<<" = "<<z<<", "<<#q<<" = "<<q<<endl
#define debugV(v) cout <<#v<<" = ";fori(i,(int) v.size()) {cout << v[i] << " ";} cout << endl << endl;
#define printVector(v) {fori(i,(int) v.size()) {cout << v[i] << " ";} cout << "\n";}
#else
#define debug(x) 1
#define debug2(x,y) 1
#define debug3(x,y,z) 1
#define debug4(x,y,z,q) 1
#define debugV(v) 1
#define printVector(v) {fori(i,(int) v.size()) {cout << v[i] << " ";} cout << "\n";}
#endif
std::mt19937 rng((unsigned int) std::chrono::steady_clock::now().time_since_epoch().count());
using namespace std;
void solve(int ttt)
{
int n;
cin >> n;
vector<ll> a(n);
fori(i,n) cin >> a[i],a[i] = -a[i];
vector<ll> p(n);
partial_sum(all(a),p.begin());
if(p.back() != 0)
{
cout << "-1\n";
return;
}
vector<ll> p2(n);
partial_sum(all(p),p2.begin());
ll z = p2.back();
if(z % n != 0)
{
cout << "-1\n";
return;
}
ll x = z/n;
vector<ll> p3(n);
p3[0] = x;
for(ll i = 1;i < n;i++)
{
ll cur = (i+1) * x - p2[i-1];
p3[i] = cur;
}
ll mn = *min_element(all(p3));
if(mn < 0)
{
fori(i,n)
{
p3[i] -= mn;
}
}
ll res = accumulate(all(p3),0ll);
cout << res << "\n";

}
int main()
{
ios::sync_with_stdio(0);
cin.tie(0);
int ttt;
ttt = 1;
//cin >> ttt;
fori(i,ttt) solve(i);
}

/**
* @Author:51D
**/

#include <iostream>
#include <string>
#include <utility>
#include <cstdlib>
#include <limits>
#include <cmath>
#include <climits>
#include <vector>
#include <bits/stdc++.h>
#include <set>
#include <map>
#include <iomanip>
#include <unordered_set>
#include <unordered_map>
#include <iterator>
#include <algorithm>
#include <sstream>
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

typedef long long ll;

#define mod 1000000007
#define inf 1e9
#define f(i,n) for(int i=0;i<n;i++)
#define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define w(t) ll tt;cin>>tt;while(tt--)
#define pb push_back
#define endl "\n"
#define read(arr,n) for(ll i=0;i<n;i++){cin>>arr[i];};
#define pi pair<ll,ll>
#define all(arr) arr.begin(),arr.end()

// template <typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
//options: less,greater_equal,less_equal,greater

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\"' << x << '\"';}
void __print(const string &x) {cerr << '\"' << x << '\"';}
void __print(bool x) {cerr << (x ? "true" : "false");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
void _print() {cerr << "]\n";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}

#ifndef ONLINE_JUDGE
#define debug(x...) cerr << "[" << #x << "] = ["; _print(x)
#else
#define debug(x...)
#endif

const int N=3e5+5;
const long long infll = 0x3f3f3f3f3f3f3f3fLL;
int p[N];

ll modulo(ll a, ll b, ll n){
ll x=1, y=a; 
while (b > 0) {
if (b%2 == 1) {
x = (x*y) % n; // multiplying with base

}
y = (y*y) % n; // squaring the base
b /= 2;
}
return x % n;
}

ll modmod(ll a,ll b,ll c){
// Fermats Little Theorem
// A^(M-1) = 1 (mod M) if M is a prime.
// So write B^C as x*(M-1) + y

ll y = modulo(b,c,mod-1);

return modulo(a,y,mod);
}

ll value[1000001];
void fillNumberOfDivisorsArray(){
for(ll i=1;i<=1000000;i++){
for(ll j=1;i*j<=1000000;j++){
value[i*j]++;
}
}
}

vector<ll> prime;
bool is_composite[N];

void sieve(ll n) {

fill(is_composite,is_composite + n,false);

for (ll i=2;i<n;i++){

if(!is_composite[i]){
prime.push_back(i);
}

for (int j=2;i*j < n;j++){
is_composite[i * j] = true;
}
}
}

void addEdge(vector<ll> adj[],ll u,ll v){
adj[u].pb(v);
adj[v].pb(u);
}

ll __lcm(ll a,ll b){
return a*b/(__gcd(a,b));
}

vector<ll> fact;
void factorialFill(){
fact.pb(1);
fact.pb(1);
for(ll i=2;i<=1000000;i++){
fact.pb((i%mod * fact.back()%mod)%mod);
}
}
ll getfact(ll num){
return fact[num]%mod;
}

ll getBits(ll num){
return log2(num) + 1;
}


struct cmp {
bool operator() (const pair<int, int> &a, const pair<int, int> &b) const {
return a.first < b.first;
}
};

void solve(ll tc){
ll n,m;
cin>>n>>m;

vector<ll> a(n),b(m);
for(ll i=0;i<n;i++){
cin>>a[i];
}

for(ll i=0;i<m;i++){
cin>>b[i];
}

ll first = -1;


ll idx1 = -1;
ll idx2 = -1;

for(ll i=1;i<n;i++){
if(a[i]!=a[0]){
idx1 = i;
break;
}
}

for(ll i=n-1;i>=0;i--){
if(a[i]!=a[0]){
idx2 = i;
break;
}
}

first = min(idx1,n-idx2);

debug(first);

ll ans = 0;

bool firstchange = true;

ll curr = a[0];

for(ll i=0;i<m;i++){
if(b[i]!=curr){
if(firstchange){
if(first == -1){
cout<<-1<<endl;
return;
}
ans += first + 1;
firstchange = false;
}
else{
ans += 2;
}

curr = b[i];
}
else{
ans++;
}
}

cout<<ans<<endl;
}

int main() {

FIO;
#ifndef ONLINE_JUDGE
freopen("debug.txt", "w", stderr);
#endif
ll tt = 1;
for(ll i=1;i<=tt;i++){
solve(i);
}

return 0;
}

// Version 2.6.2 by Eason_AC
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <map>
#include <vector>
#include <stack>
#include <ctime>
#include <set>
#include <queue>
#include <cctype>
#include <cassert>
#include <cinttypes>
#include <climits>
#define Tl template<typename T>
#define Tla template<typename T, typename... args>
#define F(T, i, a, b) for(T (i) = (a); (i) <= (b); ++(i))
#define R(T, i, a, b) for(T (i) = (a); (i) >= (b); --(i))
#define Fo(T, i, a, b, c) for(T (i) = (a); (i) <= (b); (i) += (c))
#define Re(T, i, a, b, c) for(T (i) = (a); (i) >= (b); (i) -= (c))
#define For(T, i, a, b, c) for(T (i) = (a); (i) <= (b); (i) *= (c))
#define Rep(T, i, a, b, c) for(T (i) = (a); (i) >= (b); (i) /= (c))
#define mes(a, x) memset((a), (x), sizeof((a)))
#define mec(a, b) memcpy((a), (b), sizeof((b)))
#define ll long long //No long long see your ancestor!!!
#define ull unsigned long long //Have long long see your ancestor!!!
#define lll __int128 //Have unsigned long long see your ancestor!!!
#define ld long double
#define YES puts("YES")
#define NO puts("NO")
#define Yes puts("Yes")
#define No puts("No")
#define yes puts("yes")
#define no puts("no")
#define no1 puts("-1")
#define iv inline void
#define ii inline int
#define ill inline ll
#define iull inline ull
#define i128 inline lll
#define ib inline bool
#define iT inline T
#define ilf inline double
#define ild inline ld
#define pii pair<int, int>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pll pair<ll, ll>
#define mp make_pair
#define pub push_back
#define pob pop_back()
#define fi first
#define se second
#define pq priority_queue
#define iinf 0x3f3f3f3f
#define linf 0x3f3f3f3f3f3f3f3f
using namespace std;

namespace FullPre {
Tl iv read(T &x) {T f = 1; x = 0; char c = getchar(); while(!isdigit(c)) {if(c == '-') f = -1; c = getchar();} while(isdigit(c)) {x = x * 10 + c - '0'; c = getchar();} x *= f;}
Tla iv read(T& x, args &...Args) {read(x), read(Args...);}
Tl iv write(T x) {if(x < 0) {putchar('-'); x = -x;} if(x > 9) write(x / 10); putchar(x % 10 + '0');}
Tl iv print_char(T x, char ch) {write(x), putchar(ch);}
Tl iv char_print(char ch, T x) {putchar(ch), write(x);}
Tl iv print_space(T x) {print_char(x, ' ');}
Tl iv print_space_mul(T x) {print_space(x);}
Tla iv print_space_mul(T x, args ...Args) {print_space(x), print_space_mul(Args...);}
Tl iv space_print(T x) {char_print(' ', x);}
Tl iv space_print_mul(T x) {space_print(x);}
Tla iv space_print_mul(T x, args ...Args) {space_print(x), space_print_mul(Args...);}
Tl iv println(T x) {print_char(x, '\n');}
Tl iv println_mul(T x) {println(x);}
Tla iv println_mul(T x, args ...Args) {println(x), println_mul(Args...);}
Tl iv lnprint(T x) {char_print('\n', x);}
Tl iv lnprint_mul(T x) {lnprint(x);}
Tla iv lnprint_mul(T x, args ...Args) {lnprint(x), lnprint_mul(Args...);}
iv filein(string s) {freopen((s + ".in").c_str(), "r", stdin);}
iv fileout(string s) {freopen((s + ".out").c_str(), "w", stdout);}
iv file(string s) {filein(s), fileout(s);}
Tl iT mymin(T a, T b) {return a < b ? a : b;}
Tla iT mymin(T a, T b, args ...Args) {return mymin(mymin(a, b), Args...);}
Tl iT mymax(T a, T b) {return a > b ? a : b;}
Tla iT mymax(T a, T b, args ...Args) {return mymax(mymax(a, b), Args...);}
Tl iT myabs(T a) {return a < 0 ? -a : a;}
Tl iT mysq(T a) {return a * a;}
Tl iT mygcd(T a, T b) {return !b ? a : mygcd(b, a % b);}
Tla iT mygcd(T a, T b, args ...Args) {return mygcd(mygcd(a, b), Args...);}
Tl iT mylcm(T a, T b) {return a / mygcd(a, b) * b;}
Tla iT mylcm(T a, T b, args ...Args) {return mylcm(mylcm(a, b), Args...);}
Tl iT myswap(T &a, T &b) {a ^= b ^= a ^= b;}
}
using namespace FullPre;
#define MT int Test; read(Test); while(Test--)
#define MCase int Test; read(Test); F(int, kase, 1, Test)

namespace Solution {
int n, k, x, d[17];

ib check() {
int p = n;
while(p) {
if(d[p % 10]) return 0;
p /= 10;
}
return 1;
}

iv Main() {
#ifdef LOCAL
double st = clock();
#endif
read(n, k);
F(int, i, 1, k) read(x), d[x] = 1;
for(; !check(); ++n); println(n);
#ifdef LOCAL
double ed = clock();
printf("\nTime: %.3lfs", (ed - st) / 1000000.0);
#endif
return;
}
}

int main() {
#ifdef LOCAL
file("1");
#endif
Solution :: Main();
return 0;
}
/*

*/
#include<bits/stdc++.h>
using namespace std;
const int nax = 3e5 + 10;
const int MOD = 998244353;
void plusle(int &a, int b){a+=b;if(a>=MOD)a-=MOD;}
void minun(int &a, int b){a-=b;if(a<0)a+=MOD;}
int add(int a, int b){a+=b;if(a>=MOD)a-=MOD;return a;}
int sub(int a, int b){a-=b;if (a<0)a+=MOD;return a;}
int mul(int a, int b){return 1ll*a*b%MOD;}
int power(int a, int64_t b){int res=1;for (;b>0;b >>= 1,a=mul(a,a))if(b&1)res=mul(res,a);return res;}
int inv(int a) {return power(a, MOD - 2);}

#define y1 whatthefuck
int n, m;
int v[4];
int x1, x2, y1, y2;

int main() {
cin >> n >> m;
cin >> x1 >> y1 >> x2 >> y2;
v[0] = min(x1, x2) - 1;
v[1] = n - max(x1, x2);
v[2] = min(y1, y2) - 1;
v[3] = m - max(y1, y2);

int L = abs(x1 - x2) + abs(y1 - y2);
int ans = 0;
for (int j = 0 ; j < 4 ; ++ j) {
for (int i = 1 ; i <= v[j] ; ++ i)
plusle(ans, inv(L + i));
}
cout << add(ans, 1) << '\n';
}

#include <bits/stdc++.h>

#define For(i, a, b) for (int i = a; i <= b; ++i)
#define rFor(i, b, a) for (int i = b; i >= a; --i)
#define eFor(i, u, v) for (int i = head[u], v = e[i].to; i; i = e[i].next, v = e[i].to)

typedef long long ll;

using std::cin;
using std::cout;
using std::endl;

typedef std::pair<int, int> pii;
#define fi first
#define se second

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename T> T myrand(T l, T r) {
return std::uniform_int_distribution<T>(l, r)(rnd);
}

void close_stdio() {
std::ios::sync_with_stdio(false);
std::cerr << "DO NOT use scanf/printf!\n";
}

const int kN = 45;
const int P = 1e9 + 7;
const int kS = (1 << 16) + 5;
const int kM = 20;

int n, X, Y, Z;
int dp[2][2][kM][kS];

pii trans(int sum, int mask, int x) {
// printf("trans %d %d %d\n", sum, mask, x);
if (x > X + Y + Z) return {0, 0};
while (sum + x > X + Y + Z && mask) {
// printf("trans %d %d %d\n", sum, mask, x);
assert(mask);
sum -= __builtin_ctz(mask) + 1;
mask >>= (__builtin_ctz(mask) + 1);
}
if (sum == 0 || sum + x > X + Y + Z) return {x, 0};
// printf("%d %d -> %d %d\n", sum, mask, sum + x, mask | (1 << (sum - 1)));
return {sum + x, mask | (1 << (sum - 1))};
}

void reduce(int &x) {
if (x >= P) x -= P;
}

bool has(int sum, int mask) {
if (sum < X + Y + Z || __builtin_popcount(mask) < 2) return false;
if (sum == X + Y + Z) return (mask >> (sum - Z - 1) & 1) && (mask >> (sum - Y - Z - 1) & 1);
return (mask >> (sum - Z - 1) & 1) && (mask >> (sum - Y - Z - 1) & 1) && (mask >> (sum - X - Y - Z - 1) & 1);
}

int main() {
scanf("%d%d%d%d", &n, &X, &Y, &Z);
int cur = 0;
dp[cur][0][0][0] = 1;
For(i, 1, n) {
memset(dp[cur ^ 1], 0, sizeof(dp[cur ^ 1]));
For(p, 0, 1) For(s, 0, X + Y + Z) For(mask, 0, (1 << (X + Y + Z - 1)) - 1) if (dp[cur][p][s][mask]) {
For(x, 1, 10) {
// printf("emurate %d %d %d %d\n", i, p, s, mask);
pii st = trans(s, mask, x);
reduce(dp[cur ^ 1][p | has(st.fi, st.se)][st.fi][st.se] += dp[cur][p][s][mask]);
}
}
cur ^= 1;
// if (i == 1) printf("%d\n", dp[cur][0][5][0]);
// if (i == 2) printf("%d\n", dp[cur][0][12][16]);
// if (i == 3) printf("%d\n", dp[cur][0][17][(1 << 4) | (1 << 15)]);
}
int ans = 0;
For(s, 0, X + Y + Z) For(mask, 0, (1 << (X + Y + Z - 1)) - 1)
reduce(ans += dp[cur][1][s][mask]);
printf("%d", ans);
return 0;
}
/* PAY ATTENTION TO: */
/* 1. Memory Limit, Array Size */
/* 2. Integer Overflow */
/* 3. Multi-test */
/* 4. Potential Constant-speedup */
/* Stay organized and write things down. */
#include <bits/stdc++.h>
#include <atcoder/all>
#define Rep(i,n,m) for(int i=(int)(n);i<(int)(m);i++)
#define rep(i,n) Rep(i,0,n)
#define all(v) v.begin(),v.end()
using namespace std;
using namespace atcoder;
using ll=long long;
using vi=vector<int>;
using vll=vector<ll>;
using mint=modint998244353;
using vmi=vector<mint>;
template <typename T>
struct BIT{
int size;
vector<T> data;
vector<T> Sum;
T t0;

BIT(){};
BIT(int N,T t){
size=N;
data=vector<T>(N,t);
Sum=vector<T>(N,t);
t0=t;
}
void set(int i,T t){
int j=i+1;
while(j<=size){
Sum[j-1]+=(t-data[i]);
j+=(j&-j);
}
data[i]=t;
return;
}
void add(int i,T t){
int j=i+1;
while(j<=size){
Sum[j-1]+=t;
j+=(j&-j);
}
data[i]+=t;
return;
}

T sum(int i,int j){
T sumi=t0,sumj=t0;
j++;
while(i>0){
sumi+=Sum[i-1];
i-=(i&-i);
}
while(j>0){
sumj+=Sum[j-1];
j-=(j&-j);
}
return sumj-sumi;
}
};

template <typename T>
struct RangeSum{
BIT<T> bit0;
BIT<T> bit1;
int size;

RangeSum(int N,T t){
bit0=BIT<T>(N,t);
bit1=BIT<T>(N,t);
size=N;
}

void add(int l,int r,T t){
bit0.add(l,t*(-l));
bit1.add(l,t);
if(r<size-1){
bit0.add(r+1,t*(r+1));
bit1.add(r+1,t*(-1));
}
return;
}
T sum(int l,int r){
return bit0.sum(l,r)+bit1.sum(0,r)*(r+1)-bit1.sum(0,l-1)*l;
}
void set(int i,T t){
T bf=sum(i,i);
add(i,i,t-bf);
}
};

int main(){
int N;cin>>N;
vi a(N);
rep(i,N){
cin>>a[i];
--a[i];
}
BIT<mint> bit(N+1,mint(0));
bit.set(0,1);
vi last(N,-1);
rep(i,N){
mint s=bit.sum(last[a[i]]+1,i);
bit.set(i+1,s);
if(last[a[i]]>=0) bit.set(last[a[i]]+1,0);
last[a[i]]=i;
}
cout << bit.sum(0,N).val()-1 << endl;
return 0;
}
//           A - Smaller XOR
// ----------------------------------------
// 問題
// https://atcoder.jp/contests/arc129/tasks/arc129_a
// ----------------------------------------

// 解説
// (x >> i)&1 == 1 となる最大のiについて
//   (N >> i)&1 == 1 のとき -> (N xor x) > N
//   (N >> i)&1 == 0 のとき -> (N xor x) < N

#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define ALL(A) A.begin(), A.end()
#define initArray(name, h, w, v) vector<vector<long long>> name(h, vector<long long>(w, v));
typedef long long ll;
typedef pair<long long, long long> vec2;
typedef vector<vector<long long>> Array;
template <typename T> inline bool chmax(T &a, const T b) { if (a < b) { a = b; return true; } return false; }
template <typename T> inline bool chmin(T &a, const T b) { if (a > b) { a = b; return true; } return false; }

int main() {
ll N, L, R; cin >> N >> L >> R;
int MAX = 0;
while (N >> MAX) MAX++;
MAX++;

// Nを2進法で表したときのi桁目が1であるとき
ll cnt = 0;
for (int i = 0; i <= MAX; i++) if ((N>>i)&1) {
ll max_bit = (1LL << (i+1)) - 1;
ll min_bit = 1LL << i;
ll upper = min(R, max_bit);
ll lower = max(L, min_bit);
if (lower <= upper) cnt += upper - lower + 1;
}

cout << cnt << endl;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int a, b;
cin >> a >> b;
cout << stoll(to_string(b/2) + ((b & 1) ? "5" : "0") + to_string(a)) << "\n";

return 0;
}

// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline int read(){
int x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

const int N=300005;
const int mod=998244353;

inline int qpow(int a,int b=mod-2){
int res=1;
while(b>0){
if(b&1)res=1ll*res*a%mod;
a=1ll*a*a%mod,b>>=1;
}
return res;
}
int fac[N],ifac[N];
inline void init(int n){
fac[0]=1;rep(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;
ifac[n]=qpow(fac[n]);per(i,n,1)ifac[i-1]=1ll*ifac[i]*i%mod;
}
inline int C(int n,int m){
return n<m||m<0?0:1ll*fac[n]*ifac[n-m]%mod*ifac[m]%mod;
}

int a[300005],coef[300005];
int n,k,D,ans;

inline int calc(int n,int m){return C(n-m+1,m);}
inline int F(int n,int k){
if(n<3)return k==1;
else return calc(n-3,k-1);
}

int main(){
init(N-5);
n=read(),k=read(),D=read();
rep(i,1,n)a[i]=read();
rep(i,1,(n+1)/2){
if(i&1){
if(i==1)coef[i]=calc(n-4,k-2);
else coef[i]=(1ll*mod+coef[i-2]+calc(n-4*(i/2+1),k-2*(i/2+1))-calc(n-4*(i/2),k-2*(i/2)))%mod;
coef[i]=(coef[i]+F(n-4*(i/2),k-2*(i/2)))%mod;
}else{
coef[i]=(coef[i-2]+F(n-4*(i/2-1),k-2*(i/2-1)))%mod;
}
int suma=a[i];
if(!((n&1)&&i==(n+1)/2))suma=(suma+a[n+1-i])%mod;
ans=(ans+1ll*suma*coef[i])%mod;
}
print(ans,'\n');
return 0;
}
#include <bits/stdc++.h>
#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <math.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
using ll = long long;
const ll INF = 1e18;
#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)
const double PI =acos(-1);

int main(){
ll T;cin>>T;
rep(i,T){
ll C;
cin>>C;
if(C%4==0){
cout<<"Even"<<endl;
}else if(C%4==2){
cout<<"Same"<<endl;
}else{
cout<<"Odd"<<endl;
}
}
}
// Problem: C - Swaps 2
// Contest: AtCoder - AtCoder Regular Contest 120
// URL: https://atcoder.jp/contests/arc120/tasks/arc120_c
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#pragma GCC optimize("Ofast,unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2")
#include<bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;
using ll = long long;

template<typename F>
void multitest(F func) {
int t;
cin >> t;
while(t--) func();
}
void report(int ok) {
cout << (ok?"YES":"NO") << '\n';
}

int main() {
cin.tie(0)->sync_with_stdio(0);
//multitest([&](){});
int n;
cin >> n;
vector<int> a(n), b(n);
for(auto &i : a) cin >> i;
for(auto &i : b) cin >> i;
map<int, array<vector<int>, 2>> C;
for(int i = 0; i < n; i++) {
C[a[i]+i][0].push_back(i);
C[b[i]+i][1].push_back(i);
}
ll ans = 0;
vector<int> c(n);
for(auto [_, V] : C) {
if(V[0].size() != V[1].size()) return cout << "-1", 0;
for(int i = 0; i < V[0].size(); i++)
c[V[0][i]] = V[1][i]+1;
}
vector<int> fen(n+1);
auto upd = [&](int x) {
for(; x <= n; x += x&-x)
fen[x]++;
};
auto qry = [&](int x) {
int r = 0;
for(; x; x-=x&-x)
r += fen[x];
return r;
};
for(int i = 0; i < n; i++) {
ans += i-qry(c[i]);
upd(c[i]);
}
cout << ans << '\n';
}
//3 2 6 1 5 4
#include <atcoder/modint>
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace atcoder;
using namespace std;

typedef long long ll;
typedef modint998244353 mint;

const int MAXN = (int)5e3 + 5;

vector<int> adj[MAXN];
mint C[MAXN][MAXN];
bool used[MAXN];
int n, m, e;

int dfs(int v) {
used[v] = 1;
e += sz(adj[v]);
int res = 1;

for (int to : adj[v]) {
if (!used[to]) {
res += dfs(to);
}
}

return res;
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n >> m;

for (int i = 1; i <= m; i++) {
int u, v;
cin >> u >> v;
adj[u].pb(v);
adj[v].pb(u);
}

C[0][0] = 1;

for (int i = 1; i <= n; i++) {
C[i][0] = C[i][i] = 1;

for (int j = 1; j < i; j++) {
C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
}
}

vector<mint> ans(n + 1, 0);
ans[0] = 1;
int sum = 0;

for (int i = 1; i <= n; i++) {
if (!used[i]) {
e = 0;
int v = dfs(i);
e /= 2;

vector<mint> vec(v + 1);
mint coef = mint(2).pow(e - (v - 1));

for (int j = 0; j <= v; j++) {
if (j % 2 == 0) {
vec[j] = C[v][j] * coef;
}
}

vector<mint> new_ans(sum + v + 1, 0);

for (int x = 0; x <= sum; x++) {
for (int y = 0; y <= v; y++) {
new_ans[x + y] += ans[x] * vec[y];
}
}

ans = new_ans;
sum += v;
}
}

for (int i = 0; i <= n; i++) {
cout << ans[i].val() << '\n';
}

return 0;
}

/**
*    author:  otera
*    created: 25.01.2022 00:38:02 
**/
#include<bits/stdc++.h>
#include<atcoder/modint>
using namespace std;

using ll = long long;
using ld = long double;
using ull = unsigned long long;
using uint = unsigned;
#define repa(i, n) for(int i = 0; i < n; ++ i)
#define repb(i, a, b) for(int i = a; i < b; ++ i)
#define repc(i, a, b, c) for(int i = a; i < b; i += c)
#define overload4(a, b, c, d, e, ...) e
#define rep(...) overload4(__VA_ARGS__, repc, repb, repa)(__VA_ARGS__)
#define rep1a(i, n) for(int i = 0; i <= n; ++ i)
#define rep1b(i, a, b) for(int i = a; i <= b; ++ i)
#define rep1c(i, a, b, c) for(int i = a; i <= b; i += c)
#define rep1(...) overload4(__VA_ARGS__, rep1c, rep1b, rep1a)(__VA_ARGS__)
#define per(i,n) for(int i=n-1;i>=0;i--)
#define per1(i,n) for(int i=n;i>=1;i--)
typedef pair<int, int> P;
typedef pair<ll, ll> LP;
#define pb push_back
#define eb emplace_back
#define fr first
#define sc second
#define all(c) c.begin(),c.end()
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
#define Sort(a) sort(all(a))
#define Rev(a) reverse(all(a))
#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))
#define si(c) (int)(c).size()
inline ll popcnt(ull a){ return __builtin_popcountll(a); }
#define tpow(n) (1LL<<(n))
#define unless(A) if(!(A))
ll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }
ll intpow(ll a, ll b, ll m) {ll ans = 1; while(b){ if(b & 1) (ans *= a) %= m; (a *= a) %= m; b /= 2; } return ans; }
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }
#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)
#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)
#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)
#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)
#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)
#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)
#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)
#define vec(type,name,...) vector<type>name(__VA_ARGS__)
#define VEC(type,name,size) vector<type>name(size);in(name)
#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))
#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)
#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))
template <class T> using vc = vector<T>;
template <class T> using vvc = vector<vc<T>>;
template <class T> using vvvc = vector<vvc<T>>;
template <class T> using vvvvc = vector<vvvc<T>>;
template <class T> using pq = priority_queue<T>;
template <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;
template<class T> void scan(T& a){ cin >> a; }
template<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }
void in(){}
template <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }
void print(){ cout << ' '; }
template<class T> void print(const T& a){ cout << a; }
template<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout << ' '; print(*i); } }
int out(){ cout << '\n'; return 0; }
template<class T> int out(const T& t){ print(t); cout << '\n'; return 0; }
template<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); cout << ' '; out(tail...); return 0; }
#define CHOOSE(a) CHOOSE2 a
#define CHOOSE2(a0,a1,a2,a3,a4,x,...) x
#define debug_1(x1) cout<<#x1<<": "<<x1<<endl
#define debug_2(x1,x2) cout<<#x1<<": "<<x1<<", "#x2<<": "<<x2<<endl
#define debug_3(x1,x2,x3) cout<<#x1<<": "<<x1<<", "#x2<<": "<<x2<<", "#x3<<": "<<x3<<endl
#define debug_4(x1,x2,x3,x4) cout<<#x1<<": "<<x1<<", "#x2<<": "<<x2<<", "#x3<<": "<<x3<<", "#x4<<": "<<x4<<endl
#define debug_5(x1,x2,x3,x4,x5) cout<<#x1<<": "<<x1<<", "#x2<<": "<<x2<<", "#x3<<": "<<x3<<", "#x4<<": "<<x4<<", "#x5<<": "<<x5<<endl
#ifdef DEBUG
#define debug(...) CHOOSE((__VA_ARGS__,debug_5,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)
#define dump(...) { print(#__VA_ARGS__); print(":"); out(__VA_ARGS__); }
#else
#define debug(...)
#define dump(...)
#endif

using mint = atcoder::modint998244353;

#define int long long

mint dp[65][2][2];

mint f(ll r1, int a1, ll r2, int a2, ll v) {
if((a1 ^ a2) != v % 4) return 0;
debug(r1, a1, r2, a2, v);
rep(i, 65) rep(j, 2) rep(k, 2) dp[i][j][k] = 0;
dp[60][0][0] = 1;
for(int i = 59; i >= 2; -- i) {
int nr1 = ((r1 >> i) & 1);
int nr2 = ((r2 >> i) & 1);
int nv = ((v >> i) & 1);
rep(f, 2) {
rep(g, 2) {
rep(x, 2) {
if(!f and nr1 < x) continue;
int nf = (f | (x < nr1));
rep(y, 2) {
if(!g and nr2 < y) continue;
if((x ^ y) != nv) continue;
int ng = (g | (y < nr2));
dp[i][nf][ng] += dp[i + 1][f][g];
}
}
}
}
}
mint ret = 0;
rep(f, 2) {
rep(g, 2) {
debug(f, g, dp[2][f][g].val());
if(f == 0 and (r1 / 4) * 4 + a1 > r1) continue;
if(g == 0 and (r2 / 4) * 4 + a2 > r2) continue;
ret += dp[2][f][g];
}
}
return ret;
}

// 0 <= i and i <= x and i % 4 == a なる個数
mint C(ll x, int a) {
if(x < a) return 0;
return (x - a) / 4 + 1LL;
}

mint cnt(ll r1, ll r2, ll v) {
if(r1 == -1 or r2 == -1) return 0;
mint ret = 0;
// (1, 3), (3, 1), (1, 1), (3, 3)
auto sum = [&](int i) ->  int {
if(i == 1) return 1;
if(i == 3) return 0;
assert(false);
};
for(int i = 1; i <= 3; i += 2) {
for(int j = 1; j <= 3; j += 2) {
if(v == (sum(i) ^ sum(j))) {
ret += C(r1, i) * C(r2, j);
}
}
}
debug(ret.val());
// (0, 3), (1, 2), (0, 1), (2, 3) とそのswap
auto val = [&](int i) -> int {
if(i == 0 || i == 3) return 0;
if(i == 1 || i == 2) return 1;
assert(false);
};
rep(i, 4) {
rep(j, 4) {
if(i % 2 != j % 2) {
ll w = (v ^ val(i) ^ val(j));
mint res = (i % 2 == 0 ? w <= r1 and w % 4 == i : w <= r2 and w % 4 == j);
res *= (i % 2 == 1 ? C(r1, i) : C(r2, j));
ret += res;
}
}
}
debug(ret.val());
// (0, 0), (2, 2)
ret += f(r1, 0, r2, 0, v);
ret += f(r1, 2, r2, 2, v);
// (0, 2), (2, 0)
rep(_, 2) {
ret += f(r1, 0, r2, 2, (v ^ 1));
swap(r1, r2);
}
debug(ret.val());
return ret;
}

void solve() {
LL(l, r, v);
-- l;
mint ans = cnt(r, r, v) - cnt(r, l - 1, v) - cnt(l - 1, r, v) + cnt(l - 1, l - 1, v);
if(v == 0) ans -= (r - l + 1);
debug(ans.val());
ans /= 2;
out(ans.val());
}

signed main() {
ios::sync_with_stdio(false);
cin.tie(0);
// cout << fixed << setprecision(20);
// INT(t); rep(i, t)solve();
solve();
return 0;
}
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <deque>
#include <cstdio>
#include <set>
#include <map>
#include <bitset>
#include <stack>
#include <cctype>
using namespace std;
int main() {
int n;
string s;
cin >> n >> s;
long long co = 0;
vector<long long> vec;
for (int i = 1; i < n; i++) {
co++;
if (s[i] != s[i - 1]) {
vec.emplace_back(co);
co = 0;
}
}
vec.emplace_back(co + 1);
long long ans = 0;
for (int i = 0; i < vec.size(); i++) {
ans += vec[i] * (vec[i] - 1) / 2;
}
cout << ans << endl;
}
#line 2 "/home/defineprogram/Desktop/Library/template/template.cpp"
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i, n) for (int i = 0; i < n; i++)
#define REP(i, n) for (int i = 1; i < n; i++)
#define rev(i, n) for (int i = n - 1; i >= 0; i--)
#define REV(i, n) for (int i = n - 1; i > 0; i--)
#define all(v) v.begin(), v.end()
#define PL pair<ll, ll>
#define PI pair<int, int>
#define len(s) (int)s.size()
#define compress(v) \
sort(all(v));   \
v.erase(unique(all(v)), v.end());
#define comid(v, x) lower_bound(all(v), x) - v.begin()

template<class T>
using prique=priority_queue<T,vector<T>,greater<>>;

template <class T, class U>
inline bool chmin(T &a, U b) {
if (a > b) {
a = b;
return true;
}
return false;
}
template <class T, class U>
inline bool chmax(T &a, U b) {
if (a < b) {
a = b;
return true;
}
return false;
}
constexpr ll inf = 3e18;
constexpr double pi = acos(-1);
#line 3 "/home/defineprogram/Desktop/Library/structure/SegmentTree.cpp"

template <typename Monoid,
typename OperatorMonoid,
Monoid (*f)(Monoid, Monoid, int),
Monoid (*g)(Monoid, OperatorMonoid, int),
OperatorMonoid (*h)(OperatorMonoid, OperatorMonoid, int)>
struct Segtree {
int size = 1;

private:
vector<Monoid> dat;
vector<OperatorMonoid> lazy;
Monoid M;
OperatorMonoid OM;

public:
void eval(int k, int l, int r) {
if (lazy[k] != OM) {
dat[k] = g(dat[k], lazy[k], r - l);
if (r - l > 1) {
lazy[(k << 1) + 1] = h(lazy[(k << 1) + 1], lazy[k], r - l);
lazy[(k << 1) + 2] = h(lazy[(k << 1) + 2], lazy[k], r - l);
}
lazy[k] = OM;
}
}
void update(int a, int b, OperatorMonoid M, int k = 0, int l = 0, int r = -1) {
if (r == -1) r = size;
eval(k, l, r);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = h(lazy[k], M, r - l);
eval(k, l, r);
return;
}
update(a, b, M, (k << 1) + 1, l, (l + r) >> 1);
update(a, b, M, (k << 1) + 2, (l + r) >> 1, r);
dat[k] = f(dat[(k << 1) + 1], dat[(k << 1) + 2], r - l);
}
Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {
if (r == -1) r = size;
eval(k, l, r);
if (r <= a || b <= l) return M;
if (a <= l && r <= b) return dat[k];
Monoid lv = query(a, b, (k << 1) + 1, l, (l + r) >> 1);
Monoid rv = query(a, b, (k << 1) + 2, (l + r) >> 1, r);
return f(lv, rv, r - l);
}
template <class C>
int minLeft(int a, int b, C &check, Monoid x, int k = 0, int l = 0, int r = -1) {
if (r == -1) r = size;
eval(k, l, r);
if (r <= a || b <= l || !check(dat[k], x)) return -1;
if (r - l == 1) return l;
int lv = minLeft(a, b, check, x, (k << 1) + 1, l, (l + r) >> 1);
if (lv != -1) return lv;
return minLeft(a, b, check, x, (k << 1) + 2, (l + r) >> 1, r);
}
template <class C>
int maxRight(int a, int b, C &check, Monoid x, int k = 0, int l = 0, int r = -1) {
if (r == -1) r = size;
eval(k, l, r);
if (r <= a || b <= l || !check(dat[k], x)) return -1;
if (r - l == 1) return l;
int rv = maxRight(a, b, check, x, (k << 1) + 2, (l + r) >> 1, r);
if (rv != -1) return rv;
return maxRight(a, b, check, x, (k << 1) + 1, l, (l + r) >> 1);
}
void set(int a, Monoid x) {
dat[a + size - 1] = x;
}
void init(int k = 0, int l = 0, int r = -1) {
if (r == -1) r = size;
if (r - l == 1) return;
init((k << 1) + 1, l, (l + r) >> 1);
init((k << 1) + 2, (l + r) >> 1, r);
dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2], r - l);
}
Segtree(int x, Monoid M, OperatorMonoid OM)
: M(M), OM(OM) {
while (size < x) size <<= 1;
dat.resize((size << 1) - 1, M);
lazy.resize((size << 1) - 1, OM);
}
};

/*
@brief Lazy Segment Tree
@docs docs/SegmentTree.md
*/
#line 3 "main.cpp"

int N;
string X;
auto f=[](int a,int b,int sz){return a+b;};
auto g=[](int a,int b,int sz){return b;};
int main() {
cin>>N>>X;
reverse(all(X));
Segtree<int,int,f,g,g>segtree(N,0,-1);
rep(i,len(X))segtree.set(N-i-1,X[i]-'0');
segtree.init();
cout<<1;
auto check=[&](int a,int b){return a>=1;};

int id=segtree.maxRight(0,N,check,0);
segtree.update(id+1,N,1);
segtree.update(id,id+1,0);
rep(i,N-1){
int id=segtree.maxRight(i,N,check,0);
if(id==-1)break;
int ans=segtree.query(i,i+1);
cout<<ans;
if(!ans){
segtree.update(id+1,N,1);
segtree.update(id,id+1,0);
}
}cout<<"\n";
}

/* I like me better when I'm with you */
#include <bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> 
using namespace __gnu_pbds; 
template<typename T>
using ordered_set = __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define        ll                long long
#define        ld                long double
#define        pb                push_back
#define        mp                make_pair
#define        sz(v)             ((int)(v).size()) 
#define        nl                '\n'
#define        all(x)            (x).begin(),(x).end()
#define        rall(x)           (x).rbegin(),(x).rend()
#define        rep(i,a,b)        for(int i=a;i<b;i++)
#define        per(i,a,b)        for(int i=b-1;i>=a;i--)
#define        trav(a,x)         for(auto &a:x)
#define        fs                first
#define        se                second
template<typename T,typename T1>T chkmax(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T chkmin(T &a,T1 b){if(b<a)a=b;return a;}
void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }
#ifdef nubskr
#define deb(...) cerr << "(" << #__VA_ARGS__ << "):"; dbg_out(__VA_ARGS__);
#define debv(a) cerr << #a << " : ("; trav(i,a){cerr << i << ',';}cerr << ')' << endl;
#define debp(a) cerr << #a << "[ \n"; trav(i,a){cerr << i.fs << '-' << i.se << endl;} cerr << ']';
#else
#define deb(...)
#define debv(a)
#define debp(a)
#endif

void solve(){
int n; cin >> n;
set<pair<int,int>> S;
S.insert({0,0});
rep(i,0,n){
int a,b; cin >> a >> b;
set<pair<int,int>> tmp;
trav(j,S){		
tmp.insert({gcd(j.fs,a),gcd(j.se,b)});
tmp.insert({gcd(j.fs,b),gcd(j.se,a)});
}
swap(S,tmp);
}
ll ans = 0;
// S contains all the possible combinations
trav(i,S){
chkmax(ans,lcm<ll>(i.fs,i.se));
}
cout << ans;
}

int32_t main(){ios::sync_with_stdio(false); cin.tie(NULL);
int t = 1;
// cin >> t;
while(t--){
solve();
}
}
#include "cstdio"
#include <bits/stdc++.h>

using namespace std;

#define ll long long



int main() {
int n;
cin >> n;
if(n == 1) {
cout << '7' << endl;
return 0;
}
if(n == 2) {
cout << "717" << endl;
return 0;
}
int ntemp = n;
vector<int> cs;
while(ntemp != 0) {
int c = 2;
while (true) {
int temp = (c * (c + 1)) / 2;
if (temp > ntemp) {
ntemp -= (c * (c - 1)) / 2;
cs.emplace_back(c);
break;
}
c++;
}
}
cs[0]--;
vector<char> res;
int rem = 0;
int mod = 0;
int modvals[7] = {0,1,2,3,4,5,6};
while(rem < cs.size()) {
while(cs[rem] > 0) {
int i = 0;
while((mod+modvals[i]) != rem) {
i++;
}
int digit = i == 0 ? 7 : i;
res.emplace_back('0' + digit);
cs[rem]--;
mod = rem;
for(int i = 0; i < 7; i++) {
modvals[i] = (modvals[i] * 10) % 7;
}
}
rem++;
}
for(auto it = res.rbegin(); it != res.rend(); it++) {
cout << *it;
}
cout << endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std ;

int main(){
int n;
cin >> n;
long long a[n];
for (int i = 0; i < n; i++) {
cin >> a[i];
}
long long ans = LLONG_MAX;
for (int x = -100; x <= 100; x++) {
long long calc = 0ll;
for (int i = 0; i < n; i++) {
calc += (a[i] - x) * (a[i] - x);
}
ans = min(ans, calc);
}
cout << ans << '\n';
return 0;
}
#include <iostream> 

#include <cstdio>

#include <algorithm>

#include <cstring>

#include <string>

#include <vector>

#include <queue>

#include <deque>

#include <set>

#include <unordered_set>

#include <map>

#include <unordered_map>

#include <bitset>

#include <list>

#include <cmath>

#include <climits>

#define R 998244353

using namespace std;

typedef long long ll;

typedef pair<int, int> pii;

typedef pair<ll, ll> pll;

ll factorial[400000];
ll inverse[400000];

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

ll power(int n, int p){
if(p == 0)
return 1;
ll temp = power(n, p/2);
temp = temp*temp%R;
if(p%2 == 1)
temp = temp*n%R;
return temp;
}

void GetFactorial(){
factorial[0] = 1;
for(int i = 1; i < 400000; i++)
factorial[i] = factorial[i-1]*i%R;
return;
}

void GetInverse(){
for(int i = 0; i < 400000;  i++)
inverse[i] = power(factorial[i], R-2);
}

vector<int> GetPrimes(int M){
vector<int> res;
for(int i = 2; i*i <= M; i++){
int counter = 0;
while(M % i == 0){
counter++;
M /= i;
}
if(counter != 0)
res.push_back(counter);
}
if(M > 1)
res.push_back(1);
return res;
}

ll nHk(int n, int k){
return factorial[n+k-1]*inverse[n-1]%R*inverse[k]%R;
}

int main(){

ios::sync_with_stdio(0);

cin.tie(0), cout.tie(0);

int N, M; cin >> N >> M;
GetFactorial();
GetInverse();
ll res = 0;
for(int i = 1; i <= M; i++){
vector<int> primes = GetPrimes(i);
ll tempRes = 1;
for(int num : primes)
tempRes = tempRes * nHk(num+1, N-1) % R;
res = (res + tempRes) % R;
}
cout << res;
}
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <deque>
#include <cstdio>
#include <set>
#include <map>
#include <bitset>
#include <stack>
#include <cctype>
using namespace std;
long long ans[300030] = {};
map<int,bool> r1, c1;
long long nowr = 0, nowc = 0;
int t[300030], n[300030], c2[300030];
int main() {
long long h, w, c, q;
cin >> h >> w >> c >> q;
for (int i = 0; i < q; i++) {
cin >> t[i] >> n[i] >> c2[i];
}
for (int i = q - 1; i >= 0; i--) {
if (t[i] == 1) {
if (!r1[n[i]]) {
ans[c2[i]] += w - nowr;
nowc++;
r1[n[i]] = true;
}
}
else {
if (!c1[n[i]]) {
ans[c2[i]] += h - nowc;
nowr++;
c1[n[i]] = true;
}
}
}
for (int i = 1; i <= c; i++) {
cout << ans[i] << " ";
}
cout << endl;
}
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
int main(){
ll n;cin>>n;
vector<ll> x(n);
for(int i=0;i<n;i++) cin>>x[i];
vector<ll> s={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
/*  vector<ll> v={0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
*/ll ans=614889782588491411;/*
do{
ll count=1;
for(int i=0;i<15;i++){
if(v[i]){
count*=s[i];
}
}
for(int i=0;i<n;i++){
if(gcd(x[i],count)==1){
break;
}
if(i==n-1){
ans=min(ans,count);
}
}
}while(next_permutation(v.begin(),v.end()));*/
for(int bit = 0; bit < (1<<15); ++bit) {
vector<int> S;
ll count=1;
for (int i = 0; i < 15; ++i) {
if (bit & (1<<i)) { // 列挙に i が含まれるか
count*=s[i];
}
}
for(int i=0;i<n;i++){
if(gcd(x[i],count)==1){
break;
}
if(i==n-1){
ans=min(ans,count);
}
}
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;
using P = pair<int,int>;

int op(int a, int b){
return max(a,b);
}

int e(){
return 0;
}

int main(){
int N, M;
cin >> N >> M;
vector<P> X(M);
vector<P> Y(M);
for(int i=0; i<M; i++){
int x, y;
cin >> x >> y;
X[i] = P(x,i+1);
Y[i] = P(y,i+1);
}
sort(X.begin(),X.end());
sort(Y.begin(),Y.end());
segtree<int,op,e> seg(M+1);

map<int,int> mp; //i番目はsegのどこ？
int pos = 0;
int num = 0;
for(int i=0; i<M; i++){
auto[a,b] = Y[i];
if(num != a){
pos++;
num = a;
}
mp[b] = pos;
}

vector<P> save(0);
num = 0;
int ans = 0;
for(int i=0; i<M; i++){
auto[a,b] = X[i];
if(num != a){
for(int j=0; j<save.size(); j++){
auto[x,y] = save[j];
int z = seg.get(x);
seg.set(x,max(z,y));
ans = max(ans,seg.get(x));
}
save.clear();
}
num = a;
save.push_back(P(mp[b],seg.prod(0,mp[b])+1));
}
for(int j=0; j<save.size(); j++){
auto[x,y] = save[j];
int z = seg.get(x);
ans = max({ans,z,y});
}
cout << ans << endl;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef long double ld;
typedef std::pair<int, int> pii;
typedef std::pair<int, ll> pil;
typedef std::pair<ll, int> pli;
typedef std::pair<ll, ll> pll;
typedef std::pair<int, ld> pid;
typedef std::pair<ll, ld> pld;
typedef std::pair<int, std::string> pis;
typedef std::pair<ll, std::string> pls;
typedef std::vector<int> vi;
typedef std::vector<vi> vvi;
typedef std::vector<vvi> vvvi;
typedef std::vector<vvvi> vvvvi;
typedef std::vector<ll> vl;
typedef std::vector<vl> vvl;
typedef std::vector<vvl> vvvl;
typedef std::vector<vvvl> vvvvl;
typedef std::vector<ld> vd;
typedef std::vector<vd> vvd;
typedef std::vector<std::string> vs;
#define sz(a) (int)(a).size()
#define rep(i,n) for(auto i=0; i<n; ++i)
#define repm(i,s,n) for(auto i=s; i<n; ++i)
#define repd(i,n) for(auto i=n-1; i>=0; --i)
#define repdm(i,e,n) for(auto i=n-1; i>=e; --i)
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()

constexpr int INF = std::numeric_limits<int>::max() >> 1;
constexpr long long INF_LL = std::numeric_limits<long long>::max() >> 1LL;
constexpr long long MOD1 = 1000000007;
constexpr long long MOD9 = 998244353;
using mint1 = atcoder::modint1000000007;
using mint9 = atcoder::modint998244353;
using vm1 = std::vector<mint1>;
using vvm1 = std::vector<vm1>;
using vvvm1 = std::vector<vvm1>;
using vvvvm1 = std::vector<vvvm1>;
using vm9 = std::vector<mint9>;
using vvm9 = std::vector<vm9>;
using vvvm9 = std::vector<vvm9>;
using vvvvm9 = std::vector<vvvm9>;

template <class T> inline bool chmax(T& a, T b, int eq = 0) { if (a < b || (a == b && eq)) { a = b; return 1; } return 0; }
template <class T> inline bool chmin(T& a, T b, int eq = 0) { if (a > b || (a == b && eq)) { a = b; return 1; } return 0; }

template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::istream& operator>>(std::istream& is, mint& x) noexcept {long long v = 0; std::cin >> v; x = v; return is;}
template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::ostream& operator<<(std::ostream& os, const mint& x) noexcept {os << x.val(); return os;}
inline void __n() { std::cout << "\n"; }
template <class T> inline void __(const T a) { std::cout << a; }
template <class T> inline void __l(const T a) { __(a); __n(); }
template <class T> inline void __s(const T a) { __(a); __(' '); }
template <class T1, class T2> inline void __l(const std::pair<T1, T2> a) { __s(a.first); __l(a.second); }
template <class T1, class T2> inline void __s(const std::pair<T1, T2> a) { __s(a.first); __s(a.second); }
template <class T> inline void __v(const std::vector<T> v) { for(auto a : v) __(a); }
template <class T> inline void __vl(const std::vector<T> v) { for(auto a : v) __l(a); }
template <class T> inline void __vs(const std::vector<T> v) { for(auto a : v) __s(a); __n(); }
template <class T> inline void __vvl(const std::vector<std::vector<T>> v) { for(auto a : v) { __v(a); __n(); } }
template <class T> inline void __vvs(const std::vector<std::vector<T>> v) { for(auto a : v) { __vs(a); } }
inline void __ynl(const bool b) {__l(b ? "yes" : "no");}
inline void __yns(const bool b) {__l(b ? "Yes" : "No");}
inline void __ynu(const bool b) {__l(b ? "YES" : "NO");}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

void solve() {


int T; cin >> T;

const vvi C = {
{0, 2, 1, 3, 5},
{1, 0, 2, 1, 0},
{1, 1, 0, 0, 0}
};

rep(_, T) {
vl N(3);
cin >> N[0] >> N[2] >> N[1];
N[2] /= 2;

ll ans = 0;
rep(k, 5) {
ll tmp = INF_LL;
rep(i, 3) if (C[i][k] != 0) chmin(tmp, N[i] / C[i][k]);
rep(i, 3) N[i] -= tmp * C[i][k];
ans += tmp;
}

__l(ans);
}







}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

int main() {

std::ifstream in("input.txt");
std::cin.rdbuf(in.rdbuf());

std::cin.tie(nullptr);
std::cout.tie(nullptr);
std::ios::sync_with_stdio(false);

solve();
std::cout << std::flush;

return 0;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, n) for (int i=0; i<n; ++i)
#define repi(i, j, n) for (int i=j; i<n; ++i)

int main () {
int N;
string s;
cin >> N >> s;

ll cnt = 1, ans = 0;
rep(i, N-1) {
if (s[i] == s[i+1]) ++cnt;
else {
ans += cnt * (cnt-1) / 2;
cnt = 1;
}
}
ans += cnt * (cnt-1) / 2;
cout << ans << endl;
return 0;
}
#include <iostream> 
#include <vector>

#define R 998244353

using namespace std;

typedef long long ll;

ll factorial[400000];
ll inverse[400000];

ll power(int n, int p){
if(p == 0)
return 1;
ll temp = power(n, p/2);
temp = temp*temp%R;
if(p%2 == 1)
temp = temp*n%R;
return temp;
}

void GetFactorial(){
factorial[0] = 1;
for(int i = 1; i < 400000; i++)
factorial[i] = factorial[i-1]*i%R;
return;
}

void GetInverse(){
for(int i = 0; i < 400000;  i++)
inverse[i] = power(factorial[i], R-2);
}

vector<int> GetPrimes(int M){
vector<int> res;
for(int i = 2; i*i <= M; i++){
int counter = 0;
while(M % i == 0){
counter++;
M /= i;
}
if(counter != 0)
res.push_back(counter);
}
if(M > 1)
res.push_back(1);
return res;
}

ll nHk(int n, int k){
return factorial[n+k-1]*inverse[n-1]%R*inverse[k]%R;
}

int main(){
int N, M; cin >> N >> M;
GetFactorial();
GetInverse();
ll res = 0;
for(int i = 1; i <= M; i++){
vector<int> primes = GetPrimes(i);
ll tempRes = 1;
for(int num : primes)
tempRes = tempRes * nHk(num+1, N-1) % R;
res = (res + tempRes) % R;
}
cout << res;
}
#define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep(i, s, n) for (int i = (s); i < (int)(n); i++)
#define INTINF  2147483647

int main()
{
int ans = INTINF;
int n;
cin >> n;

vector<int> num(n);

rep(i, 0, n)
{
cin >> num[i];
}

sort(num.begin(), num.end());

int mi = num[0];
int ma = num[n - 1];

for (int i = mi; i < ma + 1; i++)
{
int tmp = 0;

rep(j, 0, n)
{
tmp += (i - num[j]) * (i - num[j]);
}

ans = min(ans, tmp);
}

cout << ans;
}
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long 
#define ri int
#define pii pair<int,int>
const ll mod=998244353;
ll add(ll x,ll y){return (x+=y)<mod?x:x-mod;}
ll dec(ll x,ll y){return (x-=y)<0?x+mod:x;}
ll ksm(ll d,ll t,ll res=1){for(;t;t>>=1,d=d*d%mod) if(t&1) res=res*d%mod;return res;}
int n;
const int MAXN=2e5+7;
ll a[MAXN];
ll gcd(ll x,ll y){
if(x<0) x=-x;if(y<0) y=-y;
for(;y;x%=y,swap(x,y));return x;
}
struct node{
ll x,y,z;
}b[MAXN],S;
node operator+(const node &p,const node &q){return (node){p.x+q.x,p.y+q.y,p.z+q.z};}
node operator-(const node &p,const node &q){return (node){p.x-q.x,p.y-q.y,p.z-q.z};}
bool operator==(const node &p,const node &q){return p.x==q.x&&p.y==q.y&&p.z==q.z;}

int main(){
scanf("%d",&n);
for(ri i=1;i<=n;++i) scanf("%lld",&a[i]);
b[1]=(node){1,0,0},b[2]=(node){0,1,0},S=(node){0,0,0};a[n+1]=a[1];
for(ri i=2;i<=n+1;++i) b[i+1]=(node){b[i]+b[i]-b[i-1]+(node){0,0,a[i]}};
for(ri i=1;i<=n;++i) S=S+b[i];
b[n+1]=b[n+1]-b[1],b[n+2]=b[n+2]-b[2];
{
ll g=gcd(gcd(b[n+1].x,b[n+1].y),b[n+1].z);
if(b[n+1].x<0) b[n+1]=(node){0,0,0}-b[n+1];
b[n+1].x/=g,b[n+1].y/=g,b[n+1].z/=g;
}
{
ll g=gcd(gcd(b[n+2].x,b[n+2].y),b[n+2].z);
if(b[n+2].x<0) b[n+2]=(node){0,0,0}-b[n+2];
b[n+2].x/=g,b[n+2].y/=g,b[n+2].z/=g;
}
if(!(b[n+1]==b[n+2])) return puts("-1"),0;
if(b[n+1].x!=1) return puts("-1"),0;
ll w=max(0ll,-b[n+1].z);
for(ri i=1;i<=n;++i){
b[i].x+=b[i].y,b[i].z+=b[i].y*b[n+1].z,b[i].y=0;
if(b[i].x<0) b[i].x=-b[i].x,b[i].z=-b[i].z;
w=max(w,(-b[i].z+b[i].x-1)/b[i].x);
// b[i].x*w+b[i].z>=0
//w>=-b[i].z/b[i].x;
// printf("[%lld %lld %lld]\n",b[i].x,b[i].y,b[i].z);
}
// printf("%lldX %lldY %lld=0",b[n+1].x,b[n+1].y,b[n+1].z);puts("");
// printf("%lldX %lldY %lld=0",b[n+2].x,b[n+2].y,b[n+2].z);puts("");
S.x+=S.y,S.z+=S.y*b[n+1].z,S.y=0;
// printf("%lldX %lldY %lld",S.x,S.y,S.z);puts("");
// printf("%lld\n",w);
printf("%lld\n",S.x*w+S.z);
}
/*
4
3 0 -1 -2

x-y+z=0;

y=x+z

x<=z

y=x-z;

a[i]=2*b[i]-b[i-1]-b[i+1]
b[i+1]=2*b[i]-b[i-1]-a[i]
*/
#include <bits/stdc++.h>
#ifndef ATCODER_INTERNAL_BITOP_HPP
#define ATCODER_INTERNAL_BITOP_HPP 1
#ifdef _MSC_VER
#include <intrin.h>
#endif
namespace atcoder
{
namespace internal
{
// @param n `0 <= n`
// @return minimum non-negative `x` s.t. `n <= 2**x`
int ceil_pow2(int n)
{
int x = 0;
while ((1U << x) < (unsigned int)(n))
x++;
return x;
}
// @param n `1 <= n`
// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`
int bsf(unsigned int n)
{
#ifdef _MSC_VER
unsigned long index;
_BitScanForward(&index, n);
return index;
#else
return __builtin_ctz(n);
#endif
}
} // namespace internal
} // namespace atcoder
#endif // ATCODER_INTERNAL_BITOP_HPP
#ifndef ATCODER_INTERNAL_MATH_HPP
#define ATCODER_INTERNAL_MATH_HPP 1
#include <utility>
namespace atcoder
{
namespace internal
{
// @param m `1 <= m`
// @return x mod m
constexpr long long safe_mod(long long x, long long m)
{
x %= m;
if (x < 0)
x += m;
return x;
}
// Fast moduler by barrett reduction
// Reference: https://en.wikipedia.org/wiki/Barrett_reduction
// NOTE: reconsider after Ice Lake
struct barrett
{
unsigned int _m;
unsigned long long im;
// @param m `1 <= m`
barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}
// @return m
unsigned int umod() const { return _m; }
// @param a `0 <= a < m`
// @param b `0 <= b < m`
// @return `a * b % m`
unsigned int mul(unsigned int a, unsigned int b) const
{
// [1] m = 1
// a = b = im = 0, so okay
// [2] m >= 2
// im = ceil(2^64 / m)
// -> im * m = 2^64 + r (0 <= r < m)
// let z = a*b = c*m + d (0 <= c, d < m)
// a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im
// c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2
// ((ab * im) >> 64) == c or c + 1
unsigned long long z = a;
z *= b;
#ifdef _MSC_VER
unsigned long long x;
_umul128(z, im, &x);
#else
unsigned long long x =
(unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
unsigned int v = (unsigned int)(z - x * _m);
if (_m <= v)
v += _m;
return v;
}
};
// @param n `0 <= n`
// @param m `1 <= m`
// @return `(x ** n) % m`
constexpr long long pow_mod_constexpr(long long x, long long n, int m)
{
if (m == 1)
return 0;
unsigned int _m = (unsigned int)(m);
unsigned long long r = 1;
unsigned long long y = safe_mod(x, m);
while (n)
{
if (n & 1)
r = (r * y) % _m;
y = (y * y) % _m;
n >>= 1;
}
return r;
}
// Reference:
// M. Forisek and J. Jancina,
// Fast Primality Testing for Integers That Fit into a Machine Word
// @param n `0 <= n`
constexpr bool is_prime_constexpr(int n)
{
if (n <= 1)
return false;
if (n == 2 || n == 7 || n == 61)
return true;
if (n % 2 == 0)
return false;
long long d = n - 1;
while (d % 2 == 0)
d /= 2;
for (long long a : {2, 7, 61})
{
long long t = d;
long long y = pow_mod_constexpr(a, t, n);
while (t != n - 1 && y != 1 && y != n - 1)
{
y = y * y % n;
t <<= 1;
}
if (y != n - 1 && t % 2 == 0)
{
return false;
}
}
return true;
}
template <int n>
constexpr bool is_prime = is_prime_constexpr(n);
// @param b `1 <= b`
// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g
constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)
{
a = safe_mod(a, b);
if (a == 0)
return {b, 0};
// Contracts:
// [1] s - m0 * a = 0 (mod b)
// [2] t - m1 * a = 0 (mod b)
// [3] s * |m1| + t * |m0| <= b
long long s = b, t = a;
long long m0 = 0, m1 = 1;
while (t)
{
long long u = s / t;
s -= t * u;
m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b
// [3]:
// (s - t * u) * |m1| + t * |m0 - m1 * u|
// <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)
// = s * |m1| + t * |m0| <= b
auto tmp = s;
s = t;
t = tmp;
tmp = m0;
m0 = m1;
m1 = tmp;
}
// by [3]: |m0| <= b/g
// by g != b: |m0| < b/g
if (m0 < 0)
m0 += b / s;
return {s, m0};
}
// Compile time primitive root
// @param m must be prime
// @return primitive root (and minimum in now)
constexpr int primitive_root_constexpr(int m)
{
if (m == 2)
return 1;
if (m == 167772161)
return 3;
if (m == 469762049)
return 3;
if (m == 754974721)
return 11;
if (m == 998244353)
return 3;
int divs[20] = {};
divs[0] = 2;
int cnt = 1;
int x = (m - 1) / 2;
while (x % 2 == 0)
x /= 2;
for (int i = 3; (long long)(i)*i <= x; i += 2)
{
if (x % i == 0)
{
divs[cnt++] = i;
while (x % i == 0)
{
x /= i;
}
}
}
if (x > 1)
{
divs[cnt++] = x;
}
for (int g = 2;; g++)
{
bool ok = true;
for (int i = 0; i < cnt; i++)
{
if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)
{
ok = false;
break;
}
}
if (ok)
return g;
}
}
template <int m>
constexpr int primitive_root = primitive_root_constexpr(m);
} // namespace internal
} // namespace atcoder
#endif // ATCODER_INTERNAL_MATH_HPP
#ifndef ATCODER_INTERNAL_QUEUE_HPP
#define ATCODER_INTERNAL_QUEUE_HPP 1
#include <vector>
namespace atcoder
{
namespace internal
{
template <class T>
struct simple_queue
{
std::vector<T> payload;
int pos = 0;
void reserve(int n) { payload.reserve(n); }
int size() const { return int(payload.size()) - pos; }
bool empty() const { return pos == int(payload.size()); }
void push(const T &t) { payload.push_back(t); }
T &front() { return payload[pos]; }
void clear()
{
payload.clear();
pos = 0;
}
void pop() { pos++; }
};
} // namespace internal
} // namespace atcoder
#endif // ATCODER_INTERNAL_QUEUE_HPP
#ifndef ATCODER_INTERNAL_SCC_HPP
#define ATCODER_INTERNAL_SCC_HPP 1
#include <algorithm>
#include <utility>
#include <vector>
namespace atcoder
{
namespace internal
{
template <class E>
struct csr
{
std::vector<int> start;
std::vector<E> elist;
csr(int n, const std::vector<std::pair<int, E>> &edges)
: start(n + 1), elist(edges.size())
{
for (auto e : edges)
{
start[e.first + 1]++;
}
for (int i = 1; i <= n; i++)
{
start[i] += start[i - 1];
}
auto counter = start;
for (auto e : edges)
{
elist[counter[e.first]++] = e.second;
}
}
};
// Reference:
// R. Tarjan,
// Depth-First Search and Linear Graph Algorithms
struct scc_graph
{
public:
scc_graph(int n) : _n(n) {}
int num_vertices() { return _n; }
void add_edge(int from, int to) { edges.push_back({from, {to}}); }
// @return pair of (# of scc, scc id)
std::pair<int, std::vector<int>> scc_ids()
{
auto g = csr<edge>(_n, edges);
int now_ord = 0, group_num = 0;
std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
visited.reserve(_n);
auto dfs = [&](auto self, int v) -> void
{
low[v] = ord[v] = now_ord++;
visited.push_back(v);
for (int i = g.start[v]; i < g.start[v + 1]; i++)
{
auto to = g.elist[i].to;
if (ord[to] == -1)
{
self(self, to);
low[v] = std::min(low[v], low[to]);
}
else
{
low[v] = std::min(low[v], ord[to]);
}
}
if (low[v] == ord[v])
{
while (true)
{
int u = visited.back();
visited.pop_back();
ord[u] = _n;
ids[u] = group_num;
if (u == v)
break;
}
group_num++;
}
};
for (int i = 0; i < _n; i++)
{
if (ord[i] == -1)
dfs(dfs, i);
}
for (auto &x : ids)
{
x = group_num - 1 - x;
}
return {group_num, ids};
}
std::vector<std::vector<int>> scc()
{
auto ids = scc_ids();
int group_num = ids.first;
std::vector<int> counts(group_num);
for (auto x : ids.second)
counts[x]++;
std::vector<std::vector<int>> groups(ids.first);
for (int i = 0; i < group_num; i++)
{
groups[i].reserve(counts[i]);
}
for (int i = 0; i < _n; i++)
{
groups[ids.second[i]].push_back(i);
}
return groups;
}

private:
int _n;
struct edge
{
int to;
};
std::vector<std::pair<int, edge>> edges;
};
} // namespace internal
} // namespace atcoder
#endif // ATCODER_INTERNAL_SCC_HPP
#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP
#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1
#include <cassert>
#include <numeric>
#include <type_traits>
namespace atcoder
{
namespace internal
{
#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value ||
std::is_same<T, __int128>::value,
std::true_type,
std::false_type>::type;
template <class T>
using is_unsigned_int128 =
typename std::conditional<std::is_same<T, __uint128_t>::value ||
std::is_same<T, unsigned __int128>::value,
std::true_type,
std::false_type>::type;
template <class T>
using make_unsigned_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value,
__uint128_t,
unsigned __int128>;
template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
is_signed_int128<T>::value ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;
template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
std::is_signed<T>::value) ||
is_signed_int128<T>::value,
std::true_type,
std::false_type>::type;
template <class T>
using is_unsigned_int =
typename std::conditional<(is_integral<T>::value &&
std::is_unsigned<T>::value) ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;
template <class T>
using to_unsigned = typename std::conditional<
is_signed_int128<T>::value,
make_unsigned_int128<T>,
typename std::conditional<std::is_signed<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type>::type;
#else
template <class T>
using is_integral = typename std::is_integral<T>;
template <class T>
using is_signed_int =
typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
std::true_type,
std::false_type>::type;
template <class T>
using is_unsigned_int =
typename std::conditional<is_integral<T>::value &&
std::is_unsigned<T>::value,
std::true_type,
std::false_type>::type;
template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type;
#endif
template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;
template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;
template <class T>
using to_unsigned_t = typename to_unsigned<T>::type;
} // namespace internal
} // namespace atcoder
#endif // ATCODER_INTERNAL_TYPE_TRAITS_HPP
#ifndef ATCODER_MODINT_HPP
#define ATCODER_MODINT_HPP 1
#include <cassert>
#include <numeric>
#include <type_traits>
#ifdef _MSC_VER
#include <intrin.h>
#endif
namespace atcoder
{
namespace internal
{
struct modint_base
{
};
struct static_modint_base : modint_base
{
};
template <class T>
using is_modint = std::is_base_of<modint_base, T>;
template <class T>
using is_modint_t = std::enable_if_t<is_modint<T>::value>;
} // namespace internal
template <int m, std::enable_if_t<(1 <= m)> * = nullptr>
struct static_modint : internal::static_modint_base
{
using mint = static_modint;

public:
static constexpr int mod() { return m; }
static mint raw(int v)
{
mint x;
x._v = v;
return x;
}
static_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T> * = nullptr>
static_modint(T v)
{
long long x = (long long)(v % (long long)(umod()));
if (x < 0)
x += umod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T> * = nullptr>
static_modint(T v)
{
_v = (unsigned int)(v % umod());
}
static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }
unsigned int val() const { return _v; }
mint &operator++()
{
_v++;
if (_v == umod())
_v = 0;
return *this;
}
mint &operator--()
{
if (_v == 0)
_v = umod();
_v--;
return *this;
}
mint operator++(int)
{
mint result = *this;
++*this;
return result;
}
mint operator--(int)
{
mint result = *this;
--*this;
return result;
}
mint &operator+=(const mint &rhs)
{
_v += rhs._v;
if (_v >= umod())
_v -= umod();
return *this;
}
mint &operator-=(const mint &rhs)
{
_v -= rhs._v;
if (_v >= umod())
_v += umod();
return *this;
}
mint &operator*=(const mint &rhs)
{
unsigned long long z = _v;
z *= rhs._v;
_v = (unsigned int)(z % umod());
return *this;
}
mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }
mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }
mint pow(long long n) const
{
assert(0 <= n);
mint x = *this, r = 1;
while (n)
{
if (n & 1)
r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const
{
if (prime)
{
assert(_v);
return pow(umod() - 2);
}
else
{
auto eg = internal::inv_gcd(_v, m);
assert(eg.first == 1);
return eg.second;
}
}
friend mint operator+(const mint &lhs, const mint &rhs)
{
return mint(lhs) += rhs;
}
friend mint operator-(const mint &lhs, const mint &rhs)
{
return mint(lhs) -= rhs;
}
friend mint operator*(const mint &lhs, const mint &rhs)
{
return mint(lhs) *= rhs;
}
friend mint operator/(const mint &lhs, const mint &rhs)
{
return mint(lhs) /= rhs;
}
friend bool operator==(const mint &lhs, const mint &rhs)
{
return lhs._v == rhs._v;
}
friend bool operator!=(const mint &lhs, const mint &rhs)
{
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static constexpr unsigned int umod() { return m; }
static constexpr bool prime = internal::is_prime<m>;
};
template <int id>
struct dynamic_modint : internal::modint_base
{
using mint = dynamic_modint;

public:
static int mod() { return (int)(bt.umod()); }
static void set_mod(int m)
{
assert(1 <= m);
bt = internal::barrett(m);
}
static mint raw(int v)
{
mint x;
x._v = v;
return x;
}
dynamic_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T> * = nullptr>
dynamic_modint(T v)
{
long long x = (long long)(v % (long long)(mod()));
if (x < 0)
x += mod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T> * = nullptr>
dynamic_modint(T v)
{
_v = (unsigned int)(v % mod());
}
dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }
unsigned int val() const { return _v; }
mint &operator++()
{
_v++;
if (_v == umod())
_v = 0;
return *this;
}
mint &operator--()
{
if (_v == 0)
_v = umod();
_v--;
return *this;
}
mint operator++(int)
{
mint result = *this;
++*this;
return result;
}
mint operator--(int)
{
mint result = *this;
--*this;
return result;
}
mint &operator+=(const mint &rhs)
{
_v += rhs._v;
if (_v >= umod())
_v -= umod();
return *this;
}
mint &operator-=(const mint &rhs)
{
_v += mod() - rhs._v;
if (_v >= umod())
_v -= umod();
return *this;
}
mint &operator*=(const mint &rhs)
{
_v = bt.mul(_v, rhs._v);
return *this;
}
mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }
mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }
mint pow(long long n) const
{
assert(0 <= n);
mint x = *this, r = 1;
while (n)
{
if (n & 1)
r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const
{
auto eg = internal::inv_gcd(_v, mod());
assert(eg.first == 1);
return eg.second;
}
friend mint operator+(const mint &lhs, const mint &rhs)
{
return mint(lhs) += rhs;
}
friend mint operator-(const mint &lhs, const mint &rhs)
{
return mint(lhs) -= rhs;
}
friend mint operator*(const mint &lhs, const mint &rhs)
{
return mint(lhs) *= rhs;
}
friend mint operator/(const mint &lhs, const mint &rhs)
{
return mint(lhs) /= rhs;
}
friend bool operator==(const mint &lhs, const mint &rhs)
{
return lhs._v == rhs._v;
}
friend bool operator!=(const mint &lhs, const mint &rhs)
{
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static internal::barrett bt;
static unsigned int umod() { return bt.umod(); }
};
template <int id>
internal::barrett dynamic_modint<id>::bt = 998244353;
using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;
namespace internal
{
template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;
template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;
template <class>
struct is_dynamic_modint : public std::false_type
{
};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type
{
};
template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;
} // namespace internal
} // namespace atcoder
#endif // ATCODER_MODINT_HPP
#ifndef ATCODER_CONVOLUTION_HPP
#define ATCODER_CONVOLUTION_HPP 1
#include <algorithm>
#include <array>
#include <cassert>
#include <type_traits>
#include <vector>
namespace atcoder
{
namespace internal
{
template <class mint, internal::is_static_modint_t<mint> * = nullptr>
void butterfly(std::vector<mint> &a)
{
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);
static bool first = true;
static mint sum_e[30]; // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]
if (first)
{
first = false;
mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--)
{
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i < cnt2 - 2; i++)
{
sum_e[i] = es[i] * now;
now *= ies[i];
}
}
for (int ph = 1; ph <= h; ph++)
{
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint now = 1;
for (int s = 0; s < w; s++)
{
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++)
{
auto l = a[i + offset];
auto r = a[i + offset + p] * now;
a[i + offset] = l + r;
a[i + offset + p] = l - r;
}
now *= sum_e[bsf(~(unsigned int)(s))];
}
}
}
template <class mint, internal::is_static_modint_t<mint> * = nullptr>
void butterfly_inv(std::vector<mint> &a)
{
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);
static bool first = true;
static mint sum_ie[30]; // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]
if (first)
{
first = false;
mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--)
{
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i < cnt2 - 2; i++)
{
sum_ie[i] = ies[i] * now;
now *= es[i];
}
}
for (int ph = h; ph >= 1; ph--)
{
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint inow = 1;
for (int s = 0; s < w; s++)
{
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++)
{
auto l = a[i + offset];
auto r = a[i + offset + p];
a[i + offset] = l + r;
a[i + offset + p] =
(unsigned long long)(mint::mod() + l.val() - r.val()) *
inow.val();
}
inow *= sum_ie[bsf(~(unsigned int)(s))];
}
}
}
} // namespace internal
template <class mint, internal::is_static_modint_t<mint> * = nullptr>
std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b)
{
int n = int(a.size()), m = int(b.size());
if (!n || !m)
return {};
if (std::min(n, m) <= 60)
{
if (n < m)
{
std::swap(n, m);
std::swap(a, b);
}
std::vector<mint> ans(n + m - 1);
for (int i = 0; i < n; i++)
{
for (int j = 0; j < m; j++)
{
ans[i + j] += a[i] * b[j];
}
}
return ans;
}
int z = 1 << internal::ceil_pow2(n + m - 1);
a.resize(z);
internal::butterfly(a);
b.resize(z);
internal::butterfly(b);
for (int i = 0; i < z; i++)
{
a[i] *= b[i];
}
internal::butterfly_inv(a);
a.resize(n + m - 1);
mint iz = mint(z).inv();
for (int i = 0; i < n + m - 1; i++)
a[i] *= iz;
return a;
}
template <unsigned int mod = 998244353,
class T,
std::enable_if_t<internal::is_integral<T>::value> * = nullptr>
std::vector<T> convolution(const std::vector<T> &a, const std::vector<T> &b)
{
int n = int(a.size()), m = int(b.size());
if (!n || !m)
return {};
using mint = static_modint<mod>;
std::vector<mint> a2(n), b2(m);
for (int i = 0; i < n; i++)
{
a2[i] = mint(a[i]);
}
for (int i = 0; i < m; i++)
{
b2[i] = mint(b[i]);
}
auto c2 = convolution(move(a2), move(b2));
std::vector<T> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++)
{
c[i] = c2[i].val();
}
return c;
}
std::vector<long long> convolution_ll(const std::vector<long long> &a,
const std::vector<long long> &b)
{
int n = int(a.size()), m = int(b.size());
if (!n || !m)
return {};
static constexpr unsigned long long MOD1 = 754974721; // 2^24
static constexpr unsigned long long MOD2 = 167772161; // 2^25
static constexpr unsigned long long MOD3 = 469762049; // 2^26
static constexpr unsigned long long M2M3 = MOD2 * MOD3;
static constexpr unsigned long long M1M3 = MOD1 * MOD3;
static constexpr unsigned long long M1M2 = MOD1 * MOD2;
static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;
static constexpr unsigned long long i1 =
internal::inv_gcd(MOD2 * MOD3, MOD1).second;
static constexpr unsigned long long i2 =
internal::inv_gcd(MOD1 * MOD3, MOD2).second;
static constexpr unsigned long long i3 =
internal::inv_gcd(MOD1 * MOD2, MOD3).second;
auto c1 = convolution<MOD1>(a, b);
auto c2 = convolution<MOD2>(a, b);
auto c3 = convolution<MOD3>(a, b);
std::vector<long long> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++)
{
unsigned long long x = 0;
x += (c1[i] * i1) % MOD1 * M2M3;
x += (c2[i] * i2) % MOD2 * M1M3;
x += (c3[i] * i3) % MOD3 * M1M2;
// B = 2^63, -B <= x, r(real value) < B
// (x, x - M, x - 2M, or x - 3M) = r (mod 2B)
// r = c1[i] (mod MOD1)
// focus on MOD1
// r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)
// r = x,
//     x - M' + (0 or 2B),
//     x - 2M' + (0, 2B or 4B),
//     x - 3M' + (0, 2B, 4B or 6B) (without mod!)
// (r - x) = 0, (0)
//           - M' + (0 or 2B), (1)
//           -2M' + (0 or 2B or 4B), (2)
//           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)
// we checked that
//   ((1) mod MOD1) mod 5 = 2
//   ((2) mod MOD1) mod 5 = 3
//   ((3) mod MOD1) mod 5 = 4
long long diff =
c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));
if (diff < 0)
diff += MOD1;
static constexpr unsigned long long offset[5] = {
0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};
x -= offset[diff % 5];
c[i] = x;
}
return c;
}
} // namespace atcoder
#endif // ATCODER_CONVOLUTION_HPP
#ifndef ATCODER_DSU_HPP
#define ATCODER_DSU_HPP 1
#include <algorithm>
#include <cassert>
#include <vector>
namespace atcoder
{
// Implement (union by size) + (path compression)
// Reference:
// Zvi Galil and Giuseppe F. Italiano,
// Data structures and algorithms for disjoint set union problems
struct dsu
{
public:
dsu() : _n(0) {}
dsu(int n) : _n(n), parent_or_size(n, -1) {}
int merge(int a, int b)
{
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
int x = leader(a), y = leader(b);
if (x == y)
return x;
if (-parent_or_size[x] < -parent_or_size[y])
std::swap(x, y);
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
return x;
}
bool same(int a, int b)
{
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
return leader(a) == leader(b);
}
int leader(int a)
{
assert(0 <= a && a < _n);
if (parent_or_size[a] < 0)
return a;
return parent_or_size[a] = leader(parent_or_size[a]);
}
int size(int a)
{
assert(0 <= a && a < _n);
return -parent_or_size[leader(a)];
}
std::vector<std::vector<int>> groups()
{
std::vector<int> leader_buf(_n), group_size(_n);
for (int i = 0; i < _n; i++)
{
leader_buf[i] = leader(i);
group_size[leader_buf[i]]++;
}
std::vector<std::vector<int>> result(_n);
for (int i = 0; i < _n; i++)
{
result[i].reserve(group_size[i]);
}
for (int i = 0; i < _n; i++)
{
result[leader_buf[i]].push_back(i);
}
result.erase(
std::remove_if(result.begin(), result.end(),
[&](const std::vector<int> &v)
{ return v.empty(); }),
result.end());
return result;
}

private:
int _n;
// root node: -1 * component size
// otherwise: parent
std::vector<int> parent_or_size;
};
} // namespace atcoder
#endif // ATCODER_DSU_HPP
#ifndef ATCODER_FENWICKTREE_HPP
#define ATCODER_FENWICKTREE_HPP 1
#include <cassert>
#include <vector>
namespace atcoder
{
// Reference: https://en.wikipedia.org/wiki/Fenwick_tree
template <class T>
struct fenwick_tree
{
using U = internal::to_unsigned_t<T>;

public:
fenwick_tree() : _n(0) {}
fenwick_tree(int n) : _n(n), data(n) {}
void add(int p, T x)
{
assert(0 <= p && p < _n);
p++;
while (p <= _n)
{
data[p - 1] += U(x);
p += p & -p;
}
}
T sum(int l, int r)
{
assert(0 <= l && l <= r && r <= _n);
return sum(r) - sum(l);
}

private:
int _n;
std::vector<U> data;
U sum(int r)
{
U s = 0;
while (r > 0)
{
s += data[r - 1];
r -= r & -r;
}
return s;
}
};
} // namespace atcoder
#endif // ATCODER_FENWICKTREE_HPP
#ifndef ATCODER_LAZYSEGTREE_HPP
#define ATCODER_LAZYSEGTREE_HPP 1
#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>
namespace atcoder
{
template <class S,
S (*op)(S, S),
S (*e)(),
class F,
S (*mapping)(F, S),
F (*composition)(F, F),
F (*id)()>
struct lazy_segtree
{
public:
lazy_segtree() : lazy_segtree(0) {}
lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}
lazy_segtree(const std::vector<S> &v) : _n(int(v.size()))
{
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
lz = std::vector<F>(size, id());
for (int i = 0; i < _n; i++)
d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--)
{
update(i);
}
}
void set(int p, S x)
{
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--)
push(p >> i);
d[p] = x;
for (int i = 1; i <= log; i++)
update(p >> i);
}
S get(int p)
{
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--)
push(p >> i);
return d[p];
}
S prod(int l, int r)
{
assert(0 <= l && l <= r && r <= _n);
if (l == r)
return e();
l += size;
r += size;
for (int i = log; i >= 1; i--)
{
if (((l >> i) << i) != l)
push(l >> i);
if (((r >> i) << i) != r)
push(r >> i);
}
S sml = e(), smr = e();
while (l < r)
{
if (l & 1)
sml = op(sml, d[l++]);
if (r & 1)
smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}
return op(sml, smr);
}
S all_prod() { return d[1]; }
void apply(int p, F f)
{
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--)
push(p >> i);
d[p] = mapping(f, d[p]);
for (int i = 1; i <= log; i++)
update(p >> i);
}
void apply(int l, int r, F f)
{
assert(0 <= l && l <= r && r <= _n);
if (l == r)
return;
l += size;
r += size;
for (int i = log; i >= 1; i--)
{
if (((l >> i) << i) != l)
push(l >> i);
if (((r >> i) << i) != r)
push((r - 1) >> i);
}
{
int l2 = l, r2 = r;
while (l < r)
{
if (l & 1)
all_apply(l++, f);
if (r & 1)
all_apply(--r, f);
l >>= 1;
r >>= 1;
}
l = l2;
r = r2;
}
for (int i = 1; i <= log; i++)
{
if (((l >> i) << i) != l)
update(l >> i);
if (((r >> i) << i) != r)
update((r - 1) >> i);
}
}
template <bool (*g)(S)>
int max_right(int l)
{
return max_right(l, [](S x)
{ return g(x); });
}
template <class G>
int max_right(int l, G g)
{
assert(0 <= l && l <= _n);
assert(g(e()));
if (l == _n)
return _n;
l += size;
for (int i = log; i >= 1; i--)
push(l >> i);
S sm = e();
do
{
while (l % 2 == 0)
l >>= 1;
if (!g(op(sm, d[l])))
{
while (l < size)
{
push(l);
l = (2 * l);
if (g(op(sm, d[l])))
{
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}
template <bool (*g)(S)>
int min_left(int r)
{
return min_left(r, [](S x)
{ return g(x); });
}
template <class G>
int min_left(int r, G g)
{
assert(0 <= r && r <= _n);
assert(g(e()));
if (r == 0)
return 0;
r += size;
for (int i = log; i >= 1; i--)
push((r - 1) >> i);
S sm = e();
do
{
r--;
while (r > 1 && (r % 2))
r >>= 1;
if (!g(op(d[r], sm)))
{
while (r < size)
{
push(r);
r = (2 * r + 1);
if (g(op(d[r], sm)))
{
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;
std::vector<F> lz;
void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
void all_apply(int k, F f)
{
d[k] = mapping(f, d[k]);
if (k < size)
lz[k] = composition(f, lz[k]);
}
void push(int k)
{
all_apply(2 * k, lz[k]);
all_apply(2 * k + 1, lz[k]);
lz[k] = id();
}
};
} // namespace atcoder
#endif // ATCODER_LAZYSEGTREE_HPP
#ifndef ATCODER_MATH_HPP
#define ATCODER_MATH_HPP 1
#include <algorithm>
#include <cassert>
#include <tuple>
#include <vector>
namespace atcoder
{
long long pow_mod(long long x, long long n, int m)
{
assert(0 <= n && 1 <= m);
if (m == 1)
return 0;
internal::barrett bt((unsigned int)(m));
unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));
while (n)
{
if (n & 1)
r = bt.mul(r, y);
y = bt.mul(y, y);
n >>= 1;
}
return r;
}
long long inv_mod(long long x, long long m)
{
assert(1 <= m);
auto z = internal::inv_gcd(x, m);
assert(z.first == 1);
return z.second;
}
// (rem, mod)
std::pair<long long, long long> crt(const std::vector<long long> &r,
const std::vector<long long> &m)
{
assert(r.size() == m.size());
int n = int(r.size());
// Contracts: 0 <= r0 < m0
long long r0 = 0, m0 = 1;
for (int i = 0; i < n; i++)
{
assert(1 <= m[i]);
long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];
if (m0 < m1)
{
std::swap(r0, r1);
std::swap(m0, m1);
}
if (m0 % m1 == 0)
{
if (r0 % m1 != r1)
return {0, 0};
continue;
}
// assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)
// (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));
// r2 % m0 = r0
// r2 % m1 = r1
// -> (r0 + x*m0) % m1 = r1
// -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)
// -> x = (r1 - r0) / g * inv(u0) (mod u1)
// im = inv(u0) (mod u1) (0 <= im < u1)
long long g, im;
std::tie(g, im) = internal::inv_gcd(m0, m1);
long long u1 = (m1 / g);
// |r1 - r0| < (m0 + m1) <= lcm(m0, m1)
if ((r1 - r0) % g)
return {0, 0};
// u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)
long long x = (r1 - r0) / g % u1 * im % u1;
// |r0| + |m0 * x|
// < m0 + m0 * (u1 - 1)
// = m0 + m0 * m1 / g - m0
// = lcm(m0, m1)
r0 += x * m0;
m0 *= u1; // -> lcm(m0, m1)
if (r0 < 0)
r0 += m0;
}
return {r0, m0};
}
long long floor_sum(long long n, long long m, long long a, long long b)
{
long long ans = 0;
if (a >= m)
{
ans += (n - 1) * n * (a / m) / 2;
a %= m;
}
if (b >= m)
{
ans += n * (b / m);
b %= m;
}
long long y_max = (a * n + b) / m, x_max = (y_max * m - b);
if (y_max == 0)
return ans;
ans += (n - (x_max + a - 1) / a) * y_max;
ans += floor_sum(y_max, a, m, (a - x_max % a) % a);
return ans;
}
} // namespace atcoder
#endif // ATCODER_MATH_HPP
#ifndef ATCODER_MAXFLOW_HPP
#define ATCODER_MAXFLOW_HPP 1
#include <algorithm>
#include <cassert>
#include <limits>
#include <queue>
#include <vector>
namespace atcoder
{
template <class Cap>
struct mf_graph
{
public:
mf_graph() : _n(0) {}
mf_graph(int n) : _n(n), g(n) {}
int add_edge(int from, int to, Cap cap)
{
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
int m = int(pos.size());
pos.push_back({from, int(g[from].size())});
g[from].push_back(_edge{to, int(g[to].size()), cap});
g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});
return m;
}
struct edge
{
int from, to;
Cap cap, flow;
};
edge get_edge(int i)
{
int m = int(pos.size());
assert(0 <= i && i < m);
auto _e = g[pos[i].first][pos[i].second];
auto _re = g[_e.to][_e.rev];
return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};
}
std::vector<edge> edges()
{
int m = int(pos.size());
std::vector<edge> result;
for (int i = 0; i < m; i++)
{
result.push_back(get_edge(i));
}
return result;
}
void change_edge(int i, Cap new_cap, Cap new_flow)
{
int m = int(pos.size());
assert(0 <= i && i < m);
assert(0 <= new_flow && new_flow <= new_cap);
auto &_e = g[pos[i].first][pos[i].second];
auto &_re = g[_e.to][_e.rev];
_e.cap = new_cap - new_flow;
_re.cap = new_flow;
}
Cap flow(int s, int t)
{
return flow(s, t, std::numeric_limits<Cap>::max());
}
Cap flow(int s, int t, Cap flow_limit)
{
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
std::vector<int> level(_n), iter(_n);
internal::simple_queue<int> que;
auto bfs = [&]()
{
std::fill(level.begin(), level.end(), -1);
level[s] = 0;
que.clear();
que.push(s);
while (!que.empty())
{
int v = que.front();
que.pop();
for (auto e : g[v])
{
if (e.cap == 0 || level[e.to] >= 0)
continue;
level[e.to] = level[v] + 1;
if (e.to == t)
return;
que.push(e.to);
}
}
};
auto dfs = [&](auto self, int v, Cap up)
{
if (v == s)
return up;
Cap res = 0;
int level_v = level[v];
for (int &i = iter[v]; i < int(g[v].size()); i++)
{
_edge &e = g[v][i];
if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0)
continue;
Cap d =
self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));
if (d <= 0)
continue;
g[v][i].cap += d;
g[e.to][e.rev].cap -= d;
res += d;
if (res == up)
break;
}
return res;
};
Cap flow = 0;
while (flow < flow_limit)
{
bfs();
if (level[t] == -1)
break;
std::fill(iter.begin(), iter.end(), 0);
while (flow < flow_limit)
{
Cap f = dfs(dfs, t, flow_limit - flow);
if (!f)
break;
flow += f;
}
}
return flow;
}
std::vector<bool> min_cut(int s)
{
std::vector<bool> visited(_n);
internal::simple_queue<int> que;
que.push(s);
while (!que.empty())
{
int p = que.front();
que.pop();
visited[p] = true;
for (auto e : g[p])
{
if (e.cap && !visited[e.to])
{
visited[e.to] = true;
que.push(e.to);
}
}
}
return visited;
}

private:
int _n;
struct _edge
{
int to, rev;
Cap cap;
};
std::vector<std::pair<int, int>> pos;
std::vector<std::vector<_edge>> g;
};
} // namespace atcoder
#endif // ATCODER_MAXFLOW_HPP
#ifndef ATCODER_MINCOSTFLOW_HPP
#define ATCODER_MINCOSTFLOW_HPP 1
#include <algorithm>
#include <cassert>
#include <limits>
#include <queue>
#include <vector>
namespace atcoder
{
template <class Cap, class Cost>
struct mcf_graph
{
public:
mcf_graph() {}
mcf_graph(int n) : _n(n), g(n) {}
int add_edge(int from, int to, Cap cap, Cost cost)
{
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
int m = int(pos.size());
pos.push_back({from, int(g[from].size())});
g[from].push_back(_edge{to, int(g[to].size()), cap, cost});
g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});
return m;
}
struct edge
{
int from, to;
Cap cap, flow;
Cost cost;
};
edge get_edge(int i)
{
int m = int(pos.size());
assert(0 <= i && i < m);
auto _e = g[pos[i].first][pos[i].second];
auto _re = g[_e.to][_e.rev];
return edge{
pos[i].first,
_e.to,
_e.cap + _re.cap,
_re.cap,
_e.cost,
};
}
std::vector<edge> edges()
{
int m = int(pos.size());
std::vector<edge> result(m);
for (int i = 0; i < m; i++)
{
result[i] = get_edge(i);
}
return result;
}
std::pair<Cap, Cost> flow(int s, int t)
{
return flow(s, t, std::numeric_limits<Cap>::max());
}
std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit)
{
return slope(s, t, flow_limit).back();
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t)
{
return slope(s, t, std::numeric_limits<Cap>::max());
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit)
{
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);
// variants (C = maxcost):
// -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0
// reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge
std::vector<Cost> dual(_n, 0), dist(_n);
std::vector<int> pv(_n), pe(_n);
std::vector<bool> vis(_n);
auto dual_ref = [&]()
{
std::fill(dist.begin(), dist.end(),
std::numeric_limits<Cost>::max());
std::fill(pv.begin(), pv.end(), -1);
std::fill(pe.begin(), pe.end(), -1);
std::fill(vis.begin(), vis.end(), false);
struct Q
{
Cost key;
int to;
bool operator<(Q r) const { return key > r.key; }
};
std::priority_queue<Q> que;
dist[s] = 0;
que.push(Q{0, s});
while (!que.empty())
{
int v = que.top().to;
que.pop();
if (vis[v])
continue;
vis[v] = true;
if (v == t)
break;
// dist[v] = shortest(s, v) + dual[s] - dual[v]
// dist[v] >= 0 (all reduced cost are positive)
// dist[v] <= (n-1)C
for (int i = 0; i < int(g[v].size()); i++)
{
auto e = g[v][i];
if (vis[e.to] || !e.cap)
continue;
// |-dual[e.to] + dual[v]| <= (n-1)C
// cost <= C - -(n-1)C + 0 = nC
Cost cost = e.cost - dual[e.to] + dual[v];
if (dist[e.to] - dist[v] > cost)
{
dist[e.to] = dist[v] + cost;
pv[e.to] = v;
pe[e.to] = i;
que.push(Q{dist[e.to], e.to});
}
}
}
if (!vis[t])
{
return false;
}
for (int v = 0; v < _n; v++)
{
if (!vis[v])
continue;
// dual[v] = dual[v] - dist[t] + dist[v]
//         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])
//         = - shortest(s, t) + dual[t] + shortest(s, v)
//         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C
dual[v] -= dist[t] - dist[v];
}
return true;
};
Cap flow = 0;
Cost cost = 0, prev_cost = -1;
std::vector<std::pair<Cap, Cost>> result;
result.push_back({flow, cost});
while (flow < flow_limit)
{
if (!dual_ref())
break;
Cap c = flow_limit - flow;
for (int v = t; v != s; v = pv[v])
{
c = std::min(c, g[pv[v]][pe[v]].cap);
}
for (int v = t; v != s; v = pv[v])
{
auto &e = g[pv[v]][pe[v]];
e.cap -= c;
g[v][e.rev].cap += c;
}
Cost d = -dual[s];
flow += c;
cost += c * d;
if (prev_cost == d)
{
result.pop_back();
}
result.push_back({flow, cost});
prev_cost = cost;
}
return result;
}

private:
int _n;
struct _edge
{
int to, rev;
Cap cap;
Cost cost;
};
std::vector<std::pair<int, int>> pos;
std::vector<std::vector<_edge>> g;
};
} // namespace atcoder
#endif // ATCODER_MINCOSTFLOW_HPP
#ifndef ATCODER_SCC_HPP
#define ATCODER_SCC_HPP 1
#include <algorithm>
#include <cassert>
#include <vector>
namespace atcoder
{
struct scc_graph
{
public:
scc_graph() : internal(0) {}
scc_graph(int n) : internal(n) {}
void add_edge(int from, int to)
{
int n = internal.num_vertices();
assert(0 <= from && from < n);
assert(0 <= to && to < n);
internal.add_edge(from, to);
}
std::vector<std::vector<int>> scc() { return internal.scc(); }

private:
internal::scc_graph internal;
};
} // namespace atcoder
#endif // ATCODER_SCC_HPP
#ifndef ATCODER_SEGTREE_HPP
#define ATCODER_SEGTREE_HPP 1
#include <algorithm>
#include <cassert>
#include <vector>
namespace atcoder
{
template <class S, S (*op)(S, S), S (*e)()>
struct segtree
{
public:
segtree() : segtree(0) {}
segtree(int n) : segtree(std::vector<S>(n, e())) {}
segtree(const std::vector<S> &v) : _n(int(v.size()))
{
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
for (int i = 0; i < _n; i++)
d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--)
{
update(i);
}
}
void set(int p, S x)
{
assert(0 <= p && p < _n);
p += size;
d[p] = x;
for (int i = 1; i <= log; i++)
update(p >> i);
}
S get(int p)
{
assert(0 <= p && p < _n);
return d[p + size];
}
S prod(int l, int r)
{
assert(0 <= l && l <= r && r <= _n);
S sml = e(), smr = e();
l += size;
r += size;
while (l < r)
{
if (l & 1)
sml = op(sml, d[l++]);
if (r & 1)
smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}
return op(sml, smr);
}
S all_prod() { return d[1]; }
template <bool (*f)(S)>
int max_right(int l)
{
return max_right(l, [](S x)
{ return f(x); });
}
template <class F>
int max_right(int l, F f)
{
assert(0 <= l && l <= _n);
assert(f(e()));
if (l == _n)
return _n;
l += size;
S sm = e();
do
{
while (l % 2 == 0)
l >>= 1;
if (!f(op(sm, d[l])))
{
while (l < size)
{
l = (2 * l);
if (f(op(sm, d[l])))
{
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}
template <bool (*f)(S)>
int min_left(int r)
{
return min_left(r, [](S x)
{ return f(x); });
}
template <class F>
int min_left(int r, F f)
{
assert(0 <= r && r <= _n);
assert(f(e()));
if (r == 0)
return 0;
r += size;
S sm = e();
do
{
r--;
while (r > 1 && (r % 2))
r >>= 1;
if (!f(op(d[r], sm)))
{
while (r < size)
{
r = (2 * r + 1);
if (f(op(d[r], sm)))
{
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;
void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
};
} // namespace atcoder
#endif // ATCODER_SEGTREE_HPP
#ifndef ATCODER_STRING_HPP
#define ATCODER_STRING_HPP 1
#include <algorithm>
#include <cassert>
#include <numeric>
#include <string>
#include <vector>
namespace atcoder
{
namespace internal
{
std::vector<int> sa_naive(const std::vector<int> &s)
{
int n = int(s.size());
std::vector<int> sa(n);
std::iota(sa.begin(), sa.end(), 0);
std::sort(sa.begin(), sa.end(), [&](int l, int r)
{
if (l == r)
return false;
while (l < n && r < n)
{
if (s[l] != s[r])
return s[l] < s[r];
l++;
r++;
}
return l == n;
});
return sa;
}
std::vector<int> sa_doubling(const std::vector<int> &s)
{
int n = int(s.size());
std::vector<int> sa(n), rnk = s, tmp(n);
std::iota(sa.begin(), sa.end(), 0);
for (int k = 1; k < n; k *= 2)
{
auto cmp = [&](int x, int y)
{
if (rnk[x] != rnk[y])
return rnk[x] < rnk[y];
int rx = x + k < n ? rnk[x + k] : -1;
int ry = y + k < n ? rnk[y + k] : -1;
return rx < ry;
};
std::sort(sa.begin(), sa.end(), cmp);
tmp[sa[0]] = 0;
for (int i = 1; i < n; i++)
{
tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
}
std::swap(tmp, rnk);
}
return sa;
}
// SA-IS, linear-time suffix array construction
// Reference:
// G. Nong, S. Zhang, and W. H. Chan,
// Two Efficient Algorithms for Linear Time Suffix Array Construction
template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
std::vector<int> sa_is(const std::vector<int> &s, int upper)
{
int n = int(s.size());
if (n == 0)
return {};
if (n == 1)
return {0};
if (n == 2)
{
if (s[0] < s[1])
{
return {0, 1};
}
else
{
return {1, 0};
}
}
if (n < THRESHOLD_NAIVE)
{
return sa_naive(s);
}
if (n < THRESHOLD_DOUBLING)
{
return sa_doubling(s);
}
std::vector<int> sa(n);
std::vector<bool> ls(n);
for (int i = n - 2; i >= 0; i--)
{
ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
}
std::vector<int> sum_l(upper + 1), sum_s(upper + 1);
for (int i = 0; i < n; i++)
{
if (!ls[i])
{
sum_s[s[i]]++;
}
else
{
sum_l[s[i] + 1]++;
}
}
for (int i = 0; i <= upper; i++)
{
sum_s[i] += sum_l[i];
if (i < upper)
sum_l[i + 1] += sum_s[i];
}
auto induce = [&](const std::vector<int> &lms)
{
std::fill(sa.begin(), sa.end(), -1);
std::vector<int> buf(upper + 1);
std::copy(sum_s.begin(), sum_s.end(), buf.begin());
for (auto d : lms)
{
if (d == n)
continue;
sa[buf[s[d]]++] = d;
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
sa[buf[s[n - 1]]++] = n - 1;
for (int i = 0; i < n; i++)
{
int v = sa[i];
if (v >= 1 && !ls[v - 1])
{
sa[buf[s[v - 1]]++] = v - 1;
}
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
for (int i = n - 1; i >= 0; i--)
{
int v = sa[i];
if (v >= 1 && ls[v - 1])
{
sa[--buf[s[v - 1] + 1]] = v - 1;
}
}
};
std::vector<int> lms_map(n + 1, -1);
int m = 0;
for (int i = 1; i < n; i++)
{
if (!ls[i - 1] && ls[i])
{
lms_map[i] = m++;
}
}
std::vector<int> lms;
lms.reserve(m);
for (int i = 1; i < n; i++)
{
if (!ls[i - 1] && ls[i])
{
lms.push_back(i);
}
}
induce(lms);
if (m)
{
std::vector<int> sorted_lms;
sorted_lms.reserve(m);
for (int v : sa)
{
if (lms_map[v] != -1)
sorted_lms.push_back(v);
}
std::vector<int> rec_s(m);
int rec_upper = 0;
rec_s[lms_map[sorted_lms[0]]] = 0;
for (int i = 1; i < m; i++)
{
int l = sorted_lms[i - 1], r = sorted_lms[i];
int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
bool same = true;
if (end_l - l != end_r - r)
{
same = false;
}
else
{
while (l < end_l)
{
if (s[l] != s[r])
{
break;
}
l++;
r++;
}
if (l == n || s[l] != s[r])
same = false;
}
if (!same)
rec_upper++;
rec_s[lms_map[sorted_lms[i]]] = rec_upper;
}
auto rec_sa =
sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);
for (int i = 0; i < m; i++)
{
sorted_lms[i] = lms[rec_sa[i]];
}
induce(sorted_lms);
}
return sa;
}
} // namespace internal
std::vector<int> suffix_array(const std::vector<int> &s, int upper)
{
assert(0 <= upper);
for (int d : s)
{
assert(0 <= d && d <= upper);
}
auto sa = internal::sa_is(s, upper);
return sa;
}
template <class T>
std::vector<int> suffix_array(const std::vector<T> &s)
{
int n = int(s.size());
std::vector<int> idx(n);
iota(idx.begin(), idx.end(), 0);
sort(idx.begin(), idx.end(), [&](int l, int r)
{ return s[l] < s[r]; });
std::vector<int> s2(n);
int now = 0;
for (int i = 0; i < n; i++)
{
if (i && s[idx[i - 1]] != s[idx[i]])
now++;
s2[idx[i]] = now;
}
return internal::sa_is(s2, now);
}
std::vector<int> suffix_array(const std::string &s)
{
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++)
{
s2[i] = s[i];
}
return internal::sa_is(s2, 255);
}
// Reference:
// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
// Applications
template <class T>
std::vector<int> lcp_array(const std::vector<T> &s,
const std::vector<int> &sa)
{
int n = int(s.size());
assert(n >= 1);
std::vector<int> rnk(n);
for (int i = 0; i < n; i++)
{
rnk[sa[i]] = i;
}
std::vector<int> lcp(n - 1);
int h = 0;
for (int i = 0; i < n; i++)
{
if (h > 0)
h--;
if (rnk[i] == 0)
continue;
int j = sa[rnk[i] - 1];
for (; j + h < n && i + h < n; h++)
{
if (s[j + h] != s[i + h])
break;
}
lcp[rnk[i] - 1] = h;
}
return lcp;
}
std::vector<int> lcp_array(const std::string &s, const std::vector<int> &sa)
{
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++)
{
s2[i] = s[i];
}
return lcp_array(s2, sa);
}
// Reference:
// D. Gusfield,
// Algorithms on Strings, Trees, and Sequences: Computer Science and
// Computational Biology
template <class T>
std::vector<int> z_algorithm(const std::vector<T> &s)
{
int n = int(s.size());
if (n == 0)
return {};
std::vector<int> z(n);
z[0] = 0;
for (int i = 1, j = 0; i < n; i++)
{
int &k = z[i];
k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);
while (i + k < n && s[k] == s[i + k])
k++;
if (j + z[j] < i + z[i])
j = i;
}
z[0] = n;
return z;
}
std::vector<int> z_algorithm(const std::string &s)
{
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++)
{
s2[i] = s[i];
}
return z_algorithm(s2);
}
} // namespace atcoder
#endif // ATCODER_STRING_HPP
#ifndef ATCODER_TWOSAT_HPP
#define ATCODER_TWOSAT_HPP 1
#include <cassert>
#include <vector>
namespace atcoder
{
// Reference:
// B. Aspvall, M. Plass, and R. Tarjan,
// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean
// Formulas
struct two_sat
{
public:
two_sat() : _n(0), scc(0) {}
two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}
void add_clause(int i, bool f, int j, bool g)
{
assert(0 <= i && i < _n);
assert(0 <= j && j < _n);
scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));
scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));
}
bool satisfiable()
{
auto id = scc.scc_ids().second;
for (int i = 0; i < _n; i++)
{
if (id[2 * i] == id[2 * i + 1])
return false;
_answer[i] = id[2 * i] < id[2 * i + 1];
}
return true;
}
std::vector<bool> answer() { return _answer; }

private:
int _n;
std::vector<bool> _answer;
internal::scc_graph scc;
};
} // namespace atcoder
#endif // ATCODER_TWOSAT_HPP
#pragma GCC optimize("Ofast")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx")
#include <bits/stdc++.h>
using namespace std;
using namespace atcoder;
using ll = long long;
using vec = vector<ll>;
using vect = vector<double>;
using Graph = vector<vector<ll>>;
#define endl '\n'
#define loop(i, n) for (register int i = 0; i < n; i++)
#define Loop(i, m, n) for (int i = m; i < n; i++)
#define pool(i, n) for (int i = n; i >= 0; i--)
#define Pool(i, m, n) for (int i = n; i >= m; i--)
#define modd 1000000007ll
//#define modd 998244353ll
#define flagcount(bit) __builtin_popcount(bit)
#define flag(x) (1ll << x)
#define flagadd(bit, x) bit |= flag(x)
#define flagpop(bit, x) bit &= ~flag(x)
#define flagon(bit, i) bit &flag(i)
#define flagoff(bit, i) !(bit & (1ll << i))
#define all(v) v.begin(), v.end()
#define low2way(v, x) lower_bound(all(v), x)
#define high2way(v, x) upper_bound(all(v), x)
#define idx_lower(v, x) (distance(v.begin(), low2way(v, x)))                //配列vでx未満の要素数を返す
#define idx_upper(v, x) (distance(v.begin(), high2way(v, x)))               //配列vでx以下の要素数を返す
#define idx_lower2(v, x) (v.size() - idx_lower(v, x))                       //配列vでx以上の要素数を返す
#define idx_upper2(v, x) (v.size() - idx_upper(v, x))                       //配列vでxより大きい要素の数を返す
#define idx_count(v, l, r) max(0, (int)(idx_upper(v, r) - idx_lower(v, l))) //配列vでl<=x<=rを満たす要素xの数を返す
#define putout(a) cout << a << '\n'
#define Sum(v) accumulate(all(v), 0ll)
ll ctoi(char c)
{
if (c >= '0' && c <= '9')
{
return c - '0';
}
return -1;
}
template <typename T>
string make_string(T N)
{
string ret;
T now = N;
while (now > 0)
{
T x = now % 10;
ret += (char)('0' + x);
now /= 10;
}
reverse(all(ret));
return ret;
}
template <typename T>
T gcd(T a, T b)
{
if (a % b == 0)
{
return (b);
}
else
{
return (gcd(b, a % b));
}
}
template <typename T>
T lcm(T x, T y)
{
T z = gcd(x, y);
return x * y / z;
}
template <typename T>
bool primejudge(T n)
{
if (n < 2)
return false;
else if (n == 2)
return true;
else if (n % 2 == 0)
return false;
double sqrtn = sqrt(n);
for (T i = 3; i < sqrtn + 1; i++)
{
if (n % i == 0)
{
return false;
}
i++;
}
return true;
}
template <typename T>
bool chmax(T &a, const T &b)
{
if (a < b)
{
a = b; // aをbで更新
return true;
}
return false;
}
template <typename T>
bool chmin(T &a, const T &b)
{
if (a > b)
{
a = b; // aをbで更新
return true;
}
return false;
}
//場合によって使い分ける
//const ll dx[4]={1,0,-1,0};
//const ll dy[4]={0,1,0,-1};
const ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};
const ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
//cout << fixed << setprecision(10);
//vector<vector<ll>> field(h, vector<ll>(w));
class FastIO
{
static const int rdata_sz = (1 << 25), wdata_sz = (1 << 25);
char rdata[rdata_sz], wdata[wdata_sz], *rb, *wb;
char tmp_s[20];

public:
FastIO()
{
fread(rdata, 1, rdata_sz, stdin);
rb = rdata;
wb = wdata;
}
~FastIO()
{
fwrite(wdata, 1, wb - wdata, stdout);
}

template <typename T>
inline void read(T &x)
{
bool neg = false;
x = 0;
while ((*rb < '0' || *rb > '9') && *rb != '-')
++rb;
if (*rb == '-')
{
neg = true;
++rb;
}
while ('0' <= *rb && *rb <= '9')
{
x = 10 * x + (*rb - '0');
++rb;
}
if (neg)
x = -x;
}
template <typename T>
inline void read(T &x, T &y)
{
read(x);
read(y);
}
template <typename T>
inline void read(T &x, T &y, T &z)
{
read(x);
read(y);
read(z);
}
template <typename T>
inline void read(T &x, T &y, T &z, T &X)
{
read(x);
read(y);
read(z);
read(X);
}
template <typename T>
inline void read(T &x, T &y, T &z, T &X, T &Y)
{
read(x);
read(y);
read(z);
read(X);
read(Y);
}
template <typename T>
inline void read(T &x, T &y, T &z, T &X, T &Y, T &Z)
{
read(x);
read(y);
read(z);
read(X);
read(Y);
read(Z);
}
#define pc(x) *(wb++) = x
template <typename T>
inline void write(T x)
{
if (x == 0)
{
pc('0');
pc('\n');
return;
}
if (x < 0)
{
pc('-');
x = -x;
}
char *t = tmp_s;
while (x)
{
T y = x / 10;
*(t++) = (x - y * 10) + '0';
x = y;
}
while (t != tmp_s)
pc(*(--t));
pc('\n');
}
#undef pc
};
static struct IO
{
char tmp[1 << 10];
// fast input routines
char cur;

//#define nextChar() (cur = getc_unlocked(stdin))
//#define peekChar() (cur)
inline char nextChar() { return cur = getc_unlocked(stdin); }
inline char peekChar() { return cur; }

inline operator bool() { return peekChar(); }
inline static bool isBlank(char c) { return (c < '!' && c); }
inline bool skipBlanks()
{
while (isBlank(nextChar()))
;
return peekChar() != 0;
}

inline IO &operator>>(char &c)
{
c = nextChar();
return *this;
}

inline IO &operator>>(char *buf)
{
if (skipBlanks())
{
if (peekChar())
{
*(buf++) = peekChar();
while (!isBlank(nextChar()))
*(buf++) = peekChar();
}
*(buf++) = 0;
}
return *this;
}

inline IO &operator>>(string &s)
{
if (skipBlanks())
{
s.clear();
s += peekChar();
while (!isBlank(nextChar()))
s += peekChar();
}
return *this;
}

inline IO &operator>>(double &d)
{
if ((*this) >> tmp)
sscanf(tmp, "%lf", &d);
return *this;
}

#define defineInFor(intType)                         \
inline IO &operator>>(intType &n)                \
{                                                \
if (skipBlanks())                            \
{                                            \
int sign = +1;                           \
if (peekChar() == '-')                   \
{                                        \
sign = -1;                           \
n = nextChar() - '0';                \
}                                        \
else                                     \
n = peekChar() - '0';                \
while (!isBlank(nextChar()))             \
{                                        \
n += n + (n << 3) + peekChar() - 48; \
}                                        \
n *= sign;                               \
}                                            \
return *this;                                \
}

defineInFor(int)
defineInFor(unsigned int)
defineInFor(long long)

// fast output routines

//#define putChar(c) putc_unlocked((c), stdout)
inline void putChar(char c)
{
putc_unlocked(c, stdout);
}
inline IO &operator<<(char c)
{
putChar(c);
return *this;
}
inline IO &operator<<(const char *s)
{
while (*s)
putChar(*s++);
return *this;
}

inline IO &operator<<(const string &s)
{
for (int i = 0; i < (int)s.size(); ++i)
putChar(s[i]);
return *this;
}

char *toString(double d)
{
sprintf(tmp, "%lf%c", d, '\0');
return tmp;
}
inline IO &operator<<(double d) { return (*this) << toString(d); }

#define defineOutFor(intType)                   \
inline char *toString(intType n)            \
{                                           \
char *p = (tmp + 30);                   \
if (n)                                  \
{                                       \
bool isNeg = 0;                     \
if (n < 0)                          \
isNeg = 1, n = -n;              \
while (n)                           \
*--p = (n % 10) + '0', n /= 10; \
if (isNeg)                          \
*--p = '-';                     \
}                                       \
else                                    \
*--p = '0';                         \
return p;                               \
}                                           \
inline IO &operator<<(intType n) { return (*this) << toString(n); }

defineOutFor(int)
defineOutFor(long long)

#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;
using mint = modint998244353;
ll N, M;
vector<vector<ll>> G;

int main()
{
ll N, M;
cin >> N >> M;
vector<ll> p(N + M);
loop(i, N + M) cin >> p[i];
G.resize(N + M);
loop(i, N + M)
{
G[i].emplace_back(p[i] - 1);
}
ll K = 0, R = 0, B = 0;
vector<bool> seen(N + M, false);
loop(i, N + M)
{
if (seen[i])
continue;
K++;
bool red = true, blue = true;
ll now = i;
ll c = 0;
while (true)
{
if (seen[now])
break;
c++;
seen[now] = true;
if (now < N)
blue = false;
else
red = false;
now = G[now][0];
}
if (red && c > 1)
R++;
if (blue && c > 1)
B++;
}
putout((N + M) - K + 2 * max(R, B));
return 0;
}

#line 2 "/home/defineprogram/Desktop/Library/template/template.cpp"
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i, n) for (int i = 0; i < n; i++)
#define REP(i, n) for (int i = 1; i < n; i++)
#define rev(i, n) for (int i = n - 1; i >= 0; i--)
#define REV(i, n) for (int i = n - 1; i > 0; i--)
#define all(v) v.begin(), v.end()
#define PL pair<ll, ll>
#define PI pair<int, int>
#define len(s) (int)s.size()
#define compress(v) \
sort(all(v));   \
v.erase(unique(all(v)), v.end());
#define comid(v, x) lower_bound(all(v), x) - v.begin()

template<class T>
using prique=priority_queue<T,vector<T>,greater<>>;

template <class T, class U>
inline bool chmin(T &a, U b) {
if (a > b) {
a = b;
return true;
}
return false;
}
template <class T, class U>
inline bool chmax(T &a, U b) {
if (a < b) {
a = b;
return true;
}
return false;
}
constexpr ll inf = 3e18;
constexpr double pi = acos(-1);
#line 2 "main.cpp"

int N,L;
int ans[50000][15];
int main() {
cin>>N>>L;
rep(i,N){
int x=i;
rep(j,L){
ans[i][L-j-1]=x%3;
x/=3;
}
ans[i][0]=2;
}
rep(i,3)rep(j,N){
rep(k,L)cout<<(ans[j][k]+i)%3;
cout<<"\n";
}
}

#include <bits/stdc++.h>
using namespace std;

const long long MOD = 998244353LL;

int main() {
long long N, K; cin >> N >> K;
vector<long long> cnt(N,K);
for(int i = 0; i < K; i++) {
char c; cin >> c;
int k; cin >> k;
if(c == 'L') {
for(int j = 0; j < k-1; j++) {
if(cnt[j] > 1) cnt[j]--;
}
cnt[k-1] = 1;
}
else {
for(int j = k; j < N; j++) {
if(cnt[j] > 1) cnt[j]--;
}
cnt[k-1] = 1;
}
}
long long ans = 1;
for(int i = 0; i < N; i++) {
ans *= cnt[i];
ans %= MOD;
}
cout << ans << endl;
}
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll MOD=998244353;

int main(){
ll n;cin>>n;
int maxl=1,minr=1e9;
while(n--){
int l,r;cin>>l>>r;
maxl=max(maxl,l);
minr=min(minr,r);
if(maxl<=minr){
cout<<0<<endl;
}else{
cout<<(maxl-minr+1)/2<<endl;
}
}
}
#include <bits/stdc++.h>

using namespace std ;

int main(){
string s;
cin >> s;
int n = s.size();
for (int i = 0; i < n; i++) {
map<char, int> m;
m[s[i]]++;
for (int j = i + 1; j <= min(i + 5, n - 1); j++) {
m[s[j]]++;
if (m[s[j]] > (j-i+1) / 2) {
cout << i + 1 << ' ' << j + 1 << '\n';
return 0;
}
}
}
cout << "-1 -1\n";
return 0;
}
#include <bits/stdc++.h>
#define re register
#define int long long
using namespace std;
const int M=1000002,mod=998244353;
int RD(){
int x=0,f=1;char c=getchar();
while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
while(c<='9'&&c>='0'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
return x*f;
}
int n,ans;
signed main() {
n=RD();
for(int i=1;;i++)
{
int j=n/i;
if(j==i)
{
ans+=j;
ans%=mod;
break;
}
if(j<i)
{
ans+=i-1;
ans%=mod;
break;
}
ans+=(j-i)/2;
ans%=mod;
}printf("%lld",ans);
return 0;
}
/*
*/
#include <bits/stdc++.h>
using namespace std;
#define fr(i, n) for (int i = 0; i < (int)(n); i++)
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define pb push_back
#define ppb pop_back
#define pf push_front
#define ppf pop_front
#define f(a) a.first
#define s(a) a.second

int main()
{
int n;
cin >> n;

vector<int> vec(n);

fr(i, n)
{
cin >> vec.at(i);
}

int b = -1;

vector<int> result;

fr(i, n - 1)
{
if (vec.at(i) > vec.at(i + 1))
{
b = i;
break;
}
else
{
b = i + 1;
}
}

if (b >= 0)
{
fr(i, n)
{
if (vec.at(i) == vec.at(b))
{
continue;
}
else
{
result.pb(vec.at(i));
}
}
}

fr(i, result.size())
{
cout << result.at(i) << " ";
}

return 0;
}

#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 998244353;//1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
string s;
cin >> s;
int n = s.length();
for(int i = 0; i < n; i++)
{
if(i + 1 < n)
{
if(s[i] == s[i + 1])
return (void)(cout << i + 1 << ' ' << i + 2 << '\n');
}
if(i + 2 < n)
{
if(s[i] == s[i + 2])
return (void)(cout << i + 1 << ' ' << i + 3 << '\n');
}
}
cout << -1 << ' ' << -1 << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include <bits/stdc++.h>
using namespace std;
#define rep(i, k, n) for(int i = k; i < n; i++)
#define MAX_N 110000
typedef long long ll;
typedef pair<ll, ll> P;
const ll INF = 100000000000;
using Graph = vector<vector<ll>>;
using Field = vector<vector<char>>;

int main(void) {
int n;
cin >> n;
string s;
cin >> s;

ll ans = 0, cnt;
rep(i, 1, n) {
cnt = 1;
while(1) {
if(s[i] != s[i-1]) break;
i++; cnt++;
}
if(cnt >= 2) {
ans += cnt*(cnt-1)/2;
}
}
cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,b,a) for(int i=b;i>a;i--)
#define rbit(i,a) for(int i=0;i<(1<<a);i++)
typedef long long ll;
typedef long double lld;
const ll mod=998244353;
using namespace std;
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
const string zton="0123456789";
const string atoz="abcdefghijklmnopqrstuvwxyz";
ll gcd(ll a,ll b){
ll r;
r=a%b;
if(r==0){
return b;
}
else{
return gcd(b,r);
}
}
typedef pair<int,int> P;
ll inv[501010];
ll kaijou[501010];
ll kaijou_inv[501010];
ll nck(ll n,ll k){
if(n<k)return 0ll;
else return (((kaijou[n]*kaijou_inv[k])%mod)*kaijou_inv[n-k])%mod;
}


int main(void){
inv[0]=1;
inv[1]=1;
rep(i,2,501010) inv[i]=inv[mod%i]*(mod-mod/i)%mod;
kaijou[0]=1ll;
rep(i,1,501010){
kaijou[i]=kaijou[i-1]*1ll*i;
kaijou[i]%=mod;
}
kaijou_inv[0]=1ll;
rep(i,1,501010){
kaijou_inv[i]=kaijou_inv[i-1]*1ll*(inv[i]);
kaijou_inv[i]%=mod;
}

int N,M;
cin >> N >> M;
ll dp[M+1];
fill(dp,dp+M+1,0);
dp[0]=1;
rep(i,1,M+1){
if(i%2==1){
dp[i]=0;
continue;
}
for(int j=0;j*2<=min(N,i);j++){
dp[i]+=(dp[(i-2*j)/2]*nck(N,2*j)%mod);
dp[i]%=mod;
}
}
cout << dp[M] << endl;
}
# include <bits/stdc++.h>
// # include <atcoder/all>

typedef long long ll;

using namespace std;
// using namespace atcoder;

#define rep(i,n) for (ll i=0; i<(ll)(n);i++)
#define ALL(a)  (a).begin(),(a).end()

ll gcd(ll x, ll y) { return (x==0)? y : gcd(y%x,x); }
ll lcm(ll x, ll y) { return x/gcd(x,y)*y; }
ll P(ll n, ll k) { return (k==1) ? n : n*(P(n-1,k-1)); }

ll mod=1000000007;
ll comb[2000][2000];
ll nCr(ll n, ll r) {
if(n==r) return comb[n][r] = 1;
if(r==0) return comb[n][r] = 1;
if(r==1) return comb[n][r] = n;
// if(comb[n][r]) return comb[n][r]%mod;
if(comb[n][r]) return comb[n][r];
// return comb[n][r] = (nCr(n-1,r) + nCr(n-1,r-1))%mod;
return comb[n][r] = (nCr(n-1,r) + nCr(n-1,r-1));
}

ll inv(ll x) {
ll res=1, k=mod-2;
while(k>0) {
if(k&1 == 1) res=(res*x)%mod;
x=(x*x)%mod;
k/=2;
}
return res;
}

ll nCr_mod_memo[1010101];

void nCr_mod_init() {
nCr_mod_memo[0]=1;
for(ll i=1;i<1010101;i++) nCr_mod_memo[i]=(nCr_mod_memo[i-1]*i)%mod;
}

ll nCr_mod(ll n, ll k) {
// ll a=1,b=1;
// for(int i=0;i<k;i++) a=(a*(n-i))%mod;
// for(int i=0;i<k;i++) b=(b*(k-i))%mod;

ll a=nCr_mod_memo[n];
ll b=nCr_mod_memo[n-k];
ll c=nCr_mod_memo[k];
ll bc=(b*c)%mod;

return (a*inv(bc))%mod;
}


/*
ll binpower(ll a, ll b) {
ll ans=1;
while (b != 0) {
if (b%2 == 1) ans = (ans*a)%mod;
a=(a*a)%mod;
b/=2;
}
return ans;
}
*/


ll binpower(ll a, ll b, ll m) {
ll ans=1;

a%=m;

while (b != 0) {
if (b%2 == 1) ans = (ans*a)%m;
a=(a*a)%m;
b/=2;
}
return ans;
}


bool judgeIentersected
(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy) {

ll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
ll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
ll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
ll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

return tc * td < 0 && ta * tb < 0;
// return tc * td <= 0 && ta * tb <= 0; // 端点を含む場合
};



int main() {
ll k,n,m;
cin>>k>>n>>m;
vector<ll> a(k);
rep(i,k) cin>>a[i];

vector<ll> b(k,0);
priority_queue< pair<ll,ll> > Q;

rep(i,k) {
b[i]+=(m*a[i])/n;
a[i]=(m*a[i])%n;

Q.push(make_pair(a[i],i));
}

ll cnt=m;
rep(i,k) cnt-=b[i];

/*
while(!Q.empty()) {
cout<<Q.top().first<<" "<<Q.top().second<<endl;
Q.pop();
}
*/

///*
while(cnt > 0) {
auto p=Q.top();
Q.pop();

p.first-=n;
b[p.second]++;
cnt--;

Q.push(p);
}
//*/

rep(i,k) cout<<b[i]<<" "; cout<<endl;

return 0;
}

#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
#include <tuple>
#include <cstdint>
#include <cstdio>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <deque>
#include <unordered_map>
#include <unordered_set>
#include <bitset>
#include <cctype>
#include <climits>
#include <functional>
#include <cassert>

#define rep(i, n) for(int i = 0; i < (n); i++)
#define per(i, n) for(int i = (n) - 1; i >= 0; i--)
using ll = long long;
#define vi vector<int>
#define vvi vector<vi>
#define vl vector<ll>
#define pii pair<int, int>
#define pll pair<ll, ll>
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
//#define mod 1000000007
using namespace std;
template<class T, class U>
bool chmax(T &a, const U &b){ return a < b ? (a = b, 1) : 0; }
template<class T, class U>
bool chmin(T &a, const U &b){ return a > b ? (a = b, 1) : 0; }
constexpr int mod = 3;
constexpr int len = 400010;
int bf[len], bg[len];
struct initializer {
initializer(){
for(int i = 1; i < len; i++){
int v = i;
while(v % mod == 0) v /= mod, bf[i]++;
bg[i] = v % mod;
}
bg[0] = 1;
for(int i = 1; i < len; i++){
bf[i] += bf[i - 1];
bg[i] *= bg[i - 1];
bg[i] %= mod;
}
}
} initializer;
int C(int n, int r){
assert(0 <= n && n < len);
if(n < r || bf[n] != bf[r] + bf[n - r]) return 0;
int res = (bg[n] * bg[r]) % mod;
res = (res * bg[n - r]) % mod;
return res;
}
int P(int n, int r){
assert(0 <= n && n < len);
if(n < r || bf[n] != bf[n - r]) return 0;
return (bg[n] * bg[n - r]) % mod;
}
int H(int n, int r){
assert(0 < n && 0 <= r);
assert(0 < n+r && n+r <= len);
int res = (bg[n + r - 1] * bg[n - 1]) % mod;
res = (res * bg[r]) % mod;
return res;
}
int main(){
int n;
cin >> n;
vector<char> c(n);
int ans = 0;
rep(i, n){
cin >> c[i];
int val = C(n - 1, i);
if(c[i] == 'B'){
ans += 0 * val % 3;
}
if(c[i] == 'W'){
ans += 1 * val % 3;
}
if(c[i] == 'R'){
ans += 2 * val % 3;
}
ans %= 3;
}
if(!(n & 1)) ans = (-ans + 3) % 3;
if(ans == 0) cout << "B\n";
if(ans == 1) cout << "W\n";
if(ans == 2) cout << "R\n";
}
/**
*	author:	social_chameleon
*	created:	2022/01/19
*/

#pragma region MACROS

#pragma region HEADER
#pragma GCC optimize("O3")
#ifdef LOCAL
#include <debug_print.hpp>
#define debug(...) debug_print::multi_print(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...) (static_cast<void>(0))
#endif
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#pragma endregion
#pragma region TYPES
using ll = long long;
#define int ll
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pil = pair<int, ll>;
using pli = pair<ll, int>;
using ld = long double;
template <typename T>
using vc = vector<T>;
template <typename T>
using vvc = vector<vc<T>>;
template <typename T>
using vvvc = vector<vvc<T>>;
using vi = vc<int>;
using vl = vc<ll>;
using vb = vc<bool>;
using vpi = vc<pii>;
using vpl = vc<pll>;
template <class T>
using pq = priority_queue<T>;
template <class T>
using pqg = priority_queue<T, vector<T>, greater<T>>;
#pragma endregion
#pragma region UTILITY_FUNCTIONS
template <typename T>
int si(const T& x) { return x.size(); }
template <class T>
inline bool chmax(T& a, const T& b) { return (a < b ? a = b, 1 : 0); }
template <class T>
inline bool chmin(T& a, const T& b) { return (a > b ? a = b, 1 : 0); }
#define overload2(a, b, name, ...) name
#define overload4(a, b, c, d, name, ...) name
#define overload5(a, b, c, d, e, name, ...) name
#pragma endregion
#pragma region WORDS
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define ppb pop_back
#define ppf pop_front
#define eb emplace_back
#define ef emplace_front
#pragma endregion
#pragma region LOOPS
#define rep0(n) for (int _ = 0; _ < n; ++_)
#define rep1(i, n) for (ll i = 0; i < (n); ++i)
#define rep2(i, a, b) for (ll i = (a); i < (b); ++i)
#define rep3(i, a, b, c) for (ll i = (a); i < (b); i += (c))
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1, rep0)(__VA_ARGS__)
#define rrep0(n) for (int jidlsjf = 0; jidlsjf < n; ++jidlsjf)
#define rrep1(i, n) for (ll i = (n)-1; i >= 0; --i)
#define rrep2(i, a, b) for (ll i = (a)-1; i >= b; --i)
#define rrep3(i, a, b, c) for (ll i = (a)-1; i >= b; i -= c)
#define rrep(...) overload4(__VA_ARGS__, rrep3, rrep2, rrep1, rrep0)(__VA_ARGS__)
#define fore0(v) rep(a.size())
#define fore1(a, v) for (auto&& a : v)
#define fore2(a, b, v) for (auto&& [a, b] : v)
#define fore3(a, b, c, v) for (auto&& [a, b, c] : v)
#define fore4(a, b, c, d, v) for (auto&& [a, b, c, d] : v)
#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)
#pragma endregion
#pragma region CONTAINER_METHODS
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
template <typename T>
int closest(vector<T>& v, T x) {
int n = (int)v.size();
int pos = lower_bound(v.begin(), v.end(), x) - v.begin();
if (pos == 0) return pos;
if (pos == n) return n - 1;
return (v[pos] - x <= x - v[pos - 1]) ? pos : pos - 1;
}
#define all(c) begin(c), end(c)
#define rall(c) rbegin(c), rend(c)
#define SORT(v) sort(all(v))
#define REV(v) reverse(all(v))
#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())
template <typename T = ll, typename S>
T SUM(const S& v) { return accumulate(all(v), T(0)); }
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
template <typename T = int>
T mex(unordered_set<T> st) {
T ret = T(0);
while (st.count(ret) != 0) ++ret;
return ret;
}
#pragma endregion
#pragma region VECTOR_DEFINITIONS
#define vec(type, name, ...) vector<type> name(__VA_ARGS__)
#define vec2(type, name1, name2, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__)
#define vec3(type, name1, name2, name3, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__)
#define vec4(type, name1, name2, name3, name4, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__), name4(__VA_ARGS__)
#define vv(type, name, a, ...) vector<vector<type>> name(a, vector<type>(__VA_ARGS__))
#define vvv(type, name, a, b, ...) vector<vector<vector<type>>> name(a, vector<vector<type>>(b, vector<type>(__VA_ARGS__)))
#define vvvv(type, name, a, b, c, ...) vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))
constexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};
constexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
#pragma endregion
#pragma region TYPICAL_OUTPUT
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
const string firstsecond[2] = {"second", "first"};
const string FirstSecond[2] = {"Second", "First"};
const string possiblestr[2] = {"impossible", "possible"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
void first(bool t = 1) { cout << firstsecond[t] << endl; }
void First(bool t = 1) { cout << FirstSecond[t] << endl; }
void possible(bool t = 1) { cout << possiblestr[t] << endl; }
#pragma endregion
#pragma region INPUT
int scan() { return getchar(); }
void scan(signed& a) { cin >> a; }
void scan(long long& a) { cin >> a; }
void scan(char& a) { cin >> a; }
void scan(double& a) { cin >> a; }
void scan(string& a) { cin >> a; }
template <class T, class S>
void scan(pair<T, S>& p) { scan(p.first), scan(p.second); }
template <class T>
void scan(vector<T>& a) {
for (auto& i : a) scan(i);
}
template <class T>
void scan(T& a) { cin >> a; }
void IN() {}
template <class Head, class... Tail>
void IN(Head& head, Tail&... tail) {
scan(head);
IN(tail...);
}
#define INT(...)   \
int __VA_ARGS__; \
IN(__VA_ARGS__)
#define LL(...)   \
ll __VA_ARGS__; \
IN(__VA_ARGS__)
#define STR(...)      \
string __VA_ARGS__; \
IN(__VA_ARGS__)
#define CHR(...)    \
char __VA_ARGS__; \
IN(__VA_ARGS__)
#define DBL(...)      \
double __VA_ARGS__; \
IN(__VA_ARGS__)
#define VEC(type, name, size) \
vector<type> name(size);    \
IN(name)
#define VEC2(type, name1, name2, size)   \
vector<type> name1(size), name2(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i])
#define VEC3(type, name1, name2, name3, size)         \
vector<type> name1(size), name2(size), name3(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])
#define VEC4(type, name1, name2, name3, name4, size)               \
vector<type> name1(size), name2(size), name3(size), name4(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i])
#define VV(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
IN(name)
#pragma endregion
#pragma region MATH
static constexpr int inf = numeric_limits<int>::max() / 2;
static constexpr ll infll = numeric_limits<ll>::max() / 2;
static constexpr double infdbl = numeric_limits<double>::max() / 2;
template <typename T, typename S>
T ceil(T x, S y) {
assert(y);
return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S>
T floor(T x, S y) {
assert(y);
return (y < 0 ? floor(-x, -y)
: (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
template <class T>
ll POW(T x, int n) {
ll res = 1;
for (; n; n >>= 1, x *= x)
if (n & 1) res *= x;
return res;
}
template <class T, class S>
ll POW(T x, S n, const ll& mod) {
ll res = 1;
x %= mod;
for (; n; n >>= 1, x = x * x % mod)
if (n & 1) res = res * x % mod;
return res;
}
template <typename T>
map<T, int> factor(T n) {
map<T, int> ret;
for (T i = 2; i * i <= n; i++) {
while (n % i == 0) {
ret[i]++;
n /= i;
}
}
if (n != 1) ret[n] = 1;
return ret;
}
template <class T>
vector<T> divisor(T x) {
vector<T> ret;
for (T i = 1; i * i <= x; i++)
if (x % i == 0) {
ret.pb(i);
if (i * i != x) ret.pb(x / i);
}
return ret;
}
vector<int> cumsum(const vector<bool>& v) {
vector<int> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<T> cumsum(const vector<T>& v) {
vector<T> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<vector<T>> cumsum2d(const vector<vector<T>>& v) {
vector<vector<T>> ret = v;
for (int i = 0; i < (int)v.size(); ++i) {
for (int j = 0; j < (int)v[0].size(); ++j) {
if (i > 0) ret[i][j] += ret[i - 1][j];
if (j > 0) ret[i][j] += ret[i][j - 1];
if (i > 0 && j > 0) ret[i][j] -= ret[i - 1][j - 1];
}
}
return ret;
}
template <typename T>
T parsum2d(const vector<vector<T>>& cum, int i1, int i2, int j1, int j2) {
if (i1 > i2 || j1 > j2) return 0;
T ret = cum[i2][j2];
if (i1 > 0) ret -= cum[i1 - 1][j2];
if (j1 > 0) ret -= cum[i2][j1 - 1];
if (i1 > 0 && j1 > 0) ret += cum[i1 - 1][j1 - 1];
return ret;
}
template <typename T, typename S, typename U>
bool inc(const T& x, const S& l, const U& r) {
return l <= x and x < r;
}
constexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }
template <typename T>
T arith_sum_from_range(T first, T last, T diff = T(1)) {
assert((last - first) % diff == 0);
return ((last - first) / 2 + 1) * (first + last) / 2;
}
template <typename T, typename S>
T arith_sum_from_term(T first, S n, T diff = T(1)) {
return (2 * first + (n - 1) * diff) * n / 2;
}
#pragma endregion
#pragma region BIT_FUNCTIONS
ll pow2(int i) { return 1LL << i; }
#define bit(n, k) (((n) >> (k)) & 1)
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
constexpr ll mask(int n) { return (1LL << n) - 1; }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
template <typename T>
T inv_all_bit(T a) {
T ret = 0;
int n = topbit(a);
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_all_bit(T a, int n) {
T ret = 0;
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_bit(T a, int k) { return a ^ (1 << k); }
#pragma endregion
#pragma region PAIR_OPERATORS
template <class T, class S>
pair<T, S> operator-(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi - y.fi, x.se - y.se);
}
template <class T, class S>
pair<T, S> operator+(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi + y.fi, x.se + y.se);
}
template <class T>
pair<T, T> operator&(const pair<T, T>& l, const pair<T, T>& r) {
return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se));
}
template <class T, class S>
pair<T, S> operator+=(pair<T, S>& l, const pair<T, S>& r) {
return l = l + r;
}
template <class T, class S>
pair<T, S> operator-=(pair<T, S>& l, const pair<T, S>& r) {
return l = l - r;
}
template <class T>
bool intersect(const pair<T, T>& l, const pair<T, T>& r) {
return (l.se < r.se ? r.fi < l.se : l.fi < r.se);
}
#pragma endregion
#pragma region SEARCH
template <class F>
void bit_search(int n, const F& f) {
for (int i = 0; i < (1 << n); ++i) {
set<int> st;
for (int j = 0; j < n; ++j) {
if ((i >> j & 1) == 1) {
st.insert(j);
}
}
f(st);
}
}
template <class T, class F>
T bin_search(T ok, T ng, const F& f) {
while (abs(ok - ng) > 1) {
T mid = ok + ng >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search_double(T ok, T ng, const F& f, int iter = 80) {
while (iter--) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
#pragma endregion
#pragma region STRING
void ERASE(string& s, char c) { s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const string& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const vector<char>& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
template <typename T>
void ERASE(vector<T>& v, T x) { v.erase(remove(all(v), x), v.end()); }
template <typename T>
void ERASE(vector<T>& v, const vector<T>& list) { fore(x, list) v.erase(remove(all(v), x), v.end()); }
#pragma endregion
#pragma region OUTPUT
template <typename T, typename S>
ostream& operator<<(ostream& os, const pair<T, S>& p) {
os << p.first << " " << p.second;
return os;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < (int)v.size(); i++) {
os << v[i] << (((i + 1) != v.size()) ? " " : "");
}
return os;
}
void OUT() { cout << endl; }
template <class Head, class... Tail>
void OUT(const Head& head, const Tail&... tail) {
cout << head;
if (sizeof...(tail)) cout << ' ';
OUT(tail...);
}
template <typename T>
string pad(T n, int d, char c) {
ostringstream sout;
sout << setfill(c) << setw(d) << n;
return sout.str();
}
#pragma endregion
#pragma region GRAPH
template <typename T = int>
struct Edge {
int from, to;
T cost;
int id;

Edge() = default;
Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}

operator int() const {
return to;
}
};

template <typename T = int>
struct Graph {
vector<vector<Edge<T>>> g;
int edge_id;

Graph() = default;
explicit Graph(int n) : g(n), edge_id(0) {}

size_t size() const {
return g.size();
}

void add_directed_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id++);
}

void add_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id);
g[to].emplace_back(to, from, cost, edge_id++);
}

void read(int m, int padding = -1, bool weighted = false, bool directed = false) {
for (int i = 0; i < m; ++i) {
int a, b;
cin >> a >> b;
a += padding;
b += padding;
T c = T(1);
if (weighted) {
cin >> c;
}
if (directed) {
add_directed_edge(a, b, c);
} else {
add_edge(a, b, c);
}
}
}

inline vector<Edge<T>>& operator[](const int& k) {
return g[k];
}

inline const vector<Edge<T>>& operator[](const int& k) const {
return g[k];
}
};
#pragma endregion
#pragma region PARSE
inline int toi(char c) { return c - '0'; }
int toi(string s) { return stoi(s); }
ll toll(string s) { return stoll(s); }
template <typename T>
string tos(T x) {
return to_string(x);
}
inline char toc(int i) { return '0' + i; }
template <typename T>
string tobit(T x, size_t d) {
if (d <= 2)
return bitset<2>(x).to_string();
else if (d <= 4)
return bitset<4>(x).to_string();
else if (d <= 8)
return bitset<8>(x).to_string();
else if (d <= 16)
return bitset<16>(x).to_string();
else if (d <= 32)
return bitset<32>(x).to_string();
else
return bitset<64>(x).to_string();
}
#pragma endregion

#pragma endregion
// constexpr signed MOD = 1e9 + 7;
constexpr signed MOD = 998244353;
#pragma region MOD
template <signed mod>
struct ModInt {
signed x;

ModInt() : x(0) {}

ModInt(long long y) : x((y >= 0) ? (y % mod) : (mod - ((-y) % mod)) % mod) {}

ModInt& operator++() {
++x;
if (x == mod) {
x = 0;
}
return *this;
}

ModInt& operator--() {
if (x == 0) {
x = mod;
}
--x;
return *this;
}

ModInt operator++(signed) {
ModInt ret = *this;
++*this;
return ret;
}

ModInt operator--(signed) {
ModInt ret = *this;
--*this;
return ret;
}

ModInt& operator+=(const ModInt& p) {
if ((x += p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator-=(const ModInt& p) {
if ((x += mod - p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator*=(const ModInt& p) {
x = (int)(1LL * x * p.x % mod);
return *this;
}

ModInt& operator/=(const ModInt& p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt& p) const { return x == p.x; }

bool operator!=(const ModInt& p) const { return x != p.x; }

/**
*  拡張ユークリッドの互除法を用いた逆元計算
*  - time: O(logx)
*/
ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while (b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(long long n) const {
ModInt ret(1), mul(x);
while (n > 0) {
if (n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream& operator<<(ostream& os, const ModInt& p) { return os << p.x; }

friend istream& operator>>(istream& is, ModInt& a) {
long long t;
is >> t;
a = ModInt<mod>(t);
return (is);
}

static signed get_mod() { return mod; }
};

using mint = ModInt<MOD>;
using vmi = vc<mint>;
#pragma endregion

/**
*  unite: O(α(n))
*  same: O(α(n))
*  leader: O(α(n))
*  size: O(α(n))
*  groups: O(n)
*/
struct UnionFind {
int n;

// root node: -1 * component size
// otherwise: parent
vector<int> leader_or_size;

explicit UnionFind(int n) : n(n), leader_or_size(n, -1) {}

int unite(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
int x = leader(a), y = leader(b);
if (x == y) return x;
if (-leader_or_size[x] < -leader_or_size[y]) swap(x, y);
leader_or_size[x] += leader_or_size[y];
leader_or_size[y] = x;
return x;
}

bool same(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
return leader(a) == leader(b);
}

int leader(int a) {
assert(0 <= a && a < n);
if (leader_or_size[a] < 0) return a;
return leader_or_size[a] = leader(leader_or_size[a]);
}

int size(int a) {
assert(0 <= a && a < n);
return -leader_or_size[leader(a)];
}

vector<vector<int>> groups() {
vector<int> leader_buf(n), group_size(n);
for (int i = 0; i < n; ++i) {
leader_buf[i] = leader(i);
++group_size[leader_buf[i]];
}
vector<vector<int>> ret(n);
for (int i = 0; i < n; ++i) {
ret[i].reserve(group_size[i]);
}
for (int i = 0; i < n; i++) {
ret[leader_buf[i]].push_back(i);
}
ret.erase(
std::remove_if(ret.begin(), ret.end(),
[&](const vector<int>& v) { return v.empty(); }),
ret.end());
return ret;
}
};

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(9);
cerr << fixed << setprecision(9);

INT(n);
auto uf = UnionFind(n);
int loop = 0;
rep(i, n) {
INT(f);
--f;
if (uf.same(i, f))
++loop;
else
uf.unite(i, f);
}
OUT(mint(2).pow(loop) - 1);

return 0;
}

/*
*	Created By: 'Present_Sir'
*	Created On: Sunday 23 January 2022 01:23:26 PM
*/

#include<bits/stdc++.h>
#define int long long

using namespace std;

int get(vector < int > &a, vector < int > &b){
int n = a.size();
vector < int > order(n);

iota(order.begin(), order.end(), 0ll);

sort(order.begin(), order.end(), [&](int x, int y){
if(a[x] == a[y]){
return b[x] > b[y];
}else return a[x] < a[y];
});

int ans = 0;
vector < int > dp(1, -1);
for(auto x: order){
int y = b[x];
if(y > dp.back()){
ans = max(ans, (int)dp.size());
dp.push_back(y);
continue;
}
int idx = lower_bound(dp.begin(), dp.end(), y) - dp.begin();
dp[idx] = y;
ans = max(ans, idx);
}
return ans;
}

int32_t main(){
ios_base::sync_with_stdio(false);
cin.tie(NULL);

int m, n;
cin >> m >> n;

vector < int > a(n), b(n);

for(int i=0; i<n; ++i){
cin >> a[i] >> b[i];
}

cout << get(a, b) << "\n";

return 0;
}

#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;

#define all(x) (x).begin(),(x).end()
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)

using namespace std;


const long long INF = 1LL << 61;
const ll MOD = 1e9 + 7;

//---------------------------
int main(void){
ll n, m;
cin >> n >> m;

vector<vector<ll>> g(n);
rep(i, m){
ll a, b;
cin >> a >> b;
a--, b--;
g[a].push_back(b);
}

rep(i, n){
if(g[i].size() == 0) continue;
sort(all(g[i]));
}

vector<ll> dp(n, INF);

rep(i, n){
for(ll j = g[i].size() - 1; j >= 0; j--){
auto itr = lower_bound(all(dp), g[i][j]);
*itr = g[i][j];
}
}

cout << lower_bound(all(dp), INF) - dp.begin()<< endl;

} 
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}

const int inf = 1001001001;
const ll INF = 1001001001001001001;

const double PI = acos(-1);

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

using mint = modint998244353;
const int MOD = 998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;

signed main(){
cout << fixed << setprecision(15);

int A, B;
cin >> A >> B;
vector<int> ans;
if(A == B){
rep2(i, 1, A){
ans.eb(i);
ans.eb(-i);
}
}
if(A > B){
int sum = 0;
rep2(i, 1, A){
ans.eb(i);
sum += i;
}
rep2(i, 1, B-1){
ans.eb(-i);
sum -= i;
}
ans.eb(-sum);
}
if(A < B){
int sum = 0;
rep2(i, 1, B){
ans.eb(-i);
sum -= i;
}
rep2(i, 1, A-1){
ans.eb(i);
sum += i;
}
ans.eb(-sum);
}
rep(i, sz(ans)) cout << ans[i] << " ";
return 0;
}
#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int mod = (119 << 23) + 1;

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

int n, m; cin>>n>>m;
vector<int> dp(m + 1), f(n + 1), inv(n + 1);

auto bp = [&](int a, int b){
int rr = 1;
while(b){
if(b&1) rr = rr * 1ll * a % mod;
a = a * 1ll * a % mod, b >>= 1;
} return rr;
};

f[0] = inv[0] = 1;
for(int i=1;i<=n;i++){
f[i] = f[i-1] * 1ll * i % mod;
inv[i] = bp(f[i], mod - 2);
}
auto C = [&](int n, int k) { return f[n] * 1ll * inv[k] % mod * inv[n - k] % mod; };

dp[0] = 1;
for(int i=0;i<13;i++){
for(int j=m;j>=0;j--){
for(int x=2;j + (1 << i) * x<=m && x <= n;x+=2){
dp[j + (1 << i) * x] = (dp[j + (1 << i) * x] + C(n, x) * 1ll * dp[j]) % mod;
}
}
}

cout<<dp[m]<<"\n";
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 1e18;

int main() {
ll H, W, C, Q;
cin >> H >> W >> C >> Q;
vector<pair<ll, pair<ll, ll>>> qs(Q);
for (int i = 0; i < Q; i++) {
ll t, n, c;
cin >> t >> n >> c;
n--;
c--;
qs[i] = make_pair(t, make_pair(n, c));
}
reverse(qs.begin(), qs.end());

vector<ll> cs(C, 0);
set<ll> done_r;
set<ll> done_c;
for (auto q : qs) {
ll t, n, c;
pair<ll, ll> p;
tie(t, p) = q;
tie(n, c) = p;

if (t == 1) {
if (done_r.count(n)) continue;
cs[c] += W - done_c.size();
done_r.insert(n);
} else {
if (done_c.count(n)) continue;
cs[c] += H - done_r.size();
done_c.insert(n);
}
}

for (int i = 0; i < C; i++) cout << cs[i] << (i + 1 == C ? "\n" : " ");
}
#include <bits/stdc++.h>

using namespace std;

#define N 100002
#define MOD 1000000007
#define MOD2 998244353
#define fo(i, b, n) for (long i = b; i < n; ++i)
#define rfo(i, b, n) for (long i = b; i >= n; --i)
#define all(ar) ar.begin(), ar.end()
#define rall(ar) ar.rbegin(), ar.rend()
#define mem(ar, val) memset(ar, (val), sizeof(ar))
#define fi first
#define se second
#define pb push_back
#define fastIO ios_base::sync_with_stdio(false); cin.tie(NULL); cout << fixed << setprecision(6);

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<bool> vb;
typedef vector<vb> vvb;
typedef vector<vi> vvi;
typedef vector<vll> vvll;

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '"' << x << '"';}
void __print(const char *x) {cerr << '"' << x << '"';}
void __print(const string &x) {cerr << '"' << x << '"';}
void __print(bool x) {cerr << (x ? "true" : "false");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
void _print() {cerr << "]" << endl;}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}

#ifndef ONLINE_JUDGE
#define deb(x...) cerr << "[" << #x << "] = ["; _print(x)
#else
#define deb(x...)
#endif

const double PI = 3.1415926535897932384626;
const ll oo = 9e18;
const double EPS = 1e-6;
const ll sz = 2 * N;

ll a[sz], b[sz];

void solution(int testno) {
ll h, w, k;
cin >> h >> w >> k;
ll sa = 0, sb = 0;
fo(i,0,h) {
cin >> a[i];
sa += a[i];
sa %= k;
}
fo(i,0,w) {
cin >> b[i];
sb += b[i];
sb %= k;
}
if(sa != sb)
cout << "-1";
else {
ll cs = 0, rs = 0;
fo(i,0,h) {
ll t1 = (w - 1) * (k - 1);
ll lst = (a[i] - (t1 % k) + k) % k;
rs += t1 + lst;
}
fo(i,0,w) {
ll t1 = (h - 1) * (k - 1);
ll lst = (b[i] - (t1 % k) + k) % k;
cs += t1 + lst;
}
cout << min(cs, rs);
}

cout << endl;
}

signed main()
{
fastIO;
int test = 1;
// cin >> test;
clock_t begin, end;

fo(i,1,test+1) {
begin = clock();
solution(i);
end = clock();

//cerr << "[ Case :- " << i << " | Time Taken :- " << ((ld)end - (ld)begin) / CLOCKS_PER_SEC << " ]" << endl;
}
return 0;
}
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace std;

typedef long long ll;

const int MAXN = (int)2e5 + 5;

ll A[MAXN], B[MAXN], C[MAXN];
ll coefB[MAXN], coefC[MAXN];
ll ans;
int n, m;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
cin >> n >> m;

for (int i = 0; i < n; i++) {
cin >> A[i];
}

for (int i = 0; i < m; i++) {
cin >> B[i];
}

for (int i = 0; i < m; i++) {
cin >> C[i];
}

sort(A, A + n);
reverse(A, A + n);
ll SA = accumulate(A, A + n, 0ll);
ll SC = accumulate(C, C + m, 0ll);
ll ans = LLONG_MAX;

for (int i = 0; i < m; i++) {
int l = 0, r = n, opt = -1;

while (l <= r) {
int m = (l + r) / 2;

if (B[i] * m - C[i] < 0) {
opt = m;
l = m + 1;
}
else {
r = m - 1;
}
}

if (opt != -1) {
coefB[0] += B[i];
coefB[opt + 1] -= B[i];
coefC[0] += C[i];
coefC[opt + 1] -= C[i];
}
}

for (int q = 1; q <= n; q++) {
coefB[q] += coefB[q - 1];
coefC[q] += coefC[q - 1];
}

ll cur = SA + SC;

for (int q = 0; q <= n; q++) {
if (q > 0) {
cur -= A[q - 1];
}

ans = min(ans, cur + coefB[q] * q - coefC[q]);
}

cout << ans << '\n';
return 0;
}

#include <bits/stdc++.h>

using namespace std;

// long longの省略
typedef long long ll;

// rep(先頭にRで逆からループ、末尾にSで「1～n」となる)
#define rep(i, a, n) for(int i = a; i < n; i++)
#define reps(i, a, n) for(int i = a; i <= n; i++)
#define rrep(i, a, n) for(int i = n - 1; i >= a; i--)
#define rreps(i, a, n) for(int i = n; i >= a; i--)

// ソートなどに対象を入れる場合
#define all(x) (x).begin(),(x).end()

// ソートされた配列から重複を削除して詰めなおす
#define UNIQUE(x) x.erase( unique(x.begin(), x.end()), x.end() );

// bfs等で4方向調べるときの配列(上下左右の順番)
int d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

// 余りを答えとして出す時の割る値(デフォルト値)
int MOD = 1e9 + 7;

// ユークリッド互除法
int __gcd(int a, int b){
int c;

while((c = a % b) != 0){
a = b;
b = c;
}

return b;
}

// 「number」の「n」ビット目が「1」であるか「0」か
// ビット目の数え方は配列の添え字と同じ
bool __bit(int number, int n){
if(number & (1 << n))
return true;

return false;
}

// aよりもbが大きいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmax(T &a, const T& b) {
if (a < b) {
a = b;  // aをbで更新
return true;
}

return false;
}
// aよりもbが小さいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmin(T &a, const T& b) {
if (a > b) {
a = b;  // aをbで更新
return true;
}

return false;
}

// 累乗をmodで計算
ll mod_pow(ll a, ll n, ll mod) {
ll res = 1;
while (n > 0) {
if (n & 1) res = res * a % mod;
a = a * a % mod;
n >>= 1;
}
return res;
}

// nCrをmodで計算
// COMinit(取りうるnの最大値)を実行してから、COM(n, r)を使用すること)
vector<ll> fac, finv, inv;

void COMinit(int MAX) {
fac.resize(MAX); finv.resize(MAX); inv.resize(MAX);

fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++){
fac[i] = fac[i - 1] * i % MOD;
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
finv[i] = finv[i - 1] * inv[i] % MOD;
}
}

long long COM(int n, int k){
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
}

int main(){
int N; cin >> N;

vector<int> a(N);
rep(i, 0, N) cin >> a[i];

int ans = INT_MAX;
reps(i, -100, 100){
int sum = 0;
rep(j, 0, N)
sum += (i - a[j]) * (i - a[j]);

chmin(ans, sum);
}

cout << ans << endl;

return 0;
}
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <vector>
#define setIO(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)
#define closefile fclose(stdin), fclose(stdout)
#define m_p make_pair
#define sz(x) (int)x.size()
#define see(x) cerr << x << " "
#define seeln(x) cerr << x << endl
#define out(x) cerr << #x << " = " << x << " "
#define outln(x) cerr << #x << " = " << x << endl
#define outarr(x, l, r) {cerr << #x"[" << l << " ~ " << r << "] = "; for (int _i = l; _i <= r; ++_i) cerr << x[_i] << " "; cerr << endl;}
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define gc() getchar()
//#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
template <class T> void read(T &x) {
x = 0; int c = gc(); int flag = 0;
while (c < '0' || c > '9') flag |= (c == '-'), c = gc();
while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = gc();
if (flag) x = -x;
}
template <class T> bool checkmax(T &a, T b) {return a < b ? a = b, 1 : 0;}
template <class T> bool checkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}
constexpr int N = 200005;
int n;
int a[N], c[N];
ll b[N];
ll s = 0;

void init() {
scanf("%d", &n);
for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), s += a[i];
}

void solve() {
if (s) {
printf("-1\n");
return;
}
ll tot = 0;
for (int i = 2; i <= n; ++i) {
c[i] = c[i - 1] + a[i];
tot += c[i];
}
if (tot % n) {
printf("-1\n");
return;
}
b[1] = tot / n;
for (int i = 2; i <= n; ++i) {
b[i] = b[1] - c[i];
}
ll mn = 0, cur = 0, sum = 0;
for (int i = 1; i < n; ++i) {
cur += b[i];
checkmax(mn, cur);
sum += cur;
}
ll ans = mn * n - sum;
printf("%lld\n", ans);
}

int main() {
init();
solve();
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#include <atcoder/convolution>
#include <atcoder/modint>
using namespace atcoder;

//基本的にこれがなくてもうまくいくコードを心がけるが、念の為。時間ギリギリアウトの時は消してみる
#define int long long

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef pair<int, int> pi;
typedef pair<long long, long long> pl;
typedef vector<int> vi;
typedef vector<long long> vl;
typedef vector<vector<int> > vvi;
typedef vector<vector<long long> > vvl;
typedef priority_queue<int> pq;
typedef priority_queue<int, vector<int>, greater<int> > pqg;
typedef priority_queue<long long> pql;
typedef priority_queue<long long, vector<long long>, greater<long long> > pqgl;

#define pb push_back
#define eb emplace_back
#define mp make_pair

#define all(obj) (obj).begin(), (obj).end()

#define reps(i, n, m) for (int i = (int)(n); i < (int)(m); i++)
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = n; i >= 0; i--)

#define cbit(x) __builtin_popcountll(x)

#define minv(v) *min_element(v.begin(), v.end())
#define maxv(v) *max_element(v.begin(), v.end())

#define print(v)                       \
for (auto k : v) cout << k << " "; \
cout << endl;

#define yesno(bool)            \
if (bool) {                \
cout << "Yes" << endl; \
} else {                   \
cout << "No" << endl;  \
}

//既存値aより新規値bが大きければ更新
template <class T>
bool chmax(T &a, const T &b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
//既存値aより新規値bが小さければ更新
template <class T>
bool chmin(T &a, const T &b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}

#define ednl endl  //打ち間違え用
#define enld endl
#define Endl endl

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
// int dx[8] = {1, 1, 1, 0, -1, -1, -1, 0};
// int dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};

// const int MOD = 998244353;  //素数(223*119+1)
// const int MOD = 1000000007;  //素数

// using mint = modint998244353;
// using mint = modint1000000007;
// using mint = static_modint<1000000009>;
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////

signed main() {
int n;
cin >> n;

vi a(n), b(n);
rep(i, n) cin >> a[i];
rep(i, n) cin >> b[i];
sort(all(b));
int x;
vi ans;
rep(i, n) {
x = a[0] ^ b[i];
vi v(n);
rep(i, n) {
v[i] = a[i] ^ x;
}
sort(all(v));
if (b == v) ans.pb(x);
}
sort(all(ans));
ans.erase(unique(ans.begin(), ans.end()), ans.end());
cout << ans.size() << endl;
print(ans);
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long


int main()
{
int t;
cin>>t;
while(t--)
{
ll a;
cin>>a;
int bit[20],tot=0,maxn=0,f=1,ans;
while(a)
{
bit[++tot]=a%10;
a/=10;
}
while(1)
{
maxn=0,f=1;
while(!bit[tot]) tot--;
for(int i=tot;i&&f;i--)
{
if(bit[i]<maxn)
{
bit[i]+=10;
bit[i+1]--;
f=0;
}
maxn=max(maxn,(bit[i]+2)/3);
}   
if(f)
{
ans=maxn;
break;
}
}
cout<<ans<<endl;
}
}
#include <bits/stdc++.h>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
#endif
using ll = long long;
using ld = long double;
using ull = unsigned long long;
#define endl "\n"
typedef pair<int,int> Pii;
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))
#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)
#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define ALL(x) begin(x), end(x)
#define PB push_back
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(s) (s).begin(),(s).end()
#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)
#define drep(i, n) drep2(i, n, 0)
#define rever(vec) reverse(vec.begin(), vec.end())
#define sor(vec) sort(vec.begin(), vec.end())
#define fi first
#define se second
#define pb push_back
#define P pair<ll,ll>
#define PQminll priority_queue<ll, vector<ll>, greater<ll>>
#define PQmaxll priority_queue<ll,vector<ll>,less<ll>>
#define PQminP priority_queue<P, vector<P>, greater<P>>
#define PQmaxP priority_queue<P,vector<P>,less<P>>
#define NP next_permutation
//typedef string::const_iterator State;
//class ParseError {};
//const ll mod = 1000000009;
const ll mod = 998244353;
//const ll mod = 1000000007;
const ll inf = 4100000000000000000ll;
const ld eps = ld(0.000000000001);
const long double pi = 3.141592653589793;
template<class T>void vcin(vector<T> &n){for(int i=0;i<int(n.size());i++) cin>>n[i];}
template<class T,class K>void vcin(vector<T> &n,vector<K> &m){for(int i=0;i<int(n.size());i++) cin>>n[i]>>m[i];}
template<class T>void vcout(vector<T> &n){for(int i=0;i<int(n.size());i++){cout<<n[i]<<" ";}cout<<endl;}
template<class T>void vcin(vector<vector<T>> &n){for(int i=0;i<int(n.size());i++){for(int j=0;j<int(n[i].size());j++){cin>>n[i][j];}}}
template<class T>void vcout(vector<vector<T>> &n){for(int i=0;i<int(n.size());i++){for(int j=0;j<int(n[i].size());j++){cout<<n[i][j]<<" ";}cout<<endl;}cout<<endl;}
void yes(bool a){cout<<(a?"yes":"no")<<endl;}
void YES(bool a){cout<<(a?"YES":"NO")<<endl;}
void Yes(bool a){cout<<(a?"Yes":"No")<<endl;}
void possible(bool a){ cout<<(a?"possible":"impossible")<<endl; }
void Possible(bool a){ cout<<(a?"Possible":"Impossible")<<endl; }
void POSSIBLE(bool a){ cout<<(a?"POSSIBLE":"IMPOSSIBLE")<<endl; }
template<class T>void print(T a){cout<<a<<endl;}
template<class T,class F>void print(pair<T,F> a){cout<<a.fi<<" "<<a.se<<endl;}
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0;}
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0;}
template<class T> void ifmin(T t,T u){if(t>u){cout<<-1<<endl;}else{cout<<t<<endl;}}
template<class T> void ifmax(T t,T u){if(t>u){cout<<-1<<endl;}else{cout<<t<<endl;}}
ll fastgcd(ll u,ll v){ll shl=0;while(u&&v&&u!=v){bool eu=!(u&1);bool ev=!(v&1);if(eu&&ev){++shl;u>>=1;v>>=1;}else if(eu&&!ev){u>>=1;}else if(!eu&&ev){v>>=1;}else if(u>=v){u=(u-v)>>1;}else{ll tmp=u;u=(v-u)>>1;v=tmp;}}return !u?v<<shl:u<<shl;}
ll modPow(ll a, ll n, ll mod) { if(mod==1) return 0;ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }
vector<ll> divisor(ll x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++){ if(x % i == 0) {ans.push_back(i); if(i*i!=x){ ans.push_back(x / ans[i]);}}}sor(ans); return ans; }
ll pop(ll x){return __builtin_popcountll(x);}
ll poplong(ll x){ll y=-1;while(x){x/=2;y++;}return y;}

void cincout() {
ios::sync_with_stdio(false);
std::cin.tie(nullptr);
cout<< fixed << setprecision(10);
}
template<class T>
vector<T> NTT(vector<T> a,vector<T> b){
ll nmod=T::mod();
int n=a.size();
int m=b.size();
vector<int> x1(n);
vector<int> y1(m);
for(int i=0;i<n;i++){
ll tmp1,tmp2,tmp3;
tmp1=a[i].val();
x1[i]=tmp1;
}
for(int i=0;i<m;i++){
ll tmp1,tmp2,tmp3;
tmp1=b[i].val();
y1[i]=tmp1;
}
auto z1=convolution<167772161>(x1,y1);
auto z2=convolution<469762049>(x1,y1);
auto z3=convolution<1224736769>(x1,y1);
vector<T> res(n+m-1);
ll m1=167772161;
ll m2=469762049;
ll m3=1224736769;
ll m1m2=104391568;
ll m1m2m3=721017874;
ll mm12=m1*m2%nmod;
for(int i=0;i<n+m-1;i++){
int v1=(z2[i]-z1[i])*m1m2%m2;
if(v1<0) v1+=m2;
int v2=(z3[i]-(z1[i]+v1*m1)%m3)*m1m2m3%m3;
if(v2<0) v2+=m3;
res[i]=(z1[i]+v1*m1+v2*mm12);
}
return res;
}
template<class T>
struct FormalPowerSeries:vector<T>{
using vector<T>::vector;
using F=FormalPowerSeries;
F &operator=(const vector<T> &g){
int n=g.size();
int m=(*this).size();
(*this).resize(n);
for(int i=0;i<n;i++) (*this)[i]=g[i];
return (*this);
}
F &operator=(const F &g){
int n=g.size();
int m=(*this).size();
(*this).resize(n);
for(int i=0;i<n;i++) (*this)[i]=g[i];
return (*this);
}
F &operator-(){
for(int i=0;i<(*this).size();i++) (*this)[i]*=-1;
return (*this);
}
F &operator+=(const F &g){
int n=(*this).size();
int m=g.size();
if(n<m) (*this).resize(m);
for(int i=0;i<m;i++) (*this)[i]+=g[i];
return (*this);
}
F &operator+=(const T &r){
if((*this).size()==0) (*this).resize(1);
(*this)[0]+=r;
return (*this);
}
F &operator-=(const F &g){
int n=(*this).size();
int m=g.size();
if(n<m) (*this).resize(m);
for(int i=0;i<m;i++) (*this)[i]-=g[i];
return (*this);
}
F &operator-=(const T &r){
if((*this).size()==0) (*this).resize(1);
(*this)[0]-=r;
return (*this);
}
F &operator*=(const F &g){
(*this)=convolution((*this),g);
return (*this);
}
F &operator*=(const T &r){
for(int i=0;i<(*this).size();i++) (*this)[i]*=r;
return (*this);
}
F &operator/=(const F &g){
int n=(*this).size();
(*this)=convolution((*this),g.inv());
(*this).resize(n);
return (*this);
}
F &operator/=(const T &r){
r=r.inv();
for(int i=0;i<(*this).size();i++) (*this)[i]*=r;
return (*this);
}
F &operator<<=(const int d) {
int n=(*this).size();
(*this).insert((*this).begin(),d,0);
return *this;
}
F &operator>>=(const int d) {
int n=(*this).size();
(*this).erase((*this).begin(),(*this).begin()+min(n, d));
return *this;
}
F operator*(const T &g) const { return F(*this)*=g;}
F operator-(const T &g) const { return F(*this)-=g;}
F operator+(const T &g) const { return F(*this)+=g;}
F operator/(const T &g) const { return F(*this)/=g;}
F operator*(const F &g) const { return F(*this)*=g;}
F operator-(const F &g) const { return F(*this)-=g;}
F operator+(const F &g) const { return F(*this)+=g;}
F operator/(const F &g) const { return F(*this)/=g;}
F operator%(const F &g) const { return F(*this)%=g;}
F operator<<(const int d) const { return F(*this)<<=d;}
F operator>>(const int d) const { return F(*this)>>=d;}  
F pre(int sz) const {
return F(begin(*this), begin(*this) + min((int)this->size(), sz));
}
F inv(int deg=-1) const {
int n=(*this).size();
if(deg==-1) deg=n;
assert(n>0&&(*this)[0]!=T(0));
F g(1);
g[0]=(*this)[0].inv();
while(g.size()<deg){
int m=g.size();
F f(begin(*this),begin(*this)+min(n,2*m));
F r(g);
f.resize(2*m);
r.resize(2*m);
internal::butterfly(f);
internal::butterfly(r);
for(int i=0;i<2*m;i++) f[i]*=r[i];
internal::butterfly_inv(f);
f.erase(f.begin(),f.begin()+m);
f.resize(2*m);
internal::butterfly(f);
for(int i=0;i<2*m;i++) f[i]*=r[i];
internal::butterfly_inv(f);
T in=T(2*m).inv();
in*=-in;
for(int i=0;i<m;i++) f[i]*=in;
g.insert(g.end(),f.begin(),f.begin()+m);
}
return g.pre(deg);
}
T eval(const T &a){
T x=1;
T ret=0;
for(int i=0;i<(*this).size();i++){
ret+=(*this)[i]*x;
x*=a;
}
return ret;
}
void onemul(const int d,const T c){
int n=(*this).size();
for(int i=n-d-1;i>=0;i--){
(*this)[i+d]+=(*this)[i]*c;
}
}
void onediv(const int d,const T c){
int n=(*this).size();
for(int i=0;i<n-d;i++){
(*this)[i+d]-=(*this)[i]*c;
}
}
F diff() const {
int n=(*this).size();
F ret(n);
for(int i=1;i<n;i++) ret[i-1]=(*this)[i]*i;
ret[n-1]=0;
return ret;
}
F integral() const {
int n=(*this).size(),mod =T::mod();
vector<T> inv(n);
inv[1]=1;
for(int i=2;i<n;i++) inv[i]=T(mod)-inv[mod%i]*(mod/i);
F ret(n);
for(int i=n-2;i>=0;i--) ret[i+1]=(*this)[i]*inv[i+1];
ret[0]=0;
return ret;
}
F log(int deg=-1) const {
int n=(*this).size();
if(deg==-1) deg=n;
assert((*this)[0]==T(1));
return ((*this).diff()*(*this).inv(deg)).pre(deg).integral();
}
F exp(int deg=-1) const {
int n=(*this).size();
if(deg==-1) deg=n;
assert(n==0||(*this)[0]==0);
F Inv;
Inv.reserve(deg);
Inv.push_back(T(0));
Inv.push_back(T(1));
auto inplace_integral = [&](F& f) -> void {
const int n = (int)f.size();
int mod=T::mod();
while(Inv.size()<=n){
int i = Inv.size();
Inv.push_back((-Inv[mod%i])*(mod/i));
}
f.insert(begin(f),T(0));
for(int i=1;i<=n;i++) f[i]*=Inv[i];
};
auto inplace_diff = [](F &f) -> void {
if(f.empty()) return;
f.erase(begin(f));
T coeff=1,one=1;
for(int i=0;i<f.size();i++){
f[i]*=coeff;
coeff++;
}
};
F b{1,1<(int)(*this).size()?(*this)[1]:0},c{1},z1,z2{1,1};
for(int m=2;m<=deg;m<<=1){
auto y=b;
y.resize(2*m);
internal::butterfly(y);
z1=z2;
F z(m);
for(int i=0;i<m;i++) z[i]=y[i]*z1[i];
internal::butterfly_inv(z);
T si=T(m).inv();
for(int i=0;i<m;i++) z[i]*=si;
fill(begin(z),begin(z)+m/2,T(0));
internal::butterfly(z);
for(int i=0;i<m;i++) z[i]*=-z1[i];
internal::butterfly_inv(z);
for(int i=0;i<m;i++) z[i]*=si;
c.insert(end(c),begin(z)+m/2,end(z));
z2=c;
z2.resize(2*m);
internal::butterfly(z2);
F x(begin((*this)),begin((*this))+min<int>((*this).size(),m));
x.resize(m);
inplace_diff(x);
x.push_back(T(0));
internal::butterfly(x);
for(int i=0;i<m;i++) x[i]*=y[i];
internal::butterfly_inv(x);
for(int i=0;i<m;i++) x[i]*=si;
x-=b.diff();
x.resize(2*m);
for(int i=0;i<m-1;i++) x[m+i]=x[i],x[i]=T(0);
internal::butterfly(x);
for(int i=0;i<2*m;i++) x[i]*=z2[i];
internal::butterfly_inv(x);
T si2=T(m<<1).inv();
for(int i=0;i<2*m;i++) x[i]*=si2;
x.pop_back();
inplace_integral(x);
for(int i=m;i<min<int>((*this).size(),2*m);i++) x[i]+=(*this)[i];
fill(begin(x),begin(x)+m,T(0));
internal::butterfly(x);
for(int i=0;i<2*m;i++) x[i]*=y[i];
internal::butterfly_inv(x);
for(int i=0;i<2*m;i++) x[i]*=si2;
b.insert(end(b),begin(x)+m,end(x));
}
return b.pre(deg);
}
F pow(ll m){
int n=(*this).size();
int x=0;
while(x<(*this).size()&&(*this)[x]==T(0)){
x++;
}
if(x*m>=n){
F ret(n);
return ret;
}
F f(n-x);
T y=(*this)[x];
for(int i=x;i<n;i++) f[i-x]=(*this)[i]/y;
f=f.log();
for(int i=0;i<f.size();i++) f[i]*=m;
f=f.exp();
y=y.pow(m);
for(int i=0;i<f.size();i++) f[i]*=y;
F ret(n);
for(int i=x*m;i<n;i++) ret[i]=f[i-x*m];
return ret;
}
F shift(T c){
int n=(*this).size();
int mod=T::mod();
vector<T> inv(n+1);
inv[1]=1;
for(int i=2;i<=n;i++) inv[i]=mod-inv[mod%i]*(mod/i);
T x=1;
for(int i=0;i<n;i++){
(*this)[i]*=x;
x*=(i+1);
}
F g(n);
T y=1;
T now=1;
for(int i=0;i<n;i++){
g[n-i-1]=now*y;
now*=c;
y*=inv[i+1];
}
auto tmp=convolution(g,(*this));
T z=1;
for(int i=0;i<n;i++){
(*this)[i]=tmp[n+i-1]*z;
z*=inv[i+1];
}
return (*this);
}
pair<F,F> division(F g){
F f=(*this);
int n=f.size();
int m=g.size();
if(n<m){
F p(0);
return {p,f};
}
F p(n-m+1),q(n-m+1);
for(int i=0;i<n-m+1;i++) p[i]=f[n-i-1];
for(int i=0;i<n-m+1&&i<m;i++) q[i]=g[m-i-1];
p/=q;
for(int i=0;i<(n-m+1)/2;i++) swap(p[i],p[(n-m+1)-i-1]);
g.resize(n);
g*=p;
for(int i=0;i<n;i++) f[i]-=g[i];
int v=n-m+1,u=0;
for(int i=0;i<n;i++) if(f[i].val()) chmax(u,i+1);
p.resize(v);
f.resize(u);
return {p,f};
}
vector<T> multieva(vector<T> p){
int m=p.size();
int n=(*this).size();
int M=1;
int l=0;
while(M<m){
M*=2;
l++;
}
p.resize(M);
swap(m,M);
vector<vector<F>> g(l+1);
g[0].resize(m);
for(int i=0;i<m;i++){
g[0][i].resize(2);
g[0][i][0]=-p[i];
g[0][i][1]=1;
}
for(int i=0;i<l;i++){
g[i+1].resize(m>>(i+1));
for(int j=0;j<(m>>(i+1));j++) g[i+1][j]=g[i][2*j]*g[i][2*j+1];
}
g[l][0]=(*this).division(g[l][0]).se;
for(int i=l;i>=1;i--){
for(int j=0;j<(m>>(i-1));j++){
g[i-1][j]=g[i][j/2].division(g[i-1][j]).se;
}
}
for(int i=0;i<M;i++) if(g[0][i].size()==0) g[0][i].resize(1);
vector<T> ret(M);
for(int i=0;i<M;i++) ret[i]=g[0][i][0];
return ret;
}
};
template<class T>
void GaussJordan(vector<vector<T>> &A,bool is_extended = false){
ll m=A.size(),n=A[0].size();
ll rank=0;
for(int i=0;i<n;i++){
if(is_extended&&i==n-1) break;
ll p=-1;
for(int j=rank;j<m;j++){
if(A[j][i]!=T(0)){
p=j;
break;
}
}
if(p==-1) continue;
swap(A[p],A[rank]);
auto k=A[rank][i];
for(int i2=0;i2<n;i2++){
A[rank][i2]/=k;
}
for(int j=0;j<m;j++){
if(j!=rank&&A[j][i]!=T(0)){
auto fac=A[j][i];
for(int i2=0;i2<n;i2++){
A[j][i2]-=A[rank][i2]*fac;
}
}
}
rank++;
}
}

template<class T>
void linear_equation(vector<vector<T>> a, vector<T> b, vector<T> &res) {
ll m=a.size(),n=a[0].size();
vector<vector<T>> M(m,vector<T>(n+1));
for(int i=0;i<m;i++){
for(int j=0;j<n;j++){
M[i][j]=a[i][j];
}
M[i][n]=b[i];
}
GaussJordan(M,true);
res.assign(n,0);
for(int i=0;i<n;i++) res[i]=M[i][n];
}
template<class F>
pair<F,F> Characteristic_equation(const F &a) {
using T=typename F::value_type;
ll n=a.size();
ll p=n/2;
ll u=p+(p+1);
vector<vector<T>> f(u,vector<T>(u));
f[0][0]=1;
for(int i=1;i<=p;i++){
f[i][i-1]=-1;
}
for(int i=p;i<u;i++){
ll t=0;
for(int j=1+i-p;j<u;j++){
f[j][i]=a[t];
t++;
}
}
vector<T> b(u);
b[0]=1;
vector<T> res(u);
linear_equation(f,b,res);
F X(p),Y(p+1);
for(int i=0;i<p;i++) X[i]=res[i];
for(int j=p;j<res.size();j++) Y[j-p]=res[j];
return {X,Y};
}
template <class T>
T getK(FormalPowerSeries<T> p, FormalPowerSeries<T> q,ll k){
if(k<0) return T(0);
ll d=q.size();
while(k){
auto qn=q;
for(int i=1;i<d;i+=2) qn[i]*=-1;
p.resize(2*d);
q.resize(2*d);
p*=qn;
q*=qn;
for(int i=0;i<d-1;i++){
p[i]=p[(i<<1)|(k&1)];
}
for(int i=0;i<d;i++){
q[i]=q[(i<<1)];
}
p.resize(d-1);
q.resize(d);
k/=2;
}
return p[0];
}
using fps=FormalPowerSeries<modint998244353>;
using mint = modint998244353;
constexpr ll MAX = 3000000;
ll fac[MAX],finv[MAX],inv[MAX];
void COMinit(){
fac[0]=fac[1]=1;
finv[0]=finv[1]=1;
inv[1]=1;
for(int i=2;i<MAX;i++){
fac[i]=fac[i-1]*i%mod;
inv[i]=mod-inv[mod%i]*(mod/i)%mod;
finv[i]=finv[i-1]*inv[i]%mod;
}
}
ll binom(ll n,ll k){
if(n<k) return 0;
if(n<0||k<0) return 0;
return fac[n]*(finv[k]*finv[n-k]%mod)%mod;
}
ll HOM(ll n,ll k){
if(n==0&&k==0) return 1;
return binom(n+k-1,k);
}
ll POM(ll n,ll k){
if(n<k) return 0;
return fac[n]*finv[n-k]%mod;
}
int main() {
cincout();
COMinit();
ll n,m;
cin>>n>>m;
n--;
m--;
fps f(m+1);
for(int i=0;i<=m;i++) f[i]=binom(2*i,i);
fps g(m+1);
for(int i=0;i<=m;i++) g[i]=binom(n+2*i,2*i)*binom(2*i,i);
g/=f;
mint ans=0;
for(int i=0;i<=m;i++) ans+=g[i]*g[m-i];
cout<<(ans*binom(2*n,n)).val()<<endl;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
string s; cin>>s; s = "#" + s;
for(int i=0; i<26; i++){
vector<int> pfs(sz(s), 0), minq(sz(s), 0), id(sz(s), 0);
for(int j=1; j<sz(s); j++){
if(s[j] - 'a' == i)pfs[j]++;
if(j > 1){
pfs[j] += pfs[j-1];
minq[j] = 2*pfs[j] - j;
id[j] = j;
if(minq[j] > minq[j-2]){
cout<<id[j-2]+1<<' '<<j<<endl; return;
}
}
else minq[j] = 2*pfs[j] - j, id[j] = j;
if(minq[j] > minq[j-1]){
minq[j] = minq[j-1];
id[j] = id[j-1];
}
}
}
cout<<-1<<' '<<-1<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <iostream>
#include <string>
#include <sstream>
#include <iomanip> 
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>
#include <functional>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <bitset>
#include <complex>

using namespace std;

//#pragma GCC optimize("Ofast")
//#pragma GCC optimization("unroll-loops, no-stack-protector")
//#pragma GCC target("avx,avx2,fma")


typedef long long LL;
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;

typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;

typedef long double LD;
typedef pair<LD, LD> PLDLD;

typedef complex<double> CD;
typedef vector<CD> VCD;

#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound

#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define REV(x) reverse(x.begin(), x.end());
#define RSZ resize
#define ASS assign

const LL INF = 1E18;
const int MAXX = 200005;
const LD PAI = 4 * atan((LD)1);


int main()
{
ios::sync_with_stdio(false);
cin.tie(0);

LL n, i, j, k, minn, maxx, ans, x, l, r;
cin >> n;
minn = 1E9; maxx = 0;
for (i = 1; i <= n; i++) {
cin >> l >> r;
maxx = max(maxx, l);
minn = min(minn, r);

if (maxx <= minn) ans = 0;
else ans = (maxx - minn + 1) / 2;

cout << ans << "\n";
}



return 0;
}

#include<bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp> 
// #include <ext/pb_ds/detail/standard_policies.hpp>
// using namespace __gnu_pbds;

#pragma GCC optimize("O3")
#ifdef LOCAL
#include "/Users/lbjlc/Desktop/coding/debug_utils.h"
#else
#define print(...) ;
#define printn(...) ;
#define printg(...) ;
#define fprint(...) ;
#define fprintn(...) ;
#endif

#define rep(i, a, b) for(auto i = (a); i < (b); i++)
#define rrep(i, a, b) for(auto i = (a); i > (b); i--)
#define all(v) (v).begin(), (v).end()
#define pb push_back
// #define mp make_pair
#define fi first
#define se second
#define maxi(x, y) x = max(x, y)
#define mini(x, y) x = min(x, y)
// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }
// #define endl '\n'
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int get_random() {
static uniform_int_distribution<int> dist(0, 1e9 + 6);
return dist(rng);
}
const vector<pair<int,int>> eight_directions = {{1,1},{1,0},{1,-1},{0,1},{0,-1},{-1,1},{-1,0},{-1,-1}};
const vector<pair<int,int>> four_directions = {{1,0},{0,1},{0,-1},{-1,0}};
#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}


typedef unsigned long long ull;
typedef long long ll;

typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<pii> vpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef vector<long long> vll;
#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)

template<class T>
void make_unique(T & v) {
sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());
}
int geti() { int x; cin >> x; return x; }
long long getll() { long long x; cin >> x; return x; }
double getd() { double x; cin >> x; return x; }
// pair<int, int> a(geti(), geti()) does not work
// pair<int, int> a({geti(), geti()}) works, since it uses initializer.

const int MAXN = 3e5 + 100;

void solve(int tt) {
// cout<<"Case #"<<tt<<": ";
}

string s[MAXN];
int main(int argc, char * argv[]) {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
// solve_testcase;

int n, m;
cin>>n>>m;

long long cnt[2]={0};
rep(i,0,n) {
cin>>s[i];
int tmp = 0;
for(auto c:s[i]) tmp += c - '0';
tmp %= 2;
cnt[tmp]++;
}
long long res = cnt[0] * cnt[1];
cout<<res<<endl;


return 0;
}












#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <deque>
#include <cstdio>
#include <set>
#include <map>
#include <bitset>
#include <stack>
#include <cctype>
using namespace std;
char c[5] = {'1','2','3','4','5'};
int main() {
int h, w;
string s[770];
cin >> h >> w;
for (int i = 0; i < h; i++) {
cin >> s[i];
}
for (int i = 0; i < h; i++) {
for (int j = 0; j < w; j++) {
if (s[i][j] == '.') {
vector<char> v;
if (i - 1 >= 0) {
v.emplace_back(s[i - 1][j]);
}
if (j - 1 >= 0) {
v.emplace_back(s[i][j - 1]);
}
if (i + 1 < h) {
v.emplace_back(s[i + 1][j]);
}
if (j + 1 < w) {
v.emplace_back(s[i][j + 1]);
}
for (int k = 0; k < 5; k++) {
bool bo = true;
for (int l = 0; l < v.size(); l++) {
if (c[k] == v[l]) {
bo = false;
}
}
if (bo) {
s[i][j] = c[k];
break;
}
}
}
}
}
for (int i = 0; i < h; i++) {
cout << s[i] << endl;
}
}
#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int n;
cin >> n;

string s;
cin >> s;

s += "$";

int curr = 1;
int64_t ans = 0;

for (int i = 1; i <= n; ++i) {
if (s[i] == s[i - 1]) {
++curr;
} else {
ans += (curr * 1ll * (curr - 1)) / 2;
curr = 1;
}
}

cout << ans << "\n";

return 0;
}

#include "bits/stdc++.h"
using namespace std;

#define ar array

const int N = 2e5 + 5;
vector<int> edges[N];

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

int n, k; cin>>n>>k;
for(int i=1;i<n;i++){
int a, b; cin>>a>>b;
edges[a].push_back(b);
edges[b].push_back(a);
}

auto check = [&](int m){
vector<ar<int, 2>> d(n + 1);
int res = 0;
function<void(int, int)> dfs = [&](int u, int p){
for(auto x : edges[u]){
if(x == p) continue;
dfs(x, u);
if(d[u][0]){
if(d[x][0]){
d[u][1] = min(d[u][1], d[x][1] + 1);
} else {
if(m - d[u][1] < d[x][1] + 1) d[u] = d[x], d[u][1]++;
}
} else {
if(d[x][0]){
if(m - (d[x][1] + 1) >= d[u][1]) d[u] = d[x], d[u][1]++;
} else {
d[u][1] = max(d[u][1], d[x][1] + 1);
}
}
}

if(d[u][0] == 0 && d[u][1] == m){
res++;
d[u] = {1, 0};
}
};

dfs(1, 1);
if(d[1][0] == 0) res++;
//~ cout<<m<<" "<<res<<"\n";
return (res <= k);
};

int l = 1, r = n;
while(l < r){
int m = (l + r) >> 1;
if(check(m)) r = m;
else l = m + 1;
}

//~ cout<<check(l)<<"\n";
//~ cout<<(l * 1. / 2.)<<"\n";
cout<<l<<"\n";
}

#include <bits/stdc++.h>
using namespace std;

int main() {
int T;
cin >> T;
for (int i = 0; i < T; i++) {
long long n2, n3, n4, count = 0;
cin >> n2 >> n3 >> n4;
long long a = min((n3 / 2), n4);
n3 -= a * 2;
n4 -= a;
count += a;
long long b = min((n2 / 2), (n3 / 2));
n2 -= b * 2;
n3 -= b * 2;
count += b;
long long c = min(n2, (n4 / 2));
n2 -= c;
n4 -= c * 2;
count += c;
long long d = min((n2 / 3), n4);
n2 -= d * 3;
n4 -= d;
count += d;
long long e = n2 / 5;
n2 -= e * 5;
count += e;
cout << count << endl;
}
}
#include <bits/stdc++.h>

using namespace std;

// long longの省略
typedef long long ll;

// rep(先頭にRで逆からループ、末尾にSで「1～n」となる)
#define rep(i, a, n) for(int i = a; i < n; i++)
#define reps(i, a, n) for(int i = a; i <= n; i++)
#define rrep(i, a, n) for(int i = n - 1; i >= a; i--)
#define rreps(i, a, n) for(int i = n; i >= a; i--)

// ソートなどに対象を入れる場合
#define all(x) (x).begin(),(x).end()

// ソートされた配列から重複を削除して詰めなおす
#define UNIQUE(x) x.erase( unique(x.begin(), x.end()), x.end() );

int d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

int __gcd(ll a, ll b){
ll c;

while((c = a % b) != 0){
a = b;
b = c;
}

return b;
}

// 「number」の「n」ビット目が「1」であるか「0」か
// ビット目の数え方は配列の添え字と同じ
bool __bit(int number, int n){
if(number & (1 << n))
return true;

return false;
}

// aよりもbが大きいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmax(T &a, const T& b) {
if (a < b) {
a = b;  // aをbで更新
return true;
}

return false;
}
// aよりもbが小さいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmin(T &a, const T& b) {
if (a > b) {
a = b;  // aをbで更新
return true;
}

return false;
}

int main(){
int N; cin >> N;

vector<int> X(N);
vector<bool> number(51, true);
rep(i, 0, N) cin >> X[i];

reps(i, 2, 50){
if(number[i]){
for(int j = i * 2; j <= 50; j += i){
number[j] = false;
}
}
}

// 素数の集合を作成
vector<int> data;
reps(i, 2, 50){
//printf("%d:%d\n", i, (int)number[i]);
if(number[i])
data.push_back(i);
}

// ビット全探索
int size = data.size();
ll ans = LLONG_MAX;
rep(bit, 1, 1 << size){
ll temp = 1;
rep(i, 0, size){
if(__bit(bit, i))
temp *= data[i];
}

int i = 0;
for(; i < N; i++){
if(__gcd(temp, X[i]) == 1)
break;
}

if(i == N)
chmin(ans, temp);
}

cout << ans << endl;

return 0;
}
#include <iostream>
#include <algorithm>

using namespace std;


int main() {
int n;
cin >> n;
long long n2, n3, n4;

for(int i=0;i<n;i++){
cin >> n2 >> n3 >> n4;
long long maxTens = 0;
long long maxThreeUsage = n3/2;
if(n4 >= maxThreeUsage){
maxTens += maxThreeUsage;
n4 -= maxThreeUsage;
if(n4 / 2 >= n2){
maxTens += n2;
cout << maxTens << "\n";
continue;
}else{
maxTens += n4/2;
n2 -= n4/2;
if(n4%2 == 1 && n2 >= 3){
n2 -= 3;
maxTens++;
}
maxTens += n2/5;
cout << maxTens << "\n";
continue;
}
}else{
maxTens += n4;
maxThreeUsage -= n4;
if(maxThreeUsage >= n2 / 2){
maxTens += n2/2;
cout << maxTens << "\n";
continue;
}else{
maxTens += maxThreeUsage;
n2 -= maxThreeUsage * 2;
maxTens += n2/5;
cout << maxTens << "\n";
continue;
}
}
}
}
#include <bits/stdc++.h>
using namespace std;
using ll=int;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)
class mint {
public:
long long x;
constexpr mint(long long x = 0) : x((x % MOD + MOD) % MOD) {}
constexpr mint operator-() const { return mint(-x); }
constexpr mint& operator+=(const mint& a) {
if ((x += a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator-=(const mint& a) {
if ((x += MOD - a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator*=(const mint& a) {
(x *= a.x) %= MOD;
return *this;
}
constexpr mint operator+(const mint& a) const {
mint res(*this);
return res += a;
}
constexpr mint operator-(const mint& a) const {
mint res(*this);
return res -= a;
}
constexpr mint& operator++() {
++x;
if (x >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator--() {
--x;
if (x < 0) x += MOD;
return *this;
}
constexpr mint operator++(int) {
mint tmp(*this);
++x;
if (x >= MOD) x -= MOD;
return tmp;
}
constexpr mint operator--(int) {
mint tmp(*this);
--x;
if (x < 0) x += MOD;
return tmp;
}
constexpr mint operator*(const mint& a) const {
mint res(*this);
return res *= a;
}
constexpr mint pow(long long t) const {
if (!t) return 1;
mint a = pow(t >> 1);
a *= a;
if (t & 1) a *= *this;
return a;
}

// for prime mod
constexpr mint inv() const { return pow(MOD - 2); }
constexpr mint& operator/=(const mint& a) { return (*this) *= a.inv(); }
constexpr mint operator/(const mint& a) const {
mint res(*this);
return res /= a;
}
};
ostream& operator<<(ostream& os, const mint& m) {
os << m.x;
return os;
}
ostream& operator>>(ostream& os, const mint& m) {
os >> m.x;
return os;
}
bool operator==(const mint x, const mint y) { return (x.x == y.x); }
bool operator!=(const mint x, const mint y) { return !(x.x == y.x); }
bool operator>(const mint x, const mint y) { return (x.x > y.x); }
bool operator<(const mint x, const mint y) { return (y.x > x.x); }
bool operator>=(const mint x, const mint y) { return !(x.x < y.x); }
bool operator<=(const mint x, const mint y) { return !(x.x > y.x); }

//nCk
const ll MAX = 400010;

long long fac[MAX], finv[MAX], inv[MAX];

void COMinit(){
fac[0] = fac[1]=1;
finv[0] = finv[1]=1;
inv[1] = 1;
for(int i=2; i<MAX; i++){
fac[i] = fac[i-1] * i % MOD;
inv[i] = MOD-inv[MOD%i] * (MOD/i) % MOD;
finv[i] = finv[i-1] * inv[i] % MOD;//逆元の階上
}
}

ll COM(int n, int k){
if (n<k)
return 0;
if (n<0 || k<0)
return 0;
return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;
}

//エラトステネス（nまでの素数抽出）
vector<ll> prime(0, 0);

void eratos(ll n){
vector<bool> N(n+10,true);
N[0] = false;
N[1] = false;
for(int i=2; i<=n; i++){
if (N[i])
prime.push_back(i);
int j=2;
while (i*j <= n)
N[i*j++] = false;
}
}

/*
4=
2*2
3
1 1 1

1か2個、3か所に2を挿入。
3H1+3H2
3+6 = 9

3を1か所に。
3H1
3
0
1

9+3+1=13

M以下で、ありうる素数の組み合わせを考えないといけない

M以下の全部の約数の個数をしっておく
M=10
6
*/

int main(){
cincout();
COMinit();

ll N, M;
cin >> N >> M;

eratos(M+10);//nまでの素数を抽出
mint ans = 0;
for(ll i=1; i<=M; ++i){
ll n=i;
map<ll, ll> cnt;
for(auto p: prime){
while(n%p==0){
++cnt[p];
n/=p;
}
if (n==1) break;
}
// NHcnt
mint add = 1;
for(auto c: cnt){
add *= COM(N+c.second-1, c.second);
}
ans += add;
}
cout << ans << endl;
}
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <deque>
#include <map>
#include <cmath>
typedef long long LL;
using namespace std;
const int Mod = 1000000007;

int main() {
int N;
cin >> N;
string S;
cin >> S;
LL count = 0;
LL ans = 0;
for (int i = 0; i < N - 1; i++) {
if (S[i] == S[i+1]) {
count++;
} else {
ans += count * (count + 1) / 2;
count = 0;
}
}
ans += count * (count + 1) / 2;
cout << ans << endl;
}
#include <iostream>
#include <string>
using namespace std;

int main() {
long long A, B; // long long 型の変数 A, B を定義
cin >> A >> B; // 整数 A, B を入力
cout << 500000000LL * B + A << endl; // 答えを出力（500000000LL は「long long 型の 500000000」という意味）
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep(i, s, n) for (int i = (s); i < (int)(n); i++)
#define INTINF  2147483647

int main()
{
int n, m;
int odd = 0, even = 0;
cin >> n >> m;

rep(i, 0, n)
{
string s;
int ct = 0;

cin >> s;

rep(i, 0, m)
{
if (s[i] == '1')
{
ct++;
}
}

if (ct % 2 == 0)
{
even++;
}
else
{
odd++;
}
}

cout << (ll) even * (ll)odd;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int64_t n, l, r;
cin >> n >> l >> r;

auto intersect = [&] (pair<int64_t, int64_t> lhs, pair<int64_t, int64_t> rhs) {
return max<int64_t>(0, min(lhs.second, rhs.second) - max(lhs.first, rhs.first) + 1);
};

auto cnt = [&] (int64_t l, int64_t r, int64_t pref, int bit) {
return intersect({l, r}, {pref, pref + (1ll << bit) - 1});
};

int64_t pref = 0, ans = 0;
for (int bit = 62; bit >= 0; --bit) {
auto mask = n & (1ll << bit);
pref ^= mask;
if (mask) {
ans += cnt(l, r, pref, bit);
}
pref ^= mask;
}

cout << ans << "\n";

return 0;
}

#include <bits/stdc++.h>

#define For(i, a, b) for (int i = a; i <= b; ++i)
#define rFor(i, b, a) for (int i = b; i >= a; --i)
#define eFor(i, u, v) for (int i = head[u], v = e[i].to; i; i = e[i].next, v = e[i].to)

typedef long long ll;

using std::cin;
using std::cout;
using std::endl;

typedef std::pair<int, int> pii;
#define fi first
#define se second

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename T> T myrand(T l, T r) {
return std::uniform_int_distribution<T>(l, r)(rnd);
}

void close_stdio() {
std::ios::sync_with_stdio(false);
std::cerr << "DO NOT use scanf/printf!\n";
}

const int kN = 5005;
const int P = 1e9 + 7;

int n, m, f[2][kN * 2];
char s[kN];

int main() {
scanf("%d%s", &n, s + 1);
m = strlen(s + 1);
int cur = 0;
f[cur][m] = 1;
For(i, 1, n) {
memset(f[cur ^ 1], 0, sizeof(f[cur ^ 1]));
For(j, 0, m + n) if (f[cur][j]) {
(f[cur ^ 1][std::max(0, j - 1)] += f[cur][j]) %= P;
f[cur ^ 1][j + 1] = ((ll)f[cur][j] * 2 + f[cur ^ 1][j + 1]) % P;
}
cur ^= 1;
}
printf("%d", f[cur][0]);
return 0;
}
/* PAY ATTENTION TO: */
/* 1. Memory Limit, Array Size */
/* 2. Integer Overflow */
/* 3. Multi-test */
/* 4. Potential Constant-speedup */
/* Stay organized and write things down. */

#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n;

int f(int x){
if(x==0) return 0;
int a=x/10,b=x%10;
if(b>=1&&b<=3&&f(a)<=1) return 1;
else if(b>=2&&b<=6&&f(a)<=2) return 2;
else if(b>=3&&b<=9&&f(a)<=3) return 3;
else if(b>=4&&f(a)<=4) return 4;
if(b<=2&&f(a-1)<=4) return 4;
else return 5;
}

signed main(){
cin>>T;
while(T--){
cin>>n;
cout<<f(n)<<endl;
}
return 0;
}

#include <stdio.h>
#include <string.h>
#include <set>
#include <algorithm>

using namespace std;
#define MAXN 2050

int ax[MAXN];
int bx[MAXN];

int main() {
int N;
scanf("%d", &N);
for (int i=1; i<=N; i++) scanf("%d", &ax[i]);
for (int i=1; i<=N; i++) scanf("%d", &bx[i]);
multiset<int> sa;
for (int i=2; i<=N; i++) {
sa.insert(ax[i] ^ ax[1]);
}
set<int> ans;
for (int i=1; i<=N; i++) {
multiset<int> sb;
for (int j=1; j<=N; j++) {
if (j != i) sb.insert(bx[j] ^ bx[i]);
}
if (sa == sb) {
ans.insert(ax[1] ^ bx[i]);
}
}
printf("%d\n", (int)ans.size());
for (int x : ans) {
printf("%d\n", x);
}
}

#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
ll MOD = 1000000007;

const double PI = 3.14159265358979323846;

#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)

// a^p
// 2^3 = 2 * 2^2
// 2^2 = 2 * (2^1)
// 2^1 = 2
ll modpow(ll a, ll p, ll mod) {
if (p == 0) return 1;

if (p % 2 == 0) {
ll half = modpow(a, p / 2, mod) % mod;
return half * half % mod;
} else {
return a * modpow(a, p - 1, mod) % mod;
}
}

// a/b
// https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
ll moddiv(ll a, ll b, ll mod) { return a * modpow(b, mod - 2, mod); }

// nCa を求める
ll modCombination(ll n, ll a, ll mod) {
if (n < 0 || n < a) return 0;
if (n - a < a) {
return modCombination(n, n - a, mod);
}

ll denominator = 1;  // 分母
ll numerator = 1;    // 分子

for (ll i = 0; i < a; i++) {
denominator *= a - i;
numerator *= n - i;
denominator %= mod;
numerator %= mod;
}

return numerator * modpow(denominator, mod - 2, mod) % mod;
}

class UnionFind {
private:
vector<ll> parents;

public:
UnionFind(ll n) : parents(n, -1) {}

bool issame(ll x, ll y) { return root(x) == root(y); }

bool merge(ll x, ll y) {
if (issame(x, y)) return false;

ll rx = root(x);
ll ry = root(y);
if (parents[rx] > parents[ry]) swap(rx, ry);
// サイズ情報を更新
parents[rx] += parents[ry];
// yの親を更新
parents[ry] = rx;

return true;
}

ll size(ll x) { return -parents[root(x)]; }

ll root(ll x) {
if (parents[x] < 0) return x;
// 根の親の値に木の(-)サイズの情報を入れる
return parents[x] = root(parents[x]);
}
};

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
vector<ll> enum_divisors(ll n) {
vector<ll> res;
// sqrt(n)まで試し割り
for (ll i = 1; i * i <= n; i++) {
if (n % i == 0) {
res.push_back(i);
// 重複しないならばiの相方であるn/iも約数
// e.g. n=25のときのi=5は重複
if (n / i != i) res.push_back(n / i);
}
}

sort(res.begin(), res.end());
return res;
}

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
map<ll, ll> prime_factors(ll n) {
map<ll, ll> res;
// sqrt(n)まで試し割り
for (ll a = 2; a * a <= n; a++) {
if (n % a != 0) continue;

// nで割れる限り割る
while (n % a == 0) {
res[a]++;
n /= a;
}
}
if (n != 1) res[n]++;

return res;
}

ll gcd(ll a, ll b) {
if (b == 0)
return a;
else
return gcd(b, a % b);
}

// cf. https://qiita.com/drken/items/56a6b68edef8fc605821
class AccumSum2D {
private:
vector<vector<ll>> sum;
ll H;
ll W;

public:
AccumSum2D(vector<vector<ll>> &A) {
H = (ll)A.size();
W = (ll)A[0].size();
sum.resize(H + 1, vector<ll>(W + 1));

for (ll i = 0; i < H; i++) {
for (ll j = 0; j < W; j++) {
sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + A[i][j];
}
}
}

// クエリ [x1, x2) × [y1, y2) の長方形区域の和
ll Sum(ll x1, ll x2, ll y1, ll y2) {
return sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];
}
};

// cf. https://tsutaj.hatenablog.com/entry/2017/03/30/224339
template <class S, S (*op)(S, S), S (*e)()>
class LazySegmentTree {
private:
ll n;
vector<S> node;
vector<S> lazy;

public:
LazySegmentTree(const vector<S> &A) {
ll size = (ll)A.size();
n = 1;
while (n < size) {
n *= 2;
}
node.resize(2 * n - 1);
lazy.resize(2 * n - 1);

for (ll i = 0; i < size; i++) {
node[i + n - 1] = A[i];
}

for (ll i = n - 2; i >= 0; i--) {
node[i] = op(node[2 * i + 1], node[2 * i + 2]);
}
}

// [a,b)
S query(ll a, ll b) { return query(a, b, 0, 0, n); }

// [a,b)
void update(ll a, ll b, S x) { update(a, b, x, 0, 0, n); }

private:
void eval(ll k, ll l, ll r) {
if (lazy[k] != e()) {
if (r - l > 1) {
lazy[2 * k + 1] = op(lazy[2 * k + 1], lazy[k]);
lazy[2 * k + 2] = op(lazy[2 * k + 2], lazy[k]);
}

node[k] = op(node[k], lazy[k]);
lazy[k] = e();
}
}

S query(ll a, ll b, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return e();
if (a <= l && r <= b) return node[k];

ll m1 = query(a, b, 2 * k + 1, l, (l + r) / 2);
ll m2 = query(a, b, 2 * k + 2, (l + r) / 2, r);
return op(m1, m2);
}

void update(ll a, ll b, S x, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return;
if (a <= l && r <= b) {
lazy[k] = op(lazy[k], x);
eval(k, l, r);
return;
}

update(a, b, x, 2 * k + 1, l, (l + r) / 2);
update(a, b, x, 2 * k + 2, (l + r) / 2, r);

node[k] = op(node[2 * k + 1], node[2 * k + 2]);
}
};

// p/q
struct fraction {
ll p, q;
fraction(ll _p = 0, ll _q = 1) : p(_p), q(_q) {
if (q == 0) {
p = 1;
return;
}

ll g = gcd(p, q);
p /= g;
q /= g;
}

bool operator<(const fraction &other) const {
return p * other.q < q * other.p;
}

bool operator<=(const fraction &other) const {
return p * other.q <= q * other.p;
}

bool operator==(const fraction &other) const {
return p == other.p && q == other.q;
}
};

// 多次元 vector 生成
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

int main() {
cin.tie(nullptr);
ios_base::sync_with_stdio(false);
cout << fixed << setprecision(15);

ll N;
cin >> N;
vector<ll> A(N), B(N);
rep(i, N) cin >> A[i];
rep(i, N) cin >> B[i];

sort(B.begin(), B.end());

set<ll> ans;
rep(i, N) {
ll x = A[0] ^ B[i];

vector<ll> C(N);
rep(j, N) { C[j] = A[j] ^ x; }
sort(C.begin(), C.end());

if (B == C) {
ans.insert(x);
}
}

if (ans.size()) {
cout << ans.size() << endl;
for (auto a : ans) {
cout << a << endl;
}

} else {
cout << 0 << endl;
}

return 0;
}

#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<assert.h>
#include<random>
#include<string>
#include<algorithm>
#include<queue>
#include<bitset>

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()

const long long mod = 1e9 + 7;
const long long inf = 1e18;
const int N = 5010;

using ll = long long;

using namespace std;

ll dp[N][N];

ll add(ll a, ll b)
{
ll res = (a + b);
if (res >= mod) res -= mod;
if (res < 0) res += mod;
return res;
}

ll bp(ll a, ll n)
{
ll res = 1;
while (n)
{
if (n & 1)
res = (res * a) % mod;
a = (a * a) % mod;
n >>= 1;
}
return res;
}

ll rev(ll n)
{
ll k = bp(n, mod - 2);
ll s = (k * n) % mod;
return bp(n, mod - 2);
}

void solve()
{
int n;
string s;
cin >> n >> s;

dp[0][0] = 1;

ll p = 1;

for (int i = 0; i < s.size(); i++)
{
p = (p << 1) % mod;
}

for (int i = 1; i <= n; i++)
{

for (int len = 0; len <= n; len++)
{
if (len == 0) dp[i][len] = (dp[i - 1][len] + dp[i - 1][len + 1]) % mod;
else dp[i][len] = (dp[i - 1][len - 1] * 2 + dp[i - 1][len + 1]) % mod;
}
}

cout << (dp[n][s.size()] * rev(p)) % mod << '\n';
}

signed main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
#include <iostream>
#include <cstdio>
#include <stdio.h>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <stack>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <ctime>
#include <cassert>
#include <complex>
#include <string>
#include <cstring>
#include <utility>
#include <numeric>
#define pb push_back
#define mk make_pair
#define endl "\n"
#define mod 1000000007
#define mod1 29996224275833
#define mul 31
#define PI 3.14159265358979323846264
//#include bits/stdc++.h
//#include <ext/pb_ds/tree_policy.hpp>
//#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
typedef long long int lli;
typedef long double ld;
typedef pair<lli,lli> ii;
vector <lli> p[500005],f(200005);
lli a[26][26][26], b[26][26], c[26];
//map<lli,lli>mp[200005];
//lli dp[200005][2];
//freopen("codecoder.in", "r", stdin);
//freopen("codecoder.out", "w", stdout);
lli gcd(lli a, lli b)
{
if (b == 0)
return a;
return gcd(b, a % b);

}
lli bpow(lli a, lli b) {
lli res = 1;
while (b > 0) {
if (b & 1)
res = (res * a)%mod;
a = (a * a)%mod;
//cout<<res<<" "<<a<<endl;
b >>= 1;
}
return res%mod;
}
void fact(lli i)
{
f[0]=1;
for(lli k=1;k<=i;k++)
{
(f[k]=f[k-1]*k)%=mod;
}
}
lli isprime(lli n)
{
if(n==1)
return 0;
for(lli i=2;i<=sqrt(n);i++)
if(n%i==0)
return 0;
return 1;
}
lli find(lli x)
{
if(f[x]==x)
return x;
else
return f[x]=find(f[x]);
}
bool cmp(pair<lli, lli> x,pair<lli, lli> y)
{
return x.second<y.second;
}
void check()
{
cout<<"HI"<<endl;
}
lli comb(lli i,lli j)
{
if(j>i)return 0;
lli k=f[i];
lli g=(f[j]*(f[i-j]))%mod;
lli h=bpow(g,mod-2);
return (k*h)%mod;
}
pair<ld,ld>az(ld a,ld b,ld c,ld d,ld u)
{
ld x1=(a-c)*cos(u)-(b-d)*sin(u)+c;
ld y1=(a-c)*sin(u)+(b-d)*cos(u)+d;
return {x1,y1};
}
/*void sieve()
{
for(lli i=2;i<=sqrt(10000000);i++)
{
if(b[i]==0)
{
k.pb(i);
for(lli j=2;i*j<=sqrt(10000000);j++)
{
b[i*j]=1;
}
}
}
}*/
int main ()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
lli t;t=1;
while(t--)
{
lli n,l,r;
cin>>n>>l>>r;
lli u=(lli)log2(l);
lli z=(lli)log2(r);
lli sum=0;
//cout<<u<<" "<<z<<endl;
for(lli i=u;i<=z;i++)
{
if(i==u && i==z)
{
lli x=(lli)pow(2,i);
lli y=(lli)pow(2,i+1);
x=max(x,l);
y=min(y,r+1);
if((1ll<<i)&n)
{
sum+=(y-x);
}
}
else if(i==u)
{
lli x=(lli)pow(2,i);
lli y=(lli)pow(2,i+1);
x=max(x,l);
if((1ll<<i)&n)
{
sum+=(y-x);
}
}
else if(i==z)
{
lli x=(lli)pow(2,i);
lli y=(lli)pow(2,i+1);
y=min(y,r+1);
//cout<<x<<" "<<y<<endl;
if((1ll<<i)&n)
{
sum+=(y-x);
}
}
else
{
lli x=(lli)pow(2,i);
lli y=(lli)pow(2,i+1);
if((1ll<<i)&n)
{
sum+=(y-x);
}
}
//cout<<i<<" "<<sum<<endl;
}
cout<<sum<<endl;
}
}

#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;
using ll = long long;
const int INF = INT_MAX;
const ll LINF = LLONG_MAX;
bool chmin(int& a, int b){ if(a > b){ a = b; return 1; } return 0; }
bool chmax(int& a, int b){ if(a < b){ a = b; return 1; } return 0; }
int mod = 1000000007;
int mod2 = 998244353;

int main() {
ll a, b, c;
cin >> a >> b >> c;
ll ans;
if ((a + c) % 2 == 1) {
ans = 1;
c++;
}
else ans = 0;
ll temp = (a + c) / 2LL;
if (b > temp) {
if (b < max(a, c)) ans += b - (a - b) - c;
else ans += (b - a) + (b - c);
}
else ans += temp - b;
cout << ans << endl;
}
#include<bits/stdc++.h>
using namespace std;
int main(){
int A;
cin>>A;
for(int i=0;i<A;i++){
long long B;
cin>>B;
if(B%4==2){
cout<<"Same"<<endl;
}
else if(B%4==0){
cout<<"Even"<<endl;
}
else{
cout<<"Odd"<<endl;
}
}

}
#include<bits/stdc++.h>
using namespace std;
int n,dp[3010][3010],sz[3010],c[3010][3010];
const int mod=998244353;
vector<int>g[3010];
int p[3010];
void dfs(int x,int f){
sz[x]=1;dp[x][1]=1;
for(int v:g[x])if(v!=f){
dfs(v,x);
for(int i=1;i<=sz[x]+sz[v];i++)p[i]=0;
for(int i=1;i<=sz[x];i++){
int s=0;
for(int j=1;j<=sz[v];j++){
(s+=dp[v][sz[v]+1-j])%=mod;
(p[i+j]+=1ll*dp[x][i]*c[i-1+j][j]%mod*s%mod*c[sz[x]-i+sz[v]-j][sz[v]-j]%mod)%=mod;
}
}
sz[x]+=sz[v];
for(int i=1;i<=sz[x];i++)dp[x][i]=p[i];
}
}
int main(){
cin>>n;c[0][0]=1;
for(int i=1;i<=n;i++){
c[i][0]=1;
for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
}
for(int i=1,u,v;i<n;i++){
scanf("%d%d",&u,&v);
g[u].push_back(v),g[v].push_back(u);
}
dfs(1,0);
int ans=0;
for(int i=1;i<=n;i++)(ans+=dp[1][i])%=mod;
return printf("%d",2*ans%mod),0;
}

// B - Cross-free Matching
// https://atcoder.jp/contests/arc126/tasks/arc126_b

#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using LL = __int128;
const int INF = INT_MAX;  // = 2^31 - 1 = 2147483647
// const ll INF = LLONG_MAX; // = 2^63 - 1 = 9223372036854775807
// const ll MOD = 1000000007;
// using mint = modint1000000007;
// const ll MOD = 998244353;
// using mint = modint998244353;
// const double EPS = 1e-10;

int N, M;
pair<int, int> p[200000];
int b[200000];
int dp[200001];

int main() {
cin.tie(0), cout.tie(0), ios_base::sync_with_stdio(0);
cout << fixed << setprecision(10);

cin >> N >> M;

for (int i=0; i<M; i++) {
int a, b;
cin >> a >> b;
p[i].first = a;
p[i].second = -b;
}

sort(p, p+M);

for (int i=0; i<M; i++) {
b[i] = -p[i].second;
}

fill(dp, dp+M+1, INF);
dp[0] = -1;

int ans = 0;
for (int i=0; i<M; i++) {
int k = lower_bound(dp, dp+M+1, b[i]) - dp;
dp[k] = b[i];
ans = max(ans, k);
}

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
ll MOD = 1000000007;

const double PI = 3.14159265358979323846;

#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)

// a^p
// 2^3 = 2 * 2^2
// 2^2 = 2 * (2^1)
// 2^1 = 2
ll modpow(ll a, ll p, ll mod) {
if (p == 0) return 1;

if (p % 2 == 0) {
ll half = modpow(a, p / 2, mod) % mod;
return half * half % mod;
} else {
return a * modpow(a, p - 1, mod) % mod;
}
}

// a/b
// https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
ll moddiv(ll a, ll b, ll mod) { return a * modpow(b, mod - 2, mod); }

// nCa を求める
ll modCombination(ll n, ll a, ll mod) {
if (n < 0 || n < a) return 0;
if (n - a < a) {
return modCombination(n, n - a, mod);
}

ll denominator = 1;  // 分母
ll numerator = 1;    // 分子

for (ll i = 0; i < a; i++) {
denominator *= a - i;
numerator *= n - i;
denominator %= mod;
numerator %= mod;
}

return numerator * modpow(denominator, mod - 2, mod) % mod;
}

class UnionFind {
private:
vector<ll> parents;

public:
UnionFind(ll n) : parents(n, -1) {}

bool issame(ll x, ll y) { return root(x) == root(y); }

bool merge(ll x, ll y) {
if (issame(x, y)) return false;

ll rx = root(x);
ll ry = root(y);
if (parents[rx] > parents[ry]) swap(rx, ry);
// サイズ情報を更新
parents[rx] += parents[ry];
// yの親を更新
parents[ry] = rx;

return true;
}

ll size(ll x) { return -parents[root(x)]; }

ll root(ll x) {
if (parents[x] < 0) return x;
// 根の親の値に木の(-)サイズの情報を入れる
return parents[x] = root(parents[x]);
}
};

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
vector<ll> enum_divisors(ll n) {
vector<ll> res;
// sqrt(n)まで試し割り
for (ll i = 1; i * i <= n; i++) {
if (n % i == 0) {
res.push_back(i);
// 重複しないならばiの相方であるn/iも約数
// e.g. n=25のときのi=5は重複
if (n / i != i) res.push_back(n / i);
}
}

sort(res.begin(), res.end());
return res;
}

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
map<ll, ll> prime_factors(ll n) {
map<ll, ll> res;
// sqrt(n)まで試し割り
for (ll a = 2; a * a <= n; a++) {
if (n % a != 0) continue;

// nで割れる限り割る
while (n % a == 0) {
res[a]++;
n /= a;
}
}
if (n != 1) res[n]++;

return res;
}

ll gcd(ll a, ll b) {
if (b == 0)
return a;
else
return gcd(b, a % b);
}

// cf. https://qiita.com/drken/items/56a6b68edef8fc605821
class AccumSum2D {
private:
vector<vector<ll>> sum;
ll H;
ll W;

public:
AccumSum2D(vector<vector<ll>> &A) {
H = (ll)A.size();
W = (ll)A[0].size();
sum.resize(H + 1, vector<ll>(W + 1));

for (ll i = 0; i < H; i++) {
for (ll j = 0; j < W; j++) {
sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + A[i][j];
}
}
}

// クエリ [x1, x2) × [y1, y2) の長方形区域の和
ll Sum(ll x1, ll x2, ll y1, ll y2) {
return sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];
}
};

// cf. https://tsutaj.hatenablog.com/entry/2017/03/30/224339
template <class S, S (*op)(S, S), S (*e)()>
class LazySegmentTree {
private:
ll n;
vector<S> node;
vector<S> lazy;

public:
LazySegmentTree(const vector<S> &A) {
ll size = (ll)A.size();
n = 1;
while (n < size) {
n *= 2;
}
node.resize(2 * n - 1);
lazy.resize(2 * n - 1);

for (ll i = 0; i < size; i++) {
node[i + n - 1] = A[i];
}

for (ll i = n - 2; i >= 0; i--) {
node[i] = op(node[2 * i + 1], node[2 * i + 2]);
}
}

// [a,b)
S query(ll a, ll b) { return query(a, b, 0, 0, n); }

// [a,b)
void update(ll a, ll b, S x) { update(a, b, x, 0, 0, n); }

private:
void eval(ll k, ll l, ll r) {
if (lazy[k] != e()) {
if (r - l > 1) {
lazy[2 * k + 1] = op(lazy[2 * k + 1], lazy[k]);
lazy[2 * k + 2] = op(lazy[2 * k + 2], lazy[k]);
}

node[k] = op(node[k], lazy[k]);
lazy[k] = e();
}
}

S query(ll a, ll b, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return e();
if (a <= l && r <= b) return node[k];

ll m1 = query(a, b, 2 * k + 1, l, (l + r) / 2);
ll m2 = query(a, b, 2 * k + 2, (l + r) / 2, r);
return op(m1, m2);
}

void update(ll a, ll b, S x, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return;
if (a <= l && r <= b) {
lazy[k] = op(lazy[k], x);
eval(k, l, r);
return;
}

update(a, b, x, 2 * k + 1, l, (l + r) / 2);
update(a, b, x, 2 * k + 2, (l + r) / 2, r);

node[k] = op(node[2 * k + 1], node[2 * k + 2]);
}
};

// p/q
struct fraction {
ll p, q;
fraction(ll _p = 0, ll _q = 1) : p(_p), q(_q) {
if (q == 0) {
p = 1;
return;
}

ll g = gcd(p, q);
p /= g;
q /= g;
}

bool operator<(const fraction &other) const {
return p * other.q < q * other.p;
}

bool operator<=(const fraction &other) const {
return p * other.q <= q * other.p;
}

bool operator==(const fraction &other) const {
return p == other.p && q == other.q;
}
};

// 多次元 vector 生成
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

int main() {
cin.tie(nullptr);
ios_base::sync_with_stdio(false);
cout << fixed << setprecision(15);

ll N;
cin >> N;
vector<ll> X(N);
rep(i, N) cin >> X[i];

vector<bool> is_prime(51, true);
is_prime[0] = false;
is_prime[1] = false;

vector<ll> primes;
for (ll i = 2; i <= 50; i++) {
if (!is_prime[i]) continue;
primes.push_back(i);
for (ll j = 2 * i; j <= 50; j += i) {
is_prime[j] = false;
}
}

ll ans = 1e18;
rep(bits, 1LL << (ll)primes.size()) {
if (bits == 0) continue;
ll v = 1;
rep(i, (ll)primes.size()) {
if ((bits >> i) & 1) {
v *= primes[i];
}
}

bool ok = true;
rep(i, N) {
if (gcd(v, X[i]) == 1) {
ok = false;
break;
}
}

if (ok) {
ans = min(ans, v);
}
}
cout << ans << endl;

return 0;
}

#include<bits/stdc++.h>

using namespace std;
using ll = int64_t;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>

// Use ordered_set s to define a set and use insert, erase, upper_bound, lower_bound, find, end as usual.
// Use s.order_of_key(x) to find how many elements in the set are less than the current element to be inserted.
// Use s.find_by_order(x) to find element in set at xth index(when arranged linearly).#include<bits/stdc++.h>

class Solution{
public:
static bool sorter(pair<ll,ll>& a, pair<ll,ll>& b){
if(a.first == b.first){
return a.second > b.second;
}
else{
return a.first < b.first;
}
}
void solve(){
ll n,m;
cin>>n>>m;
vector<pair<ll,ll>> v(m);
for(int i = 0;i < m;i++){
cin>>v[i].first>>v[i].second;
}
sort(v.begin(),v.end(),sorter);
vector<ll> ans;
vector<ll> vp;
for(pair<ll,ll> p:v){
vp.push_back(p.second);
}
for(ll p:vp){
if(ans.empty()){
ans.push_back(p);
}
else{
if(ans.back() < p){
ans.push_back(p);
}
else{
auto it = lower_bound(ans.begin(),ans.end(),p);
ll index = it-ans.begin();
ans[index] = p;
}
}
}
cout<<ans.size()<<"\n";
}
};

int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

Solution* a = new Solution();
a->solve();

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i, k, n) for(int i = k; i < n; i++)
#define MAX_N 110000
typedef long long ll;
typedef pair<ll, ll> P;
const ll INF = 100000000000;
using Graph = vector<vector<ll>>;
using Field = vector<vector<char>>;

int main(void) {
ll h, w, C, q;
cin >> h >> w >> C >> q;

vector<int> t(q+1);
map<ll, P> m_h, m_w;
rep(i, 1, q+1) {
ll n, c;
cin >> t[i] >> n >> c;

if(t[i] == 1) {
m_w[i] = {c, n};
} else {
m_h[i] = {c, n};
}
}

map<ll, bool> c_h, c_w;
map<ll, ll> ans;
int cnt1 = 0, cnt2 = 0;
for(int i = q; i >= 1; i--) {
if(t[i] == 1) {
if(!c_w[m_w[i].second]) {
cnt1++;
ans[m_w[i].first] += w-cnt2;
}
c_w[m_w[i].second] = true;
} else {
if(!c_h[m_h[i].second]) {
cnt2++;
ans[m_h[i].first] += h-cnt1;
}
c_h[m_h[i].second] = true;
}
}

rep(i, 1, C+1) {
if(i > 1) cout << ' ';
cout << ans[i];
}
cout << endl;

return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
ll MOD = 1000000007;

const double PI = 3.14159265358979323846;

#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)

// a^p
// 2^3 = 2 * 2^2
// 2^2 = 2 * (2^1)
// 2^1 = 2
ll modpow(ll a, ll p, ll mod) {
if (p == 0) return 1;

if (p % 2 == 0) {
ll half = modpow(a, p / 2, mod) % mod;
return half * half % mod;
} else {
return a * modpow(a, p - 1, mod) % mod;
}
}

// a/b
// https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a
ll moddiv(ll a, ll b, ll mod) { return a * modpow(b, mod - 2, mod); }

// nCa を求める
ll modCombination(ll n, ll a, ll mod) {
if (n < 0 || n < a) return 0;
if (n - a < a) {
return modCombination(n, n - a, mod);
}

ll denominator = 1;  // 分母
ll numerator = 1;    // 分子

for (ll i = 0; i < a; i++) {
denominator *= a - i;
numerator *= n - i;
denominator %= mod;
numerator %= mod;
}

return numerator * modpow(denominator, mod - 2, mod) % mod;
}

class UnionFind {
private:
vector<ll> parents;

public:
UnionFind(ll n) : parents(n, -1) {}

bool issame(ll x, ll y) { return root(x) == root(y); }

bool merge(ll x, ll y) {
if (issame(x, y)) return false;

ll rx = root(x);
ll ry = root(y);
if (parents[rx] > parents[ry]) swap(rx, ry);
// サイズ情報を更新
parents[rx] += parents[ry];
// yの親を更新
parents[ry] = rx;

return true;
}

ll size(ll x) { return -parents[root(x)]; }

ll root(ll x) {
if (parents[x] < 0) return x;
// 根の親の値に木の(-)サイズの情報を入れる
return parents[x] = root(parents[x]);
}
};

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
vector<ll> enum_divisors(ll n) {
vector<ll> res;
// sqrt(n)まで試し割り
for (ll i = 1; i * i <= n; i++) {
if (n % i == 0) {
res.push_back(i);
// 重複しないならばiの相方であるn/iも約数
// e.g. n=25のときのi=5は重複
if (n / i != i) res.push_back(n / i);
}
}

sort(res.begin(), res.end());
return res;
}

// cf. https://qiita.com/drken/items/a14e9af0ca2d857dad23
map<ll, ll> prime_factors(ll n) {
map<ll, ll> res;
// sqrt(n)まで試し割り
for (ll a = 2; a * a <= n; a++) {
if (n % a != 0) continue;

// nで割れる限り割る
while (n % a == 0) {
res[a]++;
n /= a;
}
}
if (n != 1) res[n]++;

return res;
}

ll gcd(ll a, ll b) {
if (b == 0)
return a;
else
return gcd(b, a % b);
}

// cf. https://qiita.com/drken/items/56a6b68edef8fc605821
class AccumSum2D {
private:
vector<vector<ll>> sum;
ll H;
ll W;

public:
AccumSum2D(vector<vector<ll>> &A) {
H = (ll)A.size();
W = (ll)A[0].size();
sum.resize(H + 1, vector<ll>(W + 1));

for (ll i = 0; i < H; i++) {
for (ll j = 0; j < W; j++) {
sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + A[i][j];
}
}
}

// クエリ [x1, x2) × [y1, y2) の長方形区域の和
ll Sum(ll x1, ll x2, ll y1, ll y2) {
return sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];
}
};

// cf. https://tsutaj.hatenablog.com/entry/2017/03/30/224339
template <class S, S (*op)(S, S), S (*e)()>
class LazySegmentTree {
private:
ll n;
vector<S> node;
vector<S> lazy;

public:
LazySegmentTree(const vector<S> &A) {
ll size = (ll)A.size();
n = 1;
while (n < size) {
n *= 2;
}
node.resize(2 * n - 1);
lazy.resize(2 * n - 1);

for (ll i = 0; i < size; i++) {
node[i + n - 1] = A[i];
}

for (ll i = n - 2; i >= 0; i--) {
node[i] = op(node[2 * i + 1], node[2 * i + 2]);
}
}

// [a,b)
S query(ll a, ll b) { return query(a, b, 0, 0, n); }

// [a,b)
void update(ll a, ll b, S x) { update(a, b, x, 0, 0, n); }

private:
void eval(ll k, ll l, ll r) {
if (lazy[k] != e()) {
if (r - l > 1) {
lazy[2 * k + 1] = op(lazy[2 * k + 1], lazy[k]);
lazy[2 * k + 2] = op(lazy[2 * k + 2], lazy[k]);
}

node[k] = op(node[k], lazy[k]);
lazy[k] = e();
}
}

S query(ll a, ll b, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return e();
if (a <= l && r <= b) return node[k];

ll m1 = query(a, b, 2 * k + 1, l, (l + r) / 2);
ll m2 = query(a, b, 2 * k + 2, (l + r) / 2, r);
return op(m1, m2);
}

void update(ll a, ll b, S x, ll k, ll l, ll r) {
eval(k, l, r);
if (b <= l || r <= a) return;
if (a <= l && r <= b) {
lazy[k] = op(lazy[k], x);
eval(k, l, r);
return;
}

update(a, b, x, 2 * k + 1, l, (l + r) / 2);
update(a, b, x, 2 * k + 2, (l + r) / 2, r);

node[k] = op(node[2 * k + 1], node[2 * k + 2]);
}
};

// p/q
struct fraction {
ll p, q;
fraction(ll _p = 0, ll _q = 1) : p(_p), q(_q) {
if (q == 0) {
p = 1;
return;
}

ll g = gcd(p, q);
p /= g;
q /= g;
}

bool operator<(const fraction &other) const {
return p * other.q < q * other.p;
}

bool operator<=(const fraction &other) const {
return p * other.q <= q * other.p;
}

bool operator==(const fraction &other) const {
return p == other.p && q == other.q;
}
};

// 多次元 vector 生成
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}

int main() {
cin.tie(nullptr);
ios_base::sync_with_stdio(false);
cout << fixed << setprecision(15);

ll N;
cin >> N;
vector<ll> A(N);
rep(i, N) cin >> A[i];

sort(A.begin(), A.end());

ll mod = 998244353;
ll ans = 0;
rep(i, N) {
ans += A[i] * A[i];
ans %= mod;
}

ll v = 0;
for (ll i = N - 2; i >= 0; i--) {
v *= 2;
v %= mod;
v += A[i + 1];
v %= mod;

ans += A[i] * v;
ans %= mod;
}
cout << ans << endl;

return 0;
}

/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


map<LL, int> memo;

int f(LL n) {
if (n <= 10) return (n+2)/3;
if (11 <= n && n <= 13) return 1;
if (14 <= n && n <= 16) return 2;
if (memo.count(n)) return memo[n];
int ret = -1;
for (int k = 1; ret < 0 && k <= 5; ++k) {
for (int r = k; ret <= 0 && r <= 3*k; ++r) {
LL nn = n-r;
if (nn%10 == 0 && f(nn/10) <= k) ret = k;
}
}
memo[n] = ret;
return ret;
}


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

int t;
cin >> t;
rep(ti, t) {
LL n;
cin >> n;
cout << f(n) << endl;
}

cout << flush;
return 0;
}

#include <bits/stdc++.h>
#include <bitset>
#include <fstream>
using namespace std;
using ll = long long;
using P = pair<int, int>;
const int INF = 2147483647;
// 9,223,372,036,854,775,807
const ll INFL = 9223372036854775807;


int main()
{

ll n;
cin >> n;
ll lmax=-1;
ll rmin=INFL;
for(int i=0;i<n;i++){
ll rtmp,ltmp;
cin >> ltmp >> rtmp;
lmax = max(ltmp,lmax);
rmin = min(rmin,rtmp);
ll anstmp;
if((lmax+rmin)%2==0){
ll x = (lmax+rmin)/2;
anstmp = max(lmax-x,x-rmin);
}
else{
ll xtmp = (lmax+rmin)/2;
anstmp = (lmax-xtmp);
}
ll ans;
ans = max(anstmp,ll(0));
cout << ans << endl;
}
return 0;

}




// time-limit: 2000
// problem-url: https://atcoder.jp/contests/arc124/tasks/arc124_e

// For you created my inmost being; you knit me together in my mother's womb.
// I praise you because I am fearfully and wonderfully made,
// your works are wonderful, I know that full well.
// Psalms 139:13-14
#include <bits/stdc++.h> 
using namespace std;

template <class T>
inline bool mnto(T& a, T b) {return a > b ? a = b, 1 : 0;}
template <class T>
inline bool mxto(T& a, T b) {return a < b ? a = b, 1: 0;}
#define REP(i, s, e) for (int i = s; i < e; i++)
#define RREP(i, s, e) for (int i = s; i >= e; i--)
typedef long long ll;
typedef long double ld;
#define MP make_pair
#define FI first
#define SE second
typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
#define MT make_tuple
typedef tuple<int, int, int> iii;
#define ALL(_a) _a.begin(), _a.end()
#define pb push_back
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;

#ifdef DEBUG
#define debug(args...) printf(args)
#else
#define debug(args...)
#endif

#define INF 1000000005
#define LINF 1000000000000000005
#define MOD 998244353
#define MAXN 100005
#define inv6 166374059

int n;
ll a[MAXN];
ll dp[MAXN][2];
ll ans;

int main() {
scanf("%d", &n);
REP (i, 0, n) {
scanf("%lld", &a[i]);
}
REP (z, 0, 2) {
REP (zz, 0, 2) {
if (zz == 0) {
// color 0 urself
dp[0][0] = (a[0] * (a[0] + 1 - z * 2) / 2 % MOD) % MOD; // + 1 -> - 1
ll sl = a[0] * (a[0] + 1) / 2 % MOD;
ll sp = a[0] * (a[0] + 1) % MOD * (2 * a[0] + 1) % MOD * inv6 % MOD;
dp[0][1] = a[0] * sl % MOD - sp;
if (dp[0][1] < 0) {
dp[0][1] += MOD;
}
} else {
dp[0][0] = a[0] + 1 - z; // + 1 -> + 0
dp[0][1] = a[0] * (a[0] + 1) / 2 % MOD;
}
debug("%d: %lld %lld\n", 0, dp[0][0], dp[0][1]);
REP (i, 1, n) {
// dp[i][0] = red ball not transfered yet
dp[i][0] = dp[i - 1][1] * (a[i] + 1 - z) % MOD + // + 1 -> + 0
dp[i - 1][0] * (a[i] * (a[i] + 1 - z * 2) / 2 % MOD) % MOD; // + 1 -> - 1
if (dp[i][0] >= MOD) {
dp[i][0] -= MOD;
}
// dp[i][1] = red ball already transfered
ll sl = a[i] * (a[i] + 1) / 2 % MOD;
ll sp = a[i] * (a[i] + 1) % MOD * (2 * a[i] + 1) % MOD * inv6 % MOD;
ll d = a[i] * sl % MOD - sp;
if (d < 0) {
d += MOD;
}
dp[i][1] = dp[i - 1][1] * sl % MOD +
dp[i - 1][0] * d % MOD;
if (dp[i][1] >= MOD) {
dp[i][1] -= MOD;
}
debug("%d: %lld %lld\n", i, dp[i][0], dp[i][1]);
}
if (z == 0) {
ans += dp[n - 1][zz];
if (ans >= MOD) {
ans -= MOD;
}
} else {
ans -= dp[n - 1][zz];
if (ans < 0) {
ans += MOD;
}
}
}
}
printf("%lld\n", ans);
return 0;
}


