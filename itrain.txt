#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se scond
typedef long long ll;
using namepace std;

ll n, sum, heap[300005], x, y, ans = 1e18;

int main(){
cin >> n;
for(int i = 0; i < n; i++){
cin >> heap[i];
sum += heap[i];
}
y = sum;
for(int i = 0; i < n-1; i++){
x += heap[i];
y -= heap[i];
ans = min(abs(x-y), ans);
}
cout << ans << endl;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for (int i=x;i<y;i++)
#define per(i,x,y) for (int i=y-1;i>=x;i--)
#define f first
#define se second
#define pb push_back
#defie mp make_pair
#define sz(x) ((int)(x.size()))
#defne all(x) (x).begin(), (x).end()
using ll = long long;
using ld = long double;
using db = double;
using pie = pair<int,int>;
const int N = 110;
int h,w,n,a[N][N],c[N*N];
int main() {
scanf("%d%d%d",&h,&w,&n);	
rep(i,0,n) scanf("%d",&c[i]);
int top=0;
int i=0,j=0,rt=1;
while(top<n) {
if(c[top]==0) {
top++;
} else if(j==w) {
i++;
j=w-1;
assert(rt);
rt=0;
} else if(j<0) {
i++;
j=0;
assert(!rt);
rt=1;
} else {
if(rt) a[i][j++]=1+top;
else a[i][j--]=1+top;
c[top]--;
}
}
rep(x,0,h) {
rep(y,0,w) {
printf("%d ",a[x][y]);
}
printf("\n");
}
}

#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#deine rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
ou(arg);  // out 関数を使うように変更
std::cerr << '\n';
}

const int inf = 1001001001;
const ll INF = 1001001001001001001;

const double PI = acos(-1);

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

using mint = modint998244353;
const int MOD = 998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;

signed main(){
cout << fixed << setprecision(15);

int N;
cin >> N;
vector<int> v;
v.eb(0);
rep(i, N){
int A;
cin >> A;
v.eb(A);
}
v.eb(0);
int sum = 0;
rep(i, N+1) sum += abs(v[i+1] - v[i]);
rep(i, N){
cout << sum - abs(v[i+1] - v[i]) - abs(v[i+2] - v[i+1]) + abs(v[i+2] - v[i]) << endl;
}
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ri register int
#define ll long long
#define ui unsigned int
il ll read(){
bool f=true;ll x=0;
register char ch=getchar();
while(ch<'0'||ch>'9') {if(ch=='-') f=false;ch=getchar();}
while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
if() return x;
return ~(--x);
}
il int read(char *s){
int len=0;
register char ch=getchar();
while(ch==' '||ch=='\n') ch=getchar();
while(ch!=' '&&ch!='\n'&&ch!=EOF) s[++len]=ch,ch=getchar();
return len;
}
il void write(const ll &x){if(x>9) write(x/10);putchar(x%10+'0');}
il voi print(const ll &x) {x<0?putchar('-'),write(~(x-1)):write(x);putchar('\n');}
il ll max(const ll &a,const ll &b){return a>b?a:b;}
il ll min(const ll &a,const ll &b){return a<b?a:b;}
const int MAXN=5e3+7;
ll f[MAXN][MAXN],g[MAXN],siz[MAXN],res[MAXN];
vector<int> e[MAXN];
cont ll mod=1e9+7;
void dfs(int u,int fa){
f[u][siz[u]=1]=1;
for(ri i=0;i<e[u].size();++i){
int v=e[u][i];
if(v==fa) continue;
dfs(v,u);
for(ri j=0;j<=siz[u]+siz[v];++j) res[j]=0;
for(ri j=1;j<=siz[u];++j){
for(ri k=0;k<=siz[v];++k){
res[j+k]=(res[j+k]+f[u][j]*f[v][k])%mod;
}
}
siz[u]+=siz[v];
for(ri j=1;j<=siz[u];++j) f[u][j]=res[j];
}
for(ri i=1;i<=siz[u];++i) f[u][0]=(f[u][0]-f[u][i]*g[i]%mod+mod)%mod;
}
int n;
int main(){
n=read();
g[0]=1;
for(ri i=2;i<=n;i+=2) g[i]=g[i-2]*(i-1)%mod;
for(ri i=1;i<n;++i){
int u=read(),v=read();
e[u].push_back(v),e[v].push_back(u);
}
dfs(1,1);
print(mod-f[1][0]);
return 0;
}
#include<bits/stdc++.h>
using namespace std;

int num[55],n,avg;
long long S[2505];
long long ans=0,dp[2505][2505];

int main() {
scanf("%d %d", &n, &avg);
dp[0][0] = 1;
for(int i=1;i<=n;i++) {
scanf("%d", &num[i]);
for(int j=i;j>0;j--){
for(int k=num[i];k<=2500;k++) {
dp[j][k]+= dp[j-1][k-num[i]];
S[k] += dp[j-1][k-num[i]];
}
}
}
for(int i=avg;i<=2500;i+=avg){
ans += dp[i/avg][i];
}
printf("%lld\n", ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

struct UnionFind {
vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2

UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化
for(int i = 0; i < N; i++) par[i] = i;
}

int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}
if (par[x] == x) return x;
return par[x] = root(par[x]);
}

void unite(int x, int y) { // xとyの木を併合
int rx = root(x); //xの根をrx
int ry = root(y); //yの根をry
if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま
par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける
}

bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す
int rx = root(x);
int ry = root(y);
return rx == ry;
}
};

int main(){
int n;
cin>>n;
vector<pii> x(n),y(n);
rep(i,n){
cin>>x[i].first>>y[i].first;
x[i].second=i;
y[i].second=i;
}
sort(ALL(x)); sort(ALL(y));
struct edge{int u,v,cost;};
vector<edge> e;
rep(i,n-1){
e.push_back({x[i].second,x[i+1].second,x[i+1].first-x[i].first});
e.push_back({y[i].second,y[i+1].second,y[i+1].first-y[i].first});
}
sort(ALL(e),[](edge l,edge r){
return l.cost < r.cost;
});
UnionFind d(n);
ll ans=0;
for(auto [u,v,cost]:e){
if(!d.same(u,v)){
d.unite(u,v);
ans+=cost;
}
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
#define ll long long
#define ld long double
using namespace std;
int main()
{
ios_base::sync_with_stdio(false); cin.tie(NULL);
int n; cin>>n;
map<ll,ll>frq;
while(n--)
{
ll a; cin>>a;
frq[a]+=1;
}
ll sum=0;
for(auto i=frq.begin();i!=frq.end();i++)
{
ll a=i->first,  b=i->second;
if(b>a)
sum+=b-a;
else if(a>b)
sum+=b;
}
cout<<sum<<endl;
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,INF=0x3f3f3f3f;
const double pi=4*atan(1);
#define int long long
#define mod 100005
#define lowbit(a) ((a)&-(a))
#define IOS std::ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
int a[N]={0},b[N],c[N],d[N];
int n,m,t,x,y,k,len=1,cnt=0,maxx=0,ans=INF,g,num,minn;
signed main(){
cin>>n;
cnt=0;
num=0;
for(int i=1;i<=n;i++){
cin>>x;
if(x%4==0) num++;
if((x-2)%4==0) cnt++;
}
if(num*2+cnt+1>=n&&n%2) cout<<"Yes"<<endl;
else if(num*2+cnt>=n&&n%2==0) cout<<"Yes"<<endl;
else cout<<"No"<<endl;
return 0;
}
#include<bits/stdc++.h>

using namespace std;

#define debug(x) cout << '[' << #x << " is: " << x << "] " << endl;
#define imod(a , n) (a % n + n ) % n

#define ll long long
#define int ll
#define logar(x , y) log(x) / log(y)
#define __sum(n) n * (n + 1) / 2
#define __lcm(a , b) a / __gcd(a , b) * b
#define pii pair<int , int >
const int N = 3e5 + 1 ,  M = N * 4 , MX = 2e4 + 40;
const ll MOD = 1e9+ 7 , oo = 1e9 + 9 , OO = 1e18 ;//, mod = MOD ;
const double pi = acos(-1) , eps = 1e-17 ;

int di[] = {1 , -1 , 0 , 0};
int dj[] = {0 , 0 , -1 , 1};

//challenge : 97915 left





int32_t main()
{   //inF;
//inF;outF;
//    fastio;


int n ;
cin >> n ;


string ans = "Yes";
int x = 0 , y = 0 ;
int t = 0;

while(n--){
int a , b , ti;
cin >> ti >> a >> b ;

int dt = ti - t ;
int dxy = abs(x - a) + abs(y - b);

if(dt < dxy)ans = "No";
else {
dt -= dxy ;
if(dt % 2)ans = "No";
}
x = a , y = b;

t = ti ;

}

cout << ans ;

}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 998244353, LOG = 301;

struct vect {
int x, y;
vect(int x = 0, int y = 0) : x(x), y(y) {}
vect operator-(const vect& a) {
return vect(x - a.x, y - a.y);
}
int operator^(const vect& a) {
return x * a.y - y * a.x;
}
friend istream& operator>>(istream& in, vect& a) {
return in >> a.x >> a.y;
}
};

int bpow(int a, int b) {
if (!b) return 1ll;
if (b & 1) return a * bpow(a, b - 1) % mod;
int t = bpow(a, b / 2);
return t * t % mod;
}

int gcd(int a, int b) {
return (b ? gcd(b, a % b) : a);
}

vector <int> line(vect& a, vect& b) {
vect d = b - a;
int x = d.y, y = -d.x;
if (x < 0 or x == 0 and y < 0) x = -x, y = -y;
int z = -(x * a.x + y * a.y);
int g = gcd(abs(x), gcd(abs(y), abs(z)));
return { x / g, y / g, z / g };
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);

int n; cin >> n;
vector <vect> a(n);
for (auto& x : a) cin >> x;

int ans = n;
map <vector <int>, int> lns;
for (int i = 0; i < n; ++i) {
for (int j = i + 1; j < n; ++j) {
lns[line(a[i], a[j])] = {};
}
}
for (auto& x : lns) {
int cnt = 0;
for (auto& y : a) {
if (x.first[0] * y.x + x.first[1] * y.y + x.first[2] == 0)
cnt++;
}
ans += bpow(2, cnt) - cnt - 1;
ans = (ans % mod + mod) % mod;
}
cout << (bpow(2, n) - ans - 1 + mod) % mod << '\n';
return 0;
}

#ifdef __LOCAL
#define _GLIBCXX_DEBUG


#endif
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using P = pair<int,int>;
using PIL = pair<int,ll>;
using PLI = pair<ll,int>;
using PLL = pair<ll,ll>;
#define all(x) (x).begin(),(x).end()
#define unique_delete(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
using mint = modint1000000007;

template<class T> bool chmin(T &a, T b) {if(a>b){a=b;return 1;}return 0;}
template<class T> bool chmax(T &a, T b) {if(a<b){a=b;return 1;}return 0;}
template<class T> void show_vec(T v) {for (int i=0;i<v.size();i++) cout<<v[i]<<endl;}
template<class T> void show_pair(T p) {cout<<p.first<<" "<<p.second<<endl;}
template<class T> bool judge_digit(T bit,T i) {return (((bit&(1LL<<i))!=0)?1:0);}
#define REP(i,n) for(int i=0;i<int(n);i++)
#define ROUNDUP(a,b) (((a)+(b)-1)/(b))
#define YESNO(T) cout<<(T?"YES":"NO")<<endl
#define yesno(T) cout<<(T?"yes":"no")<<endl
#define YesNo(T) cout<<(T?"Yes":"No")<<endl

const int INFint = 1 << 29;
const ll INF = 1LL << 60;
const ll MOD = 998244353LL;
const double pi = 3.14159265358979;
const vector<int> h_idx4 = {-1, 0,0,1};
const vector<int> w_idx4 = { 0,-1,1,0};
const vector<int> h_idx8 = {-1,-1,-1, 0,0, 1,1,1};
const vector<int> w_idx8 = {-1, 0, 1,-1,1,-1,0,1};

//逆元計算
// mod. m での a の逆元 a^{-1} を計算する
long long modinv(long long a, long long m) {
long long b = m, u = 1, v = 0;
while (b) {
long long t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
u %= m;
if (u < 0) u += m;
return u;}
//逆元計算終わり



//ここからべきじょうけいさん
long long pow(long long x, long long n, ll MOD) {
long long ret = 1;
while (n > 0) {
if (n & 1) ret = ret * x % MOD;  // n の最下位bitが 1 ならば x^(2^i) をかける
x = x * x % MOD;
n >>= 1;  // n を1bit 左にずらす
}
return ret;
}
//べき乗けいさんおわり

//素因数分解
vector<pair<long long, long long> > prime_factorize(long long N) {
vector<pair<long long, long long> > res;
for (long long a = 2; a * a <= N; ++a) {
if (N % a != 0) continue;
long long ex = 0; // 指数

// 割れる限り割り続ける
while (N % a == 0) {
++ex;
N /= a;
}

// その結果を push
res.push_back({a, ex});
}

// 最後に残った数について
if (N != 1) res.push_back({N, 1});
return res;
}
//素因数分解終わり

//素数判定
// 1 以上 N 以下の整数が素数かどうかを返す
vector<bool> Eratosthenes(int N) {
// テーブル
vector<bool> isprime(N+1, true);

// 1 は予めふるい落としておく
isprime[1] = false;

// ふるい
for (int p = 2; p <= N; ++p) {
// すでに合成数であるものはスキップする
if (!isprime[p]) continue;

// p 以外の p の倍数から素数ラベルを剥奪
for (int q = p * 2; q <= N; q += p) {
isprime[q] = false;
}
}

// 1 以上 N 以下の整数が素数かどうか
return isprime;
}
//素数判定おわり

//ここから二項係数高速計算
const int MAX = 10000000;
long long fac[MAX], finv[MAX], inv[MAX];

// テーブルを作る前処理
void COMinit() {
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++){
fac[i] = fac[i - 1] * i % MOD;
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
finv[i] = finv[i - 1] * inv[i] % MOD;
}
}

// 二項係数計算
long long COM(int n, int k){
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
}
//二項係数終わり

//ここからめぐる式二分探索
// index が条件を満たすかどうか
bool isOK(ll index, ll key,vector<ll>&a) {
if (a[index] >= key) return true;
else return false;
}

// 汎用的な二分探索のテンプレ
ll bsearch(ll key,vector<ll>&a) {
ll left = -1; //「index = 0」が条件を満たすこともあるので、初期値は -1
ll right = (ll)a.size(); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()

/* どんな二分探索でもここの書き方を変えずにできる！ */
while (right - left > 1) {
ll mid = left + (right - left) / 2;

if (isOK(mid, key,a)) right = mid;
else left = mid;
}

/* left は条件を満たさない最大の値、right は条件を満たす最小の値になっている */
return left;
}
//二分探索終わり

//ここからグラフ
struct edge {
int to; ll cost;
edge() = default;
edge(int _to,ll _cost) : to(_to), cost(_cost) {}

// 不等号を定義
bool operator<(const edge &other) const {
return cost < other.cost;
}
bool operator>(const edge &other) const {
return cost > other.cost;
}
};

//こっちは辺をソートするときとかに使う。クラスカル法とか。
struct Edge {
int from; int to; ll cost;
Edge() = default;
Edge(int _from, int _to,ll _cost) : from(_from), to(_to), cost(_cost) {}

// 不等号を定義
bool operator<(const Edge &other) const {
return cost < other.cost;
}
bool operator>(const Edge &other) const {
return cost > other.cost;
}
};

struct DSU {
public:
DSU() : n(0) {}
DSU(int _n) : n(_n), parent_or_size(_n, -1) {}

int merge(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
int x = leader(a), y = leader(b);
if (x == y) return x;
if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
return x;
}

bool same(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
return leader(a) == leader(b);
}

int leader(int a) {
assert(0 <= a && a < n);
if (parent_or_size[a] < 0) return a;
return parent_or_size[a] = leader(parent_or_size[a]);
}

int size(int a) {
assert(0 <= a && a < n);
return -parent_or_size[leader(a)];
}

vector<vector<int>> groups() {
vector<int> leader_buf(n), group_size(n);
for (int i = 0; i < n; i++) {
leader_buf[i] = leader(i);
group_size[leader_buf[i]]++;
}
vector<vector<int>> result(n);
for (int i = 0; i < n; i++) {
result[i].reserve(group_size[i]);
}
for (int i = 0; i < n; i++) {
result[leader_buf[i]].push_back(i);
}
result.erase(
remove_if(result.begin(), result.end(),
[&](const vector<int>& v) { return v.empty(); }),
result.end());
return result;
}

private:
int n;
// root node: -1 * component size
// otherwise: parent
vector<int> parent_or_size;
};

struct Graph {
private:
vector<vector<edge>> G;
vector<int> indegree;
int n,m;

public:
inline const std::ector<edge> &operator[](int k) const { return G[k]; }
inline std::vector<edge> &operator[](int k) { return G[k]; }
int size() const { return G.size(); }
void resize(const int n) { G.resize(n); }

Graph() = default;
Graph(int _n) : n(_n), G(_n), indegree(_n) {}
Graph(int _n, int _m, bool weight, bool directed, int index) : n(_n), m(_m), G(_n), indegree(_n,0) { input(weight,directed,index); }

void input(bool weight, bool directed, int index){
int _from, _to; ll _cost = 1;
for (int i = 0; i < m; i++){
cin >> _from >> _to;
_from -= index; _to -= index;
if (weight) cin >> _cost;
indegree[_to]++;

G[_from].push_back(edge(_to,_cost));
if (!directed) G[_to].push_back(edge(_from,_cost));
}
}

// 重みなしグラフの始点からの最短距離を求める
// 到達不可能点 : -1
// O(N + M)
vector<int> BFS(int start){
vector<int> dist(n,-1);
dist[start] = 0;

queue<int> que;
que.push(start);

while (!que.empty()){
int now = que.front();
que.pop();

for (auto &e : G[now]){
if (dist[e.to] != -1) continue;

dist[e.to] = dist[now] + 1;
que.push(e.to);
}
}

return dist;
}

// 辺長が 0or1 のグラフをに対し単一始点最短距離を求める (01BFS)
// 到達不可能点 : INF
// O(N + M)
vector<ll> Zero_One_BFS(int start){
vector<ll> dist(n,INF);
dist[start] = 0LL;

deque<int> que;
que.push_back(start);

while (!que.empty()){
auto now = que.front();
que.pop_front();

for (auto &e : G[now]){
ll next_d = dist[now] + e.cost;
if (chmin(dist[e.to], next_d)){
if (e.cost == 0) que.push_front(e.to);
else que.push_back(e.to);
}
}
}

return dist;
}

// 重み付きグラフの単一始点最短距離を求める
// 負辺を持たない
// 到達不可能点 : INF
// O((N + M)logN)
vector<ll> Dijkstra(int start){
vector<ll> dist(n,INF);
dist[start] = 0LL;

priority_queue<edge, vector<edge>, greater<edge>> pq;
pq.push(edge(start,0LL));

while (!pq.empty()){
auto p = pq.top();
pq.pop();

int now = p.to;
if (dist[now] < p.cost) continue;

for (auto &e : G[now]){
ll next_d = dist[now] + e.cost;
if (chmin(dist[e.to],next_d)){
pq.push(edge(e.to, dist[e.to]));
}
}
}

return dist;
}

// 負辺をもつ重み付きグラフの単一始点最短距離を求める
// 到達不可能点 : INF
// 負閉路 : -INF
// O(NM)
vector<ll> Bellman_Ford(int start){
vector<ll> dist(n, INF);
dist[start] = 0LL;
for (int loop = 0; loop < n - 1; loop++){
for (int v = 0; v < n; v++){
if (dist[v] == INF) continue;

for (auto &e : G[v]){
ll next_d = dist[v] + e.cost;
chmin(dist[e.to],next_d);
}
}
}

queue<int> que;
vector<bool> chk(n,false);

for (int v = 0; v < n; v++){
if (dist[v] == INF) continue;

for (auto &e : G[v]){
ll next_d = dist[v] + e.cost;
if (dist[e.to] > next_d && !chk[e.to]){
que.push(e.to);
chk[e.to] = true;
}
}
}

while (!que.empty()){
int now = que.front();
que.pop();

for (auto &e : G[now]){
if (!chk[e.to]){
chk[e.to] = true;
que.push(e.to);
}
}
}

for (int i = 0; i < n; i++) if (chk[i]) dist[i] = -INF;

return dist;
}

// 重み付きグラフの全頂点対間最短距離を求める
// 到達不可能点 : INF 
// O(N^3)
vector<vector<ll>> Warshall_Floyd(){
vector<vector<ll>> dist(n, vector<ll>(n,INF));
for (int i = 0; i < n; i++) dist[i][i] = 0LL;
for (int i = 0; i < n; i++){
for (auto &e : G[i]) chmin(dist[i][e.to], e.cost);
}

for (int k = 0; k < n; k++){
for (int i = 0; i < n; i++){
if (dist[i][k] == INF) continue;
for (int j = 0; j < n; j++){
if (dist[k][j] == INF) continue;
chmin(dist[i][j],dist[i][k] + dist[k][j]);
}
}
}

return dist;
}

// 最小全域木の辺の重みの総和
// Gが非連結 : -1
// O(MlogM)
ll Kruskal(){
vector<Edge> E;
for (int i = 0; i < n; i++){
for (auto &e : G[i]){
E.push_back(Edge(i,e.to,e.cost));
}
}
sort(E.begin(), E.end());

DSU uf(n);
ll res = 0;
sort(E.begin(), E.end());
for (auto &e : E){
if (!uf.same(e.from,e.to)){
uf.merge(e.from,e.to);
res += e.cost;
}
}

if (uf.size(0) != n) return -1;

return res;
}

// DAGをトポロジカルソートする
// O(V+E)
vector<int> Topological_sort(){
vector<int> res;
queue<int> que;

for (int i = 0; i < n; i++){
if (indegree[i] == 0){
que.push(i);
}
}

while (!que.empty()){
int x = que.front();
que.pop();

for (auto e : G[x]){
indegree[e.to]--;
if (indegree[e.to] == 0) que.push(e.to);
}

res.push_back(x);
}

return res;
}

//巡回セールスマン問題
//start一筆書きしてstartに戻る最短経路を返す。
//不可能なら-1を返す。
//O(2^N*N^2)
ll TSP(int start){
int SIZE = G.size();
vector<vector<ll>>DP(G.size(),vector<ll>(1<<G.size()));
for(int i=0;i<SIZE;i++){for(int j=0;j<(1<<SIZE);j++){DP[i][j]=INF;}}
DP[start][1<<start]=0;
//DPテーブルの準備完了。ここからfor文で回す。
for(int i=1;i<SIZE;i++){
for(int bit=0;bit<(1<<SIZE);bit++){
if(__builtin_popcount(bit)==i){
for(int j=0;j<SIZE;j++){
for(int k=0;k<G[j].size();k++){
if((bit|(1<<G[j][k].to))!=bit){
DP[G[j][k].to][bit|(1<<G[j][k].to)]=min(DP[G[j][k].to][bit|(1<<G[j][k].to)],DP[j][bit]+G[j][k].cost);
}
}
}
}
}
}
//DPテーブル作成完了。スタートに帰らない問題ならならDPテーブルの(1<<SIZE)-1を見ればok
vector<ll>CB(SIZE);
for(int i=0;i<SIZE;i++){CB[i]=INF;}
for(int i=0;i<SIZE;i++){
for(int j=0;j<G[i].size();j++){
CB[G[i][j].to]=min(CB[G[i][j].to],DP[i][(1<<SIZE)-1]+G[i][j].cost);
}
}
if(CB[start]<INF){return CB[start];}
else{return -1;}
}

};

ll x;

ll func(ll middle){
if(middle%2){
return (middle/2)*11+6;
}
else{return (middle/2)*11;}

}



int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(15);//小数の桁数指定
//COMinit();//二項係数使うときにコメントアウトを外すこと。

cin>>x;
ll left=0;
ll right=1000000000000000;
ll middle=(left+right)/2;
REP(i,2000){
if(func(middle)>=x){
right=middle;
middle=(left+right)/2;
}
else{
left=middle;
middle=(left+right)/2;
}
}
cout<<middle+1<<endl;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define endl                        '\n'
#define debug(e)                    cerr << #e << ": " <<  e << endl;
#define fast_io;                 ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
const ll MOD=1e9+7;//998244353//1e9+9//1111211111;
//ll tavmd(ll a,ll b){if(b==0){return 1;}if(b%2==0){ll x=tavmd(a,b/2);return(x*x)%MOD;}else{return(a%MOD*tavmd(a,b-1)%MOD)%MOD;}}
const ll MAXN=1e5+10;
const ll INF=1e18;
const ll LOG=30;
ll dp[3][MAXN],a[MAXN],b[MAXN];
int main(){
fast_io;
ll n;
cin>>n;
b[0]=1;
for(int i=1;i<=n;i++){
cin>>a[i];
if(i!=n){
char ch;
cin>>ch;
if(ch=='-'){
b[i]=-1;
}
else{
b[i]=1;
}
}
}
for(int i=0;i<=n;i++){
for(int j=0;j<=2;j++){
dp[j][i]=-INF;
}
}
dp[0][0]=0;
for(int i=1;i<=n;i++){
for(int j=0;j<=2;j++){
if(dp[j][i-1]==-INF)
continue;
dp[j][i]=max(dp[j][i],dp[j][i-1]+((j==1)?-1:1)*b[i-1]*a[i]);
if(b[i-1]==-1&&j!=2)
dp[j+1][i]=max(dp[j+1][i],dp[j][i-1]+((j==0)?-1:1)*a[i]);
if(j!=0)
dp[j-1][i]=max(dp[j-1][i],dp[j][i-1]+((j==1)?-1:1)*b[i-1]*a[i]);
}
}
cout<<dp[0][n];
return 0;
}

#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 404;

int Hash(int *a){
int ans = 0;
for(int i = 0;i<4;i++){
ans |= (a[i]<<(10*i));
}
return ans;
}

int a[N][4];
map<int,int> cnt;

void update(int hd,int t){
for(int i = 0;i<4;i++,hd = ((hd&1023ll)<<30ll)|(hd>>10ll) ) cnt[hd]+=t;
}

signed main() {
#ifdef LOCAL
freopen("input.txt","r",stdin);
freopen("output.txt","w",stdout);
#endif
ios::sync_with_stdio(0);
cin.tie(0);
int n;
cin>>n;
for(int i = 0;i<n;i++){
for(int j = 0;j<4;j++) cin>>a[i][j];
update(Hash(a[i]),1);
}
int ans = 0;
for(int i=0;i<n;i++){
update(Hash(a[i]),-1);
for(int j = i+1;j<n;j++){
update(Hash(a[j]),-1);
for(int k = 0;k<4;k++){
int ans_t = 1;
int v[4];
for(int z = 0;z<4;z++){
int tmp[] = {a[i][(z+1)%4],a[i][z],a[j][(4+k-z)%4],a[j][(k-z+7)%4]};
v[z] = Hash(tmp);
if(cnt[v[z]]<1){
goto out;
}
}
for(int z = 0;z<4;z++){
ans_t*=cnt[v[z]];
update(v[z],-1);
}
for(int z = 0;z<4;z++){
update(v[z],1);
}
ans+=ans_t;
out:;
}
update(Hash(a[j]),1);
}
}
cout<<ans<<endl;
}
/**
*    author:  shu8Cream
*    created: 24.01.2022 22:57:32
**/

#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for (int i=0; i<(n); i++)
#define rrep(i,n) for (int i=(n-1); i>=0; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) int((x).size())
using ll = long long;
using P = pair<ll,ll>;
using vi = vector<ll>;
using vvi = vector<vi>;
const ll INF = 8e18;

template<class T> inline bool chmax(T& a, T b) {
if (a < b) { a = b; return true; }
return false;
}
template<class T> inline bool chmin(T& a, T b) {
if (a > b) { a = b; return true; }
return false;
}

template <class T> string to_string(T s);
template <class S, class T> string to_string(pair<S, T> p);
string to_string(char c) { return string(1, c); }
string to_string(string s) { return s; }
string to_string(const char s[]) { return string(s); }

template <class T>
string to_string(T v) {
if (v.empty()) return "{}";
string ret = "{";
for (auto x : v) ret += to_string(x) + ",";
ret.back() = '}';
return ret;
}
template <class S, class T>
string to_string(pair<S, T> p) {
return "{" + to_string(p.first) + ":" + to_string(p.second) + "}";
}

void debug_out() { cout << endl; }

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
cout << to_string(H) << " ";
debug_out(T...);
}

#ifdef _DEBUG
#define debug(...) debug_out(__VA_ARGS__)
#else
#define debug(...)
#endif

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
int n; cin >> n;
vi a(n); rep(i,n) cin >> a[i];
map<ll,ll> odd,even;
rep(i,n){
if(i%2) odd[a[i]]++;
else even[a[i]]++;
}
vector<P> ODD,EVEN;
for(auto[k,v]:odd) ODD.push_back({v,k});
for(auto[k,v]:even) EVEN.push_back({v,k});
sort(rall(ODD));
sort(rall(EVEN));
if(ODD[0].second!=EVEN[0].second){
cout << n-ODD[0].first-EVEN[0].first << endl;
}else{
ll ans = INF;
if(sz(ODD)>1) chmin(ans,n-ODD[1].first-EVEN[0].first);
if(sz(EVEN)>1) chmin(ans,n-ODD[0].first-EVEN[1].first);
if(ans==INF) ans = n/2;
cout << ans << endl;
}
}
#include <bits/stdc++.h>
using namespace std; 

typedef long long ll; 
typedef pair <int, int> ii; 

const ll LINF = (ll) 1e18; 
const int INF = (int) 1e9;

int main() {
ios::sync_with_stdio(0); 
cin.tie(0); 
string s; int k; 
cin >> s >> k; 

int n = s.size(); 
set<string> substring; 

for (int i = 0; i < n; i++) {
string cur = ""; 
int cnt = 0; 
for (int j = i; j < n; j++) {
cur += s[j]; 
substring.insert(cur); 
cnt++; 
if (cnt == k) break; 
}
}

vector<string> res(substring.begin(), substring.end()); 
cout << res[k - 1] << '\n'; 
}
#include <bits/stdc++.h>
#include <random>
#include <array>
#ifdef _MSC_VER
#include <ppl.h>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#else
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

/** compro_io **/

/* tuple */
// out
namespace aux {
template<typename T, unsigned N, unsigned L>
struct tp {
static void output(std::ostream& os, const T& v) {
os << std::get<N>(v) << ", ";
tp<T, N + 1, L>::output(os, v);
}
};
template<typename T, unsigned N>
struct tp<T, N, N> {
static void output(std::ostream& os, const T& v) { os << std::get<N>(v); }
};
}
template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {
os << '[';
aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);
return os << ']';
}

template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x);

/* pair */
// out
template<class S, class T>
std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {
return os << "[" << p.first << ", " << p.second << "]";
}
// in
template<class S, class T>
std::istream& operator>>(std::istream& is, const std::pair<S, T>& p) {
return is >> p.first >> p.second;
}

/* container */
// out
template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) {
bool f = true;
os << "[";
for (auto& y : x) {
os << (f ? "" : ", ") << y;
f = false;
}
return os << "]";
}
// in
template <
class T,
class = decltype(std::begin(std::declval<T&>())),
class = typename std::enable_if<!std::is_same<T, std::string>::value>::type
>
std::istream& operator>>(std::istream& is, T& a) {
for (auto& x : a) is >> x;
return is;
}

/* struct */
template<typename T>
auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) {
out << t.stringify();
return out;
}

/* setup */
struct IOSetup {
IOSetup(bool f) {
if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); }
std::cout << std::fixed << std::setprecision(15);
}
} iosetup(true);

/** string formatter **/
template<typename... Ts>
std::string format(const std::string& f, Ts... t) {
size_t l = std::snprintf(nullptr, 0, f.c_str(), t...);
std::vector<char> b(l + 1);
std::snprintf(&b[0], l + 1, f.c_str(), t...);
return std::string(&b[0], &b[0] + l);
}

template<typename T>
std::string stringify(const T& x) {
std::ostringstream oss;
oss << x;
return oss.str();
}

/* dump */
#define ENABLE_DUMP
#ifdef ENABLE_DUMP
#define DUMPOUT std::cerr
std::ostringstream DUMPBUF;
#define dump(...) do{DUMPBUF<<"  ";DUMPBUF<<#__VA_ARGS__<<" :[DUMP - "<<__LINE__<<":"<<__FUNCTION__<<"]"<<std::endl;DUMPBUF<<"    ";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str("");DUMPBUF.clear();}while(0);
void dump_func() { DUMPBUF << std::endl; }
template <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << " "; } else { DUMPBUF << ", "; } dump_func(std::move(tail)...); }
#else
#define dump(...) void(0);
#endif

/* timer */
class Timer {
double t = 0, paused = 0, tmp;
public:
Timer() { reset(); }
static double time() {
#ifdef _MSC_VER
return __rdtsc() / 3.0e9;
#else
unsigned long long a, d;
__asm__ volatile("rdtsc"
: "=a"(a), "=d"(d));
return (d << 32 | a) / 3.0e9;
#endif
}
void reset() { t = time(); }
void pause() { tmp = time(); }
void restart() { paused += time() - tmp; }
double elapsed_ms() { return (time() - t - paused) * 1000.0; }
} timer;

/* rand */
struct Xorshift {
uint64_t x = 88172645463325252LL;
void set_seed(unsigned seed, int rep = 100) { x = uint64_t((seed + 1) * 10007); for (int i = 0; i < rep; i++) next_int(); }
unsigned next_int() { x = x ^ (x << 7); return x = x ^ (x >> 9); }
unsigned next_int(unsigned mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % mod; }
unsigned next_int(unsigned l, unsigned r) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % (r - l + 1) + l; } // inclusive
double next_double() { return double(next_int()) / UINT_MAX; }
} rnd;

/* shuffle */
template<typename T>
void shuffle_vector(std::vector<T>& v, Xorshift& rnd) {
int n = v.size();
for (int i = n - 1; i >= 1; i--) {
int r = rnd.next_int(i);
std::swap(v[i], v[r]);
}
}

/* split */
std::vector<std::string> split(std::string str, const std::string& delim) {
for (char& c : str) if (delim.find(c) != std::string::npos) c = ' ';
std::istringstream iss(str);
std::vector<std::string> parsed;
std::string buf;
while (iss >> buf) parsed.push_back(buf);
return parsed;
}

template<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) {
std::fill((T*)array, (T*)(array + N), val);
}
template<typename T, typename ...Args> auto make_vector(T x, int arg, Args ...args) { if constexpr (sizeof...(args) == 0)return std::vector<T>(arg, x); else return std::vector(arg, make_vector<T>(x, args...)); }
template<typename T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }
template<typename T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }



using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;



int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string S;
cin >> S;
int N = S.size();

if (N == 2) {
if (S[0] == S[1]) {
cout << "1 2" << endl;
}
else {
cout << "-1 -1" << endl;
}
return 0;
}

for (int i = 2; i < N; i++) {
if (S[i - 2] == S[i - 1] || S[i - 2] == S[i] || S[i - 1] == S[i]) {
cout << i - 1 << ' ' << i + 1 << endl;
return 0;
}
}

cout << "-1 -1" << endl;

return 0;
}
#include <bits/stdc++.h>
#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <math.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
using ll = long long;
const ll INF = 1e18;
#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)
const double PI =acos(-1);

int main(){
ll N,K;cin>>N>>K;
vector<ll> A(N);
rep(i,N){
cin>>A[i];
}
cout<<((N-1)+(K-1-1))/(K-1)<<endl;
}
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=1000010,mod=1e9+7;
int n,a[N],c[N],p[N],l[N],r[N],vis[N];
long long ans;
set<int>s;
void add(int x){
while(x<=n){
c[x]++;
x+=x&-x;
}
}
int que(int x){
int ss=0;
while(x){
ss+=c[x];
x-=x&-x;
}
return ss;
}
void ex(){puts("-1");exit(0);}
signed main(){
scanf("%d",&n);l[n+1]=1e9;
for(int i=1;i<=n;i++){
scanf("%d%d",&l[i],&r[i]);s.insert(i);
}
for(int i=1;i<=n;i++)if(l[i]>l[i+1]||r[i]<r[i-1])ex();
for(int i=1;i<=n;i++)if(l[i]<l[i+1])p[i]=l[i],s.erase(p[i]);
for(int i=1;i<=n;i++)if(r[i]>r[i-1])p[i]=r[i],s.erase(p[i]);
for(int i=1;i<=n;i++)if(!p[i])p[i]=*s.begin(),s.erase(p[i]);
int mx=0,mi=1e9;
for(int i=1;i<=n;i++){
vis[p[i]]++;
if(vis[p[i]]>1)ex();
}
for(int i=1;i<=n;i++){
mx=max(mx,p[i]);
if(mx!=r[i])ex();
}
for(int i=n;i>=1;i--){
mi=min(mi,p[i]);
if(mi!=l[i])ex();
}
add(p[1]);
for(int i=2;i<=n;i++){
ans+=i-1-que(p[i]-1);
add(p[i]);
}
cout<<ans;
}

#include<iostream>
#include<stdio.h>
#include<queue>
#define int long long
using namespace std;
inline int read(){
int x=0,f=1;
char ch=getchar();
while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
return x*f;
}
struct node{
int id,x;
node(){}
node(int a,int b){
id=a,x=b;
}
};
deque <node> q;
int n,vis[100005];
signed main(){
n=read();
q.push_front(node(1,1));
while(!q.empty()){
node u=q.front();
q.pop_front();
if(vis[u.id]) continue;
vis[u.id]=1;
if(u.id==0){
printf("%lld",u.x);
return 0;
}
q.push_front(node(u.id*10%n,u.x));
q.push_back(node((u.id+1)%n,u.x+1));
}
return 0;
}
#include <iostream>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
#include <cstring>

using namespace std;
//#define int long long
using ll = long long;
int const INF = 0x3f3f3f3f;
int const MOD = 1e9 + 7;

signed main() {
ios::sync_with_stdio(false);
string s;
cin >> s;
int siz = (int) s.size();
if (s[0] == s[siz - 1]) {
if (!((int) s.size() & 1)) cout << "First\n";
else cout << "Second\n";
} else {
if ((int) s.size() & 1) cout << "First\n";
else cout << "Second\n";
}
return 0;
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back
#define em emplace
#define all(v) v.begin(), v.end()
#define reset(x) memset(x, 0, sizeof(x))

using namespace std;
typedef long long ll;
typedef long double ld;
typedef complex <double> cpx;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;

const int MAX = 1010;
const int INF = 1e9;
const ll LINF = 1e18;

struct circle {
ll x, y, r;
circle() {}
circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
};

ld dist(circle a, circle b) {
return max(0.0, sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) - a.r - b.r);
}

int main() {
ios::sync_with_stdio(false); cin.tie(nullptr);
cout << fixed; cout.precision(15);

int xs, ys, xt, yt, n;
cin >> xs >> y >> xt >> yt >> n;
vector <circle> v(n);
vector <ld> d(n);
for(int i = 0; i < n; i++) {
cin >> v[i].x >> v[i].y >> v[i].r;
d[i] = dist(circle(xs, ys, 0), v[i]);
}
vector <bool> chk(n);
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n; j++) {
if(chk[j]) continue;
if(mn > d[j]) mn = d[j], idx = j;
}
chk[idx] = true;
for(int j = 0; j < n; j++) {
if(chk[j]) continue;
d[j] = min(d[j], d[idx] + dist(v[idx], v[j]));
}
}

ld ans = dist(circle(xt, yt, 0), circle(xs, ys, 0));
for(int i = 0; i < n; i++) {
ans = min(ans, dist(circle(xt, yt, 0), v[i]) + d[i]);
}
cout << ans;
}
#include<bits/stdc++.h>
using namespace std;

#define fast ios::sync_with_stdio(false); cin.tie(0);
#define fi first
#define se second
#define pb push_back
#define em emplace
#define eb emplace_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define pre(x) cout<<fixed; cout.precision(x);

typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 1e9;
const ll INF = 1e18;
const ll Mod = 998244353;

int n, m;
int a[100010];
vector<int> in[100010], out[100010];

int main() {
fast;

cin >> n >> m;
for(int i=1; i<=n; i++) cin >> a[i];
ll ans=0, sum=0, cnt=0, Ans = INF;
for(int i=1; i<n; i++) {
ans += (a[i+1] - a[i] + m) % m;
in[a[i]].eb(a[i+1]);
out[a[i+1]].eb(a[i]);

if(a[i+1] < a[i]) cnt++, sum += m - a[i] - 1;
}

for(int i=1; i<=m; i++) {
sum += cnt;
Ans = min(Ans, ans - sum);

for(auto j : in[i]) {
cnt++;
sum--;
}        

for(auto j : out[i]) {
cnt--;
sum -= (i - j + m) % m - 1;
}
}

cout << Ans;
}
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
#define e1 first
#define e2 second
#define pb push_back
#define OUT(x) {cout << x << "\n"; exit(0); }
#define TCOUT(x) {cout << x << "\n"; return; }
#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)
#define rep(i, l, r) for(int i = (l); i < (r); ++i)
#define boost {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); }
#define sz(x) int(x.size())
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
typedef long long ll;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;

using mint = long long;

mt19937_64 rng(time(0));
int random(int l, int r) {
return uniform_int_distribution<int>(l, r)(rng);
}
#ifdef DEBUG
template<class T> int size(T &&x) {
return int(x.size());
}
template<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {
return out << '(' << p.first << ", " << p.second << ')';
}
template<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {
out << '{';
for(auto it = x.begin(); it != x.end(); ++it)
out << *it << (it == prev(x.end()) ? "" : ", ");
return out << '}';
}
void dump() {}
template<class T, class... Args> void dump(T &&x, Args... args) {
cerr << x << ";  ";
dump(args...);
}
#endif
#ifdef DEBUG
struct Nl{~Nl(){cerr << '\n';}};
# define debug(x...) cerr << (strcmp(#x, "") ? #x ":  " : ""), dump(x), Nl(), cerr << ""
#else
# define debug(...) 0 && cerr
#endif

int main() {
int n; cin >> n;
vector <int> a(n);
rep(i, 0, n) cin >> a[i];
vector <int> b(n);
rep(i, 0, n) cin >> b[i];
int ret = 0;
rep(bit, 0, 29) {
vi num(n);
rep(i, 0, n) num[i] = b[i] % (1 << (bit + 1));
sort(all(num));
auto cnt = [&](int aa, int bb) -> int {
return upper_bound(all(num), bb) - lower_bound(all(num), aa);
};
ll ile = 0;
rep(i, 0, n) {
int tmp = a[i] % (1 << (bit + 1));
int pt = (1 << bit);
ile += cnt(pt - tmp, 2 * pt - 1 - tmp);
ile += cnt(3 * pt - tmp, 4 * pt - 1 - tmp);
}
debug(bit, ile);
if (ile % 2 == 1) ret += (1 << bit);
}

cout << ret << endl;
}

// oooo
/*
be hengam shena mesle y dasto pa cholofti ~
bepa to masire dahane koose neyofti ~
;Amoo_Hasan;
*/

#include<bits/stdc++.h>
#pragma GCC optimize("O3,no-stack-protector,unroll-loops")
#pragma GCC target("avx2,fma")

using namespace std;

typedef long long ll;
typedef long double ld;

#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define Sz(x) int((x).size())
#define all(x) (x).begin(), (x).end()

const ll inf = 1e18, N = 1e6 + 10, mod = 1e9 + 7, pr = 1000696969;

int n;
int d[N], par[N], ans[N], ans2[N];
pair<int, int> pos;
bool mark[N];
vector<int> G[N], vc;

void bfs(int x) {
queue<int> pq;
pq.push(x), mark[x] = 1, d[x] = 0;

while(!pq.empty()) {
int p = pq.front(); pq.pop();
for(auto i : G[p]) {
if(!mark[i]) {
pq.push(i), mark[i] = 1, d[i] = d[p] + 1, par[i] = p;
}
}
}
}

int main() {
fast_io;

cin >>n;
for(int i = 0; i < n - 1; i++) {
int u, v; cin >>u >>v;
G[u].push_back(v), G[v].push_back(u);
}

bfs(1); pos.first = 1;
for(int i = 2; i <= n; i++) if(d[i] > d[pos.first]) pos.first = i;

memset(mark, 0, sizeof(mark));
bfs(pos.first); pos.second = pos.first;
for(int i = 1; i <= n; i++) if(d[i] > d[pos.second]) pos.second = i;

memset(mark, 0, sizeof(mark));

int k = pos.second; mark[pos.second] = 1;
while(k != pos.first) {
vc.push_back(k); k = par[k]; mark[k] = 1;
}
vc.push_back(pos.first);

for(auto i : vc) {
for(auto j : G[i]) {
if(mark[j]) continue;
if(Sz(G[j]) > 1) {
return cout<<-1, 0;
}
}
}

int ind = 1, cnt = 1;
for(int i = 0; i < Sz(vc); i++) {
if(i == 0 || i == Sz(vc) - 1) {
ans[ind++] = cnt++;
}
else {
ans[ind + Sz(G[vc[i]]) - 2] = cnt++;
for(int j = 0; j < Sz(G[vc[i]]) - 2; j++) {
ans[ind++] = cnt++;
}
ind++;
}
}

ind = 1, cnt = 1;
for(int i = Sz(vc) - 1; i >= 0; i--) {
if(i == 0 || i == Sz(vc) - 1) {
ans2[ind++] = cnt++;
}
else {
ans2[ind + Sz(G[vc[i]]) - 2] = cnt++;
for(int j = 0; j < Sz(G[vc[i]]) - 2; j++) {
ans2[ind++] = cnt++;
}
ind++;
}
}

ind = 0;
for(int i = 1; i <= n; i++) {
if(ans2[i] < ans[i]) {
ind = 1;
break;
}
else if(ans[i] < ans2[i]) {
ind = 0;
break;
}
}

if(ind == 0) {
for(int i = 1; i <= n; i++) cout<<ans[i] <<" ";
}
else {
for(int i = 1; i <= n; i++) cout<<ans2[i] <<" ";
}


return 0;
}



#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(x) (x).begin(),(x).end()
#pragma GCC optimize ("-O3")
using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }
//---------------------------------------------------------------------------------------------------
/*---------------------------------------------------------------------------------------------------
∧＿∧  
∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!
（ ´_ゝ`）　/　 ⌒i     
／　　　＼　 　  |　|     
/　　 /￣￣￣￣/　　|  
＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  
＼/＿＿＿＿/　（u　⊃  
---------------------------------------------------------------------------------------------------*/





int N, K;
//---------------------------------------------------------------------------------------------------
void _main() {
cin >> N >> K;

int ans = (N - 1 + K - 2) / (K - 1);
cout << ans << endl;
}

#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
#define yn(joken) cout<<((joken) ? "Yes" : "No")<<endl
#define YN(joken) cout<<((joken) ? "YES" : "NO")<<endl
using namespace std;
using ll = long long;
using vi = vector<int>;
using vl = vector<ll>;
using vs = vector<string>;
using vc = vector<char>;
using vd = vector<double>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<ll>>;
const int INF = 1e9;
const ll LINF = 1e18;
template <class T>
bool chmax(T& a, const T& b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
is >> v[i];
}
return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
os << v[i];
if (i < int(v.size()) - 1) os << ' ';
}
return os;
}

int main(){
cin.tie(nullptr);
ios::sync_with_stdio(false);

ll N;
cin>>N;
vl A(N);
cin>>A;
ll ans=0;
while(true){
bool flg=true;
rep(i,N){
if(A[i]>N-1) flg=false;
}
if(flg) break;
ll tmp=0;
vl op(N);
rep(i,N){
op[i]=A[i]/N;
tmp+=op[i];
}
ans+=tmp;
rep(i,N) A[i]-=op[i]*N-(tmp-op[i]);
}
cout<<ans<<endl;
}
# include <bits/stdc++.h>
# define rep(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)
# define reps(i, n) for(int i=1, i##_len=(n); i<=i##_len; ++i)
# define rrep(i, n) for(int i=((int)(n)-1); i>=0; --i)
# define rreps(i, n) for(int i=((int)(n)); i>0; --i)
# define ALL(x) (x).begin(), (x).end()
# define SZ(x) ((int)(x).size())
# define pb push_back
# define optimize_cin() cin.tie(0); ios::sync_with_stdio(false)
using namespace std;
using lint = long long;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

int main()
{
int n, k;
vector<int> a(202020,0);
cin >> n >> k;
int count=0;
rep(i,n) {
int x;
cin >> x;
if(a[x]==0) count++;
a[x]+=1;
}
int ans = 0;
sort(ALL(a));
int id = 0;
while(a[id]==0){
id++;
}
while(count > k){
ans += a[id];
id++;
count--;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,n) for(int i=0;i<n;i++)
#define rrep(i,n) for(int i=n-1;i>=0;i--)
#define rrep2(i,n,k) for(int i=n-1;i>=n-k;i--)
#define vll(n,i) vector<long long>(n,i)
#define v2ll(n,m,i) vector<vector<long long>>(n,vll(m,i))
#define v3ll(n,m,k,i) vector<vector<vector<long long>>>(n,v2ll(m,k,i))
#define v4ll(n,m,k,l,i) vector<vector<vector<vector<long long>>>>(n,v3ll(m,k,l,i))
#define all(v) v.begin(),v.end()
#define chmin(k,m) k = min(k,m)
#define chmax(k,m) k = max(k,m)
#define Pr pair<ll,ll>
#define Tp tuple<ll,ll,ll>
#define riano_ std::ios::sync_with_stdio(false);std::cin.tie(nullptr)

//Graph
struct graph {
long long N;
vector<vector<tuple<long long,long long,int>>> G;
vector<long long> par_v;
vector<long long> par_e;
int edge_count = 0;

graph(long long n) {
N = n;
G = vector<vector<tuple<long long,long long,int>>>(N);
par_v = vector<long long>(N,-1);
par_e = vector<long long>(N,-1);
}

void unite(long long a,long long b,long long cost = 1,bool directed = false){
G[a].emplace_back(b,cost,edge_count);
if(!directed) G[b].emplace_back(a,cost,edge_count);
edge_count++;
}
};

const ll mod = 1e9+7;
template<uint64_t mod>
struct modint{
uint64_t val;
constexpr modint(const int64_t val_=0) noexcept:val((val_%int64_t(mod)+int64_t(mod))%int64_t(mod)){}
constexpr modint operator-() const noexcept{
return modint(*this)=mod-val;
}
constexpr modint operator+(const modint rhs) const noexcept{
return modint(*this)+=rhs;
}
constexpr modint operator-(const modint rhs) const noexcept{
return modint(*this)-=rhs;
}
constexpr modint operator*(const modint rhs) const noexcept{
return modint(*this)*=rhs;
}
constexpr modint oprator/(const modint rhs) const noexcept{
return modint(*this)/=rhs;
}
constexpr modint &operator+=(const modint rhs) noexcept{
val+=rhs.val;
val-=((val>=mod)?mod:0);
return (*this);
}
constexpr modint &operator-=(const modint rhs) noexcept{
val+=((val<rhs.val)?mod:0);
val-=rhs.val;
return (*this);
}
constexpr modint &operator*=(const modint rhs) noexcept{
val=val*rhs.val%mod;
return (*this);
}
constexpr modint &operator/=(modint rhs) noexcept{
uint64_t ex=mod-2;
modint now=1;
while(ex){
now*=((ex&1)?rhs:1);
rhs*=rhs,ex>>=1;
}
return (*this)*=now;
}
modint & operator++(){
val++;
if (val == mod) val = 0;
return *this;
}
modint operator++(int){
modint<mod> res = *this;
++*this;
return res;
}
constexpr bool operator==(const modint rhs) noexcept{
return val==rhs.val;
}
constexpr bool operator!=(const modint rhs) noexcept{
return val!=rhs.val;
}
friend constexpr ostream &operator<<(ostream& os,const modint x) noexcept{
return os<<(x.val);
}
friend constexpr istream &operator>>(istream& is,modint& x) noexcept{
uint64_t t;
is>>t,x=t;
return is;
}
};
typedef modint<mod> mint;
mint pw(long long a,long long b,long long m = mod){
if(a%m==0) return mint(0);
if(b==0) return mint(1);
else if(b%2==0){
long long x = pw(a,b/2,m).val;
return mint(x*x);
}
else{
long long x = pw(a,b-1,m).val;
return mint(a*x);
}
}
mint modinv(long long a, long long m = mod) {
long long b = m, u = 1, v = 0;
while (b) {
long long t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
u %= m;
return mint(u);
}
#define vm(n,i) vector<mint>(n,i)
#define v2m(n,m,i) vector<vector<mint>>(n,vm(m,i))
#define v3m(n,m,k,i) vector<vector<vector<mint>>>(n,v2m(m,k,i))
#define v4m(n,m,k,l,i) vector<vector<vector<vector<mint>>>>(n,v3m(m,k,l,i))
void out(vector<ll> &v){
for(ll x:v) cout << x << " ";
cout << "\n"; return;
}

int main() {
riano_; mint ans = 0;
ll N,M,K,T; cin >> N; N++;
vector<int> v;
rep(i,60){
v.push_back(N%2); N /= 2;
}
reverse(all(v));
auto dp_sm = vm(61,0);
auto dp_eq = vm(61,0); dp_eq[0] = 1;
mint cnt_eq = 0,cnt_sm = 0;
rep(i,60){
mint tmp = 0;
if(v[i]==0){
dp_eq[i+1] = dp_eq[i]+cnt_eq;
}
else{
dp_sm[i+1] = dp_eq[i]+cnt_eq;
tmp += cnt_eq;
dp_eq[i+1] = dp_eq[i]; cnt_eq += dp_eq[i];
}
dp_sm[i+1] += mint(2)*dp_sm[i]+cnt_sm;
cnt_sm *= 2;
cnt_sm += dp_sm[i]+tmp;
//cout << dp_eq[i+1] << " " << cnt_eq << " " << dp_sm[i+1] << " " << cnt_sm << endl;
}
ans = dp_sm[60];
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<long long> VL;
typedef vector<vector<long long>> VVL;
typedef pair<int,int> Pair;
typedef tuple<int,int,int> tpl;

#define ALL(a)  (a).begin(),(a).end()
#define SORT(c) sort((c).begin(),(c).end())
#define REVERSE(c) reverse((c).begin(),(c).end())
#define EXIST(m,v) (m).find((v)) != (m).end()
#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()
#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)
#define RREP(i,n) RFOR(i,n,0)

#define en "\n"

constexpr double EPS = 1e-9;
constexpr double PI  = 3.1415926535897932;
constexpr int INF = 2147483647;
constexpr long long LINF = 1LL<<60;
constexpr long long MOD =  1000000007;

template<class T> inline bool chmax(T& a, T b){if(a<b){a=b;return true;}return false;}
template<class T> inline bool chmin(T& a, T b){if(a>b){a=b;return true;}return false;}

void add(int& a, int b){
a += b;
if(a >= MOD) a -= MOD;
}

int check(int r, int g, int b, int L, int R){
int ret = 0;
if(L<=r and r<=R) ret++;
if(L<=g and g<=R) ret++;
if(L<=b and b<=R) ret++;
return ret;
}

void Main(){
int N,M; cin >> N >> M;
vector<vector<Pair>> v(N+1);
REP(i,M){
int l,r,x; cin >> l >> r >> x;
v[r].emplace_back(l,x);
}

int dp[N+2][N+2][N+2]; REP(i,N+1)REP(j,N+1)REP(k,N+1) dp[i][j][k] = 0;
dp[0][0][0] = 1;
REP(r,N+1)REP(g,N+1)REP(b,N+1){
int k = max({r,g,b});
for(auto& [L,X] : v[k]){
int R = k+1;
if(check(r,g,b,L,R) != X) dp[r][g][b] = 0;
}
add(dp[k+1][g][b], dp[r][g][b]);
add(dp[r][k+1][b], dp[r][g][b]);
add(dp[r][g][k+1], dp[r][g][b]);
}

int ans = 0;
REP(i,N)REP(j,N){
add(ans, dp[N][i][j]);
add(ans, dp[i][N][j]);
add(ans, dp[i][j][N]);
}
cout << ans << en;
return;
}

int main(void){
cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);
int t=1; //cin>>t;
while(t--) Main();
return 0;
};
// #pragma GCC target("avx2")
// #pragma GCC optimize("O3")
// #pragma GCC optimize("unroll-loops")

#define CONSTANTS
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>
using namespace std;

constexpr long long INF = 1e18;
// constexpr long long INF = LONG_LONG_MAX;
constexpr int MOD = 1000000007;
// constexpr int MOD = 998244353;
constexpr long double EPS = 1e-10;
constexpr long double PI = M_PI;

using ll = long long; using ull = unsigned long long; using ld = long double; using pll = pair<ll, ll>; using pii = pair<int, int>; using pil = pair<int, ll>; using vvl = vector<vector<ll>>; using vvi = vector<vector<int>>; using vvpll = vector<vector<pll>>; using vvpil = vector<vector<pil>>;
#define name4(i, a, b, c, d, e, ...) e
#define rep(...) name4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)
#define rep1(i, a) for (ll i = 0, _aa = a; i < _aa; i++)
#define rep2(i, a, b) for (ll i = a, _bb = b; i < _bb; i++)
#define rep3(i, a, b, c) for (ll i = a, _bb = b; (c > 0 && a <= i && i < _bb) or (c < 0 && a >= i && i > _bb); i += c)
#define rrep(i, a, b) for (ll i=(a); i>(b); i--)
#define pb push_back
#define eb emplace_back
#define mkp make_pair
#define ALL(A) A.begin(), A.end()
#define UNIQUE(A) sort(ALL(A)), A.erase(unique(ALL(A)), A.end())
#define elif else if
#define tostr to_string
#ifndef CONSTANTS
constexpr ll INF = 1e18; constexpr int MOD = 1000000007; constexpr ld EPS = 1e-10; constexpr ld PI = M_PI;
#endif

template<int mod> struct ModInt { int x; ModInt() : x(0) {} ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {} ModInt &operator++() { x++; if (x == mod) x = 0; return *this; } ModInt &operator--() { if (x == 0) x = mod; x--; return *this; } ModInt &operator+=(const ModInt &p) { if((x += p.x) >= mod) x -= mod; return *this; } ModInt &operator-=(const ModInt &p) { if((x += mod - p.x) >= mod) x -= mod; return *this; } ModInt &operator*=(const ModInt &p) { x = (int) (1LL * x * p.x % mod); return *this; } ModInt &operator/=(const ModInt &p) { *this *= p.inverse(); return *this; } ModInt operator++(int) { ModInt result = *this; ++*this; return result; } ModInt operator--(int) { ModInt result = *this; --*this; return result; } ModInt operator-() const { return ModInt(-x); } ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; } ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; } ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; } ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; } bool operator==(const ModInt &p) const { return x == p.x; } bool operator!=(const ModInt &p) const { return x != p.x; } ModInt inverse() const { int a = x, b = mod, u = 1, v = 0, t; while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); } return ModInt(u); } ModInt pow(int64_t n) const { ModInt ret(1), mul(x); while(n > 0) { if(n & 1) ret *= mul; mul *= mul; n >>= 1; } return ret; } friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; } friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); } static int get_mod() { return mod; } };
using mint = ModInt<MOD>;

template<typename T> vector<vector<T>> list2d(int N, int M, T init) { return vector<vector<T>>(N, vector<T>(M, init)); } template<typename T> vector<vector<vector<T>>> list3d(int N, int M, int L, T init) { return vector<vector<vector<T>>>(N, vector<vector<T>>(M, vector<T>(L, init))); } template<typename T> vector<vector<vector<vector<T>>>> list4d(int N, int M, int L, int O, T init) { return vector<vector<vector<vector<T>>>>(N, vector<vector<vector<T>>>(M, vector<vector<T>>(L, vector<T>(O, init)))); }
template<typename T=ll> vector<T> LIST(ll N) { vector<T> A(N); rep(i, N) { cin >> A[i]; } return A; }
void print() { cout << '\n'; } template<typename T> void print(T out) { cout << out << '\n'; } template<typename T1, typename T2> void print(const pair<T1, T2> &p) { cout << p.first << ' ' << p.second << '\n'; } template<typename T1, typename T2, typename T3> void print(const tuple<T1, T2, T3> &tp) { cout << get<0>(tp) << ' ' << get<1>(tp) << ' ' << get<2>(tp) << '\n'; } template<typename T1, typename T2, typename T3, typename T4> void print(const tuple<T1, T2, T3, T4> &tp) { cout << get<0>(tp) << ' ' << get<1>(tp) << ' ' << get<2>(tp) << ' ' << get<3>(tp) << '\n'; } template<typename T1, typename T2> void print(const vector<pair<T1, T2>> &V) { for (auto& p : V) print(p); } template<typename T> void print(const vector<T> &V) { rep(i, V.size()) { cout << V[i]; if (i != V.size()-1) cout << ' '; } cout << '\n'; } template<typename T, size_t SZ> void print(const array<T, SZ> &arr) { rep(i, arr.size()) { cout << arr[i]; if (i != arr.size()-1) cout << ' '; } cout << '\n'; } template<typename T> void print(const deque<T> &que) { vector<T> V(ALL(que)); print(V); } template<typename T> void print(const set<T> &se) { vector<T> V(ALL(se)); print(V); }
#define debug(x) (cout << #x << ": ", print(x));
void Yes() { print("Yes"); } void No() { print("No"); } void YES() { print("YES"); } void NO() { print("NO"); }
ll toint(string s) { assert(s.size() < 20); ll res = 0; for (char &c : s) { res *= 10; res += c - '0'; } return res; } int toint(char num) { return num - '0'; }
char tochar(int num) { return '0' + num; }
template<typename T> T floor(T a, T b) { if (a < 0) return (a-b+1) / b; else return a / b; }
template<typename T> T ceil(T a, T b) { if (a >= 0) return (a+b-1) / b; else return a / b; }
template<typename T> T modulo(T a, T b) { return ((a % b) + b) % b; }
template<typename T> pair<T, T> divmod(T a, T b) { T d = a / b; T m = a % b; return {d, m}; }
template<typename T> bool chmin(T &x, T y) { return (y < x) ? x = y, true : false; }
template<typename T> bool chmax(T &x, T y) { return (y > x) ? x = y, true : false; }
template<typename T> T sum(const vector<T> &A) { return accumulate(ALL(A), (T)0); } template<typename key, typename val> val sum(const map<key, val> &mp) { val res = 0; for (auto& [k, v] : mp) res += v; return res; }
template<typename T> T min(const vector<T> &A) { return *min_element(ALL(A)); } template<typename key, typename val> val min(const map<key, val> &mp) { val res = numeric_limits<val>::max(); for (auto& [k, v] : mp) chmin(res, v); return res; }
template<typename T> T max(const vector<T> &A) { return *max_element(ALL(A)); } template<typename key, typename val> val max(const map<key, val> &mp) { val res = numeric_limits<val>::min(); for (auto& [k, v] : mp) chmax(res, v); return res; }
ll pow(ll x, ll n) { ll res = 1; rep(_, n) res *= x; return res; } ll pow(int x, ll n) { return pow((ll)x, n); } ll pow(ll x, int n) { return pow(x, (ll)n); } ll pow(int x, int n) { return pow((ll)x, (ll)n); } ll pow(ll x, ll n, int mod) { x %= mod; ll res = 1; while (n > 0) { if (n & 1) { res = (res * x) % mod; } x = (x * x) % mod; n >>= 1; } return res; }
int popcount(ll S) { return __builtin_popcountll(S); }
int bit_length(ll x) { return x != 0 ? floor(log2((ld)x))+1 : 0; }
template<typename T> int bisect_left(const vector<T> &A, T val, int lo=0) { return lower_bound(A.begin()+lo, A.end(), val) - A.begin(); } template<typename T> int bisect_right(const vector<T> &A, T val, int lo=0) { return upper_bound(A.begin()+lo, A.end(), val) - A.begin(); }
template<typename T> map<T, ll> Counter(const vector<T> &A) { map<T, ll> res; for (T a : A) { res[a]++; } return res; } template<typename T> vector<ll> Counter(const vector<T> &A, T mx) { vector<ll> res(mx+1); for (T a : A) { res[a]++; } return res; } map<char, ll> Counter(const string &S) { map<char, ll> res; for (char c : S) { res[c]++; } return res; }
template<typename F> ll bisearch_min(ll mn, ll mx, const F &func) { ll ok = mx; ll ng = mn; while (ng+1 < ok) { ll mid = (ok+ng) / 2; if (func(mid)) { ok = mid; } else { ng = mid; } } return ok; } template<typename F> ll bisearch_max(ll mn, ll mx, const F &func) { ll ok = mn; ll ng = mx; while (ok+1 < ng) { ll mid = (ok+ng) / 2; if (func(mid)) { ok = mid; } else { ng = mid; } } return ok; }
template<typename T1, typename T2> pair<vector<T1>, vector<T2>> zip(const vector<pair<T1, T2>> &A) { int N = A.size(); pair<vector<T1>, vector<T2>> res = {vector<T1>(N), vector<T2>(N)}; rep(i, N) { res.first[i] = A[i].first; res.second[i] = A[i].second; } return res; } template<typename T1, typename T2, typename T3> tuple<vector<T1>, vector<T2>, vector<T3>> zip(const vector<tuple<T1, T2, T3>> &A) { int N = A.size(); tuple<vector<T1>, vector<T2>, vector<T3>> res = {vector<T1>(N), vector<T2>(N), vector<T3>(N)}; rep(i, N) { get<0>(res)[i] = get<0>(A[i]); get<1>(res)[i] = get<1>(A[i]); get<2>(res)[i] = get<2>(A[i]); } return res; }
template<typename T> struct Compress { int N; vector<T> dat; Compress(vector<T> A) { sort(A.begin(), A.end()); A.erase(unique(A.begin(), A.end()), A.end()); N = A.size(); dat = A; } int zip(T x) { return bisect_left(dat, x); } T unzip(int x) { return dat[x]; } int operator[](T x) { return zip(x); } int size() { return dat.size(); } vector<ll> zip(const vector<T> &A) { int M = A.size(); vector<ll> res(M); rep(i, M) res[i] = zip(A[i]); return res; } };
template<typename T> vector<pair<T, int>> RLE(const vector<T> &A) { if (A.empty()) return {}; int N = A.size(); vector<pair<T, int>> res; T cur = A[0]; int cnt = 1; rep(i, 1, N) { if (A[i] == A[i-1]) { cnt++; } else { res.pb({cur, cnt}); cnt = 1; cur = A[i]; } } res.pb({cur, cnt}); return res; } vector<pair<char, int>> RLE(const string &S) { if (S.empty()) return {}; int N = S.size(); vector<pair<char, int>> res; char cur = S[0]; int cnt = 1; rep(i, 1, N) { if (S[i] == S[i-1]) { cnt++; } else { res.pb({cur, cnt}); cnt = 1; cur = S[i]; } } res.pb({cur, cnt}); return res; }
template<typename T> bool mul_overflow(T x, T y) { T z; return __builtin_mul_overflow(x, y, &z); }
vector<ll> split(const string &S, char separator) { int N = S.size(); vector<ll> res; string cur; rep(i, N) { if (S[i] == separator) { res.eb(toint(cur)); cur = ""; } else { cur += S[i]; } } if (cur.size()) res.eb(toint(cur)); return res; }
string to_string(const string &S) { return S; } string to_string(char c) { return {c}; }
template<typename T> string join(const vector<T> &A, char separator=0) { int N = A.size(); string res; rep(i, N) { res += tostr(A[i]); if (separator != 0 and i != N-1) res += separator; } return res; }
template<typename T> vector<T> sorted(vector<T> A, bool reverse=false) { sort(ALL(A)); if (reverse) std::reverse(ALL(A)); return A; }
template<typename Mint> struct ModTools { int MAX; vector<Mint> fact, factinv; ModTools() {}; ModTools(int mx) { build(mx); } void build(int mx) { MAX = ++mx; fact.resize(MAX); factinv.resize(MAX); fact[0] = fact[1] = 1; rep(i, 2, MAX) { fact[i] = fact[i-1] * i; } factinv[MAX-1] = (Mint)1 / fact[MAX-1]; rep(i, MAX-2, -1, -1) { factinv[i] = factinv[i+1] * (i+1); } } Mint factorial(int x) { return fact[x]; } Mint inverse(int x) { return factinv[x]; } Mint nCr(int n, int r) { if (n < r or r < 0) return 0; r = min(r, n-r); Mint num = fact[n]; Mint den = factinv[r] * factinv[n-r]; return num * den; } Mint nHr(int n, int r) { return nCr(r+n-1, r); } Mint nPr(int n, int r) { if (n < r or r < 0) return 0; return fact[n] * factinv[n-r]; } };
template<typename T> vector<vector<T>> permutations(const vector<T> &A, int N=-1) { if (N == -1) N = A.size(); int M = A.size(); assert(N <= M); vector<vector<T>> comb; rep(bit, 1<<M) { if (popcount(bit) != N) continue; vector<T> res; rep(i, M) { if (bit>>i & 1) { res.pb(A[i]); } } comb.pb(res); } vector<vector<T>> res; for (auto &perm : comb) { sort(ALL(perm)); do { res.pb(perm); } while (next_permutation(ALL(perm))); } return res; }
template<typename T> vector<vector<T>> combinations(const vector<T> &A, int N) { int M = A.size(); vector<vector<T>> res; auto rec = [&](auto&& f, vector<T> &cur, ll x, ll n) -> void { if (n == N) { res.pb(cur); return; } rep(i, x, M) { cur.pb(A[i]); f(f, cur, i+1, n+1); cur.pop_back(); } }; vector<T> cur; rec(rec, cur, 0, 0); return res; }
template<typename T> T factorial(int x) { T res = 1; for (int i=1; i<=x; i++) res *= i; return res; }
struct UnionFind { int n, groupcnt; vector<int> par, rank, sz; vector<bool> tree; UnionFind(int n) : n(n) { par.assign(n, 0); rank.assign(n, 0); sz.assign(n, 1); tree.assign(n, true); rep(i, n) par[i] = i; groupcnt = n; } UnionFind() {} void resize(int _n) { n = _n; par.assign(n, 0); rank.assign(n, 0); sz.assign(n, 1); tree.assign(n, true); rep(i, n) par[i] = i; groupcnt = n; } int find(int x) { if (par[x] == x) { return x; } else { par[x] = find(par[x]); return par[x]; } } int merge(int a, int b) { int x = find(a); int y = find(b); if (x == y) { tree[x] = false; return x; } if (!tree[x] or !tree[y]) { tree[x] = tree[y] = false; } groupcnt--; if (rank[x] < rank[y]) { par[x] = y; sz[y] += sz[x]; return y; } else { par[y] = x; sz[x] += sz[y]; if (rank[x] == rank[y]) { rank[x]++; } return x; } } bool same(int a, int b) { return find(a) == find(b); } ll size(int x) { return sz[find(x)]; } int size() { return groupcnt; } bool is_tree(int x) { return tree[find(x)]; } set<int> get_roots() { set<int> res; rep(i, n) { res.insert(find(i)); } return res; } };
const vector<pii> dir4 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
#define directions dir4
ll gridtoid(ll i, ll j, ll W) { return i*W+j; }
pll idtogrid(ll id, ll W) { return divmod(id, W); }
template<typename _Key, typename _Tp, typename _Compare=less<_Key>, typename _Alloc=allocator<pair<const _Key, _Tp>>> struct defaultdict : public map<_Key, _Tp, _Compare, _Alloc> { const _Tp init; defaultdict() : init(_Tp()) {}; defaultdict(_Tp init) : init(init) {} _Tp& operator[](const _Key& k) { if (this->count(k)) { return map<_Key, _Tp, _Compare, _Alloc>::operator[](k); } else { return map<_Key, _Tp, _Compare, _Alloc>::operator[](k) = init; } } _Tp& operator[](_Key&& k) { if (this->count(k)) { return map<_Key, _Tp, _Compare, _Alloc>::operator[](k); } else { return map<_Key, _Tp, _Compare, _Alloc>::operator[](k) = init; } } };
ll gcd(ll a, ll b) { return __gcd(a, b); }
ll lcm(ll x, ll y) { return (x * y) / gcd(x, y); }
template<typename T> vector<pair<T, int>> factorize(T n) { vector<pair<T, int>> ret; for (T i=2; i*i<=n; i++) { int cnt = 0; while (n % i == 0) { n /= i; cnt++; } if (cnt) ret.emplace_back(i, cnt); } if (n > 1) ret.emplace_back(n, 1); return ret; }
template<typename T> vector<T> divisors(T n) { vector<T> res; for (T i=1; i*i<=n; i++) { if (n%i == 0) { res.eb(i); if (n/i != i) res.eb(n/i); } } return res; }
ll isqrt(ll n, bool ceil=false) { ll ok = 0; ll ng = 3037000500; while (ng - ok > 1) { ll m = ok + (ng - ok) / 2; if (m * m <= n) { ok = m; } else { ng = m; } } if (ceil and ok*ok != n) ok++; return ok; }
template<typename T> struct Accumulate { vector<T> acc; int N; Accumulate() {} Accumulate(int N) : N(N) { acc.resize(N); } Accumulate(const vector<T> &A) { N = A.size(); acc = A; build(); } void set(int i, T a) { acc[i] = a; } void build() { rep(i, N-1) { acc[i+1] += acc[i]; } acc.insert(acc.begin(), 0); } T query(int l, int r) { assert(0 <= l and l <= N and 0 <= r and r <= N); return acc[r]-acc[l]; } T get(int i) { return query(i, i+1); } T operator[](int i){ return query(i, i+1); } ll bisearch_fore(int l, int r, ll x) { if (l > r) return -1; ll l_sm = query(0, l); int ok = r + 1; int ng = l - 1; while (ng+1 < ok) { int mid = (ok+ng) / 2; if (query(0, mid+1) - l_sm >= x) { ok = mid; } else { ng = mid; } } if (ok != r+1) { return ok; } else { return -1; } } ll bisearch_back(int l, int r, ll x) { if (l > r) return -1; ll r_sm = query(0, r+1); int ok = l - 1; int ng = r + 1; while (ok+1 < ng) { int mid = (ok+ng) / 2; if (r_sm - query(0, mid) >= x) { ok = mid; } else { ng = mid; } } if (ok != l-1) { return ok; } else { return -1; } } };
template<typename T> struct BIT { int sz; vector<T> tree; BIT(int n) { n++; sz = 1; while (sz < n) { sz *= 2; } tree.resize(sz); } T sum(int i) { T s = 0; i++; while (i > 0) { s += tree[i-1]; i -= i & -i; } return s; } void add(int i, T x) { i++; while (i <= sz) { tree[i-1] += x; i += i & -i; } } T query(int l, int r) { return sum(r-1) - sum(l-1); } T get(int i) { return query(i, i+1); } void update(int i, T x) { add(i, x - get(i)); } T operator[](int i) { return query(i, i+1); } void print(int n) { rep(i, n) { cout << query(i, i+1); if (i == n-1) cout << endl; else cout << ' '; } } ll bisearch_fore(int l, int r, ll x) { if (l > r) return -1; ll l_sm = sum(l-1); int ok = r + 1; int ng = l - 1; while (ng+1 < ok) { int mid = (ok+ng) / 2; if (sum(mid) - l_sm >= x) { ok = mid; } else { ng = mid; } } if (ok != r+1) { return ok; } else { return -1; } } ll bisearch_back(int l, int r, ll x) { if (l > r) return -1; ll r_sm = sum(r); int ok = l - 1; int ng = r + 1; while (ok+1 < ng) { int mid = (ok+ng) / 2; if (r_sm - sum(mid-1) >= x) { ok = mid; } else { ng = mid; } } if (ok != l-1) { return ok; } else { return -1; } } };
template<typename Monoid, typename F> struct SegmentTree { int sz; vector<Monoid> seg; const F f; const Monoid M1; SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) { sz = 1; while(sz < n) sz <<= 1; seg.assign(2 * sz, M1); } SegmentTree(const F f, const Monoid &M1) : f(f), M1(M1) {} void resize(int n) { sz = 1; while(sz < n) sz <<= 1; seg.resize(2 * sz, M1); } void clear() { seg.clear(); } void set(int k, const Monoid &x) { seg[k+sz] = x; } void build() { for(int k = sz - 1; k > 0; k--) { seg[k] = f(seg[2*k], seg[2*k+1]); } } void build(const vector<Monoid> &A) { int n = A.size(); resize(n); rep(i, n) set(i, A[i]); build(); } void update(int k, const Monoid &x) { k += sz; seg[k] = x; while(k >>= 1) { seg[k] = f(seg[2*k], seg[2*k+1]); } } Monoid query(int a, int b) { Monoid L = M1, R = M1; for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) { if(a & 1) L = f(L, seg[a++]); if(b & 1) R = f(seg[--b], R); } return f(L, R); } Monoid operator[](const int &k) const { return seg[k+sz]; } Monoid all() { return seg[1]; } void print(int n) { for (int i=0; i<n; i++) { cout << query(i, i+1); if (i == n-1) cout << endl; else cout << ' '; } } template<typename C> int find_subtree(int a, const C &check, Monoid &M, bool type) { while(a < sz) { Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]); if(check(nxt)) a = 2 * a + type; else M = nxt, a = 2 * a + 1 - type; } return a - sz; } template<typename C> int find_first(int a, const C &check) { Monoid L = M1; if(a <= 0) { if(check(f(L, seg[1]))) return find_subtree(1, check, L, false); return -1; } int b = sz; for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) { if(a & 1) { Monoid nxt = f(L, seg[a]); if(check(nxt)) return find_subtree(a, check, L, false); L = nxt; ++a; } } return -1; } template<typename C> int find_last(int b, const C &check) { Monoid R = M1; if(b >= sz) { if(check(f(seg[1], R))) return find_subtree(1, check, R, true); return -1; } int a = sz; for(b += sz; a < b; a >>= 1, b >>= 1) { if(b & 1) { Monoid nxt = f(seg[--b], R); if(check(nxt)) return find_subtree(b, check, R, true); R = nxt; } } return -1; } }; template<typename Monoid, typename F> SegmentTree<Monoid, F> get_segment_tree(int N, const F& f, const Monoid& M1) { return {N, f, M1}; } template<typename Monoid, typename F> SegmentTree<Monoid, F> get_segment_tree(const F& f, const Monoid& M1) { return {f, M1}; }
const string digits = "0123456789";
const string ascii_lowercase = "abcdefghijklmnopqrstuvwxyz";
const string ascii_uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
string zfill(string str, int len) { string zeros; int n = str.size(); rep(i, len-n) zeros += '0'; return zeros+str; }
string bin(ll x) { string res; while (x) { if (x & 1) { res += '1'; } else { res += '0'; } x >>= 1; } reverse(ALL(res)); if (res == "") res += '0'; return res; }

namespace atcoder {

namespace internal {

template <class T> struct simple_queue {
std::vector<T> payload;
int pos = 0;
void reserve(int n) { payload.reserve(n); }
int size() const { return int(payload.size()) - pos; }
bool empty() const { return pos == int(payload.size()); }
void push(const T& t) { payload.push_back(t); }
T& front() { return payload[pos]; }
void clear() {
payload.clear();
pos = 0;
}
void pop() { pos++; }
};

}  // namespace internal

}  // namespace atcoder

namespace atcoder {

template <class Cap> struct mf_graph {
public:
mf_graph() : _n(0) {}
explicit mf_graph(int n) : _n(n), g(n) {}

int add_edge(int from, int to, Cap cap) {
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
int m = int(pos.size());
pos.push_back({from, int(g[from].size())});
int from_id = int(g[from].size());
int to_id = int(g[to].size());
if (from == to) to_id++;
g[from].push_back(_edge{to, to_id, cap});
g[to].push_back(_edge{from, from_id, 0});
return m;
}

struct edge {
int from, to;
Cap cap, flow;
};

edge get_edge(int i) {
int m = int(pos.size());
assert(0 <= i && i < m);
auto _e = g[pos[i].first][pos[i].second];
auto _re = g[_e.to][_e.rev];
return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};
}
std::vector<edge> edges() {
int m = int(pos.size());
std::vector<edge> result;
for (int i = 0; i < m; i++) {
result.push_back(get_edge(i));
}
return result;
}
void change_edge(int i, Cap new_cap, Cap new_flow) {
int m = int(pos.size());
assert(0 <= i && i < m);
assert(0 <= new_flow && new_flow <= new_cap);
auto& _e = g[pos[i].first][pos[i].second];
auto& _re = g[_e.to][_e.rev];
_e.cap = new_cap - new_flow;
_re.cap = new_flow;
}

Cap flow(int s, int t) {
return flow(s, t, std::numeric_limits<Cap>::max());
}
Cap flow(int s, int t, Cap flow_limit) {
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);

std::vector<int> level(_n), iter(_n);
internal::simple_queue<int> que;

auto bfs = [&]() {
std::fill(level.begin(), level.end(), -1);
level[s] = 0;
que.clear();
que.push(s);
while (!que.empty()) {
int v = que.front();
que.pop();
for (auto e : g[v]) {
if (e.cap == 0 || level[e.to] >= 0) continue;
level[e.to] = level[v] + 1;
if (e.to == t) return;
que.push(e.to);
}
}
};
auto dfs = [&](auto self, int v, Cap up) {
if (v == s) return up;
Cap res = 0;
int level_v = level[v];
for (int& i = iter[v]; i < int(g[v].size()); i++) {
_edge& e = g[v][i];
if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;
Cap d =
self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));
if (d <= 0) continue;
g[v][i].cap += d;
g[e.to][e.rev].cap -= d;
res += d;
if (res == up) return res;
}
level[v] = _n;
return res;
};

Cap flow = 0;
while (flow < flow_limit) {
bfs();
if (level[t] == -1) break;
std::fill(iter.begin(), iter.end(), 0);
Cap f = dfs(dfs, t, flow_limit - flow);
if (!f) break;
flow += f;
}
return flow;
}

std::vector<bool> min_cut(int s) {
std::vector<bool> visited(_n);
internal::simple_queue<int> que;
que.push(s);
while (!que.empty()) {
int p = que.front();
que.pop();
visited[p] = true;
for (auto e : g[p]) {
if (e.cap && !visited[e.to]) {
visited[e.to] = true;
que.push(e.to);
}
}
}
return visited;
}

private:
int _n;
struct _edge {
int to, rev;
Cap cap;
};
std::vector<std::pair<int, int>> pos;
std::vector<std::vector<_edge>> g;
};

}  // namespace atcoder

using namespace atcoder;

void solve() {
ll N;
cin >> N;
auto A = LIST(N);

ll s = N;
ll t = N+1;
mf_graph<ll> mf(N+2);
ll mx = 0;
rep(i, N) {
mx += max(A[i], 0LL);
if (A[i] > 0) {
mf.add_edge(s, i, 0);
mf.add_edge(i, t, A[i]);
} else {
mf.add_edge(s, i, -A[i]);
mf.add_edge(i, t, 0);
}
}
rep(i, N) {
ll d = i+1;
rep(j, i+d, N, d) {
mf.add_edge(i, j, MOD);
}
}
ll cut = mf.flow(s, t);
ll ans = mx-cut;
print(ans);
}

int main() {
cin.tie(0);
ios::sync_with_stdio(false);
cout << fixed << setprecision(15);

// single test case
solve();

// multi test cases
// int T;
// cin >> T;
// while (T--) solve();

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=105,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],cnt,res;
bool vis[maxn];
bitset<maxn> bs[maxn];

void solve(bitset<maxn> vis){
int tot=0;
rep2(i,1,min(n+1,34ll)) if(!vis[i]) tot+=a[i];
rep2(i,34,n+1) if(!vis[i]){
if(i*2>n) tot+=max(0ll,a[i]);
else if(i*2<=n){
if(!vis[i*2]){
tot+=max({0ll,a[i],a[i]+a[i*2]});
vis[i]=vis[i*2]=1;
}
else tot+=max(0ll,a[i]);
}
}
chkmax(res,tot);
}

void dfs(bitset<maxn> bs1, bitset<maxn> vis, int x){
cnt++;
solve(vis);
rep2(i,x,34) if(!vis[i]){
bs1[i]=1;
dfs(bs1,vis|bs[i],i+1);
bs1[i]=0;
}
}

void orzck(){
rep2(i,1,maxn) for(int j=i; j<maxn; j+=i) bs[i][j]=1;
cin >> n;
rep2(i,1,n+1) cin >> a[i];
dfs(bitset<maxn>(),bitset<maxn>(),1);
bug(cnt);
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
//================code===================//

#ifndef OHSOLUION
#pragma GCC optimize("O3")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#endif

#include <bits/stdc++.h>
#include <cmath>
#include <random>
#include <chrono>
#include <unordered_set>

#define ci(t) cin>>t
#define co(t) cout<<t
#define LL long long
#define ld long double
#define fa(i,a,b) for(int i=a;i<b;++i)
#define fd(i,a,b) for(int i=a;i>b;--i)
#define setp tuple<LL,LL,LL>
#define setl pair<LL,LL>
#define seti pair<int,int>
#define VL vector<LL>
#define VI vector<int>
#define eps 0.000000001
#define PI acos(-1)


using namespace std;


LL gcd(LL a, LL b)
{
if (!(a && b)) return max(a, b);
return a % b ? gcd(b, a % b) : b;
}

#ifdef OHSOLUTION
#define ce(t) cerr << t
#define AT cout << "\n=================ANS=================\n"
#define AE cout << "\n=====================================\n"
#define DB(a) cout << __LINE__ << ": " << #a << " = " << (a) << endl;
#define __builtin_popcount __popcnt
#define LLL LL

#else
#define AT
#define AE
#define ce(t)
#define DB(a)
#define LLL __int128
#endif

pair <int, int> vu[9] = { {0,1},{1,0},{0,-1} ,{-1,0}, {1,-1} , {-1,1},{-1,-1},{1,1},{0,0} }; //RDLU EWSN
mt19937 rng((unsigned int)chrono::steady_clock::now().time_since_epoch().count());


template<typename T, typename U> void ckmax(T& a, U b) { a = a < b ? b : a; }
template<typename T, typename U> void ckmin(T& a, U b) { a = a > b ? b : a; }
struct gcmp { bool operator()(LL a, LL b) { return a < b; } bool operator()(setl& a, setl& b) { return a.second < b.second; } };
struct lcmp { bool operator()(LL a, LL b) { return a > b; } bool operator()(setl& a, setl& b) { return a.second > b.second; } };

const int max_v = 2e5 + 7;
const int max_k = 5e2 + 7;
const int bsz = 27;
const int INF = 0x3f3f3f3f;
const LL LNF = 0x3f3f3f3f3f3f3f3f;
const LL mod = 1e9 + 9;//998244353;// 
template<typename T, typename U> void MOD(T& a, U b) { a += b; if (a < 0) a += mod; if (a >= mod) a -= mod; };

int main()
{
#ifdef OHSOLUTION
freopen("input.txt", "r", stdin);
#endif 
ios_base::sync_with_stdio(0); cin.tie(0);

LL h, w; ci(h >> w);

LL ans = LNF;

fa(u, 1, w)
{
LL a = u * h;

// hor cut
{
LL d = h / 2ll;

LL b = d * (w - u);
LL c = d * (w - u);

if (h & 1) c += w - u;

ckmin(ans, max(max(a,b),c)- min(min(a,b),c));
}
// ver cut
{
LL d = (w - u) / 2ll;

LL b = d * (h);
LL c = d * h;

if ((w - u) & 1) c += h;

ckmin(ans, max(max(a, b), c) - min(min(a, b), c));
}
}


swap(h, w);

fa(u, 1, w)
{
LL a = u * h;

// hor cut
{
LL d = h / 2ll;

LL b = d * (w - u);
LL c = d * (w - u);

if (h & 1) c += w - u;

ckmin(ans, max(max(a, b), c) - min(min(a, b), c));
}
// ver cut
{
LL d = (w - u) / 2ll;

LL b = d * (h);
LL c = d * h;

if ((w - u) & 1) c += h;

ckmin(ans, max(max(a, b), c) - min(min(a, b), c));
}
}

co(ans);

}
#include <iostream>
#include <cmath>
#include <iomanip>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <queue>
#include <stack>

#define all(x) x.begin(),x.end()
#define rall(x) x.rbegin(),x.rend()

using namespace std;
using ll = long long;
using ld = long double;
using i32 = int32_t;
using i64 = int64_t;

namespace cpio{
//IO library for Competitive-Programming
struct scanner {
private:
struct reader {
template <typename T> operator T() const {T buf; std::cin >> buf; return buf;}
};
public:
scanner() {std::cin.sync_with_stdio(false); std::cin.tie(nullptr);}

reader operator()() const {return reader();}
};

template<typename T> void vecin(std::vector<T> &v){for (auto &x : v) cin >> x;}

//Debug out
void dout(){
cerr << "\n";
}
template<typename T, typename... Ts>
void dout(const T& a, const Ts&... b){
cerr << a;
(cerr << ... << (cerr << ' ', b));
cerr << "\n";
}

template<typename... T> void input(T&... a){(cin >> ... >> a);}
}

namespace cpmath{
//Math library for Competitive-Programming
constexpr ll mod97 = 1000000007;
constexpr ll mod99 = 1000000009;
constexpr ll mod89 = 998244353;
constexpr long double pi = 3.14159265359;
std::unordered_set<long long> allowed_mod;
std::unordered_set<long long> unallowed_mod;

constexpr int DX4[4] = {1, 0, -1, 0};
constexpr int DY4[4] = {0, 1, 0, -1};
constexpr int DX8[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
constexpr int DY8[8] = {-1, -1, -1, 0, 0, 1, 1, 1};

//Calculate n! in mod (fmod)
ll factorial(ll a, ll b = -1, const ll fmod = -1){
ll ans = 1;
if (fmod > 1) {
if (b == -1) for (ll i = a; i > 1; i--) ans = ((ans%fmod)*(i%fmod))%fmod;
else for (ll i = a; i >= b; i--) ans = ((ans%fmod)*(i%fmod))%fmod;
}
else{
if (b == -1) for (ll i = a; i > 1; i--) ans = ans*i;
else for(ll i = a; i >= b; i--) ans = ans*i;
}
return ans;
}

//Calculate m^p
ll fastpow(ll m, ll p){
if (p == 0) return 1;
if (p%2 == 0){
ll t = fastpow(m, p/2);
return t*t;
}
return m*fastpow(m, p-1);
}

//Calculate m^p in mod (fmod)
ll modpow(ll m, ll p, const ll fmod){
if (p == 0) return 1;
if (p%2 == 0){
ll t = modpow(m, p/2, fmod);
return (t*t)%fmod;
}
return (m*modpow(m, p-1, fmod))%fmod;
}

//Angle convert
long double dtor(const long double deg){return deg*(pi/(ld)180);}
long double rtod(const long double rad){return rad*(ld)180/pi;}
//Angle convert

//modint a(integer < 10**18, mod, (bool)Is number for mod prime?)
template <typename T = long long>
class modint{
private:
T num;
long long mod;
bool set_prime_flag;
public:
explicit modint(T n, long long m = cpmath::mod99, bool pflag = true){
num = static_cast<T>(n);
set_prime_flag = pflag;

if (pflag == true){
if (mod_is_prime(m)) mod = m;
else throw std::invalid_argument("Invalid value for mod: Check mod is prime number or set plag to false");
}
else mod = m;
} //modint constructer

//+ operator
constexpr modint operator+(modint &t){return modint((this->raw()+t.raw())%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator+(long long t){return modint((this->raw()+t)%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator+=(modint &t){
this->num = (this->raw()+t.raw())%mod;
return modint(this->num, mod, set_prime_flag);
}
constexpr modint operator+=(long long t){
this->num = (this->raw()+t)%mod;
return modint(this->num, mod, set_prime_flag);
}
//+ operator
//- operator
constexpr modint operator-(modint &t){return modint(((this->raw()-t.raw())%this->mod+this->mod)%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator-(long long t){return modint(((this->raw()-t)%this->mod+this->mod)%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator-=(modint &t){
this->num = ((this->raw()-t.raw())%this->mod+this->mod)%this->mod;
return modint(this->num, this->mod, this->set_prime_flag);
}
constexpr modint operator-=(long long t){
this->num = ((this->raw()+t)%this->mod+this->mod)%this->mod;
return modint(this->num, mod, this->set_prime_flag);
}
//- operator
//* operator
constexpr modint operator*(modint &t){return modint((this->raw()*t.raw())%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator*(long long t){return modint((this->raw()*(t%mod))%this->mod, this->mod, this->set_prime_flag);}
constexpr modint operator*= (modint &t){
this->num = (this->raw()*t.raw())%this->mod;
return modint(this->num, this->mod, this->set_prime_flag);
}
constexpr modint operator*=(long long t){
this->num = (this->raw()*(t%mod))%mod;
return modint(this->num, this->mod, this->set_prime_flag);
}
//* operator

//= operator
constexpr modint operator=(long long t){
this->num = t%mod;
return modint(this->num, this->mod, this->set_prime_flag);
}
//= operator

void plus(T n){num = (num+(n%mod))%mod;}
void minus(T n){num = ((num-(n%mod))%mod+mod)%mod;}
void multi(T n){num = ((num%mod)*(n%mod))%mod;}
void div(T n){
if (set_prime_flag == false) throw std::logic_error("Not Divisible in case you don't set pflag true");
else num = (num*inversed(n))%mod;
}

T raw(){return num;}
private:
long long inversed(ll n){
return cpmath::modpow(n, mod-2, mod);
}

bool mod_is_prime(int n){
if (n == cpmath::mod97 || n == cpmath::mod99 || n == cpmath::mod89 || cpmath::allowed_mod.count(n) > 0){
return true;
}
else if (cpmath::unallowed_mod.count(n) > 0){
return false;
}
else{
for (ll i = 2; i*i <= n; i++){
if (n%i == 0) {
cpmath::unallowed_mod.insert(n);
return false;
}
}
cpmath::allowed_mod.insert(n);
return true;
}
} //mod_is_prime
}; //modint
}

cpio::scanner in; //Declaration of inputclass
using cpio::dout;
using cpio::input;
using cpio::vecin;
using cpmath::mod89;
using cpmath::mod97;
using cpmath::mod99;
using cpmath::modint;

//For Grid serching

//using cpmath::DX4;
//using cpmath::DY4;
//using cpmath::DX8;
//using cpmath::DY8;

//For Grid serching

string next_rotate(string now){
return now[now.size()-1]+now.substr(0, now.size()-1);
}

class dsu{
private:
long long node;
std::vector<long long> parent_or_size;
public:
explicit dsu(long long n) : node(n), parent_or_size(node, -1){}

long long leader(long long x){
check_range(x);
if (parent_or_size[x] < 0) return x;
return parent_or_size[x] = leader(parent_or_size[x]);
}

bool is_united(long long x, long long y){
check_range(x, y);
return leader(x)==leader(y);
}

void unite(long long x, long long y){
check_range(x, y);
x = leader(x);
y = leader(y);
//If x and y already in same union, do nothing.
if (x == y) return;

//Swap X and Y if size of x is more greater than y            
if (-parent_or_size[x] > -parent_or_size[y]) swap(x, y);

//Unite size, set leader of y = x;
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
}//unite

long long union_size(long long x){
check_range(x);
return -parent_or_size[leader(x)];
}

//Returns a list of leaders. Its size equal to number of disjoint-set
std::vector<long long> groups(){
std::vector<long long> leaders;
leaders.push_back(leader(0));
for (long long i = 1; i < node; i++){
//Insert leaders to the list in lexicographic ordering
long long xi = leader(i);
auto itr = lower_bound(leaders.begin(), leaders.end(), xi);
if (*itr != xi) leaders.insert(itr, xi);
}

return leaders;
}
private:
void check_range(long long x){
if (x < 0 || x > node){throw std::invalid_argument("Node selecter out of bounds");}
}

void check_range(long long x, long long y){
if (x < 0 || x > node){throw std::invalid_argument("Node selecter out of bounds : x");}
if (y < 0 || y > node){throw std::invalid_argument("Node selecter out of bounds : y");}
}
}; //dsu

int main(){
int n = in();
vector<int> a(n);
for (int i = 0; i < n; i++){
int xi = in();
a[xi]++;
}

bool ok = true;

if (n%2 == 1){ //If number of people is odd
//A_i = 0 must be one of the people. No two or more.
//All A_i must be even number and counted twice.
for (int i = 0; i < n; i++){
if (i == 0 && a[i] != 1) ok = false;

if (i != 0){
if (a[i] > 0 && i%2 != 0) ok = false;
else if (a[i] != 2 && i%2 == 0) ok = false;
}
}
}
else{ //If number of people is even
//All A_i must be odd number and counter twice.
for (int i = 0; i < n; i++){
if (i%2 == 0 && a[i] > 0) ok = false;
else if (i%2 == 1 && a[i] != 2) ok = false;
}
}

if (ok){
cout << cpmath::modpow(2, n/2, mod97) << endl;
}
else{
cout << 0 << endl;
}
}
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
#define For(i,x,y,...) for(int i=x,##__VA_ARGS__;i<=(y);++i)
#define rFor(i,x,y,...) for(int i=x,##__VA_ARGS__;i>=(y);--i)
#define Rep(i,x,y,...) for(int i=x,##__VA_ARGS__;i<(y);++i)
#define mem(a,x,n) memset(a,x,sizeof(*(a+0))*(n+1))
#define pb emplace_back
#define sz(a) int(a.size())
#define all(a) a.begin(),a.end()
#define MT make_tuple
#define MP make_pair
#define fi first
#define se second
#define priority_queue __gnu_pbds::priority_queue
typedef long long LL; typedef unsigned long long ULL;
typedef pair<int,int> PII; typedef vector<int> VI;
char buf[1<<22],*p1=buf,*p2=buf,pbuf[1<<22],*pp=pbuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
#define ocl() fwrite(pbuf,1,pp-pbuf,stdout),pp=pbuf,0
#define putchar(x) pp-pbuf==1<<22&&(ocl()),*pp++=x
template<typename T>void read(T &x){
x=0;bool f=1;char c;
while(!isdigit(c=getchar()))if(c=='-')f=0;
if(f)for(;isdigit(c);c=getchar())x=x*10+c-48;
else for(;isdigit(c);c=getchar())x=x*10-c+48;
if(c=='.')for(T i=f?10:-10;isdigit(c=getchar());i*=10)x+=(c^48)/i;
}
template<typename T,typename ...Args>void read(T &x, Args &...args)
{ read(x),read(args...); }
template<typename T>void write(T x,char y=10) {
if(!x)putchar(48);
else{static int s[44];int l=0;if(x<0)putchar('-'),x=-x;
for(;x;x/=10)s[l++]=x%10;while(l)putchar(s[--l]|48);}
putchar(y);
}
template<typename X,typename Y>void ckmax(X &x,Y y) { if( x < y ) x = y; }
template<typename X,typename Y>void ckmin(X &x,Y y) { if( y < x ) x = y; }
const int mod = 1e9+7;
template<typename X,typename Y>void ckadd(X &x,Y y) { x = x+y<mod?x+y:x+y-mod; }
template<typename X,typename Y>void ckdel(X &x,Y y) { x = x-y<0?x-y+mod:x-y; }
LL Pow(LL x,LL y=mod-2) {LL z=1;for(;y;y>>=1,x=x*x%mod)if(y&1)z=z*x%mod;return z;}

const int N = 2e5+5, inv2 = Pow(2);
int n,fa[N],h[N],son[N];
LL ans,DP[N],*cur=DP,*f[N],g[N];
VI to[N];

void dfs0(int u) {
for(int v : to[u]) {
dfs0(v);
if( h[v] > h[son[u]] ) son[u] = v;
}
h[u] = h[son[u]]+1;
}

void dfs(int u) {
if( son[fa[u]] == u ) f[u] = f[fa[u]]+1;
else f[u] = cur, cur += h[u];
if( son[u] ) dfs(son[u]);
f[u][0] = inv2;
int lim = 0;
for(int v : to[u]) if( v != son[u] ) dfs(v), ckmax(lim,h[v]);
For(i,0,lim) g[i] = 1 - f[u][i] +mod;
for(int v : to[u]) if( v != son[u] )
Rep(i,0,h[v])
(f[u][i+1] = (f[u][i+1]*(1-f[v][i]+mod) + g[i+1]*f[v][i])) %=mod,
(g[i+1] *= 1 - f[v][i] +mod) %=mod;
//	Rep(i,0,h[u]) cerr<<f[u][i]<<" "; cerr<<endl;
}

signed main() {
#ifdef JK
freopen("a.in","r",stdin);// freopen("a.out","w",stdout);
#endif
read(n); For(i,1,n) read(fa[i]), to[fa[i]].pb(i);
dfs0(0), dfs(0);
Rep(i,0,h[0]) ckadd(ans,f[0][i]);
write(ans*Pow(2,n+1)%mod);
return ocl();
}

//
// Created by whq on 2022/1/14.
//

#include <bits/stdc++.h>

#define uset unordered_set
#define umap unordered_map
#define debug cout<<"ok"<<endl
#define ll long long
#define endl '\n'
#define ii pair<ll, ll>
#define fi first
#define se second
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvl vector<vector<ll>>
#define vl vector<ll>
#define mod 1000000007
#define inf 0x3f3f3f3f
#define For(i, n) for (int i = 0; i < n; i++)
#define forn(i, a, b) for(int i=a;i<=b;i++)
#define rep(i, n) for(int i=1;i<=n;i++)
#define pb(a) push_back(a)
#define all() a.begin(),a.end()
#define lowbit(x) (x&(-x))
#define fr(x) freopen(x,"r",stdin)
#define fw(x) freopen(x,"w",stdout)
using namespace std;

class A {
public:
int solve() {
ll n;
cin >> n;
vector<ii > a(n);
for (int i = 0; i < n; i++) {
cin >> a[i].fi;
a[i].se = 0;
}
ll ans = 0;
ll sum = 0, pre = 0;
auto cmp = [&](const ii &a, const ii &b) {
return a.fi > b.fi;
};
// 新旧 sum
while (true) {
sort(all(a), cmp);
bool ok = 0;
for (int i = 0; i < n; i++) {
if (a[i].fi >= n) {
ll cur = (a[i].fi) / n;
sum += cur;
a[i].fi = (a[i].fi) % n;
ans += cur;
a[i].se = cur;
ok = 1;
}
}
if (!ok) break;
for (int i = 0; i < n; i++) {
a[i].fi += sum - a[i].se;
a[i].se = 0;
}
sum = 0;
}
cout << ans << endl;
return 0;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
A ans;
ans.solve();
return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define int long long int
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

signed main(){
int n, k, cnt = 0;
cin>>n>>k;

for(int i=0; i<n; i++){
int a;
cin>>a;
}

while(1){
n-=k;
cnt++;
if(n<1){
break;
}
n++;
}

cout<<cnt;

return 0;
}

#include <bits/stdc++.h>
#ifdef __LOCAL
#define DBG(X) cout << #X << " = " << (X) << endl;
#define SAY(X) cout << (X) << endl;
#else
#define DBG(X)
#define SAY(X)
#define NDEBUG
#endif

using namespace std;

typedef int_fast32_t int32;
typedef int_fast64_t int64;

const int32 inf = 1e9+7;
const int32 MOD = 1000000007;
const int64 llinf = 1e18;

#define YES(n) cout << ((n) ? "YES\n" : "NO\n"  )
#define Yes(n) cout << ((n) ? "Yes\n" : "No\n"  )
#define POSSIBLE(n) cout << ((n) ? "POSSIBLE\n" : "IMPOSSIBLE\n"  )
#define ANS(n) cout << (n) << "\n"
#define REP(i,n) for(int64 i=0;i<(n);++i)
#define FOR(i,a,b) for(int64 i=(a);i<(b);i++)
#define FORR(i,a,b) for(int64 i=(a);i>=(b);i--)
#define all(obj) (obj).begin(),(obj).end()
#define rall(obj) (obj).rbegin(),(obj).rend()
#define fi first
#define se second
#define pb(a) push_back(a)
typedef pair<int32,int32> pii;
typedef pair<int64,int64> pll;

template<class T> inline bool chmax(T& a, T b) {
if (a < b) { a = b; return true; } return false;
}
template<class T> inline bool chmin(T& a, T b) {
if (a > b) { a = b; return true; } return false;
}

template<int64 mod>
struct ModInt{
int64 x;
constexpr ModInt(int64 y = 0):x((y%mod+mod)%mod){}
constexpr ModInt& operator+=(const ModInt& a){
if((x += a.x) >= mod) x -= mod;
return *this;
}
constexpr ModInt& operator-=(const ModInt& a){
if((x -= a.x) < 0)x += mod;
return *this;
}
constexpr ModInt& operator*=(const ModInt& a){
x = x * a.x % mod;
return *this;
}
constexpr ModInt& operator/=(const ModInt& a){
*this *= a.inv();
return *this;
}
constexpr ModInt operator-() const {
return ModInt(-x);
}
constexpr ModInt operator+(const ModInt& a) const {
return ModInt(*this) += a;
}
constexpr ModInt operator-(const ModInt& a) const {
return ModInt(*this) -= a;
}
constexpr ModInt operator*(const ModInt& a) const {
return ModInt(*this) *= a;
}
constexpr ModInt operator/(const ModInt& a) const {
return ModInt(*this) /= a;
}
constexpr ModInt operator++(){
*this += ModInt(1);
return *this;
}
constexpr ModInt operator++(int){
ModInt old = *this;
++*this;
return old;
}
constexpr ModInt operator--(){
*this -= ModInt(1);
return *this;
}
constexpr ModInt operator--(int){
ModInt old = *this;
--*this;
return old;
}
constexpr bool operator==(const ModInt& a) const {
return x == a.x;
}
constexpr bool operator!=(const ModInt& a) const {
return x != a.x;
}
constexpr ModInt pow(int64 r) const {
if(!r)return 1;
ModInt res = pow(r>>1);
res *= res;
if(r & 1) res *= *this;
return res;
}
constexpr ModInt inv() const {
return pow(mod-2);
}
friend istream& operator>>(istream& is, ModInt& a){
int64 t;
is >> t;
a = ModInt(t);
return is;
}
friend ostream& operator<<(ostream& os, const ModInt& a){
return os << a.x;
}
};
using mint = ModInt<MOD>;

template<typename T>
struct SegmentTree{
typedef function<T(T,T)> F;
int n;    //要素数
F f;    //2項演算
T e;    //単位元
vector<T> dat;
SegmentTree(int n_,F f,T e):f(f),e(e){
init(n_);
build();
}
SegmentTree(int n_,F f,T e,vector<T>& v):f(f),e(e){
init(n_);
build(n_,v);
}
void init(int n_){
n=1;
while(n<n_)n<<=1;
dat.clear();
dat.resize(n<<1, e);
}
void build(int n_,const vector<T>& v){
for(int i=0;i<n_;++i)dat[n+i]=v[i];
build();
}
void build(){
for(int i=n-1;i>=1;--i){
dat[i] = f(dat[i<<1],dat[i<<1|1]);
}
}
void update(int k,const T& x){
dat[k+=n]=x;
while(k>>=1){
dat[k] = f(dat[k<<1],dat[k<<1|1]);
}
}
T query(int a,int b){
T l=e,r=e;
for(a+=n,b+=n;a<b;a>>=1,b>>=1){
if(a&1)l=f(l,dat[a++]);
if(b&1)r=f(dat[--b],r);
}
return f(l,r);
}
T operator[](const int &k) const {
return dat[n+k];
}
};

int main(){
cin.tie(0);
ios::sync_with_stdio(false);
int32 n;
cin >> n;
vector<pair<pii,int32>> ps(n*2);
REP(i,n){
cin >> ps[i].fi.fi >> ps[i].fi.se;
ps[i].se = 0;
}
FOR(i,n,2*n){
cin >> ps[i].fi.fi >> ps[i].fi.se;
ps[i].se = 1;
}

sort(all(ps));
int32 ans = 0;
set<int32> ys;
REP(i,2*n){
if(ps[i].se == 0){
ys.insert(ps[i].fi.se);
}else{
auto iter = ys.lower_bound(ps[i].fi.se);
if(iter != ys.begin()){
++ans;
--iter;
ys.erase(iter);
}
}
}
ANS(ans);
return 0;
}
//#include<bits/extc++.h>
#include<bits/stdc++.h>
//#define clock chrono1:steady_clock::now().time_since_epoch().count()
//#define x() real()
//#define y() imag()
//#define int long long
//#define double long double

using namespace std;

using pii = pair<int, int>;
using pll = pair<long long, long long>;
//using orderedSet = __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>,
//  __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;

int h, w; 
string S[12];
int to[12];
int cnt = 0;
int used = 0;
bool ok = false;
void recur() {
if (__builtin_popcount(used) == w) {
multiset<string> se;
for(int i = 0; i < h; i++) {
string tmp;
for(int j = 0; j < w; j++)
tmp += ' ';
for(int j = 0; j < w; j++) {
if (to[j] == -1)
tmp[j] = S[i][j];
else
tmp[j] = S[i][to[j]];
}
if (se.find(tmp) != se.end())
se.erase(se.find(tmp));
else
se.insert(S[i]);
}
if (se.size() == 1) {
string str = *(se.begin());
string rev = str;
for(int i = 0; i < w; i++) {
if (to[i] == -1)
rev[i] = str[i];
else
rev[i] = str[to[i]];
}
if (str == rev)
se.erase(se.find(str));
}
if (se.empty())
ok = true;
}

int fir = 0;
while(used & (1 << fir))
fir++;
used |= (1 << fir);
for(int i = fir + 1; i < w; i++) {
if (!(used & (1 << i))) {
used ^= (1 << i);
to[fir] = i;
to[i] = fir;
recur();
used ^= (1 << i);
to[fir] = -1;
to[i] = -1;
}
}
used ^= (1 << fir);
}

signed main() {
ios::sync_with_stdio(false), cin.tie(NULL);

for(int i = 0; i < 12; i++)
to[i] = -1;

cin >> h >> w;
for(int i = 0; i < h; i++)
cin >> S[i];

if (w & 1) {
for(int i = 0; i < w; i++) {
used ^= (1 << i);
recur();
used ^= (1 << i);
}
} else {
recur();
}

cout << ((ok) ? "YES\n" : "NO\n");

return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007

ll freq[100005];

ll fact[100005];

ll f(ll n)
{
if(fact[n])
return fact[n];
if(n == 0 || n == 1)
return 1;

fact[n] = (n*f(n-1))%mod;
return fact[n];
}

ll bigmod(ll b, ll p)
{
if(p == 0)
return 1;
if(p == 1)
return b%mod;

ll res = bigmod(b, p>>1);
res = (res*res)%mod;
if(p&1)
return (b*res)%mod;
return res;
}

ll invmod(ll b)
{
return bigmod(b, mod-2);
}

ll nCr(ll n, ll r)
{
if(n < r)
return 0;
return ((f(n) * invmod(f(r)))%mod * invmod(f(n-r)))%mod;
}

int main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

int n, a, i, k, x, y;

cin >> n;

for(i = 1; i <= n+1; i++)
{
cin >> a;

if(freq[a] != 0)
{
x = freq[a];
y = i;
}

freq[a] = i;
}

for(k = 1; k <= n+1; k++)
cout << ((nCr(n+1, k) - nCr(x-1 + n+1-y, k-1))%mod + mod)%mod << "\n";
}

#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<assert.h>
#include<random>
#include<string>
#include<algorithm>
#include<queue>
#include<bitset>

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()

const long long mod = 1e9 + 7;
const long long inf = 1e18;
const int N = 100010;

using ll = long long;

using namespace std;

ll a[N];

void solve()
{
int n;
ll x;
cin >> n >> x;

for (int i = 0; i < n; i++)
cin >> a[i];

ll ans = 0;

for (int i = 0; i < n - 1; i++)
{
if (a[i + 1] + a[i] > x)
{
ll t = a[i + 1] + a[i] - x;
if (t >= a[i + 1]) a[i] -= t - a[i], a[i + 1] = 0;
else a[i + 1] -= t;
ans += t;
}
}

cout << ans << '\n';
}

signed main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
#include <iostream>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
#include <cstring>

using namespace std;
#define int long long
using ll = long long;
int const INF = 0x3f3f3f3f;
int const MOD = 1e9 + 7;
int const N = 1e5 + 10;
int a[N];

signed main() {
ios::sync_with_stdio(false);
int n, x;
cin >> n >> x;
for (int i = 1; i <= n; i++) cin >> a[i];
int ans = 0;
if (a[1] > x) ans += a[1] - x, a[1] -= (a[1] - x);
for (int i = 2; i <= n; i++)
if (a[i] + a[i - 1] > x) {
int t = a[i] + a[i - 1] - x;
ans += t;
a[i] -= t;
}
cout << ans << endl;
return 0;
}
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e6+5;
int n;
int dis[N],vis[N],c;
struct node{
int v,w;
bool operator<(const node&n)const{
return w>n.w;
}
};
priority_queue<node>pq;
void dijkstra()
{
memset(dis,0x7f,sizeof(dis));
pq.push((node){0,0});
dis[0]=c=0;
while(!pq.empty())
{
int k=pq.top().v;
pq.pop();
if(vis[k])
continue;
vis[k]=1;
for(int i=0;i<=9;i++)
{
if(dis[k]+i<dis[(k*10+i)%n])
{
dis[(k*10+i)%n]=dis[k]+i;
pq.push((node){(k*10+i)%n,dis[k]+i});
}
}
if(!c)
vis[k]=0,dis[k]=2147483647,c=1;
}
}
int main()
{
scanf("%d",&n);
dijkstra();
printf("%d",dis[0]);
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=500025;
int n,m,i,j,t,k,L[maxn],R[maxn],loc[maxn],v[maxn],tr[maxn];ll s;

inline void Set(int x,int y)
{
if ((loc[y]&&loc[y]!=x)||(v[x]&&v[x]!=y)){puts("-1");exit(0);}
loc[y]=x;v[x]=y;
}
inline void add(int x,int y){for(;x<=n;x+=(x&(-x)))tr[x]+=y;}
inline int query(int x){int ret=0;for(;x;x-=(x&(-x)))ret+=tr[x];return ret;}

int main()
{
scanf("%d",&n);
for (i=1;i<=n;++i) scanf("%d%d",&L[i],&R[i]);
for (i=1;i<n;++i)
{
if (L[i]>L[i+1]||R[i]>R[i+1]) {puts("-1");return 0;}
if (L[i+1]==i+1&&R[i]>i) {puts("-1");return 0;}
if (R[i]==i&&L[i+1]<=i) {puts("-1");return 0;}
}//printf("ksdsd\n");
for (i=1;i<=n;++i)
{
if (L[i]^L[i+1]) Set(i,L[i]);
if (R[i]^R[i-1]) Set(i,R[i]);
}
t=1;
for (i=1;i<=n;++i) if (!v[i])
{
while (loc[t]) ++t;
v[i]=t++;
}t=0;
//for (i=1;i<=n;++i) printf("%d\n",v[i]);
for (i=1;i<=n;++i)
{
t=max(t,v[i]);
if (t^R[i]) {puts("-1");return 0;}
}t=1145141919;
for (i=n;i>0;--i)
{
t=min(t,v[i]);
if (t^L[i]) {puts("-1");return 0;}
}s=0;
for (i=1;i<=n;++i)
{
add(v[i],1);s+=i-query(v[i]);
}
printf("%lld\n",s);
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<11>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod = 1000000007;
const int mod998244353 = 998244353;

// 汎用構造体
struct edge { int to, idx; long long cost; };

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
int n, k;
cin >> n >> k;
vector<int> a(n);
rep(i, n) cin >> a[i];

int ans = (n-1)/(k-1);
if((n-1)%(k-1)) ++ans;
cout << ans << endl;
}
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

#define fs(n) fixed << setprecision(n)
#define mp(a, b) make_pair(a, b)
#define all(x) x.begin(), x.end()
#define const constexpr
#define pdesc(t) t, vector<t>, greater<t>
using ll = long long;
using ld = long double;
#define query(t) for(int _ = 0; _ < t; _++)
#define aryin(a, n) for(int i = 0; i < n; i++) cin >> a[i];
#define chmin(a, b) a = min(a, b)


int main(){
cin.tie(nullptr);
ios_base::sync_with_stdio(false);

int n, m; cin >> n >> m;
dsu d(n);
vector<int> p(n);
aryin(p, n);

for(int i = 0; i < m; i++){
int x, y; cin >> x >> y;
d.merge(x - 1, y - 1);
}

int ans = 0;
for(auto s : d.groups()){
set<int> st;
for(int v : s){
st.insert(p[v] - 1);
}
for(int v : s){
if(st.find(v) != st.end()){
ans++;
}
}
}

cout << ans << endl;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
unordered_map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
mp.reserve(1e5); cnt.reserve(1e5);
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define N 100010
typedef long long ll;
char s[N];
int n;
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>(s+1);
n=strlen(s+1);
if(s[1]=='0'||s[n]=='1'){
cout<<-1<<'\n';return 0;
}
for(int i=1;i<n;++i){
if(s[i]!=s[n-i]){
cout<<-1<<'\n';return 0;
}
}
for(int i=1,u=1;i<n;++i){
cout<<u<<' '<<i+1<<'\n';
if(s[i]=='1')u=i+1;
}
return 0;
}



#include <algorithm>
#include <iostream>
#include <numeric>
#include <cstring>
#include <iomanip>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <cmath>
#include <set>
#include <map>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int maxn = 2e5+10;
const ll inf = 1e16;

ll arr[maxn];
char opr[maxn];
ll dp[maxn][3];

int32_t main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int n; cin >> n;
for(int i = 0; i < n; i++)
{
cin >> arr[i];
if(i < n-1)
cin >> opr[i+1];
}
dp[0][0] = arr[0];
dp[0][1] = dp[0][2] = -inf;
for(int i = 1; i < n; i++)
{
if(opr[i] == '+')
{
dp[i][0] = max(dp[i-1][0] + arr[i], max(dp[i-1][1] + arr[i], dp[i-1][2] + arr[i]));
dp[i][1] = max(dp[i-1][1] - arr[i], dp[i-1][2] + arr[i]);
dp[i][2] = dp[i-1][2] + arr[i];
}
else
{
dp[i][0] = max(dp[i-1][0] - arr[i], max(dp[i-1][1] + arr[i], dp[i-1][2] + arr[i]));
dp[i][1] = max(dp[i-1][0] - arr[i], max(dp[i-1][1] + arr[i], dp[i-1][2] + arr[i]));
dp[i][2] = max(dp[i-1][1] + arr[i], dp[i-1][2] + arr[i]);
}
}
cout << max(dp[n-1][0], max(dp[n-1][1], dp[n-1][2])) << endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> pii;
typedef vector<pair<int,int>> vpii;
typedef vector<long long> vl;

int main(){
int N;
cin >> N;
int a;
set<int> s;
for(int i=0; i<N; i++){
cin >> a;
s.insert(a);
}
int ans=s.size();
if(ans%2==0) ans--;
cout << ans << endl;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <unordered_map>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 998244353, LOG = 301;
int X;
struct SegTree {
struct Node {
int mn, mx, upd, add;
Node(int x = 0, int y = 0) :
mn(x), mx(y), upd(-1), add(0) {}
Node operator+(const Node& a) {
return Node(min(a.mn, mn), max(a.mx, mx));
}
};

int size;
vector <Node> tree;
SegTree(vector <int>& a) {
size = 1;
while (size < a.size()) size <<= 1;
tree.resize(2 * size - 1);
build(0, 0, size, a);
}
void push(int v, int lx, int rx) {
if (lx + 1 == rx) return;
if (tree[v].upd != -1) {
tree[v].upd += tree[v].add;
tree[v].add = 0;
}
if (tree[v].upd != -1) {
tree[2 * v + 1].upd = tree[v].upd;
tree[2 * v + 2].upd = tree[v].upd;
tree[2 * v + 1].add = 0;
tree[2 * v + 2].add = 0;
tree[2 * v + 1].mn = tree[v].upd;
tree[2 * v + 2].mn = tree[v].upd;
tree[2 * v + 1].mx = tree[v].upd;
tree[2 * v + 2].mx = tree[v].upd;
tree[v].upd = -1;
}
else if (tree[v].add != 0) {
tree[2 * v + 1].add += tree[v].add;
tree[2 * v + 2].add += tree[v].add;
tree[2 * v + 1].mn += tree[v].add;
tree[2 * v + 2].mn += tree[v].add;
tree[2 * v + 1].mx += tree[v].add;
tree[2 * v + 2].mx += tree[v].add;
tree[v].add = 0;
}
}
void build(int v, int lx, int rx, vector <int>& a) {
if (lx + 1 == rx) {
if (lx < a.size()) tree[v] = Node(a[lx], a[lx]);
else tree[v] = Node(X, X);
return;
}
int m = (lx + rx) / 2;
build(2 * v + 1, lx, m, a);
build(2 * v + 2, m, rx, a);
tree[v] = tree[2 * v + 1] + tree[2 * v + 2];
}
int lastSmall(int v, int lx, int rx, int x) {
if (tree[v].mn > x) return -1;
if (lx + 1 == rx) return lx;
push(v, lx, rx);
int m = (lx + rx) / 2;
if (tree[2 * v + 2].mn <= x)
return lastSmall(2 * v + 2, m, rx, x);
return lastSmall(2 * v + 1, lx, m, x);
}
int lastSmall(int x) {
return lastSmall(0, 0, size, x);
}
int firstBig(int v, int lx, int rx, int x) {
if (tree[v].mx < x) return size;
if (lx + 1 == rx) return lx;
push(v, lx, rx);
int m = (lx + rx) / 2;
if (tree[2 * v + 1].mx >= x)
return firstBig(2 * v + 1, lx, m, x);
return firstBig(2 * v + 2, m, rx, x);
}
int firstBig(int x) {
return firstBig(0, 0, size, x);
}
void add(int v, int lx, int rx, int l, int r, int x) {
if (l <= lx and rx <= r) {
tree[v].add += x;
tree[v].mn += x;
tree[v].mx += x;
return;
}
if (rx <= l or r <= lx)
return;
push(v, lx, rx);
int m = (lx + rx) / 2;
add(2 * v + 1, lx, m, l, r, x);
add(2 * v + 2, m, rx, l, r, x);
tree[v] = tree[2 * v + 1] + tree[2 * v + 2];
}
void upd(int v, int lx, int rx, int l, int r, int x) {
if (l <= lx and rx <= r) {
tree[v].upd = x;
tree[v].add = 0;
tree[v].mn = tree[v].mx = x;
return;
}
if (rx <= l or r <= lx)
return;
push(v, lx, rx);
int m = (lx + rx) / 2;
upd(2 * v + 1, lx, m, l, r, x);
upd(2 * v + 2, m, rx, l, r, x);
tree[v] = tree[2 * v + 1] + tree[2 * v + 2];
}
void add(int l, int r, int x) {
add(0, 0, size, l, r, x);
}
void upd(int l, int r, int x) {
upd(0, 0, size, l, r, x);
}
int get(int v, int lx, int rx, int i) {
if (lx + 1 == rx) {
return tree[v].mx;
}
push(v, lx, rx);
int m = (lx + rx) / 2;
if (i < m)
return get(2 * v + 1, lx, m, i);
return get(2 * v + 2, m, rx, i);
}
int get(int i) {
return get(0, 0, size, i);
}
};

signed main() {
ios_base::sync_wih_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);

int n, k; cin >> X >> k;
vector <int> r(k + 2);
for (int i = 1; i <= k; ++i)
cin >> r[i];
r[k + 1] = mod * mod;
cin >> n;
vector <int> t(n), a(n), ans(n), all(n);
for (int i = 0; i < n; ++i) {
cin >> t[i] >> a[i];
all[i] = a[i];
}
sort(all.begin(), all.end());
SegTree ST(all);

int step = 0, curId = 0;
while (step <= k) {
if (step & 1 ^ 1) {
while (curId < n and t[curId] < r[step + 1]) {
int need = lower_bound(all.begin(), all.end(), a[curId])
- all.begin();
ans[curId] = max(0ll, ST.get(need) - t[curId] + r[step]);
curId++;
}
int id = ST.firstBig(r[step + 1] - r[step]);
ST.upd(0, id, 0);
ST.add(id, ST.size, r[step] - r[step + 1]);
}
else {
while (curId < n and t[curId] < r[step + 1]) {
int need = lower_bound(all.begin(), all.end(), a[curId])
- all.begin();
ans[curId] = min(X, ST.get(need) + t[curId] - r[step]);
curId++;
}
int id = ST.lastSmall(X - (r[step + 1] - r[step])) + 1;
ST.add(0, id, r[step + 1] - r[step]);
ST.upd(id, ST.size, X);
}
step++;
}

for (auto& x : ans) cout << x << '\n';
cout << '\n';

return 0;
}
// Author: Z_char 

#include <bits/stdc++.h>

// head...
using i64 = long long; using u64 = unsigned long long; using u16 = unsigned short; using i16 = short; using u32 = unsigned int; using pii = std::pair<int, int>; using f64 = double; using f80 = long double;
template<class T> using ve = std::vector<T>;
template<class T> using fun = std::function<T>;
template<class T1, class T2> using pr = std::pair<T1, T2>;
template<class T> using pq = std::priority_queue<T>;
template<class T> using lpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template<class T> using gpq = std::priority_queue<T, std::vector<T>, std::less<T>>;
#define all(x) x.begin(), x.end()
#define rg(v, l, r) &v[l], &v[r + 1]
#define vrg(v, l, r) (v).begin() + l, (v).begin() + r + 1
#define freop(x) (freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout))
std::mt19937_64 seed(std::chrono::steady_clock::now().time_since_epoch().count());
#define zxrnd(l, r) std::uniform_int_distribution<i64>(l, r)(seed)
#ifdef Z_char
template<class T> inline void debug_out(T x, char ch = '\n') { std::cerr << x << ' ' << ch; }
template<class T, class... Args> inline void debug_out(T fir, Args... args) { debug_out(fir, ' '), debug_out(args...); }
#define frein(x) freopen(#x".in", "r", stdin)
#define freout(x) freopen(#x".out", "w", stdout)
#define debug_line(...) std::cerr << "work[" << __LINE__ << "]" << ": " << "[" << #__VA_ARGS__ << "]" << " = ", debug_out(__VA_ARGS__)
#define debug(...) std::cerr << "[" << #__VA_ARGS__ << "] = ", debug_out(__VA_ARGS__)
#define debugpos std::cerr << "Running " << __FUNCTION__ << " on line " << __LINE__ << "..." << '\n'
#define debugstop std::cerr << "Running " << __FUNCTION__ << " on line " << __LINE__ << "..." << '\n', system("pause")
#define dprint(...) fprintf(stderr, __VA_ARGS__)
#define dwrite(...) write(__VA_ARGS__)
#define asert(...) assert(__VA_ARGS__)
struct _Timer_check {
clock_t val;
void operator()(bool flg = false) {
clock_t now = clock();
if (!flg) debug((1.0 * now - val) / CLOCKS_PER_SEC);
val = now;
}
};
_Timer_check cktime;
#else 
u32 def_cnt = 0;
#define frein(x) ++def_cnt
#define freout(x) ++def_cnt
#define debug_line(...) ++def_cnt
#define debug(...) ++def_cnt
#define debugpos ++def_cnt
#define debugstop ++def_cnt
#define dprint(...) ++def_cnt
#define dwrite(...) ++def_cnt
#define asert(...) ++def_cnt
#define cktime(...) ++def_cnt
#endif
template<class T> void memset(int val, T& fir) { memset(fir, val, sizeof fir); }
template<class T, class... args> void memset(int val, T& fir, args&... arg) { memset(fir, val, sizeof fir), memset(val, arg...); }
template<class T> 
inline T read() {
T x = 0; int f = 1; char ch = getchar();
for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
for (;  isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;
return x * f;
}
template<class T> inline void read(T &x) { x = read<T>(); }
template<class T, class... Args> inline void read(T &fir, Args&... args) { read(fir), read(args...); }
template<class T> 
inline void write(T x, char ch = '\n') {
static int stk[32];
if (x < 0) putchar('-'), x = -x;
int top = 0;
do stk[++top] = x % 10, x /= 10; while(x);
while (top) putchar(stk[top--] + 48);
putchar(ch);
}
template<class T, class... Args> inline void write(T fir, Args... args) { write(fir, ' '), write(args...); }
// head...

const int D = 1e9 + 7;

const int K = 73, N = 350;

char str[K];
i64 fac[N], ifac[N];

inline i64 pwer(i64 a, i64 b, i64 ret = 1) {
for (; b; b >>= 1, a = a * a % D)
if (b & 1) ret = ret * a % D;
return ret;
}

inline void solv() {
int n = read<int>(), m = read<int>();
scanf("%s", str + 1);
int top = 0;
static int stk[73], cnt[73];
stk[0] = n;
auto check = [&]() {
if (!top) return false;
std::queue<int> q;
static int f[K], vis[K], p[K];
memset(0, f, vis, p);
for (int i = 1, j = 1; i <= m; ++i) {
if (str[i] == 'r') {
if (j <= top) {
if (stk[j] > 0) q.push(j);
else p[j] = true;

++j, vis[i] = true;
}
}
else {
if (size(q)) {
f[i] = stk[q.front()] - 1;
p[q.front()] = 1;
vis[i] = true;
q.pop();
}
}
}
if (std::count(p + 1, p + top + 1, 0)) return false;
for (int i = m, cnt = 0; i >= 1; --i) {
if (vis[i]) {
if (f[i]) {
if (cnt < f[i]) return false;
cnt -= f[i];
}
}
else {
++cnt;
}
}
return true;
};
auto binom = [&](int n, int m)->i64 {
if (n < m) {
return 0;
}
return fac[n] * ifac[m] % D * ifac[n - m] % D;
};
i64 ans = 1;
fun<void(int)> dfs = [&](int now) {
if ((now + cnt[0]) * 2 - 1 > n) return;
if (check()) {
i64 ret = fac[top];
for (int i = 0; i <= stk[1]; ++i) {
ret = ret * ifac[cnt[i]] % D;
}
// ret = ret * binom(n - 2 - top * 2 - 1, 2 * (now + top) - cnt[0]) % D;
ret = ret * binom(n + top * 2 - cnt[0] * 2 + 1, 2 * (now + top)) % D;
ans += ret;
if (ans >= D) ans -= D;
}
for (int i = stk[top]; i >= 0; --i) { // 枚举新一段段数
stk[++top] = i;
++cnt[i];
dfs(now + i);
--top;
--cnt[i];
}
};
dfs(0);
write(ans);
}
inline void pre_work() {
fac[0] = 1, ifac[0] = 1;
for (int i = 1; i < N; ++i) {
fac[i] = fac[i - 1] * i % D;
ifac[i] = pwer(fac[i], D - 2);
}
}

signed main() {
pre_work();
int z_char = 1;
// int z_char = read<int>();
while (z_char--) solv();
}
// St. JR bless you

#include<bits/stdc++.h>
#define endl "\n"
using namespace std;
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
int n, x, sum=0;
cin >> n;
map<long long int,long long int>mp;
while(n--)
{
cin >> x;
mp[x]++;
}
map<long long int, long long int>::iterator it;
for(it=mp.begin();it!=mp.end();it++)
{
if(it->first==it->second)
continue;
else if(it->first>it->second)
sum+=it->second;
else sum+=(it->second-it->first);
}
cout << sum;
return 0; //Abdullah
}

#include <bits/stdc++.h>
using namespace std;
#define lowbit(x) (x &(-x))
#define int long long
#define INF 0x3f3f3f3f
const double PI = acos(-1.0);
const int maxn=1e5+5;
#define faster ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)
int gcd(int a,int b){ return b?gcd(b,a%b):a;}
int a[maxn];
signed main(){
faster;
int n; cin >> n;
int g=0,f=0;
for (int i = 0; i < n; ++i) {
cin >> a[i];
if (a[i]%4==0) g++;
else if (a[i]%2==0) f++;
}
int m=n-(f+g);
if (f!=0&&g>=m||f==0&&g>=n/2) cout << "Yes" << endl;
else cout << "No" << endl;
return 0;
}
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
int mod = 1e9 + 7;

const int N = 5e3 + 20;
vector<int> adj[N];
int dp[N][N], dp2[N][2][N], f[N], ans_all[N], cnt[N];

inline void mkey(int& x)
{
while (x >= mod) x -= mod;
while (x < 0) x += mod;
return;
}

void dfs(int u, int pp = -1)
{
int xx = 0;
dp2[u][0][1] = 1;
cnt[u] = 1;
for (int v : adj[u])
{
if (v == pp) continue;
dfs(v, u);
for (int t1 = 1; t1 <= cnt[u]; t1++) 
{
int bb = 1ll * dp2[u][xx][t1] * ans_all[v] % mod;
mkey(bb = -bb);
mkey(dp2[u][1 - xx][t1] += bb);
for (int t2 = 1; t2 <= cnt[v]; t2++)
{
mkey(dp2[u][1 - xx][t1 + t2] += 1ll * dp2[u][xx][t1] * dp[v][t2] % mod);
}
}
cnt[u] += cnt[v];
for (int i = 0; i <= cnt[u]; i++) dp2[u][xx][i] = 0;
xx ^= 1;
}
for (int i = 1; i <= cnt[u]; i++)
{
dp[u][i] = dp2[u][xx][i];
if (!(i & 1)) mkey(ans_all[u] += 1ll * f[i] * dp[u][i] % mod);
}
return;
}

int main()
{
f[0] = 1;
for (int i = 2; i < N; i += 2) f[i] = 1ll * f[i - 2] * (i - 1) % mod;
int n;
cin >> n;
for (int i = 0; i < n - 1; i++)
{
int u, v;
cin >> u >> v;
u--; v--;
adj[u].push_back(v);
adj[v].push_back(u);
}
dfs(0);
cout << ans_all[0];
return 0;
}

#include <bits/stdc++.h>
#define fast ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL)
#define ll long long int
#define ld long double
using namespace std;
const int N = 1e6 + 5;
const int MOD = 1e9 + 7;
int n, ans, component[N];
pair<int, pair<int, int> > points[N];
vector<pair<int, pair<int, int> > > edges;

bool cmp(pair<int, pair<int, int> > a, pair<int, pair<int, int> > b){
return a.second.first < b.second.first;
}

int find(int a){
while(true){
if(a == component[a])
return a;
component[a] = component[component[a]];
a = component[a];
}
}

void merge(int a, int b){
int u = find(a), v = find(b);
component[u] = component[v];
}

void MST(){
for(int i = 0; i < edges.size(); ++i){
int cost = edges[i].first, u = edges[i].second.first, v = edges[i].second.second;
if(find(u) == find(v))
continue;
// cout << cost << '\n';
merge(u, v);
ans += cost;
}
}

int main(){
fast;
cin >> n;
for(int i = 0; i < n; ++i)
component[i] = i;
for(int i = 0; i < n; ++i) {
cin >> points[i].first >> points[i].second.first;
points[i].second.second = i;
}
sort(points, points + n);
for(int i = 1; i < n; ++i)
edges.push_back({points[i].first - points[i - 1].first, {points[i].second.second, points[i - 1].second.second}});
sort(points, points + n, cmp);
for(int i = 1; i < n; ++i)
edges.push_back({points[i].second.first - points[i - 1].second.first, {points[i].second.second, points[i - 1].second.second}});
sort(edges.begin(), edges.end());
MST();
cout << ans << '\n';
return 0;
}
#include <bits/stdc++.h>

using namespace std;

vector<int> p_function(string s) {
int n = s.size();
vector<int> p(n);
for (int i = 1; i < n; i++) {
int j = p[i - 1];
while (j > 0 && s[i] != s[j])
j = p[j - 1];
if (s[i] == s[j])
j++;
p[i] = j;
}
return p;
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
string w;
cin >> w;
int n = w.size();
vector<int> p = p_function(w);
int len = n - p[n - 1];
if (p[n - 1] == 0 || n % len != 0) cout << "1 1\n";
else if (len == 1) cout << n << " 1\n";
else {
vector<int> pref(n + 1), suf(n + 1);
pref[1] = 1;
for (int i = 2; i <= n; i++) {
int len = i - p[i - 1];
if (p[i - 1] == 0 || i % len != 0) pref[i] = 1;
}
reverse(w.begin(), w.end());
p = p_function(w);
reverse(w.begin(), w.end());
suf[1] = 1;
for (int i = 2; i <= n; i++) {
int len = i - p[i - 1];
if (p[i - 1] == 0 || i % len != 0) suf[i] = 1;
}
int cnt = 0;
for (int i = 1; i < n; i++) {
if (pref[i] == 1 && suf[n-i] == 1) {
cnt++;
}
}
cout << "2 " << cnt << '\n';
}
return 0;
}
#include <bits/stdc++.h>
#include <math.h>

#include <algorithm>
#include <array>
#include <atcoder/all>
#include <bitset>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <sstream>
#include <vector>

using namespace std;
using namespace atcoder;

using Graph = vector<vector<int>>;

using ll = long long;
typedef pair<ll, ll> P_ll;
typedef pair<int, int> P;

const ll INF_ll = 1e17;
const int INF = 1e8;
template <class T>
bool chmax(T& a, const T& b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}

int main() {
int A, B;
cin >> A >> B;
char a, b;
if (A > B) {
swap(A, B);
a = '#';
b = '.';
} else {
a = '.';
b = '#';
}

vector<string> X(100, string(100, a));
int ca = 1;
int cb = 0;
int next_h = 0;
for (int i = 1; i < 100; i += 4) {
bool ok = false;
for (int j = 1; j < 100; j += 4) {
if (ca == A) {
ok = true;
break;
}
for (int k = -1; k <= 1; k++) {
for (int l = -1; l <= 1; l++) {
if (k == 0 && l == 0) {
continue;
}
X[i + k][j + l] = b;
}
}
ca++;
cb++;
}
if (ok) {
next_h = i + 3;
break;
}
}

for (int i = next_h; i < 100; i += 2) {
for (int j = 1; j < 100; j += 2) {
if (cb == B) {
continue;
}
X[i][j] = b;
cb++;
}
}

cout << 100 << " " << 100 << endl;
for (int i = 0; i < 100; i++) {
cout << X[i] << endl;
}

return 0;
}
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int maxn = 400;
int l[maxn], r[maxn];
struct edge {
int to, nxt, val;
};
edge G[maxn * maxn];
int head[maxn], cnt = 1;
inline void AddEdge(int, int);
inline int dinic(int, int);
int n;

int main() {
scanf("%d", &n);
int lc = 0, rc = 0;
int a, las = -1;
for (int i = 1; i <= n; i++) {
scanf("%d", &a);
if (las == -1)
(a & 1 ? l[++lc] : r[++rc]) = a;
else if (las + 1 != a)
((las + 1) & 1 ? l[++lc] : r[++rc]) = las + 1, (a & 1 ? l[++lc] : r[++rc]) = a;
las = a;
}
((las + 1) & 1 ? l[++lc] : r[++rc]) = las + 1;
for (int i = 1; i <= lc; i++) AddEdge(1, i + 2);
for (int i = 1; i <= rc; i++) AddEdge(i + lc + 2, 2);
int tmp;
bool flag;
for (int i = 1; i <= lc; i++)
for (int j = 1; j <= rc; j++) {
tmp = (l[i] > r[j] ? l[i] - r[j] : r[j] - l[i]), flag = (tmp != 1);
for (int x = 2; x * x <= tmp; x++)
if (!(tmp % x)) {
flag = false;
break;
}
if (flag)
AddEdge(i + 2, j + lc + 2);
}
int f = dinic(1, 2), mi = lc < rc ? lc : rc;
int ans = f + ((mi - f) & 1) * 3 + ((((lc - f) >> 1) + ((rc - f) >> 1)) << 1);
printf("%d\n", ans);
return 0;
}

inline void AddEdge(const int u, const int v) {
G[++cnt] = { v, head[u], 1 }, head[u] = cnt;
G[++cnt] = { u, head[v], 0 }, head[v] = cnt;
return;
}

int d[maxn];

queue<int> Q;
inline bool bfs(const int s, const int t) {
memset(d, 0, sizeof(d));
d[s] = 1, Q.push(s);
int u;
while (!Q.empty()) {
u = Q.front(), Q.pop();
for (int i = head[u]; i; i = G[i].nxt)
if (!d[G[i].to] && G[i].val) {
d[G[i].to] = d[u] + 1, Q.push(G[i].to);
if (G[i].to == t) {
while (!Q.empty()) Q.pop();
return true;
}
}
}
return false;
}

int cur[maxn];

int dfs(const int u, const int t, int flow) {
if (u == t || !flow)
return flow;
int ret = 0, tmp;
for (int& i = cur[u]; i; i = G[i].nxt)
if (d[G[i].to] == d[u] + 1 && G[i].val) {
tmp = dfs(G[i].to, t, 1);
G[i].val -= tmp, G[i ^ 1].val += tmp, ret += tmp, flow -= tmp;
if (!flow)
break;
}
return ret;
}

inline int dinic(const int s, const int t) {
int ret = 0;
while (bfs(s, t)) {
memcpy(cur, head, sizeof(cur));
ret += dfs(s, t, n << 1);
}
return ret;
}

#include<bits/stdc++.h>
using namespace std;
const int MAXN=10e5+5;
int disf[MAXN],diss[MAXN],vis[MAXN];
vector<int> vec[MAXN];
int main(){
int n;
cin>>n;
for (int i=0;i<n-1;i++){
int a,b;
cin>>a>>b;
vec[a].push_back(b);
vec[b].push_back(a);
}
queue<int> q,qq;
disf[1]=0;
diss[n]=0;
q.push(1);
qq.push(n);
while(!q.empty()){
int x=q.front();
vis[x]=1;
q.pop();
for (int i=0;i<vec[x].size();i++)
if (!vis[vec[x][i]]){
q.push(vec[x][i]);
disf[vec[x][i]]=disf[x]+1;
}
}
for (int i=0;i<=n;i++)
vis[i]=0;
while(!qq.empty()){
int x=qq.front();
vis[x]=1;
qq.pop();
for (int i=0;i<vec[x].size();i++)
if (!vis[vec[x][i]]){
qq.push(vec[x][i]);
diss[vec[x][i]]=diss[x]+1;
}
}
int cntf=0,cnts=0;
for (int i=1;i<=n;i++){
if (disf[i]>diss[i])
cnts++;
else cntf++;
}
if (cntf>cnts)
cout<<"Fennec";
else cout<<"Snuke";
return 0;
}

#include <bits/stdc++.h>
using namespace std;
queue<int> q;
vector<int> a[100005];
int n,x,y,cnt[3],colour[100005];
int main(){
cin>>n;
for(int i=1;i<n;i++){
cin>>x>>y;
a[x].push_back(y);
a[y].push_back(x);
}
fill(colour+1,colour+n,0);
colour[1]=1,colour[n]=2;
q.push(1),q.push(n);
while(!q.empty()){
int now=q.front();
q.pop();
cnt[colour[now]]++;
for(int i=0;i<a[now].size();i++){
int now1=a[now][i];
if(colour[now1])continue;
colour[now1]=colour[now];
q.push(now1);
}
}
if(cnt[1]>cnt[2])cout<<"Fennec";
else cout<<"Snuke";
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int32_t main() {
ios_base::sync_with_stdio(false); cin.tie(NULL);

int n;
cin >> n;
vector<int> v(n);
int joss, chole, sad;
joss = chole = sad = 0;
for(auto &x: v) {
cin >> x;
if(x % 4 == 0) joss++;
else if(x % 2 == 0) chole++;
else sad++;
}
sad += chole % 2;
if(sad - joss > 1) cout << "No" << '\n';
else cout << "Yes" << '\n';
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;

#define ENABLE_PRINT

#if defined(ENABLE_PRINT)

#define P(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)
#define P2(fmt) fprintf(stderr, fmt)
#define LP fprintf(stderr, "L: %d\n", __LINE__)

#else

#define P(fmt, ...) ((void)0)
#define P2(fmt) ((void)0)
#define LP ((void)0)

#endif

#define rep(i, n) for(int i = 0; i < (int)(n); ++i)

#define ALL(x) x.begin(),x.end()

using ll = long long;

int main(int, const char**)
{
int N; cin >> N;
vector<int> X(N); rep(i, N) cin >> X[i];
int L; cin >> L;
int Q; cin >> Q;

vector<vector<int>> dp(20, vector<int>(N));
rep(i, N) {
auto found = upper_bound(ALL(X), X[i] + L);
found--;
dp[0][i] = distance(X.begin(), found);
}

rep(i, 19) {
rep(j, N) {
dp[i + 1][j] = dp[i][dp[i][j]];
}
}
#if 0
rep(j, 20) {
P("%3d: ", j);
rep(i, N) {
P("%d ", dp[j][i]);
}
P2("\n");
}
#endif    

rep(i, Q) {
int a, b; cin >> a >> b;
a--; b--;
int ans = 0;
if(a > b) swap(a, b);
rep(j, 20) {
auto ti = 19 - j;
if(dp[ti][a] < b) {
ans += (1 << ti);
a = dp[ti][a];
}
}

cout << ans + 1 << endl;
}

return 0;
}

#include<cstdio>
#include<algorithm>
struct sgt
{
struct node
{
int ans,tag;
};
node a[550005];
void pushup(int k)
{
a[k].ans=std::max(a[k*2].ans,a[k*2+1].ans);
}
void put(int k,int w)
{
a[k].ans=a[k].ans+w;
a[k].tag=a[k].tag+w;
}
void pushdown(int k)
{
if (!a[k].tag) return;
put(k*2,a[k].tag);
put(k*2+1,a[k].tag);
a[k].tag=0;
}
void build(int k,int l,int r)
{
if (l==r) return a[k].ans=0,void();
int mid=(l+r)/2;
build(k*2,l,mid);
build(k*2+1,mid+1,r);
pushup(k);
}
void update(int k,int x,int y,int w,int l,int r)
{
if (x<=l&&r<=y) return put(k,w);
int mid=(l+r)/2;
pushdown(k);
if (x<=mid) update(k*2,x,y,w,l,mid);
if (mid<y) update(k*2+1,x,y,w,mid+1,r);
pushup(k);
}
};
struct ask
{
int l,r;
};
sgt t;
ask f[200005];
int n,m;
int cmp(ask x,ask y){return x.r>y.r;}
int main()
{
scanf("%d%d",&n,&m);
for (int i=1;i<=n;i++) scanf("%d%d",&f[i].l,&f[i].r);
std::sort(f+1,f+n+1,cmp);
t.build(1,0,m+1);
int now=0,ans=-1000000000;
for (int i=1;i<=m;i++) t.update(1,i,i,-i,0,m+1);
t.update(1,m+1,m+1,-m,0,m+1);
for (int i=m+1;i>=0;i--)
{
int ss=(!i?m:m-i+1);
if (i!=m+1&&i!=0) t.update(1,i,m+1,1,0,m+1);
while (now<n&&f[now+1].r==i) t.update(1,f[now+1].l,m+1,1,0,m+1),++now;
ans=std::max(ans,t.a[1].ans-ss);
}
printf("%d\n",ans);
return 0;
}
#include<bits/stdc++.h>
using namespace std;
int n,m;
int arr[100005]={};
int main() {
cin>>n>>m; 
for(int i=1; i<=n; i++)
cin>>arr[i];
int ans=1e9;
m--;
for(int i=1;i<=n;i++){
if(i+m<=n&&i-m>0){
int cnt=min(abs(arr[i])+abs(arr[i]-arr[i+m]),abs(arr[i])+abs(arr[i]-arr[i-m]));
ans=min(ans,cnt);
}
else if(i+m<=n){
ans=min(ans,abs(arr[i])+abs(arr[i]-arr[i+m]));
}
else if(i-m>0){
ans=min(ans,abs(arr[i])+abs(arr[i]-arr[i-m]));
}
}
cout<<ans;
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<20>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod1000000007 = 1000000007;
const int mod998244353 = 998244353;

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
ll L;
cin >> L;
int dgt = 1;
ll x = 1;

while(x <= L) x*=2, ++dgt;
--dgt;

int n = dgt;
vector<tuple<int, int, int>> ans;
rep(i, n-1) {
ans.emplace_back(n-i-1, n-i, 1<<i);
ans.emplace_back(n-i-1, n-i, 0);
}

for(int i = 0; i < n-1; ++i) {
if(L & 1<<i) {
int cst = L;
cst >>= i+1;
cst <<= i+1;
ans.emplace_back(1, n-i, cst);
}
}
sort(ALL(ans));

cout << n << " " << SZ(ans) << endl;
for(auto x : ans) {
cout << get<0>(x) << " " << get<1>(x) << " " << get<2>(x) << endl;
}
}
#include<bits/stdc++.h>
#define ll long long
#define ld long double
using namespace std;
int main()
{
ios_base::sync_with_stdio(false); cin.tie(NULL);
int n; cin>>n;
map<ll,ll>frq;
while(n--)
{
ll a; cin>>a;
frq[a]+=1;
}
ll sum=0;
for(auto i=frq.begin();i!=frq.end();i++)
{
ll a=i->first,  b=i->second;
if(b>a)
sum+=b-a;
else if(a>b)
sum+=b;
}
cout<<sum<<endl;
return 0;
}

#include <iostream>
#include <cstdio>
#include <cstring>
#define int long long

using namespace std;

const int N = 5100;
const int mod = 1e9 + 7;
int n, m;
char s[N];
int tot;
int l[N], r[N];
int ifac[N], fac[N], inv[N];
int c[N];
int cnt;
int f[100][100][100];
int vis[N];
int ans;

int C(int n, int m) {
if (m < 0 || n - m < 0) return 0;
return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

//a blue
//b red
int doit(int a, int b) {
memset(c, 0, sizeof(c));
memset(vis, 0, sizeof(vis));
memset(f, 0, sizeof(f));
for (int i = 1; i <= a; ++i) {
vis[r[i]] = 1;
}
for (int i = 1; i <= m; ++i) {
if (!vis[i] && s[i] == 'b') {
for (int j = a; j; --j) {
if (i > l[j]) {
++c[j];
break;
}
}
}
}
memset(vis, 0, sizeof(vis));
for (int i = 1; i <= a + b; ++i) {
vis[l[i]] = 1;
}
for (int i = 1; i <= m; ++i) {
if (!vis[i] && s[i] == 'r') {
for (int j = a; j; --j) {
if (i > r[j]) {
++c[j];
break;
}
}
}
}
for (int i = a; i; --i) {
c[i] = c[i] + c[i + 1];
}
f[a + 1][0][0] = 1;
for (int j = 1; j <= m; ++j) {
for (int k = 0; k <= m; ++k) {
f[a + 1][j][k] = (f[a + 1][j - 1][k] + f[a + 1][j][k]) % mod;
}
}
for (int i = a; i; --i) {
for (int k = 1; k <= c[i]; ++k) {
int lim = c[i];
for (int j = i; j <= a; ++j) {
lim = min(lim - k, c[j] - k);
if (lim < 0) break;
for (int p = 0; p <= min(lim, c[j + 1]); ++p) {
f[i][k][p + (j - i + 1) * k] = (f[i][k][p + (j - i + 1) * k] + f[j + 1][k - 1][p] * ifac[j - i + 1] % mod) % mod;
}
}
}
f[i][0][0] = ifac[a - i + 1];
for (int j = 1; j <= m; ++j) {
for (int k = 0; k <= m; ++k) {
f[i][j][k] = (f[i][j - 1][k] + f[i][j][k]) % mod;
}
}
}
int res = 0;
for (int i = 0; i <= c[1]; ++i) {
int x1 = 2 + a * 2;
int x2 = a + b - 1 + a + i * 2 + b;
res = (res + C(n + x1 - 1, x2 + x1 - 1) * f[1][c[1]][i] % mod * C(a + b, a) % mod * fac[a] % mod) % mod;
}
return res;
}

signed main() {
scanf("%lld%lld", &n, &m);
scanf("%s", s + 1);
ifac[0] = fac[0] = fac[1] = ifac[1] = inv[1] = 1;
for (int i = 2; i <= 700; ++i) {
fac[i] = fac[i - 1] * i % mod;
inv[i] = (mod - mod / i) * inv[mod % i] % mod;
ifac[i] = ifac[i - 1] * inv[i] % mod;
}
int j = 1;
for (int i = 1; i <= m; ++i) {
if (s[i] == 'r') {
l[++tot] = i;
j = max(i, j);
++j;
while (j <= m && s[j] != 'b') ++j;
if (j <= m) ++cnt;
r[tot] = j;
}
}
for (int i = 0; i <= cnt; ++i) {
for (int j = 0; j <= tot - i; ++j) {
ans += doit(i,  j);
ans %= mod;
}
}
printf("%lld\n", ans);
return 0;
}
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace std;

typedef long long ll;

const int MAXN = (int)1e5 + 5;
const int K = 300;

vector<pair<int, int>> qu[MAXN];
vector<int> seg[MAXN];
int fenw[MAXN];
int cnt[MAXN];
ll ans[MAXN];
int n, m;

void update(int p, int x) {
for (; p <= m; p |= (p + 1)) {
fenw[p] += x;
}
}

int get(int p) {
int res = 0;

for (; p > 0; --p) {
res += fenw[p];
p &= (p + 1);
}

return res;
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
cin >> n >> m;

for (int i = 1; i <= n; i++) {
int l, r;
cin >> l >> r;

for (int k = 1; k <= K; k++) {
if ((l + k - 1) / k <= r / k) {
ans[k]++;
}
}

seg[l].pb(r);
}

for (int k = K + 1; k <= m; k++) {
for (int x = k; x <= m; x += k) {
qu[x].pb({x, k});
qu[x - k].pb({x, -k});
}
}

for (int i = 1; i <= m; i++) {
for (int r : seg[i]) {
update(r, 1);
}

for (auto [x, idx] : qu[i]) {
int coef = (idx > 0 ? 1 : -1);
int sum = get(m) - get(x - 1);
ans[abs(idx)] += sum * coef;
}
}

for (int i = 1; i <= m; i++) {
cout << ans[i] << '\n';
}

return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <charconv>
#include <cmath>
#include <iomanip>
#include <limits>
#include <functional>
using namespace std;

#define rep(i, n) for (long i = 0; i < (long)(n); i++)
using ll = long long;



int main() {
ll n,m;
cin>>n>>m;
if(n==1 && m!=1){
cout<<m-2<<endl;
exit(0);
}
if(m==1 && n!=1){
cout<<n-2<<endl;
exit(0);
}
if(n==1 && m==1){
cout<<1<<endl;
exit(0);
}
cout<<n*m-(2*n+2*m-4)<<endl;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, LOG = 301;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);

int n; cin >> n;
int ans = 0;
map <int, int> cnt;
for (int x, i = 0; i < n; ++i) {
cin >> x;
cnt[x]++;
ans = max({
ans,
cnt[x] + cnt[x - 1] + cnt[x + 1],
cnt[x] + cnt[x + 1] + cnt[x + 2],
cnt[x] + cnt[x - 1] + cnt[x - 2]
});
}
cout << ans << '\n';

return 0;
}

// 解き直し.
// https://img.atcoder.jp/arc103/editorial.pdf
// C++(GCC 9.2.1)
#include <bits/stdc++.h>
using namespace std;
using P = pair<int, int>;
using vp = vector<P>;
#define repex(i, a, b, c) for(int i = a; i < b; i += c)
#define repx(i, a, b) repex(i, a, b, 1)
#define rep(i, n) repx(i, 0, n)
#define repr(i, a, b) for(int i = a; i >= b; i--)
#define a first
#define b second

int main(){

// 1. 入力情報.
char x[101010];
scanf("%s", x);
string s(x);
int N = s.size();

// 2. 条件を満たすか？
bool ok = true;
if(s[0] != '1' || s[N - 1] != '0') ok = false;
repx(i, 1, N - 1) if(s[i] != s[N - 2 - i]) ok = false;

// 3. 例外.
if(!ok){
puts("-1");
return 0;
}

// 4. グラフ構築.
// 4-1. 根 を 設定.
s[N - 1] = '1';

// 4-2. 文字 '1'.
vp ans(N - 1);
int c = 0;
repx(i, 1, N){
if(s[i] == '1'){
// {子頂点, 親頂点} を 設定.
ans[c] = {c + 1, i + 1};

// 子頂点更新.
c = i;
}
}

// 4-3. 文字 '0'.
rep(i, N){
// 子頂点 を 設定.
if(s[i] == '1') c = ans[i].b;

// {子頂点, 親頂点} を 設定.
if(s[i] == '0') ans[i] = {c, i + 1};
}

// 5. 出力.
for(auto &p : ans) printf("%d %d\n", p.a, p.b);
return 0;

}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
unordered_map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

// god fucking damnn it

#include <algorithm>
#include <iostream>
#include <numeric>
#include <cstring>
#include <iomanip>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <cmath>
#include <set>
#include <map>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int maxn = 2e5+10;
const ll inf = 1e16;

ll arr[maxn];
char opr[maxn];
ll _ps[maxn+1];
ll _ns[maxn+1];

ll *ps = _ps+1;
ll *ns = _ns+1;

int nxt_ng[maxn];

int32_t main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int n; cin >> n;
opr[0] = '+';
for(int i = 0; i < n; i++)
{
cin >> arr[i];
ps[i] = ps[i-1] + arr[i];
if(opr[i] == '+')
ns[i] = ns[i-1] + arr[i];
else
ns[i] = ns[i-1] - arr[i];
if(i < n-1)
cin >> opr[i+1];
}
nxt_ng[n-1] = n;
for(int i = n-2; i >= 0; i--)
{
if(opr[i+1] == '-')
nxt_ng[i] = i+1;
else
nxt_ng[i] = nxt_ng[i+1];
}
ll ans = ns[n-1];
for(int i = 0; i < n; i++)
{
if(opr[i] == '+') continue;
int nx = nxt_ng[i];
ans = max(ans, ns[i-1] - (ps[nx-1] - ps[i-1]) + (ps[n-1] - ps[nx-1]));
}
cout << ans << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
const int maxn = 6000000;
const int maxm = 6000000;

struct Edge {
int u, v, w, next;
} e[maxm << 1];

int en = 0, h[maxn];
bool vis[maxn];
int dis[maxn], n, m, s, tot, f[maxn], x[maxn], y[maxn];
map<int, int> mp;
vector<int> vec[maxn], p;

typedef pair<int, int> PII;

priority_queue<PII, vector<PII>, greater<PII> > q;

int find(int x) {
if (f[x] == x) return x;
return f[x] = find(f[x]);
}
void add(int u, int v, int w) {
en++;
e[en].u = u;
e[en].v = v;
e[en].w = w;
e[en].next = h[u];
h[u] = en;
}

signed main() {
cin >> n >> m;
for (int i = 1; i <= m; ++i) {
int w;
scanf("%d %d %d", &x[i], &y[i], &w);
vec[w].push_back(i);
}
tot = n;

for (int i = 1; i <= 1000000; ++i) {
if (vec[i].size() == 0) continue;
p.clear();
for (auto j : vec[i]) {
int u = x[j], v = y[j];
p.push_back(u);
p.push_back(v);
}
int t = p.size();
sort(p.begin(), p.end());

vector<int>::iterator it = unique(p.begin(), p.end());
p.erase(it, p.end());
t = p.size();

for (int j = 0; j < t; ++j) {
f[p[j]] = p[j], mp[p[j]] = 0;
// cout << "p[j]: " << p[j] << endl;
}

for (auto j : vec[i]) {
int u = x[j], v = y[j];
// cout << u << " " << v << endl;
int ru = find(u);
int rv = find(v);
if (ru != rv) f[ru] = rv;
}

for (int j = 0; j < t; ++j) {
int u = p[j];
int ru = find(u);
if (mp[ru] == 0) mp[ru] = ++tot;
add(u, mp[ru], 1);
add(mp[ru], u, 1);
}
}

for (int i = 1; i <= tot; ++i) dis[i] = INT_MAX / 3;

s = 1;
dis[s] = 0;
q.push(make_pair(0, s));

while (!q.empty()) {
int k = q.top().second;
q.pop();

if (!vis[k]) {
vis[k] = true;
for (int i = h[k]; i > 0; i = e[i].next) {
int v = e[i].v;
int w = e[i].w;
if (dis[v] > dis[k] + w) {
dis[v] = dis[k] + w;
q.push(make_pair(dis[v], v));
}
}
}
}

if (dis[n] == INT_MAX / 3) cout << -1;
else
cout << dis[n] / 2;
return 0;
}
#define TO_BE_SUBMITTED
#include <bits/stdc++.h>
// #include <atcoder/fenwicktree>
// #include <atcoder/segtree>
// #include <atcoder/lazysegtree>
// #include <atcoder/string>
// #include <atcoder/math>
// #include <atcoder/convolution>
// #include <atcoder/modint>
#include <atcoder/dsu>
// #include <atcoder/maxflow>
// #include <atcoder/mincostflow>
// #include <atcoder/scc>
// #include <atcoder/twosat>

namespace atcoder{};
using namespace atcoder;
using namespace std;

#define fr first
#define sc second
#define rep(i, n) for (int i = 0; i < (n); ++i)
#define rep1(i, n) for (int i = 1; i <= (n); ++i)
#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)
#define rrep1(i, n) for (int i = (n); i >= 1; --i)
#define srep(i, s, t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(), a.end()
#define rrng(a) a.rbegin(), a.rend()
#define isin(x, l, r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)), x.end())
#define snuke srand((unsigned)clock() + (unsigned)time(NULL));
#define show(x) cerr << #x << " = " << x << "\n";
#define PQ(T) priority_queue<T, vector<T>, greater<T>>
#define bn(x) ((1 << x) - 1)
#define dup(x, y) (((x) + (y)-1) / (y))
#define newline puts("")
using ll = long long;
using uint = unsigned;
using ull = unsigned long long;
using P = pair<int, int>;
using LP = pair<ll, ll>;
using vi = vector<int>;
using vvi = vector<vi>;
using vl = vector<ll>;
using vvl = vector<vl>;
using vp = vector<P>;
using vlp = vector<LP>;
inline int getInt()
{
int x;
scanf("%d", &x);
return x;
}
template <class T>
bool chmax(T &a, const T &b)
{
if (a < b)
{
a = b;
return true;
}
return false;
}
template <class T>
bool chmin(T &a, const T &b)
{
if (a > b)
{
a = b;
return true;
}
return false;
}

int N, M;
vi A, X, Y;

void solve()
{
cin >> N >> M;
rep(i, N){
int a;
cin >> a;
A.eb(--a);
}
dsu D(N);

rep(i, M){
int x, y;
cin >> x >> y;

X.eb(--x);
Y.eb(--y);
D.merge(x, y);
}

int ans = 0;
for(auto G : D.groups()){
set<int> S;
for(auto k : G){
S.insert(k);
}
for(auto k : G){
if(S.find(A[k]) != S.end()){
ans++;
}
}
}

cout << ans << "\n";
}

int main()
{
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout << fixed << setprecision(15);
solve();
return 0;
}
/*
arc099_a
*/

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VC = vector<char>;
using VVC = vector<VC>;
using P = pair<int, int>;
#define sz(x) int(x.size())
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define all(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int dx[] = {1, 0, -1, 0};
constexpr int dy[] = {0, 1, 0, -1};

void print(bool ok) {
if (ok) cout << "Yes" << endl;
else cout << "No" << endl;
}

int main(){
int n, k;
cin >> n >> k;
int a; rep(i,n) cin >> a;
n--; k--;
cout << (n+k-1) / k << endl;
} 
/*
arc059_b
*/

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VC = vector<char>;
using VVC = vector<VC>;
using P = pair<int, int>;
#define sz(x) int(x.size())
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define all(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int dx[] = {1, 0, -1, 0};
constexpr int dy[] = {0, 1, 0, -1};

void print(bool ok) {
if (ok) cout << "Yes" << endl;
else cout << "No" << endl;
}

bool ok(VI v) {
if (sz(v) < 2) return false;

int l = 0, r = 0;
int cnt = 0;
int len = 0;
rep(i,sz(v)-1) {
if (v[i+1] - v[i] <= 2) {
cout << v[i]+1 << " " << v[i+1]+1 << endl;
return true;
}
}
return false;
}

int main(){
string s;
cin >> s;

VVI pos(26);
rep(i,sz(s)) pos[s[i]-'a'].push_back(i);

rep(i,26) {
if (ok(pos[i])) return 0;
}
cout << -1 << " " << -1 << endl;
} 
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue< pair< int , int > > q;
int k;
int mp[100005];
bool b[100005];
int main()
{
cin>>k;
for(int i=1;i<=min(9,k-1);i++)
{
mp[i]=i;
q.push(make_pair(-i,i));
}
for(int i=10;i<k;i++)	mp[i]=2e9;
mp[0]=2e9;
while(1)
{
int nx=q.top().second;
q.pop();
if(b[nx])	continue;
if(nx==0)
{
cout<<mp[0];
return 0;
}
b[nx]=1;
for(int i=0;i<10;i++)
{
int to=(10*nx+i)%k;
int tn=mp[nx]+i;
if(tn<mp[to])
{
mp[to]=tn;
q.push(make_pair(-tn,to));
}
}
}
}
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=1000010,mod=1e9+7;
int n,a[N],c[N],p[N],l[N],r[N],vis[N];
long long ans;
set<int>s;
void add(int x){
while(x<=n){
c[x]++;
x+=x&-x;
}
}
int que(int x){
int ss=0;
while(x){
ss+=c[x];
x-=x&-x;
}
return ss;
}
void ex(){puts("-1");exit(0);}
signed main(){
scanf("%d",&n);l[n+1]=1e9;
for(int i=1;i<=n;i++){
scanf("%d%d",&l[i],&r[i]);s.insert(i);
}
for(int i=1;i<=n;i++)if(l[i]>l[i+1]||r[i]<r[i-1])ex();
for(int i=1;i<=n;i++)if(l[i]<l[i+1])p[i]=l[i],s.erase(p[i]);
for(int i=1;i<=n;i++)if(r[i]>r[i-1])p[i]=r[i],s.erase(p[i]);
for(int i=1;i<=n;i++)if(!p[i])p[i]=*s.begin(),s.erase(p[i]);
int mx=0,mi=1e9;
for(int i=1;i<=n;i++){
vis[p[i]]++;
if(vis[p[i]]>1)ex();
}
for(int i=1;i<=n;i++){
mx=max(mx,p[i]);
if(mx!=r[i])ex();
}
for(int i=n;i>=1;i--){
mi=min(mi,p[i]);
if(mi!=l[i])ex();
}
add(p[1]);
for(int i=2;i<=n;i++){
ans+=i-1-que(p[i]-1);
add(p[i]);
}
cout<<ans;
}

#include <iostream>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
#include <cstring>

using namespace std;
//#define int long long
using ll = long long;
int const INF = 0x3f3f3f3f;
int const MOD = 1e9 + 7;
int const N = 1e3 + 10;
struct Circle {
double x, y;
double r;
} s, t, c[N];

double dist(Circle &a, Circle &b) {
return max(0.0, sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) - (a.r + b.r));
}

double d[N][N], res[N];
int n;

double ans = 1e18;

void dij() {
for (int i = 0; i <= n + 1; i++) res[i] = 1e18;
priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > q;
q.emplace(0.0, 0);
res[0] = 0.0;
while (!q.empty()) {
double dis = q.top().first;
int u = q.top().second;
q.pop();
if (dis > res[u]) continue;
for (int v = 0; v <= n + 1; v++) {
if (u == v) continue;
if (res[v] > res[u] + d[u][v]) {
res[v] = res[u] + d[u][v];
if (v == n + 1) ans = min(ans, res[v]);
q.emplace(res[v], v);
}
}
}
}

signed main() {
ios::sync_with_stdio(false);
cin >> s.x >> s.y >> t.x >> t.y;
s.r = t.r = 0;
cin >> n;
d[0][n + 1] = d[n + 1][0] = dist(s, t);
for (int i = 1; i <= n; i++) {
cin >> c[i].x >> c[i].y >> c[i].r;
d[0][i] = d[i][0] = dist(s, c[i]);
d[i][n + 1] = d[n + 1][i] = dist(c[i], t);
for (int j = 1; j < i; j++) d[j][i] = d[i][j] = dist(c[i], c[j]);
}
dij();
cout.flags(ios::fixed);
cout.precision(9);
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back
#define em emplace
#define all(v) v.begin(), v.end()
#define reset(x) memset(x, 0, sizeof(x))

using namespace std;
typedef long long ll;
typedef long double ld;
typedef complex <double> cpx;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;

const int MAX = 1010;
const int INF = 1e9;
const ll LINF = 1e18;

struct circle {
ll x, y, r;
circle() {}
circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
};

ld dist(circle a, circle b) {
return max(0.0, sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) - a.r - b.r);
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

vector <circle> v(n);
vector <ld> d(n);
for(int i = 0; i < n; i++) {
cin >> v[i].x >> v[i].y >> v[i].r;
d[i] = dist(circle(xs, ys, 0), v[i]);
}
vector <bool> chk(n);
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n; j++) {
if(chk[j]) continue;
if(mn > d[j]) mn = d[j], idx = j;
}
chk[idx] = true;
for(int j = 0; j < n; j++) {
if(chk[j]) continue;
d[j] = min(d[j], d[idx] + dist(v[idx], v[j]));
}
}

ld ans = dist(circle(xt, yt, 0), circle(xs, ys, 0));
for(int i = 0; i < n; i++) {
ans = min(ans, dist(circle(xt, yt, 0), v[i]) + d[i]);
}
printf("%.9Lf\n", ans);
}
#include<bits/stdc++.h>
//#include<atcoder/all>
typedef long long ll;
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define rrep(i,a,b) for(ll i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(x) (x).begin(),(x).end()
using namespace std;
//using namespace atcoder;
const ll inf = INT_MAX / 2; const ll infl = 1LL << 60;
typedef vector<ll> vl;
typedef vector<vl> vvl;
using Graph = vector<vector<ll>>;
using P = pair<int, int>;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }
// PRINT ------------------------------
#define COUT(a) cout << (a) << endl;
#define YES cout << "YES" << endl;
#define NO cout << "NO" << endl;
#define Yes cout << "Yes" << endl;
#define No cout << "No" << endl;
// 操作------------------------------
#define pb push_back
//お役立ちツール集 ------------------------------

/*
乱数運ゲー
if(randomize){
std::uniform_int_distribution<> dist(0, 9);

std::ofstream result_file("uniform_int_distribution.tsv");
// 一様整数分布で乱数を生成する
int result = dist(engine);

if(result%2==0){
COUT("Win");
}
else{
COUT("Lose");
}
}

// 桁数
ll calc_digit(ll N) {
ll res = 0;
while (N) {
++res;
N /= 10;
}
return res;
}
// 各桁和
ll findSumOfDigits(ll n) {
ll sum = 0;
while (n > 0) { // n が 0 になるまで
sum += n % 10;
n /= 10;
}
return sum;
}
// 回文判定
bool IsPalindrome(string_view s) {
for (unsigned long int i = 0; i < s.size() / 2; ++i) {
if (s[i] != s[s.size() - 1 - i])
return false;
}
return true;
}
// 約数個数
template <typename T>
map<T, T> prime_factor(T n) {
map<T, T> ret;
for (T i = 2; i * i <= n; i++) {
T tmp = 0;
while (n % i == 0) {
tmp++;
n /= i;
}
ret[i] = tmp;
}
if (n != 1) ret[n] = 1;
return ret;
}
divisor_num(n)
入力：整数 n
出力：nの約数の個数
計算量：O(√n)

template <typename T>
T divisor_num(T N) {
map<T, T> pf = prime_factor(N);
T ret = 1;
for (auto p : pf) {
ret *= (p.second + 1);
}
return ret;
}
// 素数判定
bool IsPrime(ll num){
if (num < 2) return false;
else if (num == 2) return true;
else if (num % 2 == 0) return false; // 偶数はあらかじめ除く

double sqrtNum = sqrt(num);
for (ll i = 3; i <= sqrtNum; i += 2)
{
if (num % i == 0)
{
// 素数ではない
return false;
}
}

// 素数である
return true;
}
//約数列挙
vector<ll> enum_divisors(ll N) {
vector<ll> res;
for (ll i = 1; i * i <= N; ++i) {
if (N % i == 0) {
res.push_back(i);
// 重複しないならば i の相方である N/i も push
if (N/i != i) res.push_back(N/i);
}
}
// 小さい順に並び替える
sort(res.begin(), res.end());
return res;
}
約数全部出力
void _main() {
ll N;
cin >> N;
const auto &res = enum_divisors(N);
for (int i = 0; i < res.size(); ++i) cout << res[i] << " ";
cout << endl;
}

// 10進数→2進数への変換
ll binary(ll bina){
ll ans = 0;
for (ll i = 0; bina>0 ; i++)
{
ans = ans+(bina%2)*pow(10,i);
bina = bina/2;
}
return ans;
}
正規表現
// 調べたい文字列
string S = "algomethod";
// 調べる正規表現
regex reg{R"(a.*d)"};
// マッチした文字列情報が格納される (存在しなければ null)
smatch m;

// マッチするか (bool 値)
bool search = regex_search(S, m, reg);
//順列全探索
int n, a[109]; cin >> n;
for (int i = 0; i < n; i++) cin >> a[i];
do {
for (int i = 0; i < n; i++) {
if (i) cout << ",";
cout << a[i];
}
cout << endl;
} while(next_permutation(a, a + n));
*/
/*
// 汎用的な二分探索のテンプレ
int binary_search(int key) {
int ng = -1; //「index = 0」が条件を満たすこともあるので、初期値は -1
int ok = (int)a.size(); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()

(ok と ng のどちらが大きいかわからないことを考慮 )
while (abs(ok - ng) > 1) {
int mid = (ok + ng) / 2;

if (isOK(mid, key)) ok = mid;
else ng = mid;
}
return ok;
}
compress
X を座標圧縮して書き換える（副作用）
返り値: ソート済みの値
計算量: O(n log n)
*/
template <typename T>
vector<T> compress(vector<T> &X) {
// ソートした結果を vals に
vector<T> vals = X;
sort(vals.begin(), vals.end());
// 隣り合う重複を削除(unique), 末端のゴミを削除(erase)
vals.erase(unique(vals.begin(), vals.end()), vals.end());
// 各要素ごとに二分探索で位置を求める
for (int i = 0; i < (int)X.size(); i++) {
X[i] = lower_bound(vals.begin(), vals.end(), X[i]) - vals.begin();
}
return vals;
}
// 深さ優先探索
vector<bool> seen;
void dfs(const Graph &G, int v) {
seen[v] = true; // v を訪問済にする

// v から行ける各頂点 next_v について
for (auto next_v : G[v]) { 
if (seen[next_v]) continue; // next_v が探索済だったらスルー
dfs(G, next_v); // 再帰的に探索
}
}
/*bit全探索
for (int i = 0; i < (1 << primes.size()); ++i) {
ll m = 1;
for (int j = 0; j < primes.size(); ++j) {
if (i >> j & 1) {
m *= primes[j];
}
}
*/
map<ll,int> enumpr(ll n) {
map<ll,int> V;
for(ll i=2;i*i<=n;i++) while(n%i==0) V[i]++,n/=i;
if(n>1) V[n]++;
return V;
}
/*
auto ep = enumpr(素因数分解したい数);
int ans = ep.size();
素因数の数
*/
// union by size + path having
class UnionFind {
public:
vector <ll> par; // 各元の親を表す配列
vector <ll> siz; // 素集合のサイズを表す配列(1 で初期化)

// Constructor
UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {
for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身
}
void init(ll sz_) {
par.resize(sz_);
siz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった
for (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身
}

// Member Function
// Find
ll root(ll x) { // 根の検索
while (par[x] != x) {
x = par[x] = par[par[x]]; // x の親の親を x の親とする
}
return x;
}

// Union(Unite, Merge)
bool merge(ll x, ll y) {
x = root(x);
y = root(y);
if (x == y) return false;
// merge technique（データ構造をマージするテク．小を大にくっつける）
if (siz[x] < siz[y]) swap(x, y);
siz[x] += siz[y];
par[y] = x;
return true;
}

bool issame(ll x, ll y) { // 連結判定
return root(x) == root(y);
}

ll size(ll x) { // 素集合のサイズ
return siz[root(x)];
}
};
/*  関数名          n_ary(string str, int n, int m)
説明            n 進数で表現された数値を文字列 str で受け取り、m 進数に直して文字列で出力する。
使用ライブラリ  string
使用自作関数    ntodec, decton, pow_ll
制約事項        36進数までの対応。負の値には対応していない。
*/
/*  関数名          ntodec(const char c)
説明            char で 文字{0,1,2,...,9,A,B,...,Z} を受け取り、
int で {0,1,2,...9,10,11,...,35}に直して返す。
それ以外の文字が来た場合は-1を返す。
使用ライブラリ   なし
*/
int ntodec(const char c){
switch(c){
case '0': return 0;
case '1': return 1;
case '2': return 2;
case '3': return 3;
case '4': return 4;
case '5': return 5;
case '6': return 6;
case '7': return 7;
case '8': return 8;
case '9': return 9;
case 'A': return 10;
case 'B': return 11;
case 'C': return 12;
case 'D': return 13;
case 'E': return 14;
case 'F': return 15;
case 'G': return 16;
case 'H': return 17;
case 'I': return 18;
case 'J': return 19;
case 'K': return 20;
case 'L': return 21;
case 'M': return 22;
case 'N': return 23;
case 'O': return 24;
case 'P': return 25;
case 'Q': return 26;
case 'R': return 27;
case 'S': return 28;
case 'T': return 29;
case 'U': return 30;
case 'V': return 31;
case 'W': return 32;
case 'X': return 33;
case 'Y': return 34;
case 'Z': return 35;
default : return -1;
}
}
/*  関数名          decton(const int n)
説明            int で 数値 0〜35 を受け取り、文字{0,1,2,...,9,A,B,...,Z}に直して char で返す。
それ以外の数字が来た場合は \0 を返す。
使用ライブラリ  なし
*/
char decton(const ll n){
switch(n){
case 0: return '0';
case 1: return '1';
case 2: return '2';
case 3: return '3';
case 4: return '4';
case 5: return '5';
case 6: return '6';
case 7: return '7';
case 8: return '8';
case 9: return '9';
case 10: return 'A';
case 11: return 'B';
case 12: return 'C';
case 13: return 'D';
case 14: return 'E';
case 15: return 'F';
case 16: return 'G';
case 17: return 'H';
case 18: return 'I';
case 19: return 'J';
case 20: return 'K';
case 21: return 'L';
case 22: return 'M';
case 23: return 'N';
case 24: return 'O';
case 25: return 'P';
case 26: return 'Q';
case 27: return 'R';
case 28: return 'S';
case 29: return 'T';
case 30: return 'U';
case 31: return 'V';
case 32: return 'W';
case 33: return 'X';
case 34: return 'W';
case 35: return 'Z';
default : return '\0';
}
}
/*  関数名          pow_ll(long long x, long long n)
説明            x^n を計算する。long long 対応
使用ライブラリ  なし
*/
inline long long pow_ll(long long x, long long n){
long long ret = x;
if(n==0) return 1;
for(long long i=1; i<n; i++){
ret *= x;
}
return ret;
}
string n_ary(string str, ll n, ll m){
unsigned long tmp = 0;
string ret;

for(ll i=0; i<str.length(); i++){
tmp += (unsigned long) ntodec(str[str.length()-1-i]) * pow_ll(n, i);
}

if(tmp==0) return "0";
while(tmp!=0){
ret = decton(tmp%m) + ret;
tmp/=m;
}
return ret;
}
const int MOD = 1e9 + 7;

class mint {
long long x;
public:
mint(long long x=0) : x((x % MOD + MOD) % MOD) {}
mint operator-() const {
return mint(-x);
}
mint& operator+=(const mint& a) {
if ((x += a.x) >= MOD) x -= MOD;
return *this;
}
mint& operator-=(const mint& a) {
if ((x += MOD-a.x) >= MOD) x -= MOD;
return *this;
}
mint& operator*=(const  mint& a) {
(x *= a.x) %= MOD;
return *this;
}
mint operator+(const mint& a) const {
mint res(*this);
return res+=a;
}
mint operator-(const mint& a) const {
mint res(*this);
return res-=a;
}
mint operator*(const mint& a) const {
mint res(*this);
return res*=a;
}
mint pow(long long t) const {
if (!t) return 1;
mint a = pow(t>>1);
a *= a;
if (t&1) a *= *this;
return a;
}
// for prime MOD
mint inv() const {
return pow(MOD-2);
}
mint& operator/=(const mint& a) {
return (*this) *= a.inv();
}
mint operator/(const mint& a) const {
mint res(*this);
return res/=a;
}

friend ostream& operator<<(ostream& os, const mint& m){
os << m.x;
return os;
}
};

// 階乗を計算する
vector<mint> _factionals = {0,1};
mint factional(long long n) {
if(_factionals.size() <= n) {
long long  i = _factionals.size();
_factionals.resize(n + 1);
for(; i <= n; i++) {
_factionals[i] = _factionals[i - 1] * i;
}
}
return _factionals[n];
}

// 組み合わせ数を計算する。nCr
unordered_map<long long, vector<mint>> _combinations;
mint combination(long long n, long long r) {
if(n < 1 || r < 1 || n < r) return mint(0);
if(n == r) return mint(1);

// nが小さい場合は公式を使う
if(n < 51000) return factional(n) / (factional(r) * factional(n - r));

// nが大きい場合はnC(r) = nC(r - 1) * (n - r + 1) / r
// nC0 = 0, nC1 = nで初期化
if(r > n - r) r = n - r;
if(!_combinations.count(n)) {
_combinations[n] = {0, n};
}
auto&& vec = _combinations[n];
if(vec.size() <= r) {
long long i = vec.size();
vec.resize(r + 1);
for(; i <= r; i++) vec[i] = (vec[i - 1] * (n - i + 1)) / i;
}

return vec[r];
}

// 順序のパターン数を計算する。nPr
unordered_map<long long, vector<mint>> _permutations;
mint permutation(long long n, long long r) {
if(n < 1 || r < 1 || n < r) return mint(0);

// nが小さい場合は公式を使う
if(n < 51000) return factional(n) / factional(n - r);

// nが大きい場合はnP(r) = nP(r - 1) * (n - r + 1)
// nC0 = 0, nC1 = nで初期化
if(!_permutations.count(n)) _permutations[n] = {0, n};
auto&& vec = _permutations[n];
if(vec.size() <= r) {
long long i = vec.size();
vec.resize(r + 1);
for(; i <= r; i++) vec[i] = vec[i - 1] * (n - i + 1);
}

return vec[r];
}
// 一言 ------------------------------
// 二次元配列メモ:vector<vector<ll>> data(3, vector<ll>(4));
// 最小公倍数はlcmで用意されてます
// 配列.pb(入れたい数字)
// https://atcoder.github.io/ac-library/document_ja/index.html
// dsu uf(N) unionfind mergeで連結　sameで判定 https://atcoder.jp/contests/practice2/submissions/27938757
// FenwickTree<T>fw(N) addで入力 sumで区間範囲 一点変更、区間総和 https://atcoder.jp/contests/practice2/submissions/27939217
// floor_sum double型を受け取り、int型の最大値を返す。 https://atcoder.github.io/ac-library/document_ja/math.html

int main(){
ll N,K;
cin >> N >> K;
vl A(N);
rep(i,0,N){
cin >> A[i];
}
if(N==K){
COUT(1);
return 0;
}
N-=K;
COUT((N+K-2)/(K-1)+1);
}


#include <algorithm>
#include <iostream>
#include <numeric>
#include <cstring>
#include <iomanip>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <cmath>
#include <set>
#include <map>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int maxn = 2e5+10;

vector<int> G[maxn];
int dist[maxn];
int sz[maxn];
int notl[maxn];
int lcnt[maxn];

int prm1[maxn];
int prm2[maxn];
int n;

bool pos;

inline void dfs(int v, int par)
{
sz[v] = 1;
lcnt[v] = 0;
notl[v] = -1;
int nlcnt = 0;
for(int u: G[v])
{
if(u == par) continue;
dist[u] = dist[v]+1;
dfs(u, v);
sz[v] += sz[u];
nlcnt += (sz[u] != 1);
lcnt[v] += (sz[u] == 1);
if(sz[u] != 1)
notl[v] = u;
}
//cerr << v << ": " << nlcnt << endl;
if(nlcnt > 1)
pos = false;
}

inline void get_ans(int s, int prm[])
{
dfs(s, s);
int v = 0;
int d = 0;
while(s != -1)
{
for(int i = 0; i < lcnt[s]; i++)
prm[v++] = d+i+1;
prm[v++] = d;
d += lcnt[s]+1;
s = notl[s];
}
swap(prm[n-1], prm[n-2]);
}

inline bool cmp()
{
for(int i = 0; i < n; i++)
{
if(prm1[i] < prm2[i])
return true;
if(prm1[i] > prm2[i])
return false;
}
return true;
}

int32_t main()
{
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for(int i = 1; i < n; i++)
{
int x, y; cin >> x >> y;
x--; y--;
G[x].push_back(y);
G[y].push_back(x);
}
dfs(0, 0);
int s = max_element(dist, dist+n) - dist;
pos = true;
dist[s] = 0;
dfs(s, s);
int b = max_element(dist, dist+n) - dist;
if(!pos)
{
cout << -1 << endl;
return 0;
}
get_ans(s, prm1);
get_ans(b, prm2);
//cerr << s << " " << b << endl;
if(cmp())
{
for(int i = 0; i < n; i++)
cout << prm1[i]+1 << " ";
cout << endl;
}
else
{
for(int i = 0; i < n; i++)
cout << prm2[i]+1 << " ";
cout << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ll,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
ll k;
cin>>k;
ll n=50;
cout<<n<<endl;
vi a(n);
rep(i,n){
a[i]=n-1+k/n;
if(k%n!=0&&i<k%n) a[i]++;
else if(k%n!=0) a[i]-=k%n;
cout<<a[i]<<" ";
}
cout<<endl;
}
#ifdef xay5421
#define D(...) fprintf(stderr,__VA_ARGS__)
#else
#define D(...) ((void)0)
//#define NDEBUG
#endif
#include<bits/stdc++.h>
#define pb push_back
#define eb emplace_back
#define SZ(x) ((int)(x).size())
#define each(x,v) for(auto&x:v)
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int P=1e9+7;
inline int mo2(int x){return x<0?x+P:x;}
template<class T>inline int mo(const T&x){return mo2(static_cast<int>(x%P));}
struct Z{
int x;
int val()const{return x;}
Z():x(0){}
template<class T>Z(T x_):x(x_>=0&&x_<P?static_cast<int>(x_):mo(x_)){}
bool operator==(const Z&rhs)const{return x==rhs.x;}
bool operator!=(const Z&rhs)const{return x!=rhs.x;}
Z operator-()const{return Z(mo2(-x));}
Z pow(long long k)const{
Z res=1,t=*this;
while(k){
if(k&1)res*=t;
if(k>>=1)t*=t;
}
return res;
}
Z inv()const{
#ifdef xay5421
assert(x!=0);
#endif
return pow(P-2);
}
Z&operator+=(const Z&rhs){
(x+=rhs.x)>=P&&(x-=P);
return *this;
}
Z&operator-=(const Z&rhs){
(x-=rhs.x)<0&&(x+=P);
return *this;
}
Z&operator*=(const Z&rhs){
x=1ULL*x*rhs.x%P;
return *this;
}
Z&operator/=(const Z&rhs){
return *this*=rhs.inv();
}
#define setO(T,o) friend T operator o(const Z&lhs,const Z&rhs){Z res=lhs;return res o##=rhs;}
setO(Z,+)setO(Z,-)setO(Z,*)setO(Z,/)
#undef setO
};
const int N=200005,K=20;
int n,tin[N],tou[N],idx,fa[N][K],dep[N];
vector<int>e[N],nodes[N],ee[N];
void dfs1(int k1){
tin[k1]=++idx;
each(x,e[k1])dfs1(x);
tou[k1]=idx;
}
int LCA(int k1,int k2){
if(dep[k1]<dep[k2])swap(k1,k2);
int dt=dep[k1]-dep[k2];
per(i,K-1,0)if(dt>>i&1)k1=fa[k1][i];
if(k1==k2)return k1;
per(i,K-1,0)if(fa[k1][i]!=fa[k2][i])k1=fa[k1][i],k2=fa[k2][i];
return fa[k1][0];
}
template<class T>
inline int at(const T&v,int k){
return v[SZ(v)+k];
}
vector<int>nd;
void reset(int u){
nd.pb(u);
ee[u].clear();
}
int sz[N];
Z dp[N],pw[N];
void dfs2(int k1){
dp[k1]=sz[k1];
each(x,ee[k1]){
dfs2(x);
sz[k1]+=sz[x];
}
vector<Z>pre(SZ(ee[k1]));
vector<Z>suf(SZ(ee[k1]));
{
Z cur=1;
rep(i,0,SZ(pre)-1){
pre[i]=cur;
cur*=pw[sz[ee[k1][i]]]-dp[ee[k1][i]];
}
cur=1;
per(i,SZ(suf)-1,0){
suf[i]=cur;
cur*=pw[sz[ee[k1][i]]]-dp[ee[k1][i]];
}
}
rep(i,0,SZ(ee[k1])-1){
dp[k1]+=pre[i]*suf[i]*dp[ee[k1][i]];
}
}
Z ans;
void solve(vector<int>v){
vector<int>st;
sort(v.begin(),v.end(),[&](int lhs,int rhs){return tin[lhs]<tou[rhs];});
nd.clear();
reset(1);
st.pb(1);
each(k1,v)if(k1!=1){
int t=LCA(st.back(),k1);
while(SZ(st)>1&&dep[t]<=dep[at(st,-2)]){
ee[at(st,-2)].pb(st.back());
st.pop_back();
}
if(t!=st.back()){
reset(t);
ee[t].pb(st.back());
st.back()=t;
}
reset(k1);
st.pb(k1);
}
rep(i,1,SZ(st)-1){
ee[st[i-1]].pb(st[i]);
}
each(x,nd)sz[x]=0;
each(x,v)sz[x]=1;
dfs2(1);
ans+=dp[1]*pw[n-SZ(v)];
}
int main(){
pw[0]=1;
rep(i,1,N-1)pw[i]=pw[i-1]+pw[i-1];
scanf("%d",&n);
++n;
rep(i,2,n){
scanf("%d",&fa[i][0]);
++fa[i][0];
dep[i]=dep[fa[i][0]]+1;
rep(j,1,K-1)fa[i][j]=fa[fa[i][j-1]][j-1];
e[fa[i][0]].pb(i);
}
rep(i,1,n)nodes[dep[i]].pb(i);
dfs1(1);
rep(i,0,n)if(!nodes[i].empty()){
solve(nodes[i]);
}
printf("%d\n",ans.val());
return 0;
}
#include <iostream>
using namespace std;
int main(){
int n,t,ans=0,last;
cin>>n>>t>>last;
while(--n){
int tt;
cin>>tt;
ans+=min(tt-last,t);
last=tt;
}
cout<<ans+t;
return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;
ll ans = 0;
vector<pair<pair<int,int>,int>> v;
void solve(string &D,int dig,bool carry){
if(dig==D.size()){
if(carry) return;
int i,j;
vector<vector<int>> mp(D.size(),vector<int>(D.size()));
/*cout << D << endl;
for(auto p:v) cout << "a_" << p.first.first << " - a_" << p.first.second << " = " <<  p.second << ",";
cout << endl;*/
for(auto p:v){
auto q = p.first;
mp[q.first][q.second] = p.second;
}
ll ret = 1;
for(i=0;i<D.size();i++){
j = D.size() - 1 - i;
if((mp[i][j] + mp[j][i])!=0) return;
if(abs(mp[i][j])>=10) return;
if(i>=j){
if(j==0) ret *= (9 - abs(mp[i][j]));
else ret *= (10 - abs(mp[i][j]));
} 
}
ans += ret;
}else{
int j = D.size() - 1 - dig;
if(carry){
v.push_back({{dig,j},D[dig] - '0' + 1});
solve(D,dig + 1,false);
v.pop_back();
v.push_back({{dig,j},D[dig] - '0' - 9});
solve(D,dig + 1,true);
v.pop_back();
}else{
v.push_back({{dig,j},D[dig] - '0'});
solve(D,dig + 1,false);
v.pop_back();
v.push_back({{dig,j},D[dig] - '0' - 10});
solve(D,dig + 1,true);
v.pop_back();
}
}
}

int main(){
string D; cin >> D;
reverse(D.begin(),D.end());
int i,n = D.size();
for(i=0;i<=n;i++){
solve(D,0,false);
D.push_back('0');
}
cout << ans << endl;
}
/**
*	author:	social_chameleon
*	created:	2022/01/20
*/

#pragma region MACROS

#pragma region HEADER
#pragma GCC optimize("O3")
#ifdef LOCAL
#include <debug_print.hpp>
#define debug(...) debug_print::multi_print(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...) (static_cast<void>(0))
#endif
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#pragma endregion
#pragma region TYPES
using ll = long long;
#define int ll
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pil = pair<int, ll>;
using pli = pair<ll, int>;
using ld = long double;
template <typename T>
using vc = vector<T>;
template <typename T>
using vvc = vector<vc<T>>;
template <typename T>
using vvvc = vector<vvc<T>>;
using vi = vc<int>;
using vl = vc<ll>;
using vb = vc<bool>;
using vpi = vc<pii>;
using vpl = vc<pll>;
template <class T>
using pq = priority_queue<T>;
template <class T>
using pqg = priority_queue<T, vector<T>, greater<T>>;
#pragma endregion
#pragma region UTILITY_FUNCTIONS
template <typename T>
int si(const T& x) { return x.size(); }
template <class T>
inline bool chmax(T& a, const T& b) { return (a < b ? a = b, 1 : 0); }
template <class T>
inline bool chmin(T& a, const T& b) { return (a > b ? a = b, 1 : 0); }
#define overload2(a, b, name, ...) name
#define overload4(a, b, c, d, name, ...) name
#define overload5(a, b, c, d, e, name, ...) name
#pragma endregion
#pragma region WORDS
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define ppb pop_back
#define ppf pop_front
#define eb emplace_back
#define ef emplace_front
#pragma endregion
#pragma region LOOPS
#define rep0(n) for (int _ = 0; _ < n; ++_)
#define rep1(i, n) for (ll i = 0; i < (n); ++i)
#define rep2(i, a, b) for (ll i = (a); i < (b); ++i)
#define rep3(i, a, b, c) for (ll i = (a); i < (b); i += (c))
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1, rep0)(__VA_ARGS__)
#define rrep0(n) for (int jidlsjf = 0; jidlsjf < n; ++jidlsjf)
#define rrep1(i, n) for (ll i = (n)-1; i >= 0; --i)
#define rrep2(i, a, b) for (ll i = (a)-1; i >= b; --i)
#define rrep3(i, a, b, c) for (ll i = (a)-1; i >= b; i -= c)
#define rrep(...) overload4(__VA_ARGS__, rrep3, rrep2, rrep1, rrep0)(__VA_ARGS__)
#define fore0(v) rep(a.size())
#define fore1(a, v) for (auto&& a : v)
#define fore2(a, b, v) for (auto&& [a, b] : v)
#define fore3(a, b, c, v) for (auto&& [a, b, c] : v)
#define fore4(a, b, c, d, v) for (auto&& [a, b, c, d] : v)
#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)
#pragma endregion
#pragma region CONTAINER_METHODS
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
template <typename T>
int closest(vector<T>& v, T x) {
int n = (int)v.size();
int pos = lower_bound(v.begin(), v.end(), x) - v.begin();
if (pos == 0) return pos;
if (pos == n) return n - 1;
return (v[pos] - x <= x - v[pos - 1]) ? pos : pos - 1;
}
#define all(c) begin(c), end(c)
#define rall(c) rbegin(c), rend(c)
#define SORT(v) sort(all(v))
#define REV(v) reverse(all(v))
#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())
template <typename T = ll, typename S>
T SUM(const S& v) { return accumulate(all(v), T(0)); }
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
template <typename T = int>
T mex(unordered_set<T> st) {
T ret = T(0);
while (st.count(ret) != 0) ++ret;
return ret;
}
#pragma endregion
#pragma region VECTOR_DEFINITIONS
#define vec(type, name, ...) vector<type> name(__VA_ARGS__)
#define vec2(type, name1, name2, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__)
#define vec3(type, name1, name2, name3, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__)
#define vec4(type, name1, name2, name3, name4, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__), name4(__VA_ARGS__)
#define vv(type, name, a, ...) vector<vector<type>> name(a, vector<type>(__VA_ARGS__))
#define vvv(type, name, a, b, ...) vector<vector<vector<type>>> name(a, vector<vector<type>>(b, vector<type>(__VA_ARGS__)))
#define vvvv(type, name, a, b, c, ...) vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))
constexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};
constexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
#pragma endregion
#pragma region TYPICAL_OUTPUT
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
#pragma endregion
#pragma region INPUT
int scan() { return getchar(); }
void scan(signed& a) { cin >> a; }
void scan(long long& a) { cin >> a; }
void scan(char& a) { cin >> a; }
void scan(double& a) { cin >> a; }
void scan(string& a) { cin >> a; }
template <class T, class S>
void scan(pair<T, S>& p) { scan(p.first), scan(p.second); }
template <class T>
void scan(vector<T>& a) {
for (auto& i : a) scan(i);
}
template <class T>
void scan(T& a) { cin >> a; }
void IN() {}
template <class Head, class... Tail>
void IN(Head& head, Tail&... tail) {
scan(head);
IN(tail...);
}
#define INT(...)   \
int __VA_ARGS__; \
IN(__VA_ARGS__)
#define LL(...)   \
ll __VA_ARGS__; \
IN(__VA_ARGS__)
#define STR(...)      \
string __VA_ARGS__; \
IN(__VA_ARGS__)
#define CHR(...)    \
char __VA_ARGS__; \
IN(__VA_ARGS__)
#define DBL(...)      \
double __VA_ARGS__; \
IN(__VA_ARGS__)
#define VEC(type, name, size) \
vector<type> name(size);    \
IN(name)
#define VEC2(type, name1, name2, size)   \
vector<type> name1(size), name2(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i])
#define VEC3(type, name1, name2, name3, size)         \
vector<type> name1(size), name2(size), name3(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])
#define VEC4(type, name1, name2, name3, name4, size)               \
vector<type> name1(size), name2(size), name3(size), name4(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i])
#define VV(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
IN(name)
#pragma endregion
#pragma region MATH
static constexpr int inf = numeric_limits<int>::max() / 2;
static constexpr ll infll = numeric_limits<ll>::max() / 2;
static constexpr double infdbl = numeric_limits<double>::max() / 2;
template <typename T, typename S>
T ceil(T x, S y) {
assert(y);
return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S>
T floor(T x, S y) {
assert(y);
return (y < 0 ? floor(-x, -y)
: (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
template <class T>
ll POW(T x, int n) {
ll res = 1;
for (; n; n >>= 1, x *= x)
if (n & 1) res *= x;
return res;
}
template <class T, class S>
ll POW(T x, S n, const ll& mod) {
ll res = 1;
x %= mod;
for (; n; n >>= 1, x = x * x % mod)
if (n & 1) res = res * x % mod;
return res;
}
template <typename T>
map<T, int> factor(T n) {
map<T, int> ret;
for (T i = 2; i * i <= n; i++) {
while (n % i == 0) {
ret[i]++;
n /= i;
}
}
if (n != 1) ret[n] = 1;
return ret;
}
template <class T>
vector<T> divisor(T x) {
vector<T> ret;
for (T i = 1; i * i <= x; i++)
if (x % i == 0) {
ret.pb(i);
if (i * i != x) ret.pb(x / i);
}
return ret;
}
vector<int> cumsum(const vector<bool>& v) {
vector<int> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<T> cumsum(const vector<T>& v) {
vector<T> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<vector<T>> cumsum2d(const vector<vector<T>>& v) {
vector<vector<T>> ret = v;
for (int i = 0; i < (int)v.size(); ++i) {
for (int j = 0; j < (int)v[0].size(); ++j) {
if (i > 0) ret[i][j] += ret[i - 1][j];
if (j > 0) ret[i][j] += ret[i][j - 1];
if (i > 0 && j > 0) ret[i][j] -= ret[i - 1][j - 1];
}
}
return ret;
}
template <typename T>
T parsum2d(const vector<vector<T>>& cum, int i1, int i2, int j1, int j2) {
if (i1 > i2 || j1 > j2) return 0;
T ret = cum[i2][j2];
if (i1 > 0) ret -= cum[i1 - 1][j2];
if (j1 > 0) ret -= cum[i2][j1 - 1];
if (i1 > 0 && j1 > 0) ret += cum[i1 - 1][j1 - 1];
return ret;
}
template <typename T, typename S, typename U>
bool inc(const T& x, const S& l, const U& r) {
return l <= x and x < r;
}
constexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }
template <typename T>
T arith_sum_from_range(T first, T last, T diff = T(1)) {
assert((last - first) % diff == 0);
return ((last - first) / 2 + 1) * (first + last) / 2;
}
template <typename T, typename S>
T arith_sum_from_term(T first, S n, T diff = T(1)) {
return (2 * first + (n - 1) * diff) * n / 2;
}
#pragma endregion
#pragma region BIT_FUNCTIONS
ll pow2(int i) { return 1LL << i; }
#define bit(n, k) (((n) >> (k)) & 1)
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
constexpr ll mask(int n) { return (1LL << n) - 1; }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
template <typename T>
T inv_all_bit(T a) {
T ret = 0;
int n = topbit(a);
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_all_bit(T a, int n) {
T ret = 0;
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_bit(T a, int k) { return a ^ (1 << k); }
#pragma endregion
#pragma region PAIR_OPERATORS
template <class T, class S>
pair<T, S> operator-(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi - y.fi, x.se - y.se);
}
template <class T, class S>
pair<T, S> operator+(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi + y.fi, x.se + y.se);
}
template <class T>
pair<T, T> operator&(const pair<T, T>& l, const pair<T, T>& r) {
return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se));
}
template <class T, class S>
pair<T, S> operator+=(pair<T, S>& l, const pair<T, S>& r) {
return l = l + r;
}
template <class T, class S>
pair<T, S> operator-=(pair<T, S>& l, const pair<T, S>& r) {
return l = l - r;
}
template <class T>
bool intersect(const pair<T, T>& l, const pair<T, T>& r) {
return (l.se < r.se ? r.fi < l.se : l.fi < r.se);
}
#pragma endregion
#pragma region SEARCH
template <class F>
void bit_search(int n, const F& f) {
for (int i = 0; i < (1 << n); ++i) {
set<int> st;
for (int j = 0; j < n; ++j) {
if ((i >> j & 1) == 1) {
st.insert(j);
}
}
f(st);
}
}
template <class T, class F>
T bin_search(T ok, T ng, const F& f) {
while (abs(ok - ng) > 1) {
T mid = ok + ng >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search_double(T ok, T ng, const F& f, int iter = 80) {
while (iter--) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
#pragma endregion
#pragma region STRING
void ERASE(string& s, char c) { s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const string& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const vector<char>& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
template <typename T>
void ERASE(vector<T>& v, T x) { v.erase(remove(all(v), x), v.end()); }
template <typename T>
void ERASE(vector<T>& v, const vector<T>& list) { fore(x, list) v.erase(remove(all(v), x), v.end()); }
#pragma endregion
#pragma region OUTPUT
template <typename T, typename S>
ostream& operator<<(ostream& os, const pair<T, S>& p) {
os << p.first << " " << p.second;
return os;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < (int)v.size(); i++) {
os << v[i] << (((i + 1) != v.size()) ? " " : "");
}
return os;
}
void OUT() { cout << endl; }
template <class Head, class... Tail>
void OUT(const Head& head, const Tail&... tail) {
cout << head;
if (sizeof...(tail)) cout << ' ';
OUT(tail...);
}
template <typename T>
string pad(T n, int d, char c) {
ostringstream sout;
sout << setfill(c) << setw(d) << n;
return sout.str();
}
#pragma endregion
#pragma region GRAPH
template <typename T = int>
struct Edge {
int from, to;
T cost;
int id;

Edge() = default;
Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}

operator int() const {
return to;
}
};

template <typename T = int>
struct Graph {
vector<vector<Edge<T>>> g;
int edge_id;

Graph() = default;
explicit Graph(int n) : g(n), edge_id(0) {}

size_t size() const {
return g.size();
}

void add_directed_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id++);
}

void add_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id);
g[to].emplace_back(to, from, cost, edge_id++);
}

void read(int m, int padding = -1, bool weighted = false, bool directed = false) {
for (int i = 0; i < m; ++i) {
int a, b;
cin >> a >> b;
a += padding;
b += padding;
T c = T(1);
if (weighted) {
cin >> c;
}
if (directed) {
add_directed_edge(a, b, c);
} else {
add_edge(a, b, c);
}
}
}

inline vector<Edge<T>>& operator[](const int& k) {
return g[k];
}

inline const vector<Edge<T>>& operator[](const int& k) const {
return g[k];
}
};
#pragma endregion
#pragma region PARSE
inline int toi(char c) { return c - '0'; }
int toi(string s) { return stoi(s); }
ll toll(string s) { return stoll(s); }
template <typename T>
string tos(T x) {
return to_string(x);
}
inline char toc(int i) { return '0' + i; }
template <typename T>
string tobit(T x, size_t d) {
if (d <= 2)
return bitset<2>(x).to_string();
else if (d <= 4)
return bitset<4>(x).to_string();
else if (d <= 8)
return bitset<8>(x).to_string();
else if (d <= 16)
return bitset<16>(x).to_string();
else if (d <= 32)
return bitset<32>(x).to_string();
else
return bitset<64>(x).to_string();
}
#pragma endregion

#pragma endregion
constexpr signed MOD = 1e9 + 7;
// constexpr signed MOD = 998244353;
#pragma region MOD
template <signed mod>
struct ModInt {
signed x;

ModInt() : x(0) {}

ModInt(long long y) : x((y >= 0) ? (y % mod) : (mod - ((-y) % mod)) % mod) {}

ModInt& operator++() {
++x;
if (x == mod) {
x = 0;
}
return *this;
}

ModInt& operator--() {
if (x == 0) {
x = mod;
}
--x;
return *this;
}

ModInt operator++(signed) {
ModInt ret = *this;
++*this;
return ret;
}

ModInt operator--(signed) {
ModInt ret = *this;
--*this;
return ret;
}

ModInt& operator+=(const ModInt& p) {
if ((x += p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator-=(const ModInt& p) {
if ((x += mod - p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator*=(const ModInt& p) {
x = (int)(1LL * x * p.x % mod);
return *this;
}

ModInt& operator/=(const ModInt& p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt& p) const { return x == p.x; }

bool operator!=(const ModInt& p) const { return x != p.x; }

/**
*  拡張ユークリッドの互除法を用いた逆元計算
*  - time: O(logx)
*/
ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while (b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(long long n) const {
ModInt ret(1), mul(x);
while (n > 0) {
if (n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream& operator<<(ostream& os, const ModInt& p) { return os << p.x; }

friend istream& operator>>(istream& is, ModInt& a) {
long long t;
is >> t;
a = ModInt<mod>(t);
return (is);
}

static signed get_mod() { return mod; }
};

using mint = ModInt<MOD>;
using vmi = vc<mint>;
#pragma endregion

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(9);
cerr << fixed << setprecision(9);

INT(n);
VEC(int, a, 3 * n);
vl rmax(3 * n);
vl rmin(3 * n);
pqg<int> que1;
rep(i, 2 * n) {
rmax[i] = (i == 0 ? 0 : rmax[i - 1]) + a[i];
que1.push(a[i]);
if (i >= n) {
rmax[i] -= que1.top();
que1.pop();
}
}
pq<int> que2;
rrep(i, 3 * n - 1, n - 1) {
rmin[i] = (i == 3 * n - 2 ? 0 : rmin[i + 1]) + a[i + 1];
que2.push(a[i + 1]);
if (i < 2 * n - 1) {
rmin[i] -= que2.top();
que2.pop();
}
}
ll ans = -inf;
rep(i, n - 1, 2 * n) {
chmax(ans, rmax[i] - rmin[i]);
}
OUT(ans);

return 0;
}
#include <bits/stdc++.h>
using namespace std;

/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, 
rb_tree_tag, tree_order_statistics_node_update>;
*/

#define MOD 1000000007
typedef long long ll;
//#define int ll 

typedef pair<int, int> ii;
typedef vector<ll> vi;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define ff first
#define ss second
#define pb push_back
#define all(s) s.begin(), s.end()
#define tc int t; cin>>t; while(t--)
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
#define file_read(x,y) freopen(x, "r", stdin); \
freopen(y, "w", stdout);
#define fightFight cin.tie(0) -> sync_with_stdio(0)
#define show_vi(a)        \
cout << #a << "-->";  \
for (auto &x : a) cout << x << " "; \
cout << endl;
ll binpow(ll a, ll b) {
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % MOD;
a = a * a % MOD;
b >>= 1;
}
return res;
}
// Make modulo -1 if you don't want it to apply modulo
int main(){
fightFight;
int n;	
cin >> n;
vi arr(n);
vi freq(n, 0);
for (auto& s : arr) {
cin >> s;
freq[s]++;
}
sort(all(arr));
bool flag = true;
if (n % 2) {
flag = freq[0] == 1;
for (int i = 2; i < n; i += 2) {
flag = flag && freq[i] == 2;
}

}
else {
for (int i = 1; i < n; i += 2) {
flag = flag && freq[i] == 2;
}
}
if (flag) cout << binpow(2, n / 2) << "\n";
else cout << "0\n";
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=2005,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,x,y,a[maxn],dp[maxn][2];

void orzck(){
cin >> n >> x >> y;
rep(n) cin >> a[i];
rep3(i,n-1,0){
dp[i][0]=abs(a[n-1]-(i?a[i-1]:y));
rep2(j,i+1,n) chkmax(dp[i][0],dp[j][1]);
dp[i][1]=abs((i?a[i-1]:x)-a[n-1]);
rep2(j,i+1,n) chkmin(dp[i][1],dp[j][0]);
}
print(dp[0][0]);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<assert.h>
#include<random>
#include<string>
#include<algorithm>
#include<queue>
#include<bitset>

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()

const long long mod = 998244353;
const long long inf = 1e18;
const int N = 510;

using ll = long long;

using namespace std;

string s;
int n;

bool check(int k)
{
if (k * 2 <= n) return 1;

int c0 = 0, c1 = 0;

for (int i = max(0, n - 1 - k + 1); i < k; i++)
{
if (s[i] == '0') c0++;
else c1++;
}

if (c1 != 0 && c0 != 0) return 0;
return 1;
}

void solve()
{
cin >> s;
n = s.size();

int l = 0, r = n + 1;

while (r > l + 1)
{
int m = (r + l) / 2;

if (check(m))
l = m;
else
r = m;
}

cout << l << '\n';
}

signed main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
// #define _GLIBCXX_DEBUG
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
#define rep(i,n) for (ll i = 0; i < (n); ++i)
using vl = vector<ll>;
using vvl = vector<vl>;
using P = pair<ll,ll>;
#define pb push_back
#define int long long
#define double long double
#define INF (ll) 3e18
// Ctrl + Shift + B コンパイル
// Ctrl + C 中断
// ./m 実行


signed main(){
string s; cin >> s;
int ans = s.size()/2;
if (s.size()%2){
string a = s.substr(0,s.size()/2+1);
string b = s.substr(s.size()/2,s.size()/2+1);
reverse(a.begin(), a.end());
char bit = a[0];
rep(i, a.size()){
if (a[i] == bit && b[i] == bit) ans++;
else break;
}
} else {
string a = s.substr(0,s.size()/2);
string b = s.substr(s.size()/2,s.size()/2);
reverse(a.begin(), a.end());
char bit = a[0];
rep(i, a.size()){
if (a[i] == bit && b[i] == bit) ans++;
else break;
} 
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=105,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],cnt,res;
bool vis[maxn];
bitset<maxn> bs[maxn];

void solve(bitset<maxn> vis){
int tot=0;
rep2(i,1,n+1) if(!vis[i]){
if(i<=33) tot+=a[i];
else if(i*2<=n){
if(!vis[i*2]){
tot+=max({0ll,a[i],a[i]+a[i*2]});
vis[i]=vis[i*2]=1;
}
else if(a[i]>=0) tot+=a[i];
}
else{
if(a[i]>=0) tot+=a[i];
}
}
chkmax(res,tot);
}

void dfs(bitset<maxn> bs1, bitset<maxn> vis, int x){
cnt++;
solve(vis);
rep2(i,x,34) if(!vis[i]){
bs1[i]=1;
dfs(bs1,vis|bs[i],i+1);
bs1[i]=0;
}
}

void orzck(){
rep2(i,1,maxn) for(int j=i; j<maxn; j+=i) bs[i][j]=1;
cin >> n;
rep2(i,1,n+1) cin >> a[i];
dfs(bitset<maxn>(),bitset<maxn>(),1);
bug(cnt);
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
ll solve(){
int n;
cin>>n;
map<int,int>mp;
for(int i=0;i<n;i++){
int x;
cin>>x;
mp[x]++;
}
if(n%2==1){
if(mp[0]!=1) return 0;
for(auto &m:mp){
if(m.first==0) continue;
if(m.second!=2) return 0;
}
return qmi(2,mp.size()-1,mod);
}else{
for(auto &m:mp){
if(m.second!=2) return 0;
}
return qmi(2,mp.size(),mod);
}
}
int main(){
cout<<solve();
return 0;
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

int n;
int x[N], y[N];
pii a[N]; 
int mn1 = 1e9, mx1, mn2 = 1e9, mx2;

int main() {
qread(n);
int pos = 0;
rep(i, 1, n) {
qread(x[i], y[i]);
if(x[i] > y[i]) swap(x[i], y[i]);
a[i] = mp(x[i], y[i]);
To_min(mn1, x[i]), To_max(mx1, x[i]);
To_min(mn2, y[i]), To_max(mx2, y[i]);
}
sort(a + 1, a + n + 1);
rep(i, 1, n) if(a[i].se >= a[pos].se) pos = i;
ll ans = 1ll * (mx1 - mn1) * (mx2 - mn2);
if(pos != 1) {
multiset<int> st;
st.insert(a[1].se), st.insert(a[pos].fi);
rep(i, 2, n) if(i != pos) st.insert(a[i].fi);
To_min(ans, 1ll * (mx2 - mn1) * (*st.rbegin() - *st.begin()));
rep(i, 2, n) {
if(i != pos) {
st.erase(st.find(a[i].fi));
st.insert(a[i].se);
}
To_min(ans, 1ll * (mx2 - mn1) * (*st.rbegin() - *st.begin()));
}
}
cout << ans << endl;
return 0;
}
#include <cstdio>
#include <iostream>
#include <algorithm>
#define mod 1000000007
#define maxN 310
using namespace std;
int f[maxN][maxN][maxN];
struct Option{ int l, r, x; } p[maxN];
bool cmp (Option P, Option Q) { return P.r < Q.r; }
int main ()
{
int n = 0, m = 0; scanf("%d %d", &n, &m);
for(int i = 1;i <= m; i++) scanf("%d %d %d", &p[i].l, &p[i].r, &p[i].x);
sort(p + 1, p + m + 1, cmp);
f[1][0][0] = 1; int pre = 1;
for(int i = 1;i <= n; i++)
{
while(p[pre].r < i && pre <= m) pre++;
if(p[pre].r == i)
{
int L = 0, R = 0;
L = pre; while(p[pre].r == i && pre <= m) pre++;
R = pre - 1;
for(int j = 0;j < i; j++)
for(int k = 0;k <= j; k++)
for(int q = L;q <= R; q++)
{
int cnt = (i >= p[q].l) + (j >= p[q].l) + (k >= p[q].l);
if(cnt != p[q].x) f[i][j][k] = 0;
}
}
for(int j = 0;j < i; j++)
for(int k = 0;k <= j; k++)
f[i + 1][i][j] = (f[i + 1][i][j] + f[i][j][k]) % mod,
f[i + 1][i][k] = (f[i + 1][i][k] + f[i][j][k]) % mod,
f[i + 1][j][k] = (f[i + 1][j][k] + f[i][j][k]) % mod;
}
int Ans = 0;
for(int j = 0;j <= n; j++)
for(int k = 0;k <= j; k++)
Ans = (Ans + f[n][j][k]) % mod;
printf("%d", (((Ans + Ans) % mod) + Ans) % mod);
return 0;
}
#define _GLIBCXX_DEBUG
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
using vi = vector<int>;
using vvi = vector<vi>;




int main(){
int n, sum = 0;
bool ans = false;
cin >> n;

vi s(n);
for(int i=0; i < n; i++){
cin >> s[i];
sum += s[i];
}

sort(s.begin(), s.end());

if(sum % 10 != 0) {
cout << sum << endl;
}else{
for(int i=0; i < n; i++){
if(s[i] % 10 != 0) {
sum -= s[i];
ans = true;
break;
}
}
if(ans) {
cout << sum << endl;
}else cout << 0 << endl;

}



return 0;
}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
template <typename T> using oset = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;

void test_case() {
int N, K; std::cin >> N >> K;
std::map<int, int> C;
for (int i = 0; i < N; ++i) {
int op; std::cin >> op;
++C[op];
}
std::set<std::pair<int, int>> extra;
for (auto v : C) {
auto [a, b] = v;
extra.insert(std::make_pair(b, a));
}
int answer = 0;
while (int(extra.size()) > K) {
auto v = *extra.begin();
extra.erase(v);
answer += v.first;
}
std::cout << answer << "\n";
}

int main() {
std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr);
int test = 1;
//std::cin >> test;
while (test--) {
test_case();
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for(int i = 0; i < (int)(n); i++)
typedef long long ll;
int main(void)
{
int N,M;cin>>N>>M;
N++;
int A[N],B[N];

map<int,int>mp;

int tmp;

rep(i,M){
cin>>A[i]>>B[i];
if(A[i]==1){
tmp=B[i];
mp[tmp]=1;
}
}
rep(i,M){
tmp=A[i];
if(B[i]==N-1&&mp[tmp]==1){
cout << "POSSIBLE" << "\n";
return 0;
}
}
cout << "IMPOSSIBLE" << "\n";
}
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
#pragma GCC target("avx2,fma")
#define rep(i,l,r) for (int i = l; i < r; i++)
#define repr(i,r,l) for (int i = r; i >= l; i--)
#define X first
#define Y second
#define pb push_back
#define endl '\n'
#define debug(x) cerr << #x << " : " << x << endl;
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pll;
const long long int N = 1e5+20,mod = 1e9+7,inf = 1e9+10,sq = 32000;
inline int mkay(int a,int b){
if (a+b >= mod) return a+b-mod;
if (a+b < 0) return a+b+mod;
return a+b;
}
inline int poww(int n,int k){
int c = 1;
while (k){
if (k&1) c = (1ll*c*n)%mod;
n = (1ll*n*n)%mod;
k >>= 1;
}
return c;
}
vector<int> adj[N];
int cnt[N],a[N],b[N];
bool vis[N][2];
int main(){
ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
int n;
cin >> n;
if (n == 2){
cout << 1 << ' ' << 2;
return 0;
}
rep(i,1,n){
int u,v;
cin >> u >> v;
adj[u].pb(v);
adj[v].pb(u);
}
int st = 0,st2 = 0;
rep(i,1,n+1){
for (int u : adj[i]){
if (adj[u].size() > 1) cnt[i]++;
}
if (cnt[i] > 2){
cout << -1;
return 0;
}
}
rep(i,1,n+1){
if (cnt[adj[i][0]] <= 1 && adj[i].size() == 1){
st = i;
}
}
int p1 = 1;
a[0] = 1;
vis[st][0] = 1;
st2 = st;
st = adj[st][0];
while (p1 < n){
int sz = adj[st].size();
vis[st][0] = 1;
if (sz == 1){
a[p1] = p1+1;
p1++;
break;
}
if (sz == 2){
a[p1] = p1+1;
p1++;
for (int u : adj[st]) if (!vis[u][0]) st = u;
continue;
}
int nxt = 0;
int t = 0;
int k = 0;
for (int v : adj[st]) if (!vis[v][0] && adj[v].size() == 1) k++;
a[p1+k] = p1+1;
for (int v : adj[st]){
if (t == k) break;
if (vis[v][0]) continue;
if (adj[v].size() == 1){
a[p1] = p1+2;
p1++;
t++;
}
}
if (p1 == n-1 && k){
swap(a[p1],a[p1-1]);
break;
}
p1++;
for (int v : adj[st]) if (!vis[v][0] && adj[v].size() != 1) nxt = v;
if (nxt) st = nxt;
else break;
}
rep(i,1,n+1){
int v = adj[i][0];
if (adj[i].size() == 1 && v != adj[st2][0] && cnt[v] <= 1){
st2 = i;
break;
}
}
st = st2;
p1 = 1;
b[0] = 1;
vis[st][1] = 1;
st = adj[st][0];
while (p1 < n){
int sz = adj[st].size();
vis[st][1] = 1;
if (sz == 1){
b[p1] = p1+1;
break;
}
if (sz == 2){
b[p1] = p1+1;
p1++;
for (int u : adj[st]) if (!vis[u][1]) st = u;
continue;
}
int nxt = 0;
int t = 0;
int k = 0;
for (int v : adj[st]) if (!vis[v][1] && adj[v].size() == 1) k++;
b[p1+k] = p1+1;
for (int v : adj[st]){
if (t == k) break;
if (vis[v][1]) continue;
if (adj[v].size() == 1){
b[p1] = p1+2;
p1++;
t++;
}
}
if (p1 == n-1 && k) swap(b[p1],b[p1-1]);
p1++;
for (int v : adj[st]) if (!vis[v][1] && adj[v].size() != 1) nxt = v;
if (nxt) st = nxt;
else break;
}
bool f = 0;
rep(i,0,n){
if (a[i] < b[i]){
f = 1;
break;
}
if (b[i] < a[i]) break;
}
if (f) rep(i,0,n) cout << a[i] << ' ';
else rep(i,0,n) cout << b[i] << ' ';
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
int N,K;
cin>>N>>K;
int ans = 1,how_long=K;
while(N > how_long){
ans++;
how_long += (K-1);
}
cout<<ans<<endl;
}

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

ll a[1000000+4];

int main()
{
ll n, m, sum = 0;
scanf("%lld%lld",&n,&m);
for(int i=0;i<n;i++){
scanf("%lld",&a[i]);
}
for(int i = 1; i < n; i++){
if((a[i] + a[i-1]) > m){
ll d = (a[i] + a[i-1]) - m;
sum  = sum + d;
if(a[i] >=d){
a[i] = a[i] - d;
}else{
a[i] = 0;
}
}
}

printf("%lld\n",sum);

return 0;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vector<pair<int, ld>>> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers.
int sq(int x){
return x*x;
} 
void solve(){ 
int x, y, xx, yy; cin>>x>>y>>xx>>yy;
int n; cin>>n;
vector<array<int, 3>> v(n+2);
v[n] = {x, y, 0};
v[n+1] = {xx, yy, 0};
for(int i=0; i<n; i++){
int tx, ty, tr; cin>>tx>>ty>>tr;
v[i] = {tx, ty, tr};
}
graph g(n+2);
for(int i=0; i<n+2; i++){
for(int j=i+1; j<n+2; j++){
ld dd = sq(v[i][0] - v[j][0]) + sq(v[i][1] - v[j][1]);
dd = sqrtl(dd);
dd = max((ld)0.0, dd - v[i][2] - v[j][2]);
g[i].eb(j, dd);
g[j].eb(i, dd);
}
}
vector<ld> dist(n+2, 1e18);
dist[n] = 0;
priority_queue<pair<ld, int>> pq;
pq.push({0, n});
while(sz(pq)){
int nn = pq.top().sc; pq.pop();
for(auto x: g[nn]){
if(dist[x.fr] > x.sc + dist[nn]){
dist[x.fr] = x.sc + dist[nn];
pq.push({-dist[x.fr], x.fr});
}
}
}
cout<<fixed<<setprecision(10)<<dist[n+1]<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define per(i,x,y) for(int i=x;i>=y;--i)
#define lon long long
#define lb(o) (o&-o)
using namespace std;
const int n7=501234;
int n,tre[n7],b[n7],L[n7],R[n7],vis[n7];lon ans;

int rd(){
int shu=0;bool fu=0;char ch=getchar();
while( !isdigit(ch) ){if(ch=='-')fu=1;ch=getchar();}
while( isdigit(ch) )shu=(shu<<1)+(shu<<3)+ch-'0',ch=getchar();
return fu?-shu:shu;
}

void updat(int o,int x){
while(o<=n)tre[o]+=x,o+=lb(o);
}

int Dquery(int o){
int tot=0;
while(o)tot+=tre[o],o-=lb(o);
return tot;
}

int query(int l,int r){
return Dquery(r)-Dquery(l-1);
}

int main(){
n=rd();
rep(i,1,n)L[i]=rd(),R[i]=rd();
rep(i,1,n)if(L[i]<L[i-1]||R[i]<R[i-1]){puts("-1");return 0;}

rep(i,1,n){
if(L[i]^L[i+1]){
b[i]=L[i];
}
if(R[i]^R[i-1]){
b[i]=R[i];
}
}

rep(i,1,n){
if(!b[i])continue;
if(vis[ b[i] ]){puts("-1");return 0;}
vis[ b[i] ]=1;               
}
int poi=1;
rep(i,1,n){
while(b[i])i++;
while(vis[poi])poi++;
b[i]=poi,poi++;
}
int M=501111;
per(i,n,1){
M=min(M,b[i]);
if(M^L[i]){puts("-1");return 0;}
}
rep(i,1,n){
M=max(M,b[i]);
if(M^R[i]){puts("-1");return 0;}
}
rep(i,1,n)updat(b[i],1),ans+=query(b[i]+1,n);
printf("%lld",ans);
return 0;
}

// Problem: D - Small Multiple
// Contest: AtCoder - AtCoder Regular Contest 084
// URL: https://atcoder.jp/contests/arc084/tasks/arc084_b
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){int x=0,f=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;
ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+
(x<<3)+(ch^48);ch=getchar();}return x*f;}
//#define M
//#define mo
#define N 100010
struct Node
{
int x, y;  
bool operator <(const Node &A) const
{
return x>A.x; 
}
}t; 
struct node
{
int x, y, z, n; 
}d[N*10]; 
int n, m, i, j, k; 
int u, v, g; 
int ans[N], h[N], b[N]; 
priority_queue<Node>q; 

int sum(int x)
{
int ans=0; 
while(x) ans+=x%10, x/=10; 
return ans; 
}

void cun(int x, int y, int z)
{
// printf("cun(%lld, %lld)=%lld\n", x, y, z); 
d[++k].x=x; d[k].y=y; d[k].z=z; 
d[k].n=h[x]; h[x]=k; 
}

signed main()
{
//	freopen("tiaoshi.in", "r", stdin); 
//	freopen("tiaoshi.out", "w", stdout); 
memset(h, -1, sizeof(h)); 
n=read(); 
for(i=0; i<n; ++i)
{
for(j=0; j<=9; ++j)
cun(i, (i*10+j)%n, j);
}
q.push(Node{0, ans[0]=sum(n)}); b[0]=1; 
for(i=1; i<n; ++i) q.push(Node{i, ans[i]=sum(i)}), b[i]=1; 
while(!q.empty())
{
t=q.top(); q.pop(); 
b[u=t.x]=0; 
for(g=h[u]; g!=-1; g=d[g].n)
{
v=d[g].y;  
if(ans[u]+d[g].z<ans[v])
{

ans[v]=ans[u]+d[g].z; 
// printf("%lld->%lld\n", u, v, ans[v]); 
if(!b[v])
{
b[v]=1; 
q.push(Node{v, ans[v]}); 
}
}
}
}
// for(i=0; i<n; ++i) printf("%lld ", ans[i]); 
// printf("\n"); 
printf("%lld", ans[0]); 
return 0; 
}

/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

int n, k;
cin >> n >> k;
vector<int> a(n);
rep(i, n) cin >> a[i];
int p = -1;
rep(i, n) if (a[i] == 1) p = i;
int l = p;
int r = n-1-p;
int mn = min(l, r);
int mx = max(l, r);
dvar(mn);
dvar(mx);
int ans = (mn+k-2)/(k-1);
dvar(ans);
int overflow = ans*(k-1)-mn;
dvar(overflow);
mx -= overflow;
ans += max(0, mx+k-2)/(k-1);
cout << ans << endl;

cout << flush;
return 0;
}

#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <queue>
#include <set>
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

constexpr int N = 100000;

std::set<int> e[N];

char col[N];
int  w[N];
int  n;

int  height[N];
int  diameter;
void dfs(int u, int f)
{
height[u] = w[u];
for (int v : e[u])
if (v != f)
{
dfs(v, u);
check_max(diameter, height[u] + height[v]);
check_max(height[u], height[v] + w[u]);
}
check_max(diameter, height[u]);
}

int main()
{
n = sc.next_int();
for (int i = 1; i < n; i++)
{
int u = sc.next_int() - 1;
int v = sc.next_int() - 1;
e[u].insert(v);
e[v].insert(u);
}

sc.next_token(col);

std::queue<int> ones;
for (int i = 0; i < n; i++)
if (e[i].size() == 1)
ones.push(i);
while (!ones.empty())
{
int u = ones.front();
ones.pop();
if (col[u] == 'B' && !e[u].empty())
{
int v = *e[u].begin();
e[v].erase(u);
e[u].erase(v);
if (e[v].size() == 1)
ones.push(v);
}
}

int ans  = -2;
int root = 0;
for (int i = 0; i < n; i++)
if (!e[i].empty() || col[i] == 'W')
{
root   = i;
ans    = ans + 2;
char c = col[i];
if (e[i].size() % 2 == 1)
{
if (c == 'W')
{
w[i] = 0;
}
else
{
ans++;
w[i] = 2;
}
}
else
{
if (c == 'W')
{
ans++;
w[i] = 2;
}
else
{
w[i] = 0;
}
}
}

if (ans == -2)
{
puts("0");
return 0;
}
else if (ans == 1)
{
puts("1");
return 0;
}

dfs(root, root);

std::cout << ans - diameter << std::endl;

return 0;
}

// Code by Parsa Eslami

#include <bits/stdc++.h>
#define int long long
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FORR(i,a,b) for(int i=a;i>=b;i--)
#define S second
#define F first
#define pb push_back
#define SZ(x) (int)x.size()
#define all(x) x.begin(),x.end()
#define err(x) cout<<#x<<": "<<x<<'\n';

using namespace std;
const int INF=1e15;

int32_t main() {
ios_base::sync_with_stdio(0); cin.tie(0);

int n; cin>>n;
char opt[n];
opt[0]='+';
int a[n+1];
cin>>a[1];
FOR(i,1,n-1) cin>>opt[i]>>a[i+1];
int ss[n+2];
ss[n+1]=0;
ss[n]=a[n];
FORR(i,n-1,1) ss[i]=ss[i+1]+a[i];
int ans=0;
FOR(i,1,n) {ans+=a[i]; if(opt[i-1]=='-') ans-=2*a[i];}
int ps[n+1];
ps[0]=0;
FOR(i,1,n){
ps[i]=ps[i-1]+a[i];
if(opt[i-1]=='-') ps[i]-=2*a[i];
}
int sum=0;
FOR(i,1,n){
int nxt=0;
if(opt[i-1]=='-'){
FOR(j,i+1,n){
if(opt[j-1]=='-'){
nxt=j;
break;
}
}
if(nxt==0) break;
ans=max(ans,ss[nxt]+ps[i]-(ps[nxt-1]-ps[i]));
i=nxt-1;
}
}
cout<<ans<<'\n';

return 0;
}

#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace IN {
#define BUF_SIZE 1 << 17
static char buf[BUF_SIZE], *fs = buf, *ft = buf;
inline int nc() {
return fs == ft && (ft = (fs = buf) + fread(buf, 1, BUF_SIZE, stdin), fs == ft) ? EOF : *fs++;
}
template <typename T>
inline int rn(T &x) {
x = 0;
int f = 0;
char ch = nc();
while (ch < '0' || ch > '9') {
if (ch == '-')
f = 1;
ch = nc();
if (ch == EOF)
return EOF;
}
while (ch >= '0' && ch <= '9') {
x = x * 10 + ch - 48;
ch = nc();
}
x = f ? -x : x;
return 0;
}
template <typename T>
inline int read(T &x) {
return rn(x);
}
template <typename T, typename... Args>
inline int read(T &x, Args &...args) {
rn(x);
return read(args...);
}
#undef BUF_SIZE
}  // namespace IN
using IN::read;
using namespace std;

#define INF 0x3f3f3f3f
#define P 1000000007
#define LL long long
#define MP make_pair
#define VI vector<int>
#define VLL vector<long long>
#define PII pair<int, int>
#define PLL pair<LL, LL>
#define ALL(A) A.begin(), A.end()
#define REP(i, n) for (LL i = 0; i < (LL)n; ++i)
#define REP1(i, n) for (LL i = 1; i <= (LL)n; ++i)
#define ZERO(arr) memset(arr, 0, sizeof(arr))

// Debug
#define DISP(arr, n)                     \
do {                                 \
REP(i, n) cout << arr[i] << ' '; \
cout << endl;                    \
} while (0)
#define DISP1(arr, n)                     \
do {                                  \
REP1(i, n) cout << arr[i] << ' '; \
cout << endl;                     \
} while (0)
#define DISP_T(arr, n, m)                       \
do {                                        \
REP(i, n) {                             \
REP(j, m) cout << arr[i][j] << ' '; \
cout << endl;                       \
}                                       \
} while (0)
#define DISP_T1(arr, n, m)                       \
do {                                         \
REP1(i, n) {                             \
REP1(j, m) cout << arr[i][j] << ' '; \
cout << endl;                        \
}                                        \
} while (0)
#define DISP_V(vec)              \
do {                         \
for (auto elem : vec)    \
cout << elem << ' '; \
cout << endl;            \
} while (0)
#define DISP_VP(vec)                                          \
do {                                                      \
for (auto elem : vec)                                 \
cout << elem.first << ' ' << elem.second << endl; \
cout << endl;                                         \
} while (0)

#define SIZE 1000010

struct edge {
int v, w, nxt;
} edge[SIZE * 2];
int head[SIZE];
int tot;
void add_edge(int u, int v, int w) {
edge[++tot].v = v;
edge[tot].w = w;
edge[tot].nxt = head[u];
head[u] = tot;
}

vector<PII> t[SIZE];
set<int> col;

set<int> st[SIZE];
int dis[SIZE];

int fa[SIZE];
int find(int x) {
if (x != fa[x])
fa[x] = find(fa[x]);
return fa[x];
}
int vis[SIZE];

deque<int> q;

VI g[SIZE];

int inq[SIZE];

map<int, int> mp;

VI z[SIZE];

int n, m;
int main() {
read(n, m);
REP(i, m) {
int u, v, c;
read(u, v, c);
t[c].push_back(MP(u, v));
st[c].insert(u);
st[c].insert(v);
col.insert(c);
}
int cnt = n + 1;
REP1(i, n) fa[i] = i;
for (int c : col) {
for (auto p : t[c]) {
int u = p.first, v = p.second;
int fu = find(u), fv = find(v);
if (fu != fv)
fa[fu]=fv;
}
for (int x : st[c]) {
z[find(x)].push_back(x);
}
for (int x : st[c]) {
if (!z[x].size())
continue;
for (int y : z[x]) {
add_edge(y, cnt, 1);
add_edge(cnt, y, 0);
}
++cnt;
}
for (int x : st[c]) {
fa[x] = x;
z[x].clear();
}
}
memset(dis, 0x3f, sizeof(dis));
dis[1] = 0;
q.push_back(1);
while (!q.empty()) {
int x = q.front();
q.pop_front();
for (int i = head[x]; i; i = edge[i].nxt) {
int v = edge[i].v, w = edge[i].w;
if (dis[v] == INF) {
dis[v] = dis[x] + w;
if (w)
q.push_back(v);
else
q.push_front(v);
}
}
}
if (dis[n] == INF)
cout << -1 << endl;
else
cout << dis[n] << endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define N 1010
typedef long long ll;
int n,x[N],y[N];
string ans[N];
const char zz[4]={'R','D','U','L'};
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n;
for(int i=1;i<=n;++i){
int X,Y;
cin>>X>>Y;
X*=-1,Y*=-1;
x[i]=X+Y,y[i]=X-Y;
}
for(int i=2;i<=n;++i){
if((abs(x[i])&1)^(abs(x[1])&1)||(abs(y[i])&1)^(abs(y[1])&1)){
cout<<-1<<'\n';
return 0;
}
}
int tp=(abs(x[1])&1)^1;
for(int i=30;i>=0;--i){
int t=(1<<i)-(i==30&&tp);
for(int j=1;j<=n;++j){
int op=0;
if(x[j]>=0)op^=1,x[j]-=t;
else x[j]+=t;
if(y[j]>=0)op^=2,y[j]-=t;
else y[j]+=t;
ans[j]+=zz[op];
}
}
cout<<31<<'\n';
for(int i=30;i>=0;--i){
cout<<(1<<i)-(i==30&&tp)<<(" \n"[i==0]);
}
for(int i=1;i<=n;++i){
cout<<ans[i]<<'\n';
}
return 0;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
unordered_map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
mp.reserve(3000); cnt.reserve(3000);
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int a[N];

int main() {
qread(n);
rep(i, 1, n) qread(a[i]);
int ans = 0;
rep(i, 1, n) {
if(a[i] != i) continue;
int j = i;
while(j <= n && a[j] == j) ++j;
ans += (j - i + 1) / 2;
i = j - 1;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
//#include <atcoder/all>
using namespace std;
#define rep(i,n) for(ll i=0; i<n; i++)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rrep(i,n) for(ll i=n-1; i>=0; i--)
#define fi first
#define se second
#define pcnt __builtin_popcountll
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int,int> Pii;
typedef pair<ll,ll> Pll;
typedef pair<ll,Pll> PlP;
template<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }
template<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}cout << "\n";}
template<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}
string zero_padding(int val, int nf){ ostringstream sout;sout << setfill('0') << setw(nf) << val; return sout.str();};
const ld eps = 1e-10;
ull mo = 1000000007;
ld PI=asin(1)*2;
//using namespace atcoder;

int main(){
ll N,M;
cin >> N >> M;
if(N == 1 && M == 1){
drop(1);
}else if(N == 1){
drop(M-2);
}else if(M == 1){
drop(N-2);
}else{
drop((N-2)*(M-2));
}
}

#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#include<stdlib.h>
#include<queue>
#include<ctime>
#include<map>
#include<set>
#include<unordered_map>
const double down = 0.9997;
const long long N = 4005;
const long long mod = 1000000007;
using namespace std;
inline long long read()
{
long long x=0,f=1;
char ch=getchar();
while(!isdigit(ch))
{
if(ch=='-')
f=-1;
ch=getchar();
}
while(isdigit(ch))
{
x=(x<<1)+(x<<3)+(ch^48);
ch=getchar();
}
return x*f;
}
inline void write(long long x){
if(x<0) putchar('-'), x=-x;
if(x>9) write(x/10);
putchar(x%10+'0');
}
long long du[N],mul[N],inv[N];
long long fpow(long long a,long long x)
{
long long s = 1;
while(x)
{
if(x&1)
{
s *= a;
s %= mod;
}
a *= a;
a %= mod;
x >>= 1;
}
return s;
}
long long n,k;
long long c(long long n,long long m)
{
if(m==1)	return 1;
if(n<m || n<0 || m<0)	return 0;
return mul[n] * inv[m] % mod * inv[n-m] % mod;
}
int main()
{
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
//srand(time(0));
n = read() , k = read();
du[0] = mul[0] = 1;
for(long long i=1;i<=4000;i++)
{
du[i] = du[i-1] * 2ll % mod;
mul[i] = mul[i-1] * i % mod;
}
inv[4000] = fpow( mul[4000] , mod-2 );
for(long long i=3999;i>=0;i--)
{
inv[i] = inv[i+1] * ( i+1 ) % mod;
}
if(k==1 && n==1)
{
putchar('1');
putchar('\n');
}
else
{
write( du[max(0ll,n-k-1)] * ( ( ( c( n+k-2 , n-1 ) - c( n+k-2 , n ) ) % mod + mod ) % mod ) % mod );
putchar('\n');
}
return 0;
}


// Author: Z_char 

#include <bits/stdc++.h>

// head...
using i64 = long long; using u64 = unsigned long long; using u16 = unsigned short; using i16 = short; using u32 = unsigned int; using pii = std::pair<int, int>; using f64 = double; using f80 = long double;
template<class T> using ve = std::vector<T>;
template<class T> using fun = std::function<T>;
template<class T1, class T2> using pr = std::pair<T1, T2>;
template<class T> using pq = std::priority_queue<T>;
template<class T> using lpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template<class T> using gpq = std::priority_queue<T, std::vector<T>, std::less<T>>;
#define all(x) x.begin(), x.end()
#define rg(v, l, r) &v[l], &v[r + 1]
#define vrg(v, l, r) (v).begin() + l, (v).begin() + r + 1
#define freop(x) (freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout))
std::mt19937_64 seed(std::chrono::steady_clock::now().time_since_epoch().count());
#define zxrnd(l, r) std::uniform_int_distribution<i64>(l, r)(seed)
#ifdef Z_char
template<class T> inline void debug_out(T x, char ch = '\n') { std::cerr << x << ' ' << ch; }
template<class T, class... Args> inline void debug_out(T fir, Args... args) { debug_out(fir, ' '), debug_out(args...); }
#define frein(x) freopen(#x".in", "r", stdin)
#define freout(x) freopen(#x".out", "w", stdout)
#define debug_line(...) std::cerr << "work[" << __LINE__ << "]" << ": " << "[" << #__VA_ARGS__ << "]" << " = ", debug_out(__VA_ARGS__)
#define debug(...) std::cerr << "[" << #__VA_ARGS__ << "] = ", debug_out(__VA_ARGS__)
#define debugpos std::cerr << "Running " << __FUNCTION__ << " on line " << __LINE__ << "..." << '\n'
#define debugstop std::cerr << "Running " << __FUNCTION__ << " on line " << __LINE__ << "..." << '\n', system("pause")
#define dprint(...) fprintf(stderr, __VA_ARGS__)
#define dwrite(...) write(__VA_ARGS__)
#define asert(...) assert(__VA_ARGS__)
struct _Timer_check {
clock_t val;
void operator()(bool flg = false) {
clock_t now = clock();
if (!flg) debug((1.0 * now - val) / CLOCKS_PER_SEC);
val = now;
}
};
_Timer_check cktime;
#else 
u32 def_cnt = 0;
#define frein(x) ++def_cnt
#define freout(x) ++def_cnt
#define debug_line(...) ++def_cnt
#define debug(...) ++def_cnt
#define debugpos ++def_cnt
#define debugstop ++def_cnt
#define dprint(...) ++def_cnt
#define dwrite(...) ++def_cnt
#define asert(...) ++def_cnt
#define cktime(...) ++def_cnt
#endif
template<class T> void memset(int val, T& fir) { memset(fir, val, sizeof fir); }
template<class T, class... args> void memset(int val, T& fir, args&... arg) { memset(fir, val, sizeof fir), memset(val, arg...); }
template<class T> 
inline T read() {
T x = 0; int f = 1; char ch = getchar();
for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
for (;  isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;
return x * f;
}
template<class T> inline void read(T &x) { x = read<T>(); }
template<class T, class... Args> inline void read(T &fir, Args&... args) { read(fir), read(args...); }
template<class T> 
inline void write(T x, char ch = '\n') {
static int stk[32];
if (x < 0) putchar('-'), x = -x;
int top = 0;
do stk[++top] = x % 10, x /= 10; while(x);
while (top) putchar(stk[top--] + 48);
putchar(ch);
}
template<class T, class... Args> inline void write(T fir, Args... args) { write(fir, ' '), write(args...); }
// head...

const int D = 1e9 + 7;

const int K = 73, N = 350;

char str[K];
i64 fac[N], ifac[N];

inline i64 pwer(i64 a, i64 b, i64 ret = 1) {
for (; b; b >>= 1, a = a * a % D)
if (b & 1) ret = ret * a % D;
return ret;
}

inline void solv() {
int n = read<int>(), m = read<int>();
scanf("%s", str + 1);
int top = 0;
static int stk[73], cnt[73];
stk[0] = n;
auto check = [&]() {
if (!top) return false;
std::queue<int> q;
static int f[K], vis[K], p[K];
memset(0, f, vis, p);
for (int i = 1, j = 1; i <= m; ++i) {
if (str[i] == 'r') {
if (j <= top) {
if (stk[j] > 0) q.push(j);
else p[j] = true;

++j, vis[i] = true;
}
}
else {
if (size(q)) {
f[i] = stk[q.front()] - 1;
p[q.front()] = 1;
vis[i] = true;
q.pop();
}
}
}
if (std::count(p + 1, p + top + 1, 0)) return false;
for (int i = m, cnt = 0; i >= 1; --i) {
if (vis[i]) {
if (f[i]) {
if (cnt < f[i]) return false;
cnt -= f[i];
}
}
else {
++cnt;
}
}
return true;
};
auto binom = [&](int n, int m)->i64 {
if (n < m) {
return 0;
}
return fac[n] * ifac[m] % D * ifac[n - m] % D;
};
i64 ans = 1;
fun<void(int)> dfs = [&](int now) {
if ((now + cnt[0]) * 2 - 1 > n) return;
if (check()) {
i64 ret = fac[top];
for (int i = 0; i <= stk[1]; ++i) {
ret = ret * ifac[cnt[i]] % D;
}
// ret = ret * binom(n - 2 - top * 2 - 1, 2 * (now + top) - cnt[0]) % D;
ret = ret * binom(n + top * 2 - cnt[0] * 2 + 1, 2 * (now + top)) % D;
ans += ret;
if (ans >= D) ans -= D;
}
for (int i = stk[top]; i >= 0; --i) { // 枚举新一段段数
stk[++top] = i;
++cnt[i];
dfs(now + i);
--top;
--cnt[i];
}
};
dfs(0);
write(ans);
}
inline void pre_work() {
fac[0] = 1, ifac[0] = 1;
for (int i = 1; i < N; ++i) {
fac[i] = fac[i - 1] * i % D;
ifac[i] = pwer(fac[i], D - 2);
}
}

signed main() {
pre_work();
int z_char = 1;
// int z_char = read<int>();
while (z_char--) solv();
}
// St. JR bless you

#line 1 "Contests/AtCoder_arc102/arc102_b/main.cpp"
/* #define aclmodint */
/* #define aclsegtree */
/* #include <atcoder/all> */
/* using namespace atcoder; */

#line 1 "library/me/template.cpp"
// This is a dummy line
#ifndef ONLINE_JUDGE
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()
#define END(...) { print(__VA_ARGS__); return; }

#ifdef ONLINE_JUDGE
#define DBG(...) {}
#else
#define DBG(a) { cerr << #a << ": "; dbg(a); }
#endif

using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using ll = long long;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VS = vector<string>;
using VVS = vector<VS>;
using VVVS = vector<VVS>;
using VC = vector<char>;
using VVC = vector<VC>;
using VVVC = vector<VVC>;
using P = pair<int, int>;
using VP = vector<P>;
using VVP = vector<VP>;
using VVVP = vector<VVP>;
using LP = pair<ll, ll>;
using VLP = vector<LP>;
using VVLP = vector<VLP>;
using VVVLP = vector<VVLP>;
constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

#ifdef aclmodint

using MI7 = modint1000000007;
using V7 = vector<MI7>;
using VV7 = vector<V7>;
using VVV7 = vector<VV7>;
using MI3 = modint998244353;
using V3 = vector<MI3>;
using VV3 = vector<V3>;
using VVV3 = vector<VV3>;

ostream &operator<<(ostream &os, const modint &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI3 &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI7 &x) {
os << x.val();
return os;
}

istream &operator>>(istream &is, modint &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI3 &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI7 &x) {
int y; is >> y;
x = y;
return is;
}

#endif

void print() { cout << '\n'; }
template<typename T>
void print(const T &t) { cout << t << '\n'; }
template<typename Head, typename... Tail>
void print(const Head &head, const Tail &... tail) {
cout << head << ' ';
print(tail...);
}

#ifdef ONLINE_JUDGE
template<typename... Args>
void dbg(const Args &... args) {}
#else
void dbg() { cerr << '\n'; }
template<typename T>
void dbg(const T &t) { cerr << t << '\n'; }
template<typename Head, typename... Tail>
void dbg(const Head &head, const Tail &... tail) {
cerr << head << ' ';
dbg(tail...);
}
#endif

template< typename T1, typename T2 >
ostream &operator<<(ostream &os, const pair< T1, T2 >& p) {
os << p.first << " " << p.second;
return os;
}

template< typename T1, typename T2 >
istream &operator>>(istream &is, pair< T1, T2 > &p) {
is >> p.first >> p.second;
return is;
}

template< typename T >
ostream &operator<<(ostream &os, const vector< T > &v) {
for(int i = 0; i < (int) v.size(); i++) {
os << v[i] << (i + 1 != (int) v.size() ? " " : "");
}
return os;
}

template< typename T >
istream &operator>>(istream &is, vector< T > &v) {
for(T &in : v) is >> in;
return is;
}

template< typename T1, typename T2 >
inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

template< typename T1, typename T2 >
inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

template <typename T>
pair<VI, vector<T>> compress(const vector<T> &a) {
int n = a.size();
vector<T> x;
REP(i, n) x.push_back(a[i]);
sort(ALL(x)); x.erase(unique(ALL(x)), x.end());
VI res(n);
REP(i, n) res[i] = lower_bound(ALL(x), a[i]) - x.begin();
return make_pair(res, x);
}

#ifdef aclsegtree

template<typename S>
struct value_size { S value; int size; };

template<typename S>
S min_op(S l, S r) { return min(l, r); };
template<typename S>
S max_op(S l, S r) { return max(l, r); };
template<typename S>
S sum_op(S l, S r) { return l + r; };
template<typename S>
value_size<S> sum_op_size(value_size<S> l, value_size<S> r) {
return {l.value + r.value, l.size + r.size};
};

template<typename S>
S min_e() { return  numeric_limits<S>::max(); };
template<typename S>
S max_e() { return numeric_limits<S>::min(); };
template<typename S>
S sum_e() { return 0; }
template<typename S>
value_size<S> sum_e_size() { return {0, 0}; }
template<typename S>
value_size<S> min_e_size() { return {numeric_limits<S>::max(), 0}; }
template<typename S>
value_size<S> max_e_size() { return {numeric_limits<S>::min(), 0}; }

template<typename S, typename F>
S chmin_mapping(F f, S x) { return min(x, f); }
template<typename S, typename F>
S chmax_mapping(F f, S x) { return max(x, f); }
template<typename S, typename F>
S add_mapping(F f, S x) { return x + f; }
template<typename S, typename F>
value_size<S> add_mapping_size(F f, value_size<S> x) {
return {x.value + x.size * f, x.size};
}
template <typename S,typename F, F ID>
S change_mapping(F f, S x) { return (f == ID? x : f); }
template <typename S,typename F, F ID>
S change_mapping_size(F f, value_size<S> x) { return (f == ID? x : value_size<S>(f, x.size)); }
template <typename S, typename F1, typename F2>
S linear_mapping(pair<F1, F2> f, S x) { return x * f.first + f.second; }
template <typename S, typename F1, typename F2>
value_size<S> linear_mapping_size(pair<F1, F2> f, value_size<S> x) { return {x.value * f.first + x.size * f.second, x.size}; }

template<typename F>
F chmin_composition(F f, F g) { return min(f, g); }
template<typename F>
F chmax_composition(F f, F g) { return max(f, g); }
template<typename F>
F add_composition(F f, F g) { return f + g; }
template <typename F, F ID>
F change_composition(F f, F g) { return (f == ID? g : f); }
template<typename F1, typename F2>
pair<F1, F2> linear_composition(pair<F1, F2> f, pair<F1, F2> g) { return {f.first * g.first, f.first * g.second + f.second}; }

template<typename F>
F chmin_id() { return numeric_limits<F>::max(); }
template<typename F>
F chmax_id() { return numeric_limits<F>::min(); }
template<typename F>
F add_id() { return 0; }
template<typename F, F ID>
F change_id() { return ID; }
template<typename F1, typename F2>
pair<F1, F2> linear_id() { return {1, 0}; }

template<typename S>
using RSumQ = segtree<S, sum_op<S>, sum_e<S>>;
template<typename S>
using RMaxQ = segtree<S, max_op<S>, max_e<S>>;
template<typename S>
using RMinQ = segtree<S, min_op<S>, min_e<S>>;

template<typename S, typename F>
using RAddSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, add_mapping_size<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RMinMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, chmin_mapping<S, F>, chmin_composition<F>, chmin_id<F>>;
template<typename S, typename F>
using RMaxMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, chmax_mapping<S, F>, chmax_composition<F>, chmax_id<F>>;
template<typename S, typename F, F ID>
using RChangeMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, change_mapping_size<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F1, typename F2>
using RLinearMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
pair<F1, F2>, linear_mapping_size<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
#endif
#line 7 "Contests/AtCoder_arc102/arc102_b/main.cpp"

void solve(){
int l; cin >> l; l--;
VI u, v, w;
int sz = 0;
while((1 << sz) - 1 <= l) sz++;
sz--;
REP(i, sz) {
u.push_back(i+1);
v.push_back(i == sz - 1? 20 : i+2);
w.push_back(0);
u.push_back(i+1);
v.push_back(i == sz - 1? 20 : i+2);
w.push_back(1 << i);
}
int id = sz + 1;
int cur = 1 << sz;
dbg(cur, sz);
for(int i = sz - 1; i >= 0; i--) {
if(cur + (1 << i) <= l + 1) {
u.push_back(i + 1);
v.push_back(20);
w.push_back(cur);
cur += (1 << i);
}
}
assert(id <= 20);
print(id, u.size());
REP(i, u.size()) print(u[i], v[i] == 20? id : v[i], w[i]);
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
//cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

#include<bits/stdc++.h>
#define ll long long
#define ld long double
using namespace std;
int main()
{
ios_base::sync_with_stdio(false); cin.tie(NULL);
int n; cin>>n;
map<ll,ll>frq;
while(n--)
{
ll a; cin>>a;
frq[a]+=1;
}
ll sum=0;
for(auto i=frq.begin();i!=frq.end();i++)
{
ll a=i->first,  b=i->second;
if(b>a)
sum+=b-a;
else if(a>b)
sum+=b;
}
cout<<sum<<endl;
return 0;
}

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define int long long
#define F first
#define S second

using namespace std;
using namespace __gnu_pbds;

#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
#define ordered_multiset tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>


const int mxN = 1e5 + 1;
int n;
vector<array<int,3>> edges;
vector<int> leader(mxN), sz(mxN,1);


int root(int x) {
if(x == leader[x]) return x;
return leader[x] = root(leader[x]);
}

void unite(int x, int y) {
x = root(x), y = root(y);
if(x == y) return;
if(sz[x] < sz[y]) swap(x,y);
sz[x] += sz[y];
leader[y] = x;
}

void solve() {

cin >> n;

vector<array<int,3>> coords(n);

for(int i=1; i<=n; i++) {
leader[i] = i;
}

for(int i=0; i<n; i++) {
cin >> coords[i][0] >> coords[i][1];
coords[i][2] = i + 1;
}

sort(coords.begin(), coords.end());

for(int i=0; i<n-1; i++) {
int cost = min(abs(coords[i][0] - coords[i+1][0]), abs(coords[i][1] - coords[i+1][1]));
edges.push_back({cost, coords[i][2], coords[i+1][2]});

swap(coords[i][0], coords[i][1]);
if(i == n-2) swap(coords[i+1][0], coords[i+1][1]);
}

sort(coords.begin(), coords.end());

for(int i=0; i<n-1; i++) {
int cost = min(abs(coords[i][0] - coords[i+1][0]), abs(coords[i][1] - coords[i+1][1]));
edges.push_back({cost, coords[i][2], coords[i+1][2]});
}

sort(edges.begin(), edges.end());

int mst = 0;

for(int i=0; i<edges.size(); i++) {
if(root(edges[i][1]) == root(edges[i][2])) continue;
unite(edges[i][1], edges[i][2]);
mst += edges[i][0];
}

cout << mst << '\n';



}

signed main() {

ios_base::sync_with_stdio(false);
cin.tie(nullptr);

int tc = 1;


while(tc--) {
solve();
}
}
/*#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include <iomanip>//fixed,setprecision
#include <limits.n>//INT_MAX
#include <math.n>//M_PI
#include <random>
#include <regex> // 正規表現
#include <time.h>*/
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using mint = modint1000000007;
//using mint = modint998244353;
//std::chrono::time_point<std::chrono::steady_clock> start;
template <typename T> bool chmax(T &u, const T z) { if (u < z) {u = z; return true;} else return false; }
template <typename T> bool chmin(T &u, const T z) { if (u > z) {u = z; return true;} else return false; }
#define ll long long
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)
typedef pair<int, int> P;
ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }
ll lcm(ll a, ll b){return a * b / gcd(a, b);}

struct Student {
int sum,no, sugaku, eigo;

// 演算子オーバーロードで比較関数を定義
bool operator<(const Student& another) const {
if(sum!=another.sum)return sum>another.sum;
if (sugaku != another.sugaku)
return sugaku > another.sugaku; // 高い順に並べたいので演算子を逆に
if (eigo != another.eigo)
return eigo > another.eigo; // 同様に比較演算子を反転
return no < another.no;
}
};

const int mod=1000000007;
struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < mod);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
}c(555);

//解説AC
ll dp[55][55][3030];
int main(){
int n,a;
cin>>n>>a;
vector<int>x(n);
rep(i,n)cin>>x[i];
dp[0][0][0]=1;
rep(i,n){
rep(j,n){
rep(k,2500){
if(dp[i][j][k]){//i枚目までのカードでj枚選んで合計がkである組合せ
//カードを選ばない
dp[i+1][j][k]+=dp[i][j][k];
//カードを選ぶ
dp[i+1][j+1][k+x[i]]+=dp[i][j][k];
}
}
}
}
ll ans=0;
for(int i=1;i<=n;i++)ans+=dp[n][i][i*a];
cout<<ans<<endl;
return 0;
}

#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1;
int a[N],n;
int bit[2*N];
void update(int u,int x)
{
for(int i=u; i<2*N; i+=i&(-i)) bit[i]+=x;
}
int get(int u)
{
int ans=0;
for(int i=u; i>0; i-=i&(-i)) ans+=bit[i];
return ans;
}
int d[N];
bool check(int x)
{
for(int i=1;i<=n;i++) d[i]=0;
for(int i=1; i<=n; i++)
{
if(a[i]>=x) d[i]=d[i-1]+1;
else d[i]=d[i-1]-1;
}
memset(bit,0,sizeof(bit));
int val=0;
for(int i=1; i<=n; i++)
{
update(d[i-1]+n,1);
val+=get(d[i]+n);
}
return (val>=(n*(n+1)/2+1)/2);
}
signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
//freopen("test.inp","r",stdin);
//freopen("test.out","w",stdout);
cin >> n;
for(int i=1; i<=n; i++) cin >> a[i];
int l=1,r=1e9;
int ans=0;
while(l<=r)
{
int mid=(l+r)/2;
if(check(mid))
{
ans=mid;
l=mid+1;
}
else
{
r=mid-1;
}
}
cout << ans;

}

#include<bits/stdc++.h>

using namespace std;

#pragma GCC optimize ("Ofast")

#define all(x) x.begin() , x.end()
#define sze(x) (ll)(x.size())
#define mp(x , y) make_pair(x , y)
#define wall cerr<<"--------------------------------------"<<endl
typedef long long int ll;
typedef pair<ll , ll> pll;
typedef pair<int , int> pii;
typedef long double db;
typedef pair<pll , ll> plll;
typedef pair<int , pii> piii;
typedef pair<pll , pll> pllll;

const ll maxn = 215 , maxx = 1e7 + 16 , md = 1e9 + 7 , inf = 2e16;

ll gcd(ll a , ll b){
if(a < b) swap(a , b);
if(b == 0) return a;
return gcd(b , a % b);
}

inline ll tav(ll n , ll k){
ll res = 1;
while(k > 0){
if(k & 1){
res *= n; res %= md;
}
n *= n; n %= md;
k >>= 1;
}
return res;
}

bitset<maxx> gh;

void prime(){
gh.set(); gh[0] = gh[1] = false;
for(ll i = 2 ; i < maxx ; i++){
if(!gh[i]) continue;
for(ll j = 1ll * i * i ; j < maxx ; j += i){
gh[j] = false;
}
}
gh[2] = false;
return;
}

vector<ll> v , a , adj[maxn];
ll mt[maxn] , cnt = 0;
bitset<maxn> mark;

bool DFS(ll r){
for(auto i : adj[r]){
if(mark[i]) continue;
if(mt[i] == -1){
mt[i] = r;
cnt++;
return true;
}
mark[i] = true;
if(DFS(mt[i])){
mt[i] = r;
return true;
}
}
return false;
}

int main(){
ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

memset(mt , -1 , sizeof(mt));
prime();
ll n;
v.push_back(-1);
cin>>n;
for(ll i = 0 ; i < n ; i++){
ll h;
cin>>h;
v.push_back(h);
}
v.push_back(inf);
for(ll i = 1 ; i <= n ; i++){
if(v[i - 1] != v[i] - 1){
a.push_back(v[i]);
}
if(v[i + 1] != v[i] + 1){
a.push_back(v[i] + 1);
}
}
n = sze(a);
for(ll i = 0 ; i < n ; i++){
for(ll j = i + 1 ; j < n ; j++){
if(gh[a[j] - a[i]]){
adj[i].push_back(j); adj[j].push_back(i);
}
}
}
ll o = 0;
for(ll i = 0 ; i < n ; i++){
if(a[i] & 1) continue;
o ^= 1;
mark.reset();
DFS(i);
}
ll h = cnt;
if((cnt ^ o) & 1){
h += 3;
cnt++;
}
h += (n - (cnt << 1));
cout<<h<<'\n';
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, n) for (int i=0; i<n; ++i)
#define repi(i, j, n) for (int i=j; i<n; ++i)

int main () {
int N;
cin >> N;
vector<ll> a(N), sum(N+1);
rep(i, N) {
cin >> a[i];
sum[i+1] = sum[i] + a[i];
}

ll ans = 9223372036854775807;
repi(i, 1, N) {
ans = min(ans, abs(2 * sum[i] - sum[N]) );
}
cout << ans << endl;
return 0;
}
#ifndef HIDDEN_IN_VISUAL_STUDIO // 折りたたみ用

// 警告の抑制
#define _CRT_SECURE_NO_WARNINGS

// ライブラリの読み込み
#include <bits/stdc++.h>
using namespace std;

// 型名の短縮
using ll = long long; // -2^63 ～ 2^63 = 9 * 10^18（int は -2^31 ～ 2^31 = 2 * 10^9）
using pii = pair<int, int>;	using pll = pair<ll, ll>;	using pil = pair<int, ll>;	using pli = pair<ll, int>;
using vi = vector<int>;		using vvi = vector<vi>;		using vvvi = vector<vvi>;
using vl = vector<ll>;		using vvl = vector<vl>;		using vvvl = vector<vvl>;
using vb = vector<bool>;	using vvb = vector<vb>;		using vvvb = vector<vvb>;
using vc = vector<char>;	using vvc = vector<vc>;		using vvvc = vector<vvc>;
using vd = vector<double>;	using vvd = vector<vd>;		using vvvd = vector<vvd>;
template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
using Graph = vvi;

// 定数の定義
const double PI = 3.14159265359;
const double DEG = PI / 180.; // θ [deg] = θ * DEG [rad]
const vi dx4 = { 1, 0, -1, 0 }; // 4 近傍（下，右，上，左）
const vi dy4 = { 0, 1, 0, -1 };
const vi dx8 = { 1, 1, 0, -1, -1, -1, 0, 1 }; // 8 近傍
const vi dy8 = { 0, 1, 1, 1, 0, -1, -1, -1 };
const int INF = 1001001001; const ll INFL = 2002002002002002002LL;
const double EPS = 1e-10; // 許容誤差に応じて調整

// 入出力高速化
struct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } fastIOtmp;

// 汎用マクロの定義
#define all(a) (a).begin(), (a).end()
#define sz(x) ((int)(x).size())
#define distance (int)distance
#define Yes(b) {cout << ((b) ? "Yes" : "No") << endl;}
#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 から n-1 まで昇順
#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s から t まで昇順
#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s から t まで降順
#define repe(v, a) for(const auto& v : (a)) // a の全要素（変更不可能）
#define repea(v, a) for(auto& v : (a)) // a の全要素（変更可能）
#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d ビット全探索（昇順）
#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a の順列全て（昇順）
#define repit(it, a) for(auto it = (a).begin(); it != (a).end(); ++it) // イテレータを回す（昇順）
#define repitr(it, a) for(auto it = (a).rbegin(); it != (a).rend(); ++it) // イテレータを回す（降順）
#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod
#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // 重複除去

// 汎用関数の定義
template <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }
template <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // 最大値を更新（更新されたら true を返す）
template <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // 最小値を更新（更新されたら true を返す）

// 演算子オーバーロード
template <class T, class U> inline istream& operator>> (istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template <class T, class U> inline ostream& operator<< (ostream& os, const pair<T, U>& p) { os << "(" << p.first << "," << p.second << ")"; return os; }
template <class T, class U, class V> inline istream& operator>> (istream& is, tuple<T, U, V>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t); return is; }
template <class T, class U, class V> inline ostream& operator<< (ostream& os, const tuple<T, U, V>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << ")"; return os; }
template <class T, class U, class V, class W> inline istream& operator>> (istream& is, tuple<T, U, V, W>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t); return is; }
template <class T, class U, class V, class W> inline ostream& operator<< (ostream& os, const tuple<T, U, V, W>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << "," << get<3>(t) << ")"; return os; }
template <class T> inline istream& operator>> (istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }
template <class T> inline ostream& operator<< (ostream& os, const vector<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const list<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T, greater<T>>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const unordered_set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const unordered_map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, stack<T> s) { while (!s.empty()) { os << s.top() << " "; s.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, queue<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, deque<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop_front(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue_rev<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline vector<T>& operator--(vector<T>& v) { rep(_i_, sz(v)) --v[_i_]; return v; }
template <class T> inline vector<T>& operator++(vector<T>& v) { rep(_i_, sz(v)) ++v[_i_]; return v; }

// 手元環境（Visual Studio）
#ifdef _MSC_VER
#define popcount (int)__popcnt // 全ビット中の 1 の個数
#define popcountll (int)__popcnt64
inline int lsb(unsigned int n) { unsigned long i; _BitScanForward(&i, n); return i; } // 最下位ビットの位置（0-indexed）
inline int lsbll(unsigned long long n) { unsigned long i; _BitScanForward64(&i, n); return i; }
inline int msb(unsigned int n) { unsigned long i; _BitScanReverse(&i, n); return i; } // 最上位ビットの位置（0-indexed）
inline int msbll(unsigned long long n) { unsigned long i; _BitScanReverse64(&i, n); return i; }
template <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
#define dump(x) cout << "\033[1;36m" << (x) << "\033[0m" << endl;
#define dumps(x) cout << "\033[1;36m" << (x) << "\033[0m ";
#define dumpel(a) { int _i_ = -1; cout << "\033[1;36m"; repe(x, a) {cout << ++_i_ << ": " << x << endl;} cout << "\033[0m"; }
#define input_from_file(f) ifstream isTMP(f); cin.rdbuf(isTMP.rdbuf());
#define output_to_file(f) ofstream osTMP(f); cout.rdbuf(osTMP.rdbuf());
// 提出用（gcc）
#else
#define popcount (int)__builtin_popcount
#define popcountll (int)__builtin_popcountll
#define lsb __builtin_ctz
#define lsbll __builtin_ctzll
#define msb(n) (31 - __builtin_clz(n))
#define msbll(n) (63 - __builtin_clzll(n))
#define gcd __gcd
#define dump(x)
#define dumps(x)
#define dumpel(v)
#define input_from_file(f)
#define output_to_file(f)
#endif

#endif // 折りたたみ用


//-----------------AtCoder 専用-----------------
#include <atcoder/all>
using namespace atcoder;

//using mint = modint1000000007;
using mint = modint998244353;
//using mint = modint; // mint::set_mod(m);

istream& operator>> (istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }
ostream& operator<< (ostream& os, const mint& x) { os << x.val(); return os; }
using vm = vector<mint>;	using vvm = vector<vm>;		using vvvm = vector<vvm>;

template <class S, S(*op)(S, S), S(*e)()>ostream& operator<<(ostream& os, segtree<S, op, e> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
template <class S, S(*op)(S, S), S(*e)(), class F, S(*mp)(F, S), F(*cp)(F, F), F(*id)()>ostream& operator<<(ostream& os, lazy_segtree<S, op, e, F, mp, cp, id> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
ostream& operator<<(ostream& os, dsu d) { repe(g, d.groups()) { repe(v, g) { os << v << " "; } os << endl; } return os; };
//----------------------------------------------


//【めぐる式二分探索】O(log|ok - ng|)
/*
* 条件 okQ() を満たす要素 ok と満たさない要素 ng との境界を二分探索する．
* 境界に隣り合うような条件を満たす要素（ok 側）の位置を返す．
*/
template <typename T> T meguru_search(T ok, T ng, function<bool(T)>& okQ) {
// 境界が決定するまで
while (abs(ok - ng) > 1) {
// 区間の中間
T mid = (ok + ng) / 2;

// 中間が OK かどうかに応じて区間を縮小する．
if (okQ(mid)) ok = mid;
else ng = mid;
}
return ok;
}


int main() {
//	input_from_file("input.txt");
//	output_to_file("output.txt");

int n;
cin >> n;

vl a(n);
cin >> a;

// 中央値が m 以下か
function<bool(ll)> okQ = [&](ll m) {
dump(m);

// b[i] : a[i] <= m なら -1，さもなくば +1
vi b(n);
rep(i, n) b[i] = (a[i] <= m ? -1 : 1);
dump(b);

// acc[i] : Σb[0..i) に非負値になるようゲタを履かせたもの
vi acc(n + 1);
acc[0] = n + 10;
rep(i, n) acc[i + 1] = acc[i] + b[i];
dump(acc);

// ft[i] : いままで見た acc に値 i が何回現れたか
fenwick_tree<ll> ft(2 * n + 100);
ft.add(acc[0], 1);

// cnt_l : Σb[l..r) < 0 となる区間 [l..r) の個数
// cnt_h : Σb[l..r) >= 0 となる区間 [l..r) の個数
ll cnt_l = 0, cnt_h = 0;
repi(r, 1, n) {
cnt_l += ft.sum(acc[r] + 1, 2 * n + 100);
cnt_h += ft.sum(0, acc[r] + 1);

ft.add(acc[r], 1);
}
dumps(cnt_l); dump(cnt_h);

// cnt_l が cnt_r より大きければ OK
return cnt_l > cnt_h;
};

auto res = meguru_search((ll)1e9 + 1000, 0LL, okQ);

cout << res << endl;
}

#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC optimization ("unroll-loops")
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
typedef pair<int,int> pii;
typedef vector<int> vii;
typedef vector<ll> vll;
typedef vector<pii> vpii;
typedef unordered_map<int,int> umap;
typedef long double ld;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define popcount __builtin_popcount
#define case cout<<"Case "<<__testcase-testcase<<": ";
int main(){
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
int n,m,i,j,k;
int N=100000;
char s[N+5], t[N+5];
cin>>s>>t;
n=strlen(s);
m=strlen(t);
int sa[n+1], sb[n+1];
sa[0]=sb[0]=0;
for(i=0;i<n;i++){
if(s[i]=='A') sa[i+1]=sa[i]+1, sb[i+1]=sb[i];
else sb[i+1]=sb[i]+1, sa[i+1]=sa[i];
}

int ta[m+1], tb[m+1];
ta[0]=tb[0]=0;
for(i=0;i<m;i++){
if(t[i]=='A') ta[i+1]=ta[i]+1, tb[i+1]=tb[i];
else tb[i+1]=tb[i]+1, ta[i+1]=ta[i];
}


int q;
cin>>q;
while(q--){
int a,b,c,d;
cin>>a>>b>>c>>d;
j=(sa[b]-sa[a-1]+2*sb[b]-2*sb[a-1])%3;
k=(ta[d]-ta[c-1]+2*tb[d]-2*tb[c-1])%3;
if(j==k) cout<<"YES"<<endl;
else cout<<"NO"<<endl;
}
}

#include<bits/stdc++.h>
#define re register
#define min(a,b) ((a)<(b)?(a):(b))
const int maxn=2e5+5;
struct Seg{int x,y;}a[maxn];
int n,m,ans;
inline int cmp(const Seg A,const Seg B) {return A.x==B.x?A.y>B.y:A.x<B.x;}
int l[maxn<<2],r[maxn<<2],tag[maxn<<2],mx[maxn<<2];
inline int max(int a,int b) {return a>b?a:b;}
inline void add(int i,int v) {tag[i]+=v,mx[i]+=v;}
inline void pushup(int i) {mx[i]=max(mx[i<<1],mx[i<<1|1]);}
void build(int x,int y,int i) {
l[i]=x,r[i]=y;tag[i]=0;if(x==y){mx[i]=x;return;}
int mid=x+y>>1;build(x,mid,i<<1),build(mid+1,y,i<<1|1);pushup(i);
}
inline void pushdown(int i) {
if(!tag[i]) return;
add(i<<1,tag[i]),add(i<<1|1,tag[i]);tag[i]=0;
}
void change(int x,int y,int v,int i) {
if(x<=l[i]&&y>=r[i]) {add(i,v);return;}
int mid=l[i]+r[i]>>1;pushdown(i);
if(x<=mid) change(x,y,v,i<<1);
if(y>mid) change(x,y,v,i<<1|1);
pushup(i);
}
int query(int x,int y,int i) {
if(x<=l[i]&&y>=r[i]) return mx[i];
int mid=l[i]+r[i]>>1;pushdown(i);
if(y<=mid) return query(x,y,i<<1);
if(x>mid) return query(x,y,i<<1|1);
return max(query(x,y,i<<1),query(x,y,i<<1|1));
}
int main() {
scanf("%d%d",&n,&m);
for(re int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
std::sort(a+1,a+n+1,cmp);int nl=0,nr=m+1;
for(re int i=1;i<=n;i++) nl=max(nl,a[i].x),nr=min(nr,a[i].y);
ans=n+(nl<nr?nr-nl-1:0);
build(0,m+1,1);
for(re int i=1;i<=n;i++) {
int nw=query(a[i].x+1,a[i].y,1);
ans=max(ans,nw-a[i].x);
change(0,a[i].y,1,1);
}
printf("%d\n",ans>m?ans-m:0);return 0;
}
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native") // Enable AVX/AVX2
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize("no-stack-protector")
//#pragma GCC optimize("unroll-loops")
//#pragma GCC optimize("unswitch-loops")
//#pragma GCC optimize("fast-math")
//#pragma GCC optimize("rename-registers") // Optimization flags

#include <iostream>
#include <iomanip>
#include <fstream>
#include <cstdio>
#include <sstream>
#include <cassert>
#include <vector>
#include <numeric>
#include <string>
#include <bitset>
#include <cmath>
#include <complex>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <ctime>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <ext/pb_ds/assoc_container.hpp>

/*
⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄
⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄
⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄
⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄
⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰
⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤
⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗
⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄
⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄
⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄
⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄
⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄
⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴
⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿
*/

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef double db;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
#define all(x) (x).begin(), (x).end()
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

template <typename A, typename B>
string to_string(pair<A, B> p);

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p);

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p);

string to_string(const string& s) {
return '"' + s + '"';
}

string to_string(const char* s) {
return to_string((string) s);
}

string to_string(vector<bool> v) {
bool first = true;
string res = "{";
for (int i = 0; i < static_cast<int>(v.size()); i++) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(v[i]);
}
res += "}";
return res;
}

template <typename A>
string to_string(A v) {
bool first = true;
string res = "{";
for (const auto &x : v) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(x);
}
res += "}";
return res;
}

template <typename A, typename B>
string to_string(pair<A, B> p) {
return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p) {
return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";
}

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) {
return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";
}

void debug_out() { cout << "\n"; }
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
cout << " " << to_string(H);
debug_out(T...);
}

#ifdef CLOWN
#define dbg(...) cout << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);
#else
#define dbg(...);
#endif

int test = 0;

void fastio() {
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
}

ll check(ll b, ll n) {
ll ans = 0;
while (n >= b) {
ans += n % b;
n /= b;
}
ans += n;
return ans;
}

void solve() {
ll n, s;
cin >> n >> s;
if (n == s) {
cout << n + 1 << "\n";
return;
}
if (n < s) {
cout << -1 << "\n";
return;
}
ll ans = 1e18;
for (ll b = 1; b * b <= n; b++) {
if (b == 1) {
ll O = (n - s) / b + 1;
for (ll b1 = max(2LL, O - 20); b1 <= O + 20; b1++) {
if (check(b1, n) == s) {
ans = min(ans, b1);
}
}
} else {
ll cur = check(b, n);
if (cur == s) {
ans = min(ans, b);
}
cur = check(n / b, n);
if (cur == s) {
ans = min(ans, n / b);
}
for (ll b1 = max(2LL, b - 20); b1 <= b + 20; b1++) {
if (check(b1, n) == s) {
ans = min(ans, b1);
}
}

ll O = (n - s) / b;
for (ll b1 = max(2LL, O - 20); b1 <= O + 20; b1++) {
if (check(b1, n) == s) {
ans = min(ans, b1);
}
}
}
}
cout << (ans == (ll)1e18 ? -1 : ans) << "\n";
}

int32_t main() {
#ifdef CLOWN
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
int t = 1;
fastio();
if (test) cin >> t;
while (t--) { solve(); }
return 0;
}
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#pragma GCC optimize ("-O3")
using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
//---------------------------------------------------------------------------------------------------
/*---------------------------------------------------------------------------------------------------
∧＿∧  
∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!
（ ´_ゝ`）　/　 ⌒i     
／　　　＼　 　  |　|     
/　　 /￣￣￣￣/　　|  
＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  
＼/＿＿＿＿/　（u　⊃  
---------------------------------------------------------------------------------------------------*/




int N, A[201010];
//---------------------------------------------------------------------------------------------------
#define yes "Yes"
#define no "No"
string solve() {
int c2 = 0;
int c4 = 0;
int c = 0;

rep(i, 0, N) {
if (A[i] % 4 == 0) c4++;
else if (A[i] % 2 == 0) c2++;
else c++;
}

if (c4 + 1 == c && N == (c4 + c)) return yes;
if (c4 < c) return no;

return yes;
}
//---------------------------------------------------------------------------------------------------
void _main() {
cin >> N;
rep(i, 0, N) cin >> A[i];
cout << solve() << endl;
}
#include<bits/stdc++.h>
using namespace std;
vector<int>g[100001];
int f1[100001],f2[100001];
void dfs(int u,int p,int d,int f[]){
f[u]=d;
for(int v:g[u]){
if(v!=p)dfs(v,u,d+1,f);
}
}
int main()
{
int n;cin>>n;
for(int i=1,u,v;i<n;i++){
cin>>u>>v;
g[u].push_back(v);
g[v].push_back(u);
}
dfs(1,0,0,f1);
dfs(n,0,0,f2);
int s1=0,s2=0;
for(int i=1;i<=n;i++){
if(f1[i]<=f2[i])s1++;
else s2++;
}
if(s1>s2)cout<<"Fennec";
else cout<<"Snuke";
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=2005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,x,y,curt;

void orzck(){
cin >> n;
x=y=curt=0;
rep(n){
int nx,ny,t;
cin >> t >> nx >> ny;
if(t-curt<abs(x-nx)+abs(y-ny)||(t-curt+abs(x-nx)+abs(y-ny))%2){
print("No");
return;
}
x=nx,y=ny,curt=t;
}
print("Yes");
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;
vector<int> readVector(int N)
{
vector<int> v(N);
for (int i = 0; i < N; i++) {
cin >> v[i];
}
return v;
}

int ElementsToRemoveGoodSequence(vector<int>& v)
{
unordered_map<int, int> elem_count;	
for (auto a: v) {
elem_count[a]++;
}


int remove_count = 0;

// Also remove count that do not match
for (auto &a: elem_count) {
if (a.first > a.second) {
//cout << a.first << " has fewer (" << a.second << ")" << endl;
remove_count += a.second;
} else if (a.first < a.second) {
//cout << a.first << " has too many (" << a.second << ")" << endl;
remove_count += (a.second - a.first);
}
}
return remove_count;
}

int main()
{
int n; cin >> n;
vector<int> v = readVector(n);
cout << ElementsToRemoveGoodSequence(v) << endl;
return 0;
}

// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
int n; cin>>n;
int t, a;
cin>>t>>a;
for(int i=1; i<n; i++){
int x,y; cin>>x>>y;
int ag = 4e18;
int tx = (t + x-1)/x;
if(tx*y >= a){
ag = tx;
}
int ty = (a + y-1)/y;
if(ty*x >= t){
ag = min(ag, ty);
}
t = ag*x; a = ag*y;
}
cout<<t+a<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e5+5;
int n,x,sz[N],fa[N],dep[N];
LL a[N],sum;
map<LL,int>rv;
signed main(){
scanf("%d",&n);
for(int i=1;i<=n;i++)
scanf("%lld",&a[i]),rv[a[i]]=i,sz[i]=1;
sort(a+1,a+1+n);
for(int i=n;i>1;i--){
x=rv[a[i]];
fa[x]=rv[a[i]+2*sz[x]-n],sz[fa[x]]+=sz[x];
if(!fa[x]||fa[fa[x]]) puts("-1"),exit(0);
}
for(int i=2;i<=n;i++)
x=rv[a[i]],dep[x]=dep[fa[x]]+1,sum+=dep[x];
if(sum!=a[1]) puts("-1"),exit(0);
for(int i=2;i<=n;i++)
x=rv[a[i]],printf("%d %d\n",x,fa[x]);
return 0;
}
#include <atcoder/modint>
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace atcoder;
using namespace std;

typedef long long ll;
typedef modint1000000007 mint;

const int MAXN = (int)2e6;
const int MOD = (int)1e9 + 7;
const int O = (int)1e6;

mint dp[MAXN], pref[MAXN];
int n;

int main() {
cin >> n;
fill(dp, dp + O + 1, 1);
dp[O + 1] = n;

for (int i = 0; i <= O + 1; i++) {
pref[i] = (i ? pref[i - 1] : 0) + dp[i];
}

for (int i = O + 2; i <= O + n; i++) {
dp[i] = dp[i - 1];
dp[i] += (n - 1) * 1ll * (n - 1) % MOD;
int L = i - 1 - n;
int R = i - 1 - 2;
dp[i] += pref[R] - pref[L - 1];

pref[i] = pref[i - 1] + dp[i];
}

cout << dp[O + n].val() << endl;
return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
int n;
cin >> n;
vi a(n);
rep(i, n) cin >> a[i];
using mint = atcoder::modint1000000007;
map<int, int> cnt;
rep(i, n) cnt[a[i]]++;
mint ans = 1;
int idx = 0;
if (n % 2 == 0) {
idx = 1;
if (cnt[0] != 0) ans = 0;
while (idx < n) {
if (cnt[idx] != 2)
ans = 0;
else
ans *= 2;
idx += 2;
}

} else {
while (idx < n) {
if (idx == 0) {
if (cnt[idx] != 1) ans = 0;
}
if (idx != 0) {
if (cnt[idx] != 2)
ans = 0;
else
ans *= 2;
}
idx += 2;
}
}
cout << ans.val() << endl;
}

#include <bits/stdc++.h>
using namespace std;

int a[100005];

int main() {

ios_base::sync_with_stdio(false);
cin.tie(nullptr);

int N;
cin >> N;

for(int i = 0; i < N; i++) {
int x;
cin >> x;
a[x]++;
}

int c = 0, c2 = 0;
for(int i = 1; i <= 100000; i++) {
if(a[i] == 0) continue;
if(a[i] % 2 == 0) c++;
else c2++;
}
c2 += c-(c % 2);
c %= 2;

if(c == 1) {
if(c2 == 0) cout << "2\n";
else cout << c+c2-1 << '\n';
} else {
cout << c2 << '\n';
}
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define sz(a) (int)a.size()
#define all(a) a.begin(),a.end()
#define rep(i,n) for(int i=0;i<n;i++)
#define crep(i,x,n) for(int i=x;i<n;i++)
#define drep(i,n) for(int i=n-1;i>=0;i--)
#define vec(...) vector<__VA_ARGS__>
#define _34raRxL ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
typedef long double ld;

void print(){
cout<<"\n";
}
template<class te,class ...ti>
void print(const te&v, const ti&...nv){ 
cout<<v;
if(sizeof...(nv)){
cout<<" ";
print(nv...);
}
}

using pii=pair<int,int>;
using vi=vector<int>;
using vll=vector<long long>;

void slv(){
int n;
cin>>n;
vi a(n);
rep(i,n){
cin>>a[i];
}
rep(i,n){
a[i]--;
}
int ans=0;
rep(i,n){
if(a[i]==i){
if(i+1<n){
swap(a[i+1],a[i]);
}
ans++;
}
}
print(ans,'\n');
}

int main(){
_34raRxL;
int t=1;
// cin>>t;
slv();
//	
return 0;
}
#line 1 "Contests/AtCoder_arc099/arc099_a/main.cpp"
/* #define aclmodint */
/* #define aclsegtree */
/* #include <atcoder/all> */
/* using namespace atcoder; */

#line 1 "library/me/template.cpp"
// This is a dummy line
#ifndef ONLINE_JUDGE
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for(ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()
#define END(...) { print(__VA_ARGS__); return; }

#ifdef ONLINE_JUDGE
#define DBG(...) {}
#else
#define DBG(a) { cerr << #a << ": "; dbg(a); }
#endif

using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using ll = long long;
using VL = vector<ll>;
using VVL = vector<VL>;
using VVVL = vector<VVL>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VS = vector<string>;
using VVS = vector<VS>;
using VVVS = vector<VVS>;
using VC = vector<char>;
using VVC = vector<VC>;
using VVVC = vector<VVC>;
using P = pair<int, int>;
using VP = vector<P>;
using VVP = vector<VP>;
using VVVP = vector<VVP>;
using LP = pair<ll, ll>;
using VLP = vector<LP>;
using VVLP = vector<VLP>;
using VVVLP = vector<VVLP>;
constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

#ifdef aclmodint

using MI7 = modint1000000007;
using V7 = vector<MI7>;
using VV7 = vector<V7>;
using VVV7 = vector<VV7>;
using MI3 = modint998244353;
using V3 = vector<MI3>;
using VV3 = vector<V3>;
using VVV3 = vector<VV3>;

ostream &operator<<(ostream &os, const modint &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI3 &x) {
os << x.val();
return os;
}

ostream &operator<<(ostream &os, const MI7 &x) {
os << x.val();
return os;
}

istream &operator>>(istream &is, modint &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI3 &x) {
int y; is >> y;
x = y;
return is;
}

istream &operator>>(istream &is, MI7 &x) {
int y; is >> y;
x = y;
return is;
}

#endif

void print() { cout << '\n'; }
template<typename T>
void print(const T &t) { cout << t << '\n'; }
template<typename Head, typename... Tail>
void print(const Head &head, const Tail &... tail) {
cout << head << ' ';
print(tail...);
}

#ifdef ONLINE_JUDGE
template<typename... Args>
void dbg(const Args &... args) {}
#else
void dbg() { cerr << '\n'; }
template<typename T>
void dbg(const T &t) { cerr << t << '\n'; }
template<typename Head, typename... Tail>
void dbg(const Head &head, const Tail &... tail) {
cerr << head << ' ';
dbg(tail...);
}
#endif

template< typename T1, typename T2 >
ostream &operator<<(ostream &os, const pair< T1, T2 >& p) {
os << p.first << " " << p.second;
return os;
}

template< typename T1, typename T2 >
istream &operator>>(istream &is, pair< T1, T2 > &p) {
is >> p.first >> p.second;
return is;
}

template< typename T >
ostream &operator<<(ostream &os, const vector< T > &v) {
for(int i = 0; i < (int) v.size(); i++) {
os << v[i] << (i + 1 != (int) v.size() ? " " : "");
}
return os;
}

template< typename T >
istream &operator>>(istream &is, vector< T > &v) {
for(T &in : v) is >> in;
return is;
}

template< typename T1, typename T2 >
inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

template< typename T1, typename T2 >
inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

template <typename T>
pair<VI, vector<T>> compress(const vector<T> &a) {
int n = a.size();
vector<T> x;
REP(i, n) x.push_back(a[i]);
sort(ALL(x)); x.erase(unique(ALL(x)), x.end());
VI res(n);
REP(i, n) res[i] = lower_bound(ALL(x), a[i]) - x.begin();
return make_pair(res, x);
}

#ifdef aclsegtree

template<typename S>
struct value_size { S value; int size; };

template<typename S>
S min_op(S l, S r) { return min(l, r); };
template<typename S>
S max_op(S l, S r) { return max(l, r); };
template<typename S>
S sum_op(S l, S r) { return l + r; };
template<typename S>
value_size<S> sum_op_size(value_size<S> l, value_size<S> r) {
return {l.value + r.value, l.size + r.size};
};

template<typename S>
S min_e() { return  numeric_limits<S>::max(); };
template<typename S>
S max_e() { return numeric_limits<S>::min(); };
template<typename S>
S sum_e() { return 0; }
template<typename S>
value_size<S> sum_e_size() { return {0, 0}; }
template<typename S>
value_size<S> min_e_size() { return {numeric_limits<S>::max(), 0}; }
template<typename S>
value_size<S> max_e_size() { return {numeric_limits<S>::min(), 0}; }

template<typename S, typename F>
S chmin_mapping(F f, S x) { return min(x, f); }
template<typename S, typename F>
S chmax_mapping(F f, S x) { return max(x, f); }
template<typename S, typename F>
S add_mapping(F f, S x) { return x + f; }
template<typename S, typename F>
value_size<S> add_mapping_size(F f, value_size<S> x) {
return {x.value + x.size * f, x.size};
}
template <typename S,typename F, F ID>
S change_mapping(F f, S x) { return (f == ID? x : f); }
template <typename S,typename F, F ID>
S change_mapping_size(F f, value_size<S> x) { return (f == ID? x : value_size<S>(f, x.size)); }
template <typename S, typename F1, typename F2>
S linear_mapping(pair<F1, F2> f, S x) { return x * f.first + f.second; }
template <typename S, typename F1, typename F2>
value_size<S> linear_mapping_size(pair<F1, F2> f, value_size<S> x) { return {x.value * f.first + x.size * f.second, x.size}; }

template<typename F>
F chmin_composition(F f, F g) { return min(f, g); }
template<typename F>
F chmax_composition(F f, F g) { return max(f, g); }
template<typename F>
F add_composition(F f, F g) { return f + g; }
template <typename F, F ID>
F change_composition(F f, F g) { return (f == ID? g : f); }
template<typename F1, typename F2>
pair<F1, F2> linear_composition(pair<F1, F2> f, pair<F1, F2> g) { return {f.first * g.first, f.first * g.second + f.second}; }

template<typename F>
F chmin_id() { return numeric_limits<F>::max(); }
template<typename F>
F chmax_id() { return numeric_limits<F>::min(); }
template<typename F>
F add_id() { return 0; }
template<typename F, F ID>
F change_id() { return ID; }
template<typename F1, typename F2>
pair<F1, F2> linear_id() { return {1, 0}; }

template<typename S>
using RSumQ = segtree<S, sum_op<S>, sum_e<S>>;
template<typename S>
using RMaxQ = segtree<S, max_op<S>, max_e<S>>;
template<typename S>
using RMinQ = segtree<S, min_op<S>, min_e<S>>;

template<typename S, typename F>
using RAddSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, add_mapping_size<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RAddMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, add_mapping<S, F>, add_composition<F>, add_id<F>>;
template<typename S, typename F>
using RMinMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, chmin_mapping<S, F>, chmin_composition<F>, chmin_id<F>>;
template<typename S, typename F>
using RMaxMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, chmax_mapping<S, F>, chmax_composition<F>, chmax_id<F>>;
template<typename S, typename F, F ID>
using RChangeMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
F, change_mapping<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F, F ID>
using RChangeSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
F, change_mapping_size<S, F, ID>,
change_composition<F, ID>,
change_id<F, ID>>;
template<typename S, typename F1, typename F2>
using RLinearMinQ = lazy_segtree<S, min_op<S>, min_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearMaxQ = lazy_segtree<S, max_op<S>, max_e<S>,
pair<F1, F2>, linear_mapping<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
template<typename S, typename F1, typename F2>
using RLinearSumQ = lazy_segtree<value_size<S>, sum_op_size<S>, sum_e_size<S>,
pair<F1, F2>, linear_mapping_size<S, F1, F2>,
linear_composition<F1, F2>,
linear_id<F1, F2>>;
#endif
#line 7 "Contests/AtCoder_arc099/arc099_a/main.cpp"

void solve(){
int n, k; cin >> n >> k;
VI a(n);
int cur = 1;
int sum = k;
while(sum < n) {
sum += k - 1;
cur++;
}
print(cur);
}

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
//cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

string s;
cin >> s;
rep(i, s.length()-1) {
if (s[i] == s[i+1]) {
cout << i+1 << ' ' << i+2 << endl;
return 0;
}
}
rep(i, s.length()-2) {
if (s[i] == s[i+2]) {
cout << i+1 << ' ' << i+3 << endl;
return 0;
}
}
cout << "-1 -1" << endl;

cout << flush;
return 0;
}

/**
*	author:	social_chameleon
*	created:	2022/01/20
*/

#pragma region MACROS

#pragma region HEADER
#pragma GCC optimize("O3")
#ifdef LOCAL
#include <debug_print.hpp>
#define debug(...) debug_print::multi_print(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...) (static_cast<void>(0))
#endif
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#pragma endregion
#pragma region TYPES
using ll = long long;
#define int ll
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pil = pair<int, ll>;
using pli = pair<ll, int>;
using ld = long double;
template <typename T>
using vc = vector<T>;
template <typename T>
using vvc = vector<vc<T>>;
template <typename T>
using vvvc = vector<vvc<T>>;
using vi = vc<int>;
using vl = vc<ll>;
using vb = vc<bool>;
using vpi = vc<pii>;
using vpl = vc<pll>;
template <class T>
using pq = priority_queue<T>;
template <class T>
using pqg = priority_queue<T, vector<T>, greater<T>>;
#pragma endregion
#pragma region UTILITY_FUNCTIONS
template <typename T>
int si(const T& x) { return x.size(); }
template <class T>
inline bool chmax(T& a, const T& b) { return (a < b ? a = b, 1 : 0); }
template <class T>
inline bool chmin(T& a, const T& b) { return (a > b ? a = b, 1 : 0); }
#define overload2(a, b, name, ...) name
#define overload4(a, b, c, d, name, ...) name
#define overload5(a, b, c, d, e, name, ...) name
#pragma endregion
#pragma region WORDS
#define fi first
#define se second
#define pb push_back
#define pf push_front
#define ppb pop_back
#define ppf pop_front
#define eb emplace_back
#define ef emplace_front
#pragma endregion
#pragma region LOOPS
#define rep0(n) for (int _ = 0; _ < n; ++_)
#define rep1(i, n) for (ll i = 0; i < (n); ++i)
#define rep2(i, a, b) for (ll i = (a); i < (b); ++i)
#define rep3(i, a, b, c) for (ll i = (a); i < (b); i += (c))
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1, rep0)(__VA_ARGS__)
#define rrep0(n) for (int jidlsjf = 0; jidlsjf < n; ++jidlsjf)
#define rrep1(i, n) for (ll i = (n)-1; i >= 0; --i)
#define rrep2(i, a, b) for (ll i = (a)-1; i >= b; --i)
#define rrep3(i, a, b, c) for (ll i = (a)-1; i >= b; i -= c)
#define rrep(...) overload4(__VA_ARGS__, rrep3, rrep2, rrep1, rrep0)(__VA_ARGS__)
#define fore0(v) rep(a.size())
#define fore1(a, v) for (auto&& a : v)
#define fore2(a, b, v) for (auto&& [a, b] : v)
#define fore3(a, b, c, v) for (auto&& [a, b, c] : v)
#define fore4(a, b, c, d, v) for (auto&& [a, b, c, d] : v)
#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)
#pragma endregion
#pragma region CONTAINER_METHODS
#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))
#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))
template <typename T>
int closest(vector<T>& v, T x) {
int n = (int)v.size();
int pos = lower_bound(v.begin(), v.end(), x) - v.begin();
if (pos == 0) return pos;
if (pos == n) return n - 1;
return (v[pos] - x <= x - v[pos - 1]) ? pos : pos - 1;
}
#define all(c) begin(c), end(c)
#define rall(c) rbegin(c), rend(c)
#define SORT(v) sort(all(v))
#define REV(v) reverse(all(v))
#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())
template <typename T = ll, typename S>
T SUM(const S& v) { return accumulate(all(v), T(0)); }
#define MIN(v) *min_element(all(v))
#define MAX(v) *max_element(all(v))
template <typename T = int>
T mex(unordered_set<T> st) {
T ret = T(0);
while (st.count(ret) != 0) ++ret;
return ret;
}
#pragma endregion
#pragma region VECTOR_DEFINITIONS
#define vec(type, name, ...) vector<type> name(__VA_ARGS__)
#define vec2(type, name1, name2, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__)
#define vec3(type, name1, name2, name3, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__)
#define vec4(type, name1, name2, name3, name4, ...) vector<type> name1(__VA_ARGS__), name2(__VA_ARGS__), name3(__VA_ARGS__), name4(__VA_ARGS__)
#define vv(type, name, a, ...) vector<vector<type>> name(a, vector<type>(__VA_ARGS__))
#define vvv(type, name, a, b, ...) vector<vector<vector<type>>> name(a, vector<vector<type>>(b, vector<type>(__VA_ARGS__)))
#define vvvv(type, name, a, b, c, ...) vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))
constexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};
constexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};
#pragma endregion
#pragma region TYPICAL_OUTPUT
const string YESNO[2] = {"NO", "YES"};
const string YesNo[2] = {"No", "Yes"};
const string yesno[2] = {"no", "yes"};
void YES(bool t = 1) { cout << YESNO[t] << endl; }
void NO(bool t = 1) { YES(!t); }
void Yes(bool t = 1) { cout << YesNo[t] << endl; }
void No(bool t = 1) { Yes(!t); }
void yes(bool t = 1) { cout << yesno[t] << endl; }
void no(bool t = 1) { yes(!t); }
#pragma endregion
#pragma region INPUT
int scan() { return getchar(); }
void scan(signed& a) { cin >> a; }
void scan(long long& a) { cin >> a; }
void scan(char& a) { cin >> a; }
void scan(double& a) { cin >> a; }
void scan(string& a) { cin >> a; }
template <class T, class S>
void scan(pair<T, S>& p) { scan(p.first), scan(p.second); }
template <class T>
void scan(vector<T>& a) {
for (auto& i : a) scan(i);
}
template <class T>
void scan(T& a) { cin >> a; }
void IN() {}
template <class Head, class... Tail>
void IN(Head& head, Tail&... tail) {
scan(head);
IN(tail...);
}
#define INT(...)   \
int __VA_ARGS__; \
IN(__VA_ARGS__)
#define LL(...)   \
ll __VA_ARGS__; \
IN(__VA_ARGS__)
#define STR(...)      \
string __VA_ARGS__; \
IN(__VA_ARGS__)
#define CHR(...)    \
char __VA_ARGS__; \
IN(__VA_ARGS__)
#define DBL(...)      \
double __VA_ARGS__; \
IN(__VA_ARGS__)
#define VEC(type, name, size) \
vector<type> name(size);    \
IN(name)
#define VEC2(type, name1, name2, size)   \
vector<type> name1(size), name2(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i])
#define VEC3(type, name1, name2, name3, size)         \
vector<type> name1(size), name2(size), name3(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])
#define VEC4(type, name1, name2, name3, name4, size)               \
vector<type> name1(size), name2(size), name3(size), name4(size); \
for (int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i])
#define VV(type, name, h, w)                     \
vector<vector<type>> name(h, vector<type>(w)); \
IN(name)
#pragma endregion
#pragma region MATH
static constexpr int inf = numeric_limits<int>::max() / 2;
static constexpr ll infll = numeric_limits<ll>::max() / 2;
static constexpr double infdbl = numeric_limits<double>::max() / 2;
template <typename T, typename S>
T ceil(T x, S y) {
assert(y);
return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));
}
template <typename T, typename S>
T floor(T x, S y) {
assert(y);
return (y < 0 ? floor(-x, -y)
: (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));
}
template <class T>
ll POW(T x, int n) {
ll res = 1;
for (; n; n >>= 1, x *= x)
if (n & 1) res *= x;
return res;
}
template <class T, class S>
ll POW(T x, S n, const ll& mod) {
ll res = 1;
x %= mod;
for (; n; n >>= 1, x = x * x % mod)
if (n & 1) res = res * x % mod;
return res;
}
template <typename T>
map<T, int> factor(T n) {
map<T, int> ret;
for (T i = 2; i * i <= n; i++) {
while (n % i == 0) {
ret[i]++;
n /= i;
}
}
if (n != 1) ret[n] = 1;
return ret;
}
template <class T>
vector<T> divisor(T x) {
vector<T> ret;
for (T i = 1; i * i <= x; i++)
if (x % i == 0) {
ret.pb(i);
if (i * i != x) ret.pb(x / i);
}
return ret;
}
vector<int> cumsum(const vector<bool>& v) {
vector<int> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<T> cumsum(const vector<T>& v) {
vector<T> ret(v.size());
for (int i = 0; i < (int)v.size(); ++i) ret[i] = (i == 0 ? 0 : ret[i - 1]) + v[i];
return ret;
}
template <typename T>
vector<vector<T>> cumsum2d(const vector<vector<T>>& v) {
vector<vector<T>> ret = v;
for (int i = 0; i < (int)v.size(); ++i) {
for (int j = 0; j < (int)v[0].size(); ++j) {
if (i > 0) ret[i][j] += ret[i - 1][j];
if (j > 0) ret[i][j] += ret[i][j - 1];
if (i > 0 && j > 0) ret[i][j] -= ret[i - 1][j - 1];
}
}
return ret;
}
template <typename T>
T parsum2d(const vector<vector<T>>& cum, int i1, int i2, int j1, int j2) {
if (i1 > i2 || j1 > j2) return 0;
T ret = cum[i2][j2];
if (i1 > 0) ret -= cum[i1 - 1][j2];
if (j1 > 0) ret -= cum[i2][j1 - 1];
if (i1 > 0 && j1 > 0) ret += cum[i1 - 1][j1 - 1];
return ret;
}
template <typename T, typename S, typename U>
bool inc(const T& x, const S& l, const U& r) {
return l <= x and x < r;
}
constexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }
template <typename T>
T arith_sum_from_range(T first, T last, T diff = T(1)) {
assert((last - first) % diff == 0);
return ((last - first) / 2 + 1) * (first + last) / 2;
}
template <typename T, typename S>
T arith_sum_from_term(T first, S n, T diff = T(1)) {
return (2 * first + (n - 1) * diff) * n / 2;
}
#pragma endregion
#pragma region BIT_FUNCTIONS
ll pow2(int i) { return 1LL << i; }
#define bit(n, k) (((n) >> (k)) & 1)
int topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }
int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }
int lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }
int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }
constexpr ll mask(int n) { return (1LL << n) - 1; }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
template <typename T>
T inv_all_bit(T a) {
T ret = 0;
int n = topbit(a);
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_all_bit(T a, int n) {
T ret = 0;
rep(i, n) if (((a >> i) & 1) == 0) ret += (1 << i);
return ret;
}
template <typename T>
T inv_bit(T a, int k) { return a ^ (1 << k); }
#pragma endregion
#pragma region PAIR_OPERATORS
template <class T, class S>
pair<T, S> operator-(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi - y.fi, x.se - y.se);
}
template <class T, class S>
pair<T, S> operator+(const pair<T, S>& x, const pair<T, S>& y) {
return pair<T, S>(x.fi + y.fi, x.se + y.se);
}
template <class T>
pair<T, T> operator&(const pair<T, T>& l, const pair<T, T>& r) {
return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se));
}
template <class T, class S>
pair<T, S> operator+=(pair<T, S>& l, const pair<T, S>& r) {
return l = l + r;
}
template <class T, class S>
pair<T, S> operator-=(pair<T, S>& l, const pair<T, S>& r) {
return l = l - r;
}
template <class T>
bool intersect(const pair<T, T>& l, const pair<T, T>& r) {
return (l.se < r.se ? r.fi < l.se : l.fi < r.se);
}
#pragma endregion
#pragma region SEARCH
template <class F>
void bit_search(int n, const F& f) {
for (int i = 0; i < (1 << n); ++i) {
set<int> st;
for (int j = 0; j < n; ++j) {
if ((i >> j & 1) == 1) {
st.insert(j);
}
}
f(st);
}
}
template <class T, class F>
T bin_search(T ok, T ng, const F& f) {
while (abs(ok - ng) > 1) {
T mid = ok + ng >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search_double(T ok, T ng, const F& f, int iter = 80) {
while (iter--) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
#pragma endregion
#pragma region STRING
void ERASE(string& s, char c) { s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const string& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
void ERASE(string& s, const vector<char>& chars) { fore(c, chars) s.erase(remove(all(s), c), s.end()); }
template <typename T>
void ERASE(vector<T>& v, T x) { v.erase(remove(all(v), x), v.end()); }
template <typename T>
void ERASE(vector<T>& v, const vector<T>& list) { fore(x, list) v.erase(remove(all(v), x), v.end()); }
#pragma endregion
#pragma region OUTPUT
template <typename T, typename S>
ostream& operator<<(ostream& os, const pair<T, S>& p) {
os << p.first << " " << p.second;
return os;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < (int)v.size(); i++) {
os << v[i] << (((i + 1) != v.size()) ? " " : "");
}
return os;
}
void OUT() { cout << endl; }
template <class Head, class... Tail>
void OUT(const Head& head, const Tail&... tail) {
cout << head;
if (sizeof...(tail)) cout << ' ';
OUT(tail...);
}
template <typename T>
string pad(T n, int d, char c) {
ostringstream sout;
sout << setfill(c) << setw(d) << n;
return sout.str();
}
#pragma endregion
#pragma region GRAPH
template <typename T = int>
struct Edge {
int from, to;
T cost;
int id;

Edge() = default;
Edge(int from, int to, T cost = 1, int id = -1) : from(from), to(to), cost(cost), id(id) {}

operator int() const {
return to;
}
};

template <typename T = int>
struct Graph {
vector<vector<Edge<T>>> g;
int edge_id;

Graph() = default;
explicit Graph(int n) : g(n), edge_id(0) {}

size_t size() const {
return g.size();
}

void add_directed_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id++);
}

void add_edge(int from, int to, T cost = 1) {
g[from].emplace_back(from, to, cost, edge_id);
g[to].emplace_back(to, from, cost, edge_id++);
}

void read(int m, int padding = -1, bool weighted = false, bool directed = false) {
for (int i = 0; i < m; ++i) {
int a, b;
cin >> a >> b;
a += padding;
b += padding;
T c = T(1);
if (weighted) {
cin >> c;
}
if (directed) {
add_directed_edge(a, b, c);
} else {
add_edge(a, b, c);
}
}
}

inline vector<Edge<T>>& operator[](const int& k) {
return g[k];
}

inline const vector<Edge<T>>& operator[](const int& k) const {
return g[k];
}
};
#pragma endregion
#pragma region PARSE
inline int toi(char c) { return c - '0'; }
int toi(string s) { return stoi(s); }
ll toll(string s) { return stoll(s); }
template <typename T>
string tos(T x) {
return to_string(x);
}
inline char toc(int i) { return '0' + i; }
template <typename T>
string tobit(T x, size_t d) {
if (d <= 2)
return bitset<2>(x).to_string();
else if (d <= 4)
return bitset<4>(x).to_string();
else if (d <= 8)
return bitset<8>(x).to_string();
else if (d <= 16)
return bitset<16>(x).to_string();
else if (d <= 32)
return bitset<32>(x).to_string();
else
return bitset<64>(x).to_string();
}
#pragma endregion

#pragma endregion
constexpr signed MOD = 1e9 + 7;
// constexpr signed MOD = 998244353;
#pragma region MOD
template <signed mod>
struct ModInt {
signed x;

ModInt() : x(0) {}

ModInt(long long y) : x((y >= 0) ? (y % mod) : (mod - ((-y) % mod)) % mod) {}

ModInt& operator++() {
++x;
if (x == mod) {
x = 0;
}
return *this;
}

ModInt& operator--() {
if (x == 0) {
x = mod;
}
--x;
return *this;
}

ModInt operator++(signed) {
ModInt ret = *this;
++*this;
return ret;
}

ModInt operator--(signed) {
ModInt ret = *this;
--*this;
return ret;
}

ModInt& operator+=(const ModInt& p) {
if ((x += p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator-=(const ModInt& p) {
if ((x += mod - p.x) >= mod) {
x -= mod;
}
return *this;
}

ModInt& operator*=(const ModInt& p) {
x = (int)(1LL * x * p.x % mod);
return *this;
}

ModInt& operator/=(const ModInt& p) {
*this *= p.inverse();
return *this;
}

ModInt operator-() const { return ModInt(-x); }

ModInt operator+(const ModInt& p) const { return ModInt(*this) += p; }

ModInt operator-(const ModInt& p) const { return ModInt(*this) -= p; }

ModInt operator*(const ModInt& p) const { return ModInt(*this) *= p; }

ModInt operator/(const ModInt& p) const { return ModInt(*this) /= p; }

bool operator==(const ModInt& p) const { return x == p.x; }

bool operator!=(const ModInt& p) const { return x != p.x; }

/**
*  拡張ユークリッドの互除法を用いた逆元計算
*  - time: O(logx)
*/
ModInt inverse() const {
int a = x, b = mod, u = 1, v = 0, t;
while (b > 0) {
t = a / b;
swap(a -= t * b, b);
swap(u -= t * v, v);
}
return ModInt(u);
}

ModInt pow(long long n) const {
ModInt ret(1), mul(x);
while (n > 0) {
if (n & 1) ret *= mul;
mul *= mul;
n >>= 1;
}
return ret;
}

friend ostream& operator<<(ostream& os, const ModInt& p) { return os << p.x; }

friend istream& operator>>(istream& is, ModInt& a) {
long long t;
is >> t;
a = ModInt<mod>(t);
return (is);
}

static signed get_mod() { return mod; }
};

using mint = ModInt<MOD>;
using vmi = vc<mint>;
#pragma endregion

struct UnionFind {
int n;
std::vector<int> leader_or_size;

explicit UnionFind(int n) : n(n), leader_or_size(n, -1) {}

int unite(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
int x = leader(a), y = leader(b);
if (x == y) return x;
if (-leader_or_size[x] < -leader_or_size[y]) std::swap(x, y);
leader_or_size[x] += leader_or_size[y];
leader_or_size[y] = x;
return x;
}

bool same(int a, int b) {
assert(0 <= a && a < n);
assert(0 <= b && b < n);
return leader(a) == leader(b);
}

int leader(int a) {
assert(0 <= a && a < n);
if (leader_or_size[a] < 0) return a;
return leader_or_size[a] = leader(leader_or_size[a]);
}

int size(int a) {
assert(0 <= a && a < n);
return -leader_or_size[leader(a)];
}

std::vector<std::vector<int>> groups() {
std::vector<int> leader_buffer(n), group_size(n);
for (int i = 0; i < n; ++i) {
leader_buffer[i] = leader(i);
++group_size[leader_buffer[i]];
}
std::vector<std::vector<int>> ret(n);
for (int i = 0; i < n; ++i) ret[i].reserve(group_size[i]);
for (int i = 0; i < n; ++i) ret[leader_buffer[i]].push_back(i);
ret.erase(
std::remove_if(ret.begin(), ret.end(),
[&](const std::vector<int>& v) { return v.empty(); }),
ret.end());
return ret;
}
};

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(9);
cerr << fixed << setprecision(9);

INT(n, m);
VEC(int, p, n);
rep(i, n)-- p[i];
auto uf = UnionFind(n);
rep(i, m) {
INT(x, y);
--x, --y;
uf.unite(x, y);
}
int ans = 0;
fore(g, uf.groups()) {
set<int> st;
fore(e, g) st.insert(e);
fore(e, g) {
if (st.count(p[e])) ++ans;
}
}
OUT(ans);

return 0;
}
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x; i<=y; ++i)

using namespace std;
const int N=1005;
const double INF=1000000000000000;
bool vis[N];
int n;
double dis[N];

struct circle
{
double x,y,r;

void init(bool tp=1)
{
scanf("%lf%lf",&x,&y);
if(tp) scanf("%lf",&r);
else r=0;
}
} p[N];

double sqr(double x) {return x*x;}

double D(circle a,circle b)
{
return max(0.0,sqrt(sqr(a.x-b.x)+sqr(a.y-b.y))-a.r-b.r);
}

void dij()
{
rep(i,0,n+1) dis[i]=INF;
dis[0]=0;
rep(i,0,n)
{
int u=-1;
rep(j,0,n+1) if(!vis[j])
if(u==-1 || dis[u]>dis[j]) u=j;
vis[u]=1;
rep(j,0,n+1) dis[j]=min(dis[j],dis[u]+D(p[u],p[j]));
}
}

int main()
{
p[0].init(0);
p[1].init(0);
scanf("%d",&n);
p[n+1]=p[1];
rep(i,1,n) p[i].init();
dij();
printf("%.10lf\n",dis[n+1]);
return 0;
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

struct circle {
ll x, y, r;
circle() {}
circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
};

ld calcDist(circle a, circle b) {
return max(0.0, sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) - a.r - b.r);
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

vector <circle> v(n+2);
v[0] = circle(xs, ys, 0);
v[n+1] = circle(xt, yt, 0);
for(int i = 1; i <= n; i++) {
cin >> v[i].x >> v[i].y >> v[i].r;
dist[i] = calcDist(circle(xs, ys, 0), v[i]);
}
for (int i = 0; i < n+2; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n+2; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], idx = j;
}
visited[idx] = true;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
dist[j] = min(dist[j], dist[idx] + calcDist(v[idx], v[j]));
}
}

printf("%.9Lf\n", dist[n+1]);
}
#define _CRT_SECURE_NO_WARNINGS

#pragma GCC target ("avx,avx2")
#pragma GCC optimize ("Ofast")
#pragma GCC optimize ("unroll-loops")

#include <iostream>
#include <vector>
#include <set>
#include <list>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <iomanip>
#include <algorithm>
#include <stack>
#include <random>
#include <assert.h>
#include <queue>
#include <bitset>

using namespace std;

const long long inf = 1e9;
const long long mod = 1e9 + 7;
const long long N = 100010;
#define all(x) x.begin(), x.end()

vector<int> g[N];
int val[N];

void solve()
{
int n;
cin >> n;
fill(val, val + N, inf);
for (int i = 0; i < n - 1; i++) 
{
int v, u;
cin >> v >> u; v--, u--;
g[v].push_back(u);
g[u].push_back(v);
}
int k;
cin >> k;
multiset<pair<int, int>> q;
for(int i = 0; i < k; i++) 
{
int v, p;
cin >> v >> p;
val[v-1] = p;
q.insert({p, v-1}) ;
}
while (!q.empty()) 
{
int cur = (*q.begin()).first;
int v = (*q.begin()).second;
q.erase(q.begin());
for (auto u : g[v]) 
{
if (val[u] == inf) 
{
val[u] = cur + 1;
q.insert({cur +1, u});
}
}
}
bool ok = 1;
for (int v = 0; v < n; v++) 
for(auto u : g[v]) 
if (abs(val[v] - val[u]) != 1) 
ok = 0;

if (!ok) 
cout << "No\n";
else
{
cout << "Yes\n";
for (int v = 0; v < n; v++) 
cout << val[v] << '\n';
}

}
int main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int k;
int tot,to[2000001],nxt[2000001],va[2000001],lst[100001];
int dis[100001],vi[100001];
queue<int>q;
void add(int x,int y,int z){
to[++tot]=y;
nxt[tot]=lst[x];
lst[x]=tot;
va[tot]=z;
return;
}
void init(){
for(int i=0;i<k;i+=1){
for(int j=0;j<=9;j+=1){
add(i,(i*10+j)%k,j);	
}
dis[i]=1e9;
}
dis[0]=0;
return;
}
void solve(){
int x,y;
q.push(0); vi[0]=1;
while(!q.empty()){
x=q.front(); q.pop(); vi[x]=0;
for(int i=lst[x];i;i=nxt[i]){
y=to[i];
if(dis[y]>dis[x]+va[i]){
dis[y]=dis[x]+va[i];
if(!vi[y]){
q.push(y); vi[y]=1;
}
}
}
if(!dis[x]) dis[x]=1e9;
}
return;
}
int main(){
scanf("%d",&k);
init(); solve();
printf("%d\n",dis[0]);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define rrep(i, a, b) for (int i = (a); i >= (b); --i)
#define PB push_back
#define ar2 array<int, 2>
typedef long long LL;
const LL P = 998244353;
const LL INF = 1e9 + 1;
const int N = 5e5 + 5;
mt19937 rng(time(0));

int T, n;
char s[N], t[N];
int pr[N];

char nxt(char x) { return x < 'C' ? x + 1 : 'A'; }

void eliminate(char s[], int &n) {
pr[0] = 0;
rep(i, 1, n) pr[i] = i - 1;
rep(i, 3, n) if (pr[pr[i]]) {
int j = pr[i], k = pr[j];
char x = s[i], y = s[j], z = s[k];
if (x == nxt(y) && y == nxt(z) && z == nxt(x)) {
s[i] = s[j] = s[k] = 0;
pr[i + 1] = pr[k];
}
}
int m = 0;
rep(i, 1, n) if (s[i]) s[++m] = s[i];
n = m, s[n + 1] = 0;
}

int main() {
cin >> n;
cin >> (s + 1) >> (t + 1);
int n1 = n, n2 = n;
eliminate(s, n1), eliminate(t, n2);
bool flag = n1 == n2;
rep(i, 1, n1) if (s[i] != t[i]) flag = false;
cout << (flag ? "YES" : "NO");
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5,INF=1e9;
int n;
int L[N],R[N],P[N];
long long ans;
bool vis[N];

int c[N];
int lowbit(int x){
return x & (-x);
}
void modify(int x,int k){
while(x<N) c[x]+=k,x+=lowbit(x);
}
int query(int x){
int tot=0;
while(x) tot+=c[x],x-=lowbit(x);
return tot;
}

int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>L[i]>>R[i];
if(L[i]<L[i-1] || R[i]<R[i-1]) return puts("-1"),0;
}
for(int i=n;i>=1;i--)
if(L[i]!=L[i+1])
P[i]=L[i];
for(int i=1;i<=n;i++)
if(R[i]!=R[i-1])
P[i]=R[i];

for(int i=1;i<=n;i++){
if(!P[i]) continue;
if(vis[P[i]]) return puts("-1"),0;
vis[P[i]]=1;
}
int nw=1;
for(int i=1;i<=n;i++){
if(!P[i]){
while(vis[nw]) nw++;
P[i]=nw;
vis[nw]=1;
}
}

int mn=INF,mx=0;
for(int i=n;i>=1;i--){
mn=min(mn,P[i]);
if(mn!=L[i]) return puts("-1"),0;
}
for(int i=1;i<=n;i++){
mx=max(mx,P[i]);
if(mx!=R[i]) return puts("-1"),0;
}
for(int i=1;i<=n;i++){
ans+=i-1-query(P[i]);
modify(P[i],1);
}
cout<<ans;
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

vector <vector <int>> g, r;

int MEX(vector <int> a) {
a.push_back(mod);
sort(a.begin(), a.end());
if (a[0] != 0) return 0;
for (int i = 1; i < a.size(); ++i) {
if (a[i] == a[i - 1]) continue;
if (a[i] != a[i - 1] + 1) {
return a[i - 1] + 1;
}
}
assert(0);
return 0;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
g.resize(n + 1);
r.resize(n + 1);

for (int i = 1, x; i <= n; ++i) {
cin >> x;
g[x].push_back(i);
r[i].push_back(x);
}

set <pair <int, int>> heap;
vector <int> curSize(n + 1), a(n + 1, -1);
for (int i = 1; i <= n; ++i) {
curSize[i] = g[i].size();
heap.insert({ curSize[i], i });
}

while (!heap.empty() and heap.begin()->first == 0) {
vector <int> vals;
auto v = heap.begin()->second;
heap.erase(heap.begin());
for (auto u : g[v])
vals.push_back(a[u]);

sort(vals.begin(), vals.end());
a[v] = MEX(vals);

for (auto& u : r[v]) {
heap.erase({ curSize[u], u });
curSize[u]--;
heap.insert({ curSize[u], u });
}
}

vector <int> cyc, p(n + 1);
int st = 1;
for (int i = 1; i <= n; ++i) {
if (a[i] == -1) {
st = i;
for (auto u : r[i])
if (a[u] == -1) p[i] = u;
}
}

cyc.push_back(st);
int curV = p[st];
while (curV != st) {
cyc.push_back(curV);
curV = p[curV];
}

for (int i = 0; i < 400; ++i) {
for (auto& v : cyc) {
if (v == cyc[0]) a[v] = i;
else {
vector <int> vals;
for (auto& u : g[v])
vals.push_back(a[u]);
a[v] = MEX(vals);
}
}
vector <int> vals;
for (auto& u : g[cyc[0]])
vals.push_back(a[u]);
if (MEX(vals) == i) {
cout << "POSSIBLE\n";
return 0;
}
}

cout << "IMPOSSIBLE\n";
return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define int long long int
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define br "\n"

void code(int testcaseNumber, int totalTestcases){
/*ummeed hai ki base case ka socha hoga*/
int n, k;
cin>>n>>k;

for(int i=0; i<n; i++){
int a;
cin>>a;
}

int cnt = 0;

while(1){
n-=k;
cnt++;
if(n<1){
break;
}
n++;
}

cout<<cnt<<br;
}

signed main(){
int t=1;

for(int i=0; i<t; i++){
code(i, t-1);
}

return 0;
}


#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i = 0; i < (n); i++)
#define rep1(i, n) for(int i = 1; i <= (n); i++)
#define co(x) cout << (x) << "\n"
#define cosp(x) cout << (x) << " "
#define ce(x) cerr << (x) << "\n"
#define cesp(x) cerr << (x) << " "
#define pb push_back
#define mp make_pair
#define Would
#define you
#define please

//なんこれ？

const int cm = 1 << 17;
char cn[cm], * ci = cn + cm, ct;
inline char getcha() {
if (ci - cn == cm) { fread_unlocked(cn, 1, cm, stdin); ci = cn; }
return *ci++;
}
inline int getint() {
int A = 0;
if (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';
else while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';
return A;
}

const int dm = 1 << 21;
char dn[dm], * di = dn;

int main() {
cin.tie(0);
ios::sync_with_stdio(false);


int N = getint();
int X[200000], X2[200000];
rep(i, N) X2[i] = (X[i] = getint());

//int L = 0;
//int R = 1e9 + 1;
//while (L < R) {
//	int H = (L + R) / 2;
//	int k = 0;
//	rep(i, N) k += X[i] <= H;
//	if (k < N / 2) L = H + 1;
//	else R = H;
//}
//int L2 = L;
//int R2 = 1e9 + 1;
//while (L2 < R2) {
//	int H = (L2 + R2) / 2;
//	int k = 0;
//	rep(i, N) k += X[i] <= H;
//	if (k < N / 2 + 1) L2 = H + 1;
//	else R2 = H;
//}

nth_element(X, X + N / 2, X + N);
nth_element(X, X + N / 2 - 1, X + N / 2);
int L = X[N / 2 - 1];
int L2 = X[N / 2];
int K = L;
int keta1 = 0, keta2 = 0;
char C1[10], C2[10];
while (L) {
*(C1 + keta1) = '0' + L % 10;
L /= 10;
keta1++;
}
while (L2) {
*(C2 + keta2) = '0' + L2 % 10;
L2 /= 10;
keta2++;
}

rep(i, N) {
if (X2[i] > K) {
for (int i = keta1 - 1; i >= 0; i--)* di++ = (*(C1 + i));
*di++ = '\n';
}
else {
for (int i = keta2 - 1; i >= 0; i--)* di++ = (*(C2 + i));
*di++ = '\n';
}
}
fwrite_unlocked(dn, di - dn, 1, stdout);
}
// Problem: AT2568 [ARC074D] Lotus Leaves
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT2568
// Memory Limit: 250 MB
// Time Limit: 2000 ms

/*
* Author: chenkaifeng @BDFZ
*/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pf push_front
#define rep(i, s, t) for (int i = s; i <= t; ++i)
#define per(i, s, t) for (int i = t; i >= s; --i)

namespace nqio{const unsigned R=4e5,W=4e5;char*a,*b,i[R],o[W],*c=o,*d=o+W,h[40],*p=h,y;bool s;struct q{void r(char&x){x=a==b&&(b=(a=i)+fread(i,1,R,stdin),a==b)?-1:*a++;}void f(){fwrite(o,1,c-o,stdout);c=o;}~q(){f();}void w(char x){*c=x;if(++c==d)f();}q&operator>>(char&x){do r(x);while(x<=32);return*this;}q&operator>>(char*x){do r(*x);while(*x<=32);while(*x>32)r(*++x);*x=0;return*this;}template<typename t>q&operator>>(t&x){for(r(y),s=0;!isdigit(y);r(y))s|=y==45;if(s)for(x=0;isdigit(y);r(y))x=x*10-(y^48);else for(x=0;isdigit(y);r(y))x=x*10+(y^48);return*this;}q&operator<<(char x){w(x);return*this;}q&operator<<(char*x){while(*x)w(*x++);return*this;}q&operator<<(const char*x){while(*x)w(*x++);return*this;}template<typename t>q&operator<<(t x){if(!x)w(48);else if(x<0)for(w(45);x;x/=10)*p++=48|-(x%10);else for(;x;x/=10)*p++=48|x%10;while(p!=h)w(*--p);return*this;}}qio;}using nqio::qio;

#define OK debug("OK!\n")
#ifndef ONLINE_JUDGE
namespace debuger{void debug(const char *s) {cerr << s;}template<typename T1,typename... T2>void debug(const char*s, const T1 x, T2...ls) { int p=0; while(*(s + p)!='\0') {if(*(s+p)=='{'&&*(s+p+1)=='}'){cerr << x;debug(s + p + 2, ls...);return;}cerr << *(s + p++);}}}using debuger::debug;
#else
#define debug(...) void(0)
#endif

// const int mod = 1e9 + 7;
const int mod = 998244353;

int qpow(int x, ll p) {
int res = 1, base = x;
while(p) {
if(p & 1) res = 1ll * res * base % mod;
base = 1ll * base * base % mod;
p >>= 1;
}
return res;
}

template<typename T> inline void upd(T& x, const T& y) {	x += y;	if(x >= mod) x -= mod; }
template<typename T> inline void upd(T& x, const T& y, const T& z) { x = y + z; if(x >= mod) x -= mod; }

/* template ends here */

const int N = 305;
const int M = 1e6 + 5;

const int inf = 0x3f3f3f3f;

int n, m, e, s, t;
int cur[N], head[N], nxt[M], to[M], fl[M], tot = 1;
int dis[N];
int que[N], ph=1, pt=0;
char ss[N][N];

inline void addedge(int u, int v, int f) {
nxt[++tot] = head[u];
to[tot] = v;
fl[tot] = f;
head[u] = tot;
}

inline bool bfs() {
memset(dis, 0, sizeof dis);
memcpy(cur, head, sizeof cur);
ph=1, pt=0;
dis[s] = 1;
que[++pt] = s;
while(ph <= pt) {
int u = que[ph++];
for(int i = head[u]; i; i = nxt[i]) {
int v = to[i];
int f = fl[i];
if(f && !dis[v]) {
dis[v] = dis[u] + 1;
que[++pt] = v;
}
}
}
return dis[t];
}

inline int dfs(int u, int l) {
if(u == t) return l;
int res = 0;
for(int& i = cur[u]; i; i = nxt[i]) {
int v = to[i];
int f = fl[i];
if(f && dis[v] == dis[u] + 1) {
int x = dfs(v, min(l, f));
l -= x;
fl[i] -= x;
fl[i^1] += x;
res += x;
}
if(!l) break;
}
if(l) dis[u] = -1;
return res;
}

int dinic() {
int res = 0;
while(bfs()) res += dfs(s, inf);
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr), cout.tie(nullptr);
cout << fixed << setprecision(15); 
cerr << fixed << setprecision(15);

cin >> n >> m;
rep(i, 1, n) cin >> (ss[i]+1);
int sx, sy, tx, ty;
rep(i, 1, n) rep(j, 1, m) {
if(ss[i][j] == 'S') sx = i, sy = j;
if(ss[i][j] == 'T') tx = i, ty = j;
}
if(sx == tx || sy == ty) {
cout << -1 << "\n";
return 0;
}
s = n+m+1, t = n+m+2;
addedge(s, sx, inf);
addedge(sx, s, 0);
addedge(s, sy+n, inf);
addedge(sy+n, s, 0);
addedge(tx, t, inf);
addedge(t, tx, 0);
addedge(ty+n, t, inf);
addedge(t, ty+n, 0);
rep(i, 1, n) rep(j, 1, m) {
if(ss[i][j] == 'o') {
addedge(i, j+n, 1);
addedge(j+n, i, 1);
}
}
cout << dinic() << "\n";

return 0;
}

#include <bits/stdc++.h>
#define int long long
#define pai 3.141592653589793238462643383279502884197169399375105820
#define MOD 1000000007
#define eps 0.00000001
inline int min(int a,int b) {return a<b?a:b;}
inline int max(int a,int b) {return a>b?a:b;}
#define ULL unsigned long long
#define LL long long
#define INF 0x3f3f3f3f
#define INF_LL 0x3f3f3f3f3f3f3f3f
static char buf[1000000],*pa=buf,*pd=buf;
static char buf2[1000000],*pp=buf2;
#define getchar() pa==pd&&(pd=(pa=buf)+fread(buf,1,1000000,stdin),pa==pd)?EOF:*pa++
inline void pc(char ch){
if(pp-buf2==1000000) fwrite(buf2,1,1000000,stdout),pp=buf2;
*pp++=ch;
}
inline void pcc(){
fwrite(buf2,1,pp-buf2,stdout);
pp=buf2;
}
inline int read(void){
int w=1;
register int x(0);register char c(getchar());
while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
return w*x;
}
void write(int x){
static int sta[20];
int top=0;
do{
sta[top++]=x%10,x/=10;
}while(x);
while(top) pc(sta[--top]+48);
}
void we(int x){
write(x);
pc('\n');
}
inline bool cmp_xi(int a,int b) {return a<b;}
inline bool cmp_da(int a,int b) {return a>b;}
char op[100009][2];int ak,anss,ans[100009],s[100009],kx,N,a[100009],v[100009];
signed main(void) {
N=read();
for(int i=1;i<N;i++) {
a[i]=read();
op[i+1][0]=getchar();
while(op[i+1][0]!='-'&&op[i+1][0]!='+') op[i+1][0]=getchar();
}
v[1]=1;
for(int i=2;i<=N;i++) if(op[i][0]=='-') v[i]=-1;else v[i]=1;
a[N]=read();
for(int i=1;i<=N;i++) s[i]=a[i]*v[i]+s[i-1];
for(int i=1;i<=N;i++) a[i]+=a[i-1];
for(int i=1;i<=N;i++) {
if(v[i]==-1) ans[++kx]=i;
}
for(int i=1;i<kx;i++) {
int tmp=s[ans[i]];
tmp-=(s[ans[i+1]-1]-s[ans[i]]);
tmp+=(a[N]-a[ans[i+1]-1]);
anss=max(anss,tmp); 
}
printf("%lld",max(anss,s[N]));
}

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
template <typename T> using oset = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;

void test_case() {
int N, K; std::cin >> N >> K;
std::map<int, int> C;
for (int i = 0; i < N; ++i) {
int op; std::cin >> op;
++C[op];
}
std::set<std::pair<int, int>> extra;
for (auto v : C) {
auto [a, b] = v;
extra.insert(std::make_pair(b, a));
}
int answer = 0;
while (int(extra.size()) > K) {
auto v = *extra.begin();
extra.erase(v);
answer += v.first;
}
std::cout << answer << "\n";
}

int main() {
std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr);
int test = 1;
//std::cin >> test;
while (test--) {
test_case();
}
return 0;
}

// Code by Parsa Eslami

#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FORR(i,a,b) for(int i=a;i>=b;i--)
#define S second
#define F first
#define pb push_back
#define SZ(x) (int)x.size()
#define all(x) x.begin(),x.end()
#define err(x) cout<<#x<<": "<<x<<'\n';

using namespace std;
const int N=1e5+4;
bool B[N];
vector<int> adj[N];
int d[N],dm[N];
int s,q,n;
int ans1[N];
int ans2[N];

void dfs1(int v,int ind,int p){
FOR(i,ind,ind+dm[v]-1){
ans1[i]=i+1;
}
ans1[ind+dm[v]]=ind;
ind=ind+dm[v]+1;
for(int u:adj[v])
if(!B[u]&&u!=p){
dfs1(u,ind,v);
}
}

void dfs2(int v,int ind,int p){
FOR(i,ind,ind+dm[v]-1){
ans2[i]=i+1;
}
ans2[ind+dm[v]]=ind;
ind=ind+dm[v]+1;
for(int u:adj[v])
if(!B[u]&&u!=p){
dfs2(u,ind,v);
}
}

int32_t main() {
ios_base::sync_with_stdio(0); cin.tie(0);	

cin>>n;
FOR(i,1,n-1){
int u,v; cin>>u>>v;
d[u]++; d[v]++;
adj[u].pb(v);
adj[v].pb(u);
}
if(n==2){
cout<<"1 2\n";
return 0;
}
FOR(i,1,n) d[i]=SZ(adj[i]);
FOR(i,1,n) if(d[i]==(n-1)) {
cout<<"1 ";
FOR(i,3,n-1) cout<<i<<" ";
cout<<"2 "<<n<<'\n';
return 0;
}
FOR(i,1,n){
if(d[i]==1){
B[i]=1;
dm[adj[i][0]]++;
}
}
FOR(i,1,n){
if(d[i]-dm[i]>2) return cout<<"-1\n",0;
else if(d[i]-dm[i]==1&&!B[i]){
if(s==0) s=i;
else q=i;
}
}
for(int u:adj[q]){
if(B[u]){
B[u]=0;
dm[q]--;
q=u;
break;
}
}
for(int u:adj[s]){
if(B[u]){
B[u]=0;
dm[s]--;
s=u;
break;
}
}
dfs1(s,1,0);
dfs2(q,1,0);
FOR(i,1,n){
if(ans1[i]!=ans2[i]){
if(ans1[i]<ans2[i]){
FOR(i,1,n) cout<<ans1[i]<<" ";
cout<<'\n';
return 0;
}else break;
}
}
FOR(i,1,n) cout<<ans2[i]<<" ";
cout<<'\n';

return 0;
}

#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;

//only for atcoder
#include<atcoder/all>
using namespace atcoder;

#define rep(i,l,r) for(ll i=(l); i<(r); i++)
#define rrep(i,l,r) for(ll i=(r)-1; i>=(l); i--)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MINV(c) *min_element(ALL(c))
#define MAXV(c) *max_element(ALL(c))

using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VS = vector<string>;
using VVS = vector<VS>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VC = vector<char>;
using VVC = vector<VC>;
using VD = vector<ld>;
using VVD = vector<VD>;
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
const ll LINF = 2e18;
const int INF = 2e9;

int op(int a, int b){
return a+b;
}

int e(){
return 0;
}

int main(){
int N, M;
cin >> N >> M;
VI A(M+1);
VVI E(M+1,VI(0));
rep(i,0,N){
int l, r;
cin >> l >> r;
A[l]++;
E[r].push_back(l);
}

VVI G(M+1,VI(0));
rep(i,1,M+1){
rep(j,1,M+1){
if(i*j > M){
break;
}
G[i*j].push_back(i);
}
}

VI ans(M+1);
segtree<int,op,e> seg(M+1);
rep(i,1,M+1){
seg.set(i,A[i]);
rep(j,0,G[i].size()){
int x = G[i][j];
ans[x] += seg.prod(i-x+1,i+1);
}
rep(j,0,E[i].size()){
int g = seg.get(E[i][j]);
seg.set(E[i][j],g-1);
}
}
rep(i,1,M+1){
cout << ans[i] << endl;
}
}
#include <cstdio>
using namespace std;
const int N=25003,K=403;
const int P=1000000007;
int f[N][K],g[N][K];
int a[N],prod[K];
int n,k,m;
int read(){
char c=getchar();int x=0;
while (c<48||c>57) c=getchar();
do x=(x<<1)+(x<<3)+(c^48),c=getchar();
while (c>=48&&c<=57);
return x;
}
int qp(int a,int b=P-2){
int r=1;
while (b){
if (b&1) r=1ll*r*a%P;
a=1ll*a*a%P;
b>>=1;
}
return r;
}
bool vis[K];
int buc[K];
int main(){
n=read(); k=read(); m=read();
for (int i=1; i<=m; ++i) a[i]=read();
int tot=1ll*qp(k,n-m)*(n-m+1)%P;
int cnt=0,ans=0,L=1,R=m;
for (int i=1; i<=m; ++i){
cnt+=!buc[a[i]],++buc[a[i]];
if (i>k) --buc[a[i-k]],cnt-=!buc[a[i-k]];
if (cnt==k){
printf("%d\n",tot);
return 0;
}
}
while (L<=m&&!vis[a[L]]) vis[a[L++]]=1; --L;
for (int i=1; i<=k; ++i) vis[i]=0;
while (R>=1&&!vis[a[R]]) vis[a[R--]]=1; ++R;
for (int i=1; i<=k; ++i) vis[i]=0;
f[1][1]=g[1][1]=k;
for (int i=2; i<=n; ++i){
for (int j=1; j<k; ++j)
f[i][j]=(1ll*f[i-1][j-1]*(k-j+1)+g[i-1][j])%P;
for (int j=k-1; j; --j)
g[i][j]=(f[i][j]+g[i][j+1])%P;
}
prod[k]=1;
for (int i=2; i<=k; ++i)
prod[k]=1ll*prod[k]*i%P;
prod[k]=qp(prod[k]);
for (int i=1; i<k; ++i)
prod[k-i]=1ll*prod[k-i+1]*i%P;
if (L>=m||R<=1){
for (int i=1; i<=n-m+1; ++i)
for (int j=m; j<k&&j<i+m; ++j)
ans=(ans+1ll*f[i+m-1][j]
*g[n-i-m+j+1][j]%P*prod[j])%P;
ans=1ll*ans*prod[m]%P;
}
else{
for (int i=1; i<=n-m+1; ++i)
ans=(ans+1ll*g[i+L-1][L]*g[n-i-R+2][m-R+1])%P;
ans=1ll*ans*prod[L]%P*prod[m-R+1]%P;
}
printf("%d\n",(P-ans+tot)%P);
return 0;
}

// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
typedef int fType;
struct edge
{
int from, to;
fType cap, flow;
edge(int from, int to, fType cap, fType flow = 0) : from(from), to(to), cap(cap), flow(flow) {} 
};

struct PushRelabel
{
int N;
vector<edge> edges;
vector<vector<int> > G;
vector<int> h, inQ, count;
vector<fType> excess;
queue<int> Q;
PushRelabel(int N) : N(N), count(N<<1), G(N), h(N), inQ(N), excess(N) {}

void addEdge(int from, int to, int cap) {
G[from].push_back(edges.size());
edges.push_back(edge(from, to, cap));
G[to].push_back(edges.size());
edges.push_back(edge(to, from, 0));
}

void enQueue(int u) {
if(!inQ[u] && excess[u] > 0) Q.push(u), inQ[u] = true;
}

void Push(int edgeIdx) {
edge & e = edges[edgeIdx];
int toPush = min<fType>(e.cap - e.flow, excess[e.from]);
if(toPush > 0 && h[e.from] > h[e.to]) {
e.flow += toPush;
excess[e.to] += toPush;
excess[e.from] -= toPush;
edges[edgeIdx^1].flow -= toPush;
enQueue(e.to);
}
}

void Relabel(int u) {
count[h[u]] -= 1; h[u] = 2*N-2;
for (int i = 0; i < G[u].size(); ++i) {
edge & e = edges[G[u][i]];
if(e.cap > e.flow) h[u] = min(h[u], h[e.to]);
}
count[++h[u]] += 1;
}

void gapRelabel(int height) {
for (int u = 0; u < N; ++u) if(h[u] >= height && h[u] < N) {
count[h[u]] -= 1;
count[h[u] = N] += 1;
enQueue(u);
}
}

void Discharge(int u) {
for (int i = 0; excess[u] > 0 && i < G[u].size(); ++i) {
Push(G[u][i]);
}
if(excess[u] > 0) {
if(h[u] < N && count[h[u]] < 2) gapRelabel(h[u]);
else Relabel(u);
}
else if(!Q.empty()) { // dequeue
Q.pop();
inQ[u] = false;
}
}

fType getFlow(int src, int snk) {
h[src] = N; inQ[src] = inQ[snk] = true;
count[0] = N - (count[N] = 1);
for (int i = 0; i < G[src].size(); ++i) {
excess[src] += edges[G[src][i]].cap;
Push(G[src][i]);
}
while (!Q.empty()) {
Discharge(Q.front());
}
return excess[snk];
}
};

void example()
{
int n, m;
cin>>n>>m;
PushRelabel df(n);
while(m--) {
int x, y, c;
cin >> x >> y >> c;
--x, --y;
if(x != y){
df.addEdge(x, y, c);
df.addEdge(y, x, c);
}
}
cout << df.getFlow(0, n-1) << "\n";
}
void solve(){ 
int n; cin>>n;
vector<int> a(n + 1);
for(int i=1; i<=n; i++){
cin>>a[i];
}
PushRelabel df(2 + n);
int ans = 0;
const int inf = 1e18;
for(int i=1; i<=n; i++){
if(a[i] >= 0){
ans += a[i];
df.addEdge(i, n+1, a[i]);
}
else{
for(int j=i+i; j<=n; j+=i){
if(a[j] >= 0)
df.addEdge(i, j, inf);
}
df.addEdge(0, i, -a[i]);
}
}
cout<<ans - df.getFlow(0, n+1)<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <cstdio>
using namespace std;
const int N=25003,K=403;
const int P=1000000007;
int f[N][K],g[N][K];
int a[N],prod[K];
int n,k,m;
int read(){
char c=getchar();int x=0;
while (c<48||c>57) c=getchar();
do x=(x<<1)+(x<<3)+(c^48),c=getchar();
while (c>=48&&c<=57);
return x;
}
int qp(int a,int b=P-2){
int r=1;
while (b){
if (b&1) r=1ll*r*a%P;
a=1ll*a*a%P;
b>>=1;
}
return r;
}
bool vis[K];
int buc[K];
int main(){
n=read(); k=read(); m=read();
for (int i=1; i<=m; ++i) a[i]=read();
int tot=1ll*qp(k,n-m)*(n-m+1)%P;
int cnt=0,ans=0,L=1,R=m;
for (int i=1; i<=m; ++i){
cnt+=!buc[a[i]],++buc[a[i]];
if (i>k) --buc[a[i-k]],cnt-=!buc[a[i-k]];
if (cnt==k){
printf("%d\n",tot);
return 0;
}
}
while (L<=m&&!vis[a[L]]) vis[a[L++]]=1; --L;
for (int i=1; i<=k; ++i) vis[i]=0;
while (R>=1&&!vis[a[R]]) vis[a[R--]]=1; ++R;
for (int i=1; i<=k; ++i) vis[i]=0;
f[1][1]=g[1][1]=k;
for (int i=2; i<=n; ++i){
for (int j=1; j<k; ++j)
f[i][j]=(1ll*f[i-1][j-1]*(k-j+1)+g[i-1][j])%P;
for (int j=k-1; j; --j)
g[i][j]=(f[i][j]+g[i][j+1])%P;
}
prod[k]=1;
for (int i=2; i<=k; ++i)
prod[k]=1ll*prod[k]*i%P;
prod[k]=qp(prod[k]);
for (int i=1; i<k; ++i)
prod[k-i]=1ll*prod[k-i+1]*i%P;
if (L>=m||R<=1){
for (int i=1; i<=n-m+1; ++i)
for (int j=m; j<k&&j<i+m; ++j)
ans=(ans+1ll*f[i+m-1][j]
*g[n-i-m+j+1][j]%P*prod[j])%P;
ans=1ll*ans*prod[m]%P;
}
else{
for (int i=1; i<=n-m+1; ++i)
ans=(ans+1ll*g[i+L-1][L]*g[n-i-R+2][m-R+1])%P;
ans=1ll*ans*prod[L]%P*prod[m-R+1]%P;
}
printf("%d\n",(P-ans+tot)%P);
return 0;
}

#line 1 "main.cpp"
#include <iostream>
#line 2 "/home/denjo/compro_library/Flow/Dinic.hpp"
#include <queue>
#include <vector>
#include <limits>
#include <assert.h>

// this implementation is based on
// https://megalodon.jp/2022-0108-1135-33/https://kopricky.github.io:443/code/NetworkFlow/dinic.html

// verify:
// https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=6190842

template<class T> class Dinic {
int V;
std::vector<int> level, iter;
struct edge {
int to, rev;
T cap;
};
std::vector< std::vector<edge> > G;

void bfs(int s) {
fill(level.begin(), level.end(), -1);
std::queue<int> que;
level[s] = 0;
que.push(s);
while (!que.empty()) {
int v = que.front();
que.pop();
for (auto& e : G[v]) {
if (e.cap > 0 && level[e.to] < 0) {
level[e.to] = level[v] + 1;
que.push(e.to);
}
}
}
}

T dfs(int v, int t, T f) {
if (v == t)
return f;
for (int& i = iter[v]; i < (int)G[v].size(); i++) {
edge& e = G[v][i];
if (e.cap > 0 && level[v] < level[e.to]) {
T d = dfs(e.to, t, std::min(f, e.cap));
if (d > 0) {
e.cap -= d;
G[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}

public:

Dinic(const int node_size) : 
V(node_size), level(V), iter(V), G(V) {}

void add_edge(int from, int to, T cap) {
assert(from != to);
G[from].push_back({to, (int)G[to].size(), cap});
G[to].push_back({from, (int)G[from].size() - 1, (T)0});
}

T solve(int s, int t) {
T flow = 0;
for (;;) {
bfs(s);
if (level[t] < 0) return flow;
T f;
fill(iter.begin(), iter.end(), 0);
while ((f = dfs(s, t, std::numeric_limits<T>::max())) > 0)
flow += f;
}
}
};
#line 3 "main.cpp"
using namespace std;
using ll = int64_t;
#define infll 1LL << 60

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N;
cin >> N;
vector<int> a(N);
for (int i = 0; i < N; i++) cin >> a[i];

Dinic<ll>f(N + 2);
ll P = 0;
for (int i = 0; i < N; i++) {
if (a[i] >= 0) {
f.add_edge(i + 1, N + 1, a[i]);
P += a[i];
}
else f.add_edge(0, i + 1, -a[i]);
}

for (int k = 1; k <= N; k++) {
for (int l = 2 * k; l <= N; l += k) {
f.add_edge(k, l, infll);
}
}

cout << P - f.solve(0, N + 1) << endl;

return 0;
}



#include <bits/stdc++.h>
using namespace std; 

typedef long long ll; 
typedef pair <int, int> ii; 

const ll LINF = (ll) 1e18; 
const int INF = (int) 1e9;
const int N = (int) 1e5 + 5; 

int cnt[N];

int main() {
ios::sync_with_stdio(0); 
cin.tie(0); 
int n; 
cin >> n; 

for (int i = 0; i < n; i++) {
int a; cin >> a; 
cnt[a]++; 
}

int cnt_odd = 0, cnt_even = 0; 
for (int i = 1; i < N; i++) {
if (!cnt[i]) continue; 
if (cnt[i] & 1) cnt_odd++; else cnt_even++; 
}

cout << cnt_odd + cnt_even - (cnt_even & 1) << '\n'; 
}

#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

constexpr int N = 100005;

std::vector<int>                 e[N];
std::vector<std::pair<int, int>> es;

int deg[N], ddeg[N];
int n;

void dfs(std::vector<int> &ans, int u, int f)
{
int cnt = deg[u] - 1;
int st  = static_cast<int>(ans.size());
for (int i = st + 1; i < st + cnt; i++)
ans.emplace_back(i);
ans.emplace_back(st);
for (int v : e[u])
if (v != f)
dfs(ans, v, u);
}

int main()
{
n = sc.next_int();
for (int i = 1; i < n; i++)
{
int u = sc.next_int();
int v = sc.next_int();
es.emplace_back(u, v);
deg[u]++;
deg[v]++;
}

if (n == 2)
{
puts("1 2");
return 0;
}

for (const auto &[u, v] : es)
{
if (deg[u] > 1 && deg[v] > 1)
{
ddeg[u]++;
ddeg[v]++;
e[u].push_back(v);
e[v].push_back(u);
}
}

std::vector<int> ends;
for (int i = 1; i <= n; i++)
if (deg[i] > 1)
{
if (ddeg[i] >= 3)
{
puts("-1");
return 0;
}
else if (ddeg[i] <= 1)
{
ends.push_back(i);
}
}

if (ends.size() == 1)
ends.push_back(ends[0]);
cm_assert(ends.size() == 2);

std::vector<int> ans0{0};
dfs(ans0, ends[0], ends[0]);
std::vector<int> ans1{0};
dfs(ans1, ends[1], ends[1]);
auto ans = std::move(std::min(ans0, ans1));
ans.emplace_back(n - 1);

for (int x : ans)
std::cout << x + 1 << " ";

return 0;
}

#include <bits/stdc++.h>
using namespace std;
int a[200005];
int main()
{
int n,k,sum=0;
cin>>n>>k;
for(int i=1;i<=n;i++)
{
int x;
cin>>x;
a[x]++;
}
sort(a+1,a+n+1,greater<int>());
for(int i=1;i<=k;i++)sum+=a[i];
cout<<n-sum;
return 0;
}
#pragma GCC target ("avx2")
#pragma GCC optimization ("O3")
#pragma GCC optimization ("unroll-loops")
// warning: pragmas don't work on USACO and just set to O0

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> //gp_hash_table<T, U, chash>; 
#include <ext/pb_ds/tree_policy.hpp> //tree<T, U, cmp, rb_tree_tag,tree_order_statistics_node_update>;
using namespace std; using namespace __gnu_pbds;
// shorter template (CF specialization, because compile time better)

inline int RAND(int l, int r) {
mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<int> unifd(l, r); return unifd(mt);
}

template<class T> using pq = priority_queue<T, vector<T>, greater<T>>;
using ll = long long; using db = double; using ld = long double; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>;
using vll = vector<ll>; const int xd[4] = {0, 1, 0, -1}, yd[4] = {1, 0, -1, 0};

#define ff first
#define ss second
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define eb emplace_back
#define pb push_back
#define pf push_front

//#define TC
const ll INF = 1e18; const db EPS = 1e-8;
const int MOD = 1e9+7,//998244353
_ = 2e5 + 5;

ll power(ll x, ll y, ll m)
{
ll res = 1;
x = x % m;
if (x == 0)
return 0;
while (y > 0)
{
if (y & 1)
res = (res * x) % m;
y = y >> 1;
x = (x * x) % m;
}
return res;
}

void solve() {
int n; cin>>n;
vi a(n);
for(int i=0;i<n;i++) {
cin>>a[i];
}

sort(all(a));
int ok = 1;
if(n%2==0) {
int g = 1;
for(int i=0;i<n;i+=2) {
if(a[i]!=g||a[i+1]!=g) {
ok = 0;
}
g+=2;
}
}
else {
int g = 2;
for (int i=1;i<n;i+=2) {
if (a[i]!=g||a[i+1]!=g) {
ok=0;
}
g+=2;
}
}

if(ok) {
cout<<power(2,n/2,1e9+7);
}
else {
cout<<0<<"\n";
}
}

int main() {
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
//freopen("output.txt", "w", stdout);
#endif
cin.tie(0)->sync_with_stdio(0); //cout << setprecision(3) << fixed << showpoint;

int t = 1;
//cin >> t;
while (t--) {
solve();
}
return 0;
}
// Problem: AT2568 [ARC074D] Lotus Leaves
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT2568
// Memory Limit: 250 MB
// Time Limit: 2000 ms

/*
* Author: chenkaifeng @BDFZ
*/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pf push_front
#define rep(i, s, t) for (int i = s; i <= t; ++i)
#define per(i, s, t) for (int i = t; i >= s; --i)

namespace nqio{const unsigned R=4e5,W=4e5;char*a,*b,i[R],o[W],*c=o,*d=o+W,h[40],*p=h,y;bool s;struct q{void r(char&x){x=a==b&&(b=(a=i)+fread(i,1,R,stdin),a==b)?-1:*a++;}void f(){fwrite(o,1,c-o,stdout);c=o;}~q(){f();}void w(char x){*c=x;if(++c==d)f();}q&operator>>(char&x){do r(x);while(x<=32);return*this;}q&operator>>(char*x){do r(*x);while(*x<=32);while(*x>32)r(*++x);*x=0;return*this;}template<typename t>q&operator>>(t&x){for(r(y),s=0;!isdigit(y);r(y))s|=y==45;if(s)for(x=0;isdigit(y);r(y))x=x*10-(y^48);else for(x=0;isdigit(y);r(y))x=x*10+(y^48);return*this;}q&operator<<(char x){w(x);return*this;}q&operator<<(char*x){while(*x)w(*x++);return*this;}q&operator<<(const char*x){while(*x)w(*x++);return*this;}template<typename t>q&operator<<(t x){if(!x)w(48);else if(x<0)for(w(45);x;x/=10)*p++=48|-(x%10);else for(;x;x/=10)*p++=48|x%10;while(p!=h)w(*--p);return*this;}}qio;}using nqio::qio;

#define OK debug("OK!\n")
#ifndef ONLINE_JUDGE
namespace debuger{void debug(const char *s) {cerr << s;}template<typename T1,typename... T2>void debug(const char*s, const T1 x, T2...ls) { int p=0; while(*(s + p)!='\0') {if(*(s+p)=='{'&&*(s+p+1)=='}'){cerr << x;debug(s + p + 2, ls...);return;}cerr << *(s + p++);}}}using debuger::debug;
#else
#define debug(...) void(0)
#endif

// const int mod = 1e9 + 7;
const int mod = 998244353;

int qpow(int x, ll p) {
int res = 1, base = x;
while(p) {
if(p & 1) res = 1ll * res * base % mod;
base = 1ll * base * base % mod;
p >>= 1;
}
return res;
}

template<typename T> inline void upd(T& x, const T& y) {	x += y;	if(x >= mod) x -= mod; }
template<typename T> inline void upd(T& x, const T& y, const T& z) { x = y + z; if(x >= mod) x -= mod; }

/* template ends here */

std::mt19937 mtrnd(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 305;
const int M = 1e6 + 5;

const int inf = 0x3f3f3f3f;

int n, m, e, s, t;
int cur[N], head[N], nxt[M], to[M], fl[M], tot = 1;
int dis[N];
int que[N], ph=1, pt=0;
char ss[N][N];

inline void addedge(int u, int v, int f) {
nxt[++tot] = head[u];
to[tot] = v;
fl[tot] = f;
head[u] = tot;
}

inline bool bfs() {
memset(dis, 0, sizeof dis);
memcpy(cur, head, sizeof cur);
ph=1, pt=0;
dis[s] = 1;
que[++pt] = s;
while(ph <= pt) {
int u = que[ph++];
for(int i = head[u]; i; i = nxt[i]) {
int v = to[i];
int f = fl[i];
if(f && !dis[v]) {
dis[v] = dis[u] + 1;
que[++pt] = v;
}
}
}
return dis[t];
}

inline int dfs(int u, int l) {
if(u == t) return l;
int res = 0;
for(int& i = cur[u]; i; i = nxt[i]) {
int v = to[i];
int f = fl[i];
if(f && dis[v] == dis[u] + 1) {
int x = dfs(v, min(l, f));
l -= x;
fl[i] -= x;
fl[i^1] += x;
res += x;
}
if(!l) break;
}
if(l) dis[u] = -1;
return res;
}

int dinic() {
int res = 0;
while(bfs()) res += dfs(s, inf);
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr), cout.tie(nullptr);
cout << fixed << setprecision(15); 
cerr << fixed << setprecision(15);

cin >> n >> m;
rep(i, 1, n) cin >> (ss[i]+1);
int sx, sy, tx, ty;
rep(i, 1, n) rep(j, 1, m) {
if(ss[i][j] == 'S') sx = i, sy = j;
if(ss[i][j] == 'T') tx = i, ty = j;
}
if(sx == tx || sy == ty) {
cout << -1 << "\n";
return 0;
}
s = n+m+1, t = n+m+2;
addedge(s, sx, inf);
addedge(sx, s, 0);
addedge(s, sy+n, inf);
addedge(sy+n, s, 0);
addedge(tx, t, inf);
addedge(t, tx, 0);
addedge(ty+n, t, inf);
addedge(t, ty+n, 0);
rep(i, 1, n) rep(j, 1, m) {
if(ss[i][j] == 'o') {
addedge(i, j+n, 1);
addedge(j+n, i, 1);
}
}
cout << dinic() << "\n";

return 0;
}

#include<bits/stdc++.h>
#define reg register
#define maxn 100010
#define cmax(a,b) (a<(b)?a=(b),1:0)
#define getchar() (_S==_T&&(_T=(_S=_B)+fread(_B,1,1<<15,stdin),_S==_T)?EOF:*_S++)
char _B[1<<15],*_S=_B,*_T=_B;
int read() {
reg int s=0,f=1; reg char ch;
for(;(ch=getchar())<'0'||ch>'9';ch=='-'?f=-f:0);
for(;ch>='0'&&ch<='9';s=s*10+ch-'0',ch=getchar());
return s*f;
}
int n,mx,tt,in[maxn],rt[2],s[maxn];
struct edge{edge*nxt; int to;}e[maxn*2],*num=e,*first[maxn];
void adde(reg int a,reg int b) {*++num=(edge){first[a],b},first[a]=num,++in[b];}
void dfs(reg int x,reg int fa,reg int d,reg int k) {
cmax(mx,d)?rt[k]=x:0;
for(reg edge*i=first[x];i;i=i->nxt) if(i->to!=fa) dfs(i->to,x,d+1,k);
}
bool find(reg int x,reg int fa) {
s[++tt]=x; if(x==rt[1]) return 1;
for(reg edge*i=first[x];i;i=i->nxt) if(i->to!=fa&&find(i->to,x)) return 1;
--tt; return 0;
}
int main() {
n=read();
for(reg int i=1,x,y;i<n;++i) x=read(),y=read(),adde(x,y),adde(y,x);
dfs(1,0,0,0),mx=0,dfs(rt[0],0,0,1),find(rt[0],0);
for(reg int i=1;i<=tt;++i)
for(reg edge*j=first[s[i]];j;j=j->nxt) if(j->to!=s[i-1]&&j->to!=s[i+1])
if(in[j->to]>1) return!puts("-1");
reg bool fg=0;
for(reg int l=1,r=tt,sl=0,sr=0;l<r;++l,--r) if((sl+=in[s[l]])!=(sr+=in[s[r]])) {fg=sl>sr; break;}
fg?std::reverse(s+1,s+tt+1),0:0,++in[s[1]],++in[s[tt]];
for(reg int i=1,cnt=0;i<=tt;printf("%d ",++cnt-in[s[i]]+2),++i)
for(reg int j=1;j<=in[s[i]]-2;++j) printf("%d ",++cnt+1);
return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define reps(i, a, b) for(long long (i) = (a); (i) < (b); ++(i))
#define rep(i, n) for(long long (i) = 0; (i) < (n); ++(i))
#define repr(i, b, a) for(long long (i) = (b); (i) >= (a); --(i))
using ll = long long;
using vl = vector<long long>;
using vvl = vector<vector<long long> >;
using pl = pair<long long, long long>;
using tl = tuple<long long, long long, long long>;
using graph = vector<vector<int> >;
struct Edge{
int to;
long long cost;
Edge(int t, long long c) : to(t), cost(c) {}
bool operator<(const Edge &a) const{return cost < a.cost;}
bool operator>(const Edge &a) const{return cost > a.cost;}
};
using wgraph = vector<vector<Edge> >;
constexpr long long INF = numeric_limits<long long>::max() / 8;
constexpr long long dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};
constexpr long long dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T, typename U> inline bool chmax(T &a, const U& b) {if(a<b){a=b;return true;}return false;}
template<typename T, typename U> inline bool chmin(T &a, const U& b) {if(a>b){a=b;return true;}return false;}
template<typename T, typename U> inline T POW(T x, U n) {T ret=1;while(n>0){if(n&1){ret=ret*x;}if(n>>=1){x=x*x;}}return ret;}
template<typename T, typename U> inline T MOD(T n, U m) {if(n >= 0) {return n % m;} else return (n%m + m)%m;}
template<typename T, typename U, typename V> inline T POWMOD(T x, U n, V m){T ret=1;x%=m;while(n>0){if(n&1)ret=ret*x%m;if(n>>=1){x=x*x%m;}}return ret%m;}
template<typename T, typename U> inline T div_ceil(T a, U b){return (a + b - 1) / b;}
template<typename T> inline long long KETA(T n, long long base = 10){long long ret = 0;while(n){ret++; n /= base;} return ret;}
template<typename T> inline long long popcount(T a){return __builtin_popcount(a);}
template<typename T> inline bool contains(T S, T i){return (S & (T(1) << i)) != 0;}
template<typename T> inline void fin(T a){cout << a << '\n'; exit(0);}
template<typename T> inline T SUM(const vector<T> &v){return accumulate(v.begin(), v.end(), (T)0);}
template<typename T> inline T MIN(const vector<T> &v){return *min_element(v.begin(), v.end());}
template<typename T> inline T MAX(const vector<T> &v){return *max_element(v.begin(), v.end());}
template<typename T> inline void decr(vector<T> &v, T d = T(1)){for(auto &c : v){c -= d;}}

template<typename T,typename S> ostream&operator<<(ostream&os,const pair<T,S>&p){os<<"("<<p.first<<", "<<p.second<<")";return os;}
template<typename T,typename S> ostream&operator<<(ostream&os,const map<T,S>&ma){for(auto [a,b]:ma){os<<"("<<a<<", "<<b<<")"<<" ";}return os;}
template<typename T> ostream &operator<<(ostream&os,const set<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const multiset<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const vector<T>&v){os<<"[";for(int i=0;i<v.size();i++){os<<v[i]<<(i==v.size()-1?"":" ");}os<<"]";return os;}

void dump_func() {cerr << endl;}
template<class Head, class... Tail>
void dump_func(Head&& head, Tail&&... tail){
cerr << head;
if(sizeof...(Tail) == 0) cerr << " ";
else cerr << ", ";
dump_func(std::move(tail)...);
}



//#define ONLINE_JUDGE
#ifdef ONLINE_JUDGE
#define dump(...) true
#else
#define dump(...) cerr << __LINE__ << " : (" << #__VA_ARGS__ << ") = "; \
dump_func(__VA_ARGS__)
#endif

pair<vector<vector<int> >, vector<int> > concon(const vector<vector<int> > &G){
int n = (int)G.size();
vector<vector<int> > list;
vector<int> id(n), seen(n, 0);
auto dfs = [&](auto self, int v, vector<int> &a, const int &idx) -> void{
seen[v] = 1;
a.emplace_back(v);
id[v] = idx;
for(int nv : G[v]){
if(seen[nv]) continue;
self(self, nv, a, idx);
}
};
int cnt = 0;
for(int i = 0; i < n; ++i){
if(seen[i]) continue;
vector<int> v;
dfs(dfs, i, v, cnt);
list.emplace_back(v);
cnt++;
}
return {list, id};
}


tuple<bool, int, int> is_bipartite(const graph &G, const int &v){

//vを含むGの連結成分が二部グラフかどうか
int n = (int)G.size();
vector<int> color(n, -1);
auto dfs = [&](auto self, int v, int c) -> bool{
color[v] = c;
for(int nv : G[v]){
if(color[nv] == c) return false;
if(color[nv] != -1) continue;
if(!self(self, nv, c ^ 1)) return false;
}
return true;
};
bool res = dfs(dfs, v, 0);
dump(color);
int cnt0 = 0, cnt1 = 0;
for(int i = 0; i < n; ++i){
if(color[i] == 0) cnt0++;
if(color[i] == 1) cnt1++;
}
return {res, cnt0, cnt1};
}

bool is_bipartite(const wgraph &G, const int &v){
//vを含むGの連結成分が二部グラフかどうか
int n = (int)G.size();
vector<int> color(n, -1);
auto dfs = [&](auto self, int v, int c) -> bool{
color[v] = c;
for(auto e : G[v]){
if(color[e.to] == c) return false;
if(color[e.to] != -1) continue;
if(!self(self, e.to, c ^ 1)) return false;
}
return true;
};
return dfs(dfs, v, 0);
}




void solve(){
ll n, m; cin >> n >> m;
graph G(n);
vector<vector<int> > mat(n, vector<int> (n, 1));
rep(i, n) mat[i][i] = 0;
rep(i, m){
ll a, b; cin >> a >> b;
a--; b--;
G[a].emplace_back(b);
G[b].emplace_back(a);
mat[a][b] = 0;
mat[b][a] = 0;
}
graph H(n);
rep(i, n){
rep(j, n){
if(mat[i][j]){
H[i].emplace_back(j);
}
}
}
ll ans = INF;
auto [con, id] = concon(H);
ll s = 0, t = 0;
vector<int> dp(n + 1, 0);
dp[0] = 1;
for(auto list : con){
vector<int> nxt(n + 1, 0);
auto [b, x, y] = is_bipartite(H, list[0]);
if(!b){
cout << -1 << '\n';
return;
}
rep(i, n + 1){
if(i >= x) nxt[i] |= dp[i - x];
if(i >= y) nxt[i] |= dp[i - y];
}
swap(dp, nxt);
}

rep(i, n){
if(dp[i]){
chmin(ans, i * (i - 1) / 2 + (n - i) * (n - i - 1) / 2);
}
}
cout << ans << '\n';
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout << std::fixed << std::setprecision(15);

solve();

return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, LOG = 301;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);
int n; cin >> n;
vector <int> a(n);
for (auto& x : a) cin >> x;

int curSum = 0, ans = 0;
for (auto& x : a)
curSum += x / n;
while (curSum > 0) {
ans += curSum;
for (auto& x : a) {
int oldX = x;
x %= n;
x += (curSum - oldX / n);
}
curSum = 0;
for (auto& x : a)
curSum += x / n;
}

cout << ans << '\n';

return 0;
}

#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rev(i,a,b) for(int i=a;i>=b;i--)
#define clr(a,v) memset(a,v,sizeof(a))
#define Freopen(file) \
freopen(file".in","r",stdin); \
freopen(file".out","w",stdout);
#define int long long
using namespace std;

const int N=2e6+5;

class FTree{
int n,w,c[N];

int lowbit(int x) const
{
return x&(-x);
}

public:

void init(int _n)
{
n=_n;
w=0;
while((1<<(w+1))<=n) w++;
}

void poke(int p,int x)
{
while(p<=n){
c[p]+=x;
p+=lowbit(p);
}
}

int peek(int p) const
{
int res=0;
while(p){
res+=c[p];
p-=lowbit(p);
}
return res;
}
};

FTree T;

int n,pl[N],pr[N];
int a[N],vis[N];

signed main()
{
//	freopen("sss.in","r",stdin);

cin>>n;
For(i,1,n) cin>>pl[i]>>pr[i];

For(i,1,n){
if(i==n || pl[i]<pl[i+1]){
if( (a[i] && a[i]!=pl[i]) || (!a[i] && vis[pl[i]]) ){
puts("-1");
return 0;
}
vis[pl[i]]=1;
a[i]=pl[i];
}
if(i<n && pl[i]>pl[i+1]){
puts("-1");
return 0;
}
}

For(i,1,n){
if(i==1 || pr[i]>pr[i-1]){
if( (a[i] && a[i]!=pr[i]) || (!a[i] && vis[pr[i]]) ){
puts("-1");
return 0;
}
vis[pr[i]]=1;
a[i]=pr[i];
}
if(i>1 && pr[i]<pr[i-1]){
puts("-1");
return 0;
}
}

int t=1;

For(i,1,n){
if(!vis[i]){
while(a[t]) t++;
a[t]=i;
}
}

//	For(i,1,n) cout<<a[i]<<' ';
//	cout<<endl;

int mn=1e9;
Rev(i,n,1){
mn=min(mn,a[i]);
if(mn!=pl[i]){
puts("-1");
return 0;
}
}

int mx=0;
For(i,1,n){
mx=max(mx,a[i]);
if(mx!=pr[i]){
puts("-1");
return 0;
}
}

int ans=0;

T.init(n);

Rev(i,n,1){
ans+=T.peek(a[i]);
T.poke(a[i],1);
}

cout<<ans<<endl;

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define rrep(i, a, b) for (int i = (a); i >= (b); --i)
#define PB push_back
#define ar2 array<int, 2>
typedef long long LL;
const LL P = 998244353;
const LL INF = 1e18;
const int N = 2e5 + 5;
mt19937 rng(time(0));

int n, na, nb, nc, cnt[7];
char s[N * 3], ans[N * 3];
set<int> a, b, c;

inline int nxt(int x) { return x == n ? 2 * n + 1 : x + 1; }

void solve(set<int> &a, set<int> &b, set<int> &c, char ch1, char ch2, char ch3, char ch4) {
int x = *a.begin(), y, z;
if (x <= n) {
y = b.size() ? *b.rbegin() : -1, z = c.size() ? *c.rbegin() : -1;
assert(max(y, z) > 2 * n);
if (y > 2 * n)
ans[x] = ans[y] = ch1, b.erase(y), cnt[ch1 - '0']++;
else
ans[x] = ans[z] = ch2, c.erase(z), cnt[ch2 - '0']++;
} else {
y = b.size() ? *b.begin() : n * 4, z = c.size() ? *c.begin() : n * 4;
assert(min(y, z) <= n);
if (y <= n)
ans[x] = ans[y] = ch3, b.erase(y), cnt[ch3 - '0']++;
else
ans[x] = ans[z] = ch4, c.erase(z), cnt[ch4 - '0']++;
}
a.erase(x);
}

int main() {
cin >> n;
cin >> (s + 1);
rep(i, 1, 3 * n) if (i <= n || i > 2 * n)(s[i] == 'A' ? a : (s[i] == 'B' ? b : c)).insert(i);
while (a.size() || b.size() || c.size()) {
int na = a.size(), nb = b.size(), nc = c.size();
if (na >= nb && na >= nc) {
solve(a, b, c, '2', '1', '4', '6');
} else if (nb >= na && nb >= nc) {
solve(b, a, c, '4', '3', '2', '5');
} else { // nc >= na && nc >= nb
solve(c, a, b, '6', '5', '1', '3');
}
}
rep(i, n + 1, 2 * n) {
if (s[i] == 'A')
(cnt[3] ? ans[i] = '3', cnt[3]-- : ans[i] = '5', cnt[5]--);
if (s[i] == 'B')
(cnt[1] ? ans[i] = '1', cnt[1]-- : ans[i] = '6', cnt[6]--);
if (s[i] == 'C')
(cnt[2] ? ans[i] = '2', cnt[2]-- : ans[i] = '4', cnt[4]--);
}
cout << (ans + 1) << endl;
return 0;
}
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int MAXN = (int)1e5 + 5;
const int INF = (int)1e9;

int dist[MAXN];
int n;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n;
fill(dist, dist + n, INF);
priority_queue<pii, vector<pii>, greater<pii>> Q;

for (int i = 1; i <= 9; i++) {
int v = i % n;

if (dist[v] == INF) {
dist[v] = i;
Q.push({dist[v], v});
}
}

while (!Q.empty()) {
int cd = Q.top().first;
int v = Q.top().second;
Q.pop();

if (cd != dist[v]) {
continue;
}

for (int d = 0; d < 10; d++) {
int to = (v * 10 + d) % n;

if (dist[to] > cd + d) {
dist[to] = cd + d;
Q.push({dist[to], to});
}
}
}

cout << dist[0] << '\n';
return 0;
}

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

// struct circle {
//     ll x, y, r;
//     circle() {}
//     circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
// };

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

//vector <circle> v(n+2);
circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
dist[i] = calcDist(0, i);
}
for (int i = 0; i < n+2; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n+2; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], idx = j;
}
visited[idx] = true;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
dist[j] = min(dist[j], dist[idx] + calcDist(idx, j));
}
}

printf("%.9Lf\n", dist[n+1]);
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

ld dijkstra(int n) {
for (int i = 0; i < n; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
auto compare = [] (int a, int b) -> bool {return dist[b] < dist[a];};
priority_queue<int, vector<int>, decltype(compare)> pq(compare);
pq.push(0);
// while (!pq.empty()) {
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int cur;
for(int j = 0; j < n; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], cur = j;
}
// int cur = pq.top(); pq.pop();
// if (visited[cur]) {
//     continue;
// }
visited[cur] = true;
for (int adjVer: adjList[cur]) {
if (!visited[adjVer]) {
ld candid = dist[cur] + weight[cur][adjVer];
if (candid < dist[adjVer]) {
dist[adjVer] = candid;
// pq.push(adjVer);
}
}
}
}
return dist[n-1];
}

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
for (int j = 0; j < i; j++) {
adjList[i].insert(j);
adjList[j].insert(i);
weight[i][j] = weight[j][i] = calcDist(i, j);
}
}
for (int i = 0; i < n+1; i++) {
adjList[i].insert(n+1);
adjList[n+1].insert(i);
weight[i][n+1] = weight[n+1][i] = calcDist(i, n+1);
}
printf("%.9Lf\n", dijkstra(n+2));
}
#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<assert.h>
#include<random>
#include<string>
#include<algorithm>
#include<queue>
#include<bitset>

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()

const long long mod = 1e9 + 7;
const long long inf = 1e18;
const int N = 1010;

using ll = long long;

using namespace std;

void solve()
{
string s, t = "";
cin >> s;
t += s[0];

for (int i = 1; i < s.size(); i++)
if (t.back() != s[i])
t.push_back(s[i]);

int w = 0, b = 0;

if (t.size() == 1)
{
cout << "0\n";
return;
}

for (int i = 0; i < t.size(); i++)
{
if (i == 0 && t[i] == 'W') b++;
if (i == 0 && t[i] == 'B') w++;
if (i == (int)t.size() - 1 && t[i] == 'W') b++;
if (i == (int)t.size() - 1 && t[i] == 'B') w++;
if (i > 0 && i < (int)t.size() - 1)
{
if (t[i] == 'W') b += 2;
else w += 2;
}
}

cout << min(w, b) << '\n';

}

signed main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
#include<bits/stdc++.h>
#define ll long long
//#define int long long
using namespace std;
char gc(){static char buf[1<<16],*s,*t;if(s==t){t=(s=buf)+fread(buf,1,1<<16,stdin);if(s==t)return EOF;}return *s++;}
//#define getchar gc
int read()
{
char c;
int w=1;
while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
int ans=c-'0';
while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
return ans*w;
}
void pc(char c,int op)
{
static char buf[1<<16],*s=buf,*t=buf+(1<<16);
(op||((*s++=c)&&s==t))&&(fwrite(buf,1,s-buf,stdout),s=buf);
}
void wt(int x)
{
if(x>9)wt(x/10);
pc('0'+x%10,0);
}
void wts(int x,char op)
{
if(x<0)pc('-',0),x=-x;
wt(x);pc(op,0);
}
const int xx=1e5+5;
struct node{int next,to,v;}e[xx<<1];
int cnt,h[xx];
void add(int x,int y){cnt++;e[cnt]={h[x],y},h[x]=cnt;}
int n;
char s[xx],c[xx];
char cg(char t){return t=='W'?'B':'W';}
struct nod{int mx,se;};
nod upd(nod a,int x)
{
if(a.mx<x)a.se=a.mx,a.mx=x;
else a.se=max(a.se,x);
return a;
}
nod f[xx];
int d[xx],vs[xx],q[xx],l,r,sm;
//f是dp值 
//注意这里我是倒着算的 
void dfs(int x,int y)
{
for(int i=h[x];i;i=e[i].next)
{
if(e[i].to==y||vs[e[i].to])continue;
dfs(e[i].to,x);
f[x]=upd(f[x],f[e[i].to].mx+1+(c[e[i].to]=='W')-(c[e[i].to]=='B'));
}
}
nod g[xx];
int mx;
void dfss(int x,int y)
{
if(d[x]==1)
{
if(y)mx=max(mx,upd(f[x],g[x].mx+1+(c[y]=='W')-(c[y]=='B')).mx);
else mx=max(mx,f[x].mx);
}
if(y)f[x]=upd(f[x],g[x].mx+1+(c[y]=='W')-(c[y]=='B'));//注意以下的f改动了 
for(int i=h[x];i;i=e[i].next)
{
if(e[i].to==y||vs[e[i].to])continue;
//这里e[i].to的f还没有改动 
if(f[x].mx==f[e[i].to].mx+1+(c[e[i].to]=='W')-(c[e[i].to]=='B'))g[e[i].to].mx=f[x].se;
else g[e[i].to].mx=f[x].mx;
dfss(e[i].to,x);
}
}
signed main(){
n=read();
for(int i=1;i<n;i++)
{
int a=read(),b=read();
add(a,b),add(b,a);
d[a]++,d[b]++;
}
scanf("%s",s+1);
l=1,r=0;
for(int i=1;i<=n;i++)if(d[i]==1)q[++r]=i;
while(l<=r)//简化树的一个过程 
{
int x=q[l++];
if(s[x]=='B')
{
d[x]--;vs[x]=1;
for(int i=h[x];i;i=e[i].next)
if(!vs[e[i].to])
{
if((--d[e[i].to])==1)q[++r]=e[i].to;
}
}
}
int rt=0;
int num=0;
for(int i=1;i<=n;i++)num+=(c[i]=='W');
if(num==1)puts("1"),exit(0); 
for(int i=1;i<=n;i++)
if(!vs[i]){rt=i;break;}
if(!rt)puts("0"),exit(0);
for(int i=1;i<=n;i++)sm+=d[i];
for(int i=1;i<=n;i++)
{
if(d[i]&1)c[i]=cg(s[i]);
else c[i]=s[i];
}
for(int i=1;i<=n;i++)sm+=(c[i]=='W');
dfs(rt,0);
dfss(rt,0);
cout<<sm-mx<<"\n";
pc('1',1);
return 0;
}
#include <bits/stdc++.h>
#include <random>
#include <array>
#ifdef _MSC_VER
#include <ppl.h>
#else
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

/** compro_io **/

/* tuple */
// out
namespace aux {
template<typename T, unsigned N, unsigned L>
struct tp {
static void output(std::ostream& os, const T& v) {
os << std::get<N>(v) << ", ";
tp<T, N + 1, L>::output(os, v);
}
};
template<typename T, unsigned N>
struct tp<T, N, N> {
static void output(std::ostream& os, const T& v) { os << std::get<N>(v); }
};
}
template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {
os << '[';
aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);
return os << ']';
}

template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x);

/* pair */
// out
template<class S, class T>
std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {
return os << "[" << p.first << ", " << p.second << "]";
}
// in
template<class S, class T>
std::istream& operator>>(std::istream& is, const std::pair<S, T>& p) {
return is >> p.first >> p.second;
}

/* container */
// out
template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) {
bool f = true;
os << "[";
for (auto& y : x) {
os << (f ? "" : ", ") << y;
f = false;
}
return os << "]";
}
// in
template <
class T,
class = decltype(std::begin(std::declval<T&>())),
class = typename std::enable_if<!std::is_same<T, std::string>::value>::type
>
std::istream& operator>>(std::istream& is, T& a) {
for (auto& x : a) is >> x;
return is;
}

/* struct */
template<typename T>
auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) {
out << t.stringify();
return out;
}

/* setup */
struct IOSetup {
IOSetup(bool f) {
if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); }
std::cout << std::fixed << std::setprecision(15);
}
} iosetup(true);

/** string formatter **/
template<typename... Ts>
std::string format(const std::string& f, Ts... t) {
size_t l = std::snprintf(nullptr, 0, f.c_str(), t...);
std::vector<char> b(l + 1);
std::snprintf(&b[0], l + 1, f.c_str(), t...);
return std::string(&b[0], &b[0] + l);
}

template<typename T>
std::string stringify(const T& x) {
std::ostringstream oss;
oss << x;
return oss.str();
}

/* dump */
#define ENABLE_DUMP
#ifdef ENABLE_DUMP
#define DUMPOUT std::cerr
std::ostringstream DUMPBUF;
#define dump(...) do{DUMPBUF<<"  ";DUMPBUF<<#__VA_ARGS__<<" :[DUMP - "<<__LINE__<<":"<<__FUNCTION__<<"]"<<std::endl;DUMPBUF<<"    ";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str("");DUMPBUF.clear();}while(0);
void dump_func() { DUMPBUF << std::endl; }
template <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << " "; } else { DUMPBUF << ", "; } dump_func(std::move(tail)...); }
#else
#define dump(...) void(0);
#endif

/* timer */
class Timer {
double t = 0, paused = 0, tmp;
public:
Timer() { reset(); }
static double time() {
#ifdef _MSC_VER
return __rdtsc() / 3.0e9;
#else
unsigned long long a, d;
__asm__ volatile("rdtsc"
: "=a"(a), "=d"(d));
return (d << 32 | a) / 3.0e9;
#endif
}
void reset() { t = time(); }
void pause() { tmp = time(); }
void restart() { paused += time() - tmp; }
double elapsed_ms() { return (time() - t - paused) * 1000.0; }
} timer;

/* rand */
struct Xorshift {
uint64_t x = 88172645463325252LL;
void set_seed(unsigned seed, int rep = 100) { x = uint64_t((seed + 1) * 10007); for (int i = 0; i < rep; i++) next_int(); }
unsigned next_int() { x = x ^ (x << 7); return x = x ^ (x >> 9); }
unsigned next_int(unsigned mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % mod; }
unsigned next_int(unsigned l, unsigned r) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % (r - l + 1) + l; } // inclusive
double next_double() { return double(next_int()) / UINT_MAX; }
} rnd;

/* shuffle */
template<typename T>
void shuffle_vector(std::vector<T>& v, Xorshift& rnd) {
int n = v.size();
for (int i = n - 1; i >= 1; i--) {
int r = rnd.next_int(i);
std::swap(v[i], v[r]);
}
}

/* split */
std::vector<std::string> split(std::string str, const std::string& delim) {
for (char& c : str) if (delim.find(c) != std::string::npos) c = ' ';
std::istringstream iss(str);
std::vector<std::string> parsed;
std::string buf;
while (iss >> buf) parsed.push_back(buf);
return parsed;
}

template<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) {
std::fill((T*)array, (T*)(array + N), val);
}
template<typename T, typename ...Args> auto make_vector(T x, int arg, Args ...args) { if constexpr (sizeof...(args) == 0)return std::vector<T>(arg, x); else return std::vector(arg, make_vector<T>(x, args...)); }
template<typename T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }
template<typename T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }



using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;



int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, K;
cin >> N >> K;
vector<int> A(N);
cin >> A;

int ans = 0;
int l = 0;
while (l < N - 1) {
ans++;
l += K - 1;
}

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define sz(a) (int)a.size()
#define all(a) a.begin(),a.end()
#define rep(i,n) for(int i=0;i<n;i++)
#define crep(i,x,n) for(int i=x;i<n;i++)
#define drep(i,n) for(int i=n-1;i>=0;i--)
#define vec(...) vector<__VA_ARGS__>
#define _34raRxL ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
typedef long double ld;

void print(){
cout<<"\n";
}
template<class te,class ...ti>
void print(const te&v, const ti&...nv){ 
cout<<v;
if(sizeof...(nv)){
cout<<" ";
print(nv...);
}
}

using pii=pair<int,int>;
using vi=vector<int>;
using vll=vector<long long>;

void slv(){
int n;
cin>>n;
vi a(n);
rep(i,n){
cin>>a[i];
}
rep(i,n){
a[i]--;
}
int ans=0;
rep(i,n){
if(a[i]==i){
if(i+1<n){
swap(a[i+1],a[i]);
}
ans++;
}
}
print(ans,"");
}

int main(){
_34raRxL;
int t=1;
// cin>>t;
slv();
//	
return 0;
}
#include <cassert>
#include <functional>
#include <iomanip>
#include <iostream>
#include <vector>
#include <regex>
#include <cmath>
#include <queue>
#include <stack>
using namespace std;

const long long INF = 1LL << 60;

int main(){
int N;
cin >> N;
vector<int> A(N);
for (int i = 0; i < N; i++){
cin >> A[i];
}

// sort(A.begin(), A.end());

// cout << print_vector(A) << endl;

vector<int> nums(100001, 0);
for (int i = 0; i < N;i++){
nums[A[i]]++;
}

// 数 数字
priority_queue<pair<int, int>> yama;

for (int i = 0; i <=100000; i++){
if (nums[i] > 0)
{
yama.push(pair<int, int>(nums[i], i));
}
}

if(yama.size()==1){
cout << 1 << endl;
return 0;
}

while(true){
pair<int, int> first = yama.top();
yama.pop();
pair<int, int> second = yama.top();
yama.pop();

//cout << first.first << ' ' << second.first << endl;
if (first.first == 1 && second.first == 1)
{
yama.push(pair<int, int>(first.first, first.second));
yama.push(pair<int, int>(second.first, second.second));
break;
}

if(first.first>1&& second.first==1){
yama.push(pair<int, int>(first.first - 1, first.second));
continue;
}

yama.push(pair<int, int>(first.first-1, first.second));
yama.push(pair<int, int>(second.first-1, second.second));
}

cout << yama.size() << endl;
}
// oooo
/*
be hengam shena mesle y dasto pa cholofti ~
bepa to masire dahane koose neyofti ~
;Amoo_Hasan;
*/

#include<bits/stdc++.h>
#pragma GCC optimize("O3,no-stack-protector,unroll-loops")
#pragma GCC target("avx2,fma")

using namespace std;

typedef long long ll;
typedef long double ld;

#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define Sz(x) int((x).size())
#define all(x) (x).begin(), (x).end()

const ll inf = 1e18, N = 1e6 + 10, mod = 1e9 + 7, pr = 1000696969;

int a[N];
char c[N];
ll ps[N], aps[N];

int main() {
fast_io;

int n; cin >>n;

c[0] = '+'; cin >>a[0];
for(int i = 1; i < n; i++) {
cin >>c[i] >>a[i];
if(c[i] == '-') a[i] *= -1;
}

ps[0] = a[0];
for(int i = 1; i < n; i++) ps[i] = ps[i - 1] + a[i];

aps[0] = a[0];
for(int i = 1; i < n; i++) aps[i] = aps[i - 1] + abs(a[i]);

ll cnt = 0, ans = ps[n - 1];
for(int i = n - 1; i >= 0; i--) {
if(c[i] == '+') {
cnt += a[i];
continue;
}
ll val = aps[n - 1] - aps[i];
val -= 2 * cnt;

ans = max(ans, ps[i] + val);

cnt = 0;
}

cout<<ans;

return 0;
}




#include <bits/stdc++.h>
#define int long long
#define pai 3.141592653589793238462643383279502884197169399375105820
#define MOD 1000000007
#define eps 0.00000001
inline int min(int a,int b) {return a<b?a:b;}
inline int max(int a,int b) {return a>b?a:b;}
#define ULL unsigned long long
#define LL long long
#define INF 0x3f3f3f3f
#define INF_LL 0x3f3f3f3f3f3f3f3f
static char buf[1000000],*pa=buf,*pd=buf;
static char buf2[1000000],*pp=buf2;
#define getchar() pa==pd&&(pd=(pa=buf)+fread(buf,1,1000000,stdin),pa==pd)?EOF:*pa++
inline void pc(char ch){
if(pp-buf2==1000000) fwrite(buf2,1,1000000,stdout),pp=buf2;
*pp++=ch;
}
inline void pcc(){
fwrite(buf2,1,pp-buf2,stdout);
pp=buf2;
}
inline int read(void){
int w=1;
register int x(0);register char c(getchar());
while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
return w*x;
}
void write(int x){
static int sta[20];
int top=0;
do{
sta[top++]=x%10,x/=10;
}while(x);
while(top) pc(sta[--top]+48);
}
void we(int x){
write(x);
pc('\n');
}
inline bool cmp_xi(int a,int b) {return a<b;}
inline bool cmp_da(int a,int b) {return a>b;}
int add,f[1000009];
signed main(void) {
//freopen("m.in","r",stdin);
//freopen("m.out","w",stdout);
int N;scanf("%lld",&N);
f[N]=N;
f[N-1]=N*N%MOD;
for(int i=N-2;i>=1;i--) {
add+=f[i+3];add%=MOD;
f[i]=f[i+1]+(N-1)*(N-1)+add+i+1;
f[i]%=MOD;
}
printf("%lld",f[1]);
return 0;
}

#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
#define yn(joken) cout<<((joken) ? "Yes" : "No")<<endl
#define YN(joken) cout<<((joken) ? "YES" : "NO")<<endl
using namespace std;
using ll = long long;
using vi = vector<int>;
using vl = vector<ll>;
using vs = vector<string>;
using vc = vector<char>;
using vd = vector<double>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<ll>>;
const int INF = 1e9;
const ll LINF = 1e18;
template <class T>
bool chmax(T& a, const T& b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
is >> v[i];
}
return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
os << v[i];
if (i < int(v.size()) - 1) os << ' ';
}
return os;
}

int main(){
cin.tie(nullptr);
ios::sync_with_stdio(false);

string S;
cin>>S;
int N=sz(S);
int ans=0;
int g=0,p=0;
rep(i,N){
if(S[i]=='g'){
if(p<g){
ans++;
p++;
}
else g++;
}
else{
if(p<g) p++;
else{
ans--;
g++;
}
}
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e5+5;
int n,x,sz[N],fa[N],dep[N];
LL a[N],sum;
map<LL,int>rv;
signed main(){
scanf("%d",&n);
for(int i=1;i<=n;i++)
scanf("%lld",&a[i]),rv[a[i]]=i,sz[i]=1;
sort(a+1,a+1+n);
for(int i=n;i>1;i--){
x=rv[a[i]];
fa[x]=rv[a[i]+2*sz[x]-n],sz[fa[x]]+=sz[x];
if(!fa[x]||fa[fa[x]]) puts("-1"),exit(0);
}
for(int i=2;i<=n;i++)
x=rv[a[i]],dep[x]=dep[fa[x]]+1,sum+=dep[x];
if(sum!=a[1]) puts("-1"),exit(0);
for(int i=2;i<=n;i++)
x=rv[a[i]],printf("%d %d\n",x,fa[x]);
return 0;
}
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int main()
{
//int t;
//cin>>t;
//while(t--)
//{
int n;
map<int,int> seq;
cin>>n;
for(int i=0;i<n;i++)
{
int s;
cin>>s;
seq[s]++;
}
int c=0;
for(auto i=seq.begin();i!=seq.end();i++)
{
if((*i).first>(*i).second)
{
c+=(*i).second;
}
else if((*i).first<(*i).second)
{
c+=((*i).second-(*i).first);
}
}
cout<<c<<endl;
//seq.clear();
//}
return 0;
}



#include <cstdio>
#include <cstring>
#define Maxn 300
#define Maxk 10
#define Inf 0x3f3f3f3f
int f[Maxn+5][Maxn+5];
int d[Maxk+5][Maxk+5];
//f[i][j]表示从S到T的路径上有i个x和j个y时其余边的最小可能长度 
//d[x][y]=min{f[i][j]+i*x+j*y}
//f[i][j]=max{d[x][y]-i*x-j*y}
int mx(int a,int b){
return a>b?a:b;
}
int mn(int a,int b){
return a<b?a:b;
}
struct Edge{
int u,v,w;
}edge[Maxn*Maxn+5];
int n,m;
int main(){
scanf("%d%d",&n,&m);
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
scanf("%d",&d[i][j]);
}
}
for(int i=0;i<=100;i++){
for(int j=0;j<=100;j++){
for(int x=1;x<=n;x++){
for(int y=1;y<=m;y++){
f[i][j]=mx(f[i][j],d[x][y]-i*x-j*y);
}
}
}
}
int now;
for(int x=1;x<=n;x++){
for(int y=1;y<=m;y++){
now=Inf;
for(int i=0;i<=100;i++){
for(int j=0;j<=100;j++){
now=mn(now,f[i][j]+i*x+j*y);
}
}
if(now!=d[x][y]){
puts("Impossible");
return 0;
}
}
}
puts("Possible");
puts("202 10401");
for(int i=1;i<=100;i++){
printf("%d %d X\n",i,i+1);
}
for(int i=102;i<202;i++){
printf("%d %d Y\n",i,i+1);
}
for(int i=0;i<=100;i++){
for(int j=0;j<=100;j++){
printf("%d %d %d\n",i+1,202-j,f[i][j]);
}
}
puts("1 202");
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define forn(i,n) for(int i=0;i<int(n);i++)
typedef long long ll;
typedef pair<int, int> PII;
#define MAXN 100005
vector<ll> a[MAXN];//to store the edges
ll disf[MAXN],diss[MAXN];//store the distance of every vertice to the two
int main()
{
int n;
cin>>n;
for(int i=1;i<=n-1;i++)
{
int u,v;
cin>>u>>v;
a[u].pb(v);
a[v].pb(u);
}
memset(disf,-1,sizeof(disf));//init first array
memset(diss,-1,sizeof(diss));//init second array
queue<ll> q;//use queue to process bfs
q.push(1);
disf[1]=0;//init1
while(q.empty()==false)
{
int x=q.front();
q.pop();
for(int i=0;i<a[x].size();i++)
{
if(disf[a[x][i]]==-1)
{
disf[a[x][i]]=disf[x]+1;
q.push(a[x][i]);
}
}
}//first bfs from 1~n
q.push(n);
diss[n]=0;//init here!!
while(q.empty()==false)
{
int x=q.front();
q.pop();
for(int i=0;i<a[x].size();i++)
{
if(diss[a[x][i]]==-1)
{
diss[a[x][i]]=diss[x]+1;
q.push(a[x][i]);
}
}
}//second bfs from n~1
int f=0,s=0;
for(int i=1;i<=n;i++)
{
if(disf[i]<=diss[i])
{
f++;
}
else
{
s++;
}
}//compare
if(f>s)
{
cout<<"Fennec"<<endl;
}
else
{
cout<<"Snuke"<<endl;
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for (int i=x;i<y;i++)
#define per(i,x,y) for (int i=y-1;i>=x;i--)
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define sz(x) ((int)(x.size()))
#define all(x) (x).begin(), (x).end()
using ll = long long;
using ld = long double;
using db = double;
using pie = pair<int,int>;

int main() {
int n;
scanf("%d",&n);
vector<int> a(n);
rep(i,0,n) scanf("%d",&a[i]);
int div = 0, pdiv = 0;
rep(i,0,n) {
if(a[i]%4==0) div++;
else if(a[i]%2==0) pdiv++;
}
int good = 1,flag=0;
for(int i=1;i<n;i++) {
if(div) {
a[i] = 4;
div--;
i++;
} else {
if(pdiv >= 2) {
a[i]=2;
if(i!=n-1) a[i+1]=2;
pdiv-=2;
i++;
} else {
good = 0;
break;
}
}
}
printf("%s\n",good?"Yes":"No");

}


#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
#ifdef APURBA
#include "DEBUG_TEMPLATE.h"
#else
#define HERE
#define debug(args...)
#endif
const int N = 2e5 +5;
typedef pair<int,int> pii;


struct info{
string s;
int n;
vector<int>a;
vector<int>b;
void read()
{
cin>>s;
n = s.size();
a.resize(n);
b.resize(n);
for(int i=0;i<n;i++)
{
a[i] = (i>=0?a[i-1]:0) + (s[i]=='A'?1:0);
b[i] = (i>=0?b[i-1]:0) + (s[i]=='B'?1:0);
}
}
pii get(int l, int r)
{
int x = a[r] - (l-1>=0?a[l-1]:0);
int y = b[r] - (l-1>=0?b[l-1]:0);
return {x,y};
}
};

int32_t main()
{
#ifndef APURBA
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
#endif
info a,b;
a.read();
b.read();
int q;
cin>>q;
while(q--)
{
int l1,r1,l2,r2;
cin>>l1>>r1>>l2>>r2;
l1--;
r1--;
l2--;
r2--;
pii x = a.get(l1,r1);
pii y = b.get(l2,r2);
if( (x.first+x.second*2)%3 == (y.first+y.second*2)%3 || (x.first*2+x.second)%3 == (y.first*2+y.second)%3 )
{
cout<<"YES\n";
}
else{
cout<<"NO\n";
}
}
return 0;
}

#ifndef HIDDEN_IN_VISUAL_STUDIO // 折りたたみ用

// 警告の抑制
#define _CRT_SECURE_NO_WARNINGS

// ライブラリの読み込み
#include <bits/stdc++.h>
using namespace std;

// 型名の短縮
using ll = long long; // -2^63 ～ 2^63 = 9 * 10^18（int は -2^31 ～ 2^31 = 2 * 10^9）
using pii = pair<int, int>;	using pll = pair<ll, ll>;	using pil = pair<int, ll>;	using pli = pair<ll, int>;
using vi = vector<int>;		using vvi = vector<vi>;		using vvvi = vector<vvi>;
using vl = vector<ll>;		using vvl = vector<vl>;		using vvvl = vector<vvl>;
using vb = vector<bool>;	using vvb = vector<vb>;		using vvvb = vector<vvb>;
using vc = vector<char>;	using vvc = vector<vc>;		using vvvc = vector<vvc>;
using vd = vector<double>;	using vvd = vector<vd>;		using vvvd = vector<vvd>;
template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
using Graph = vvi;

// 定数の定義
const double PI = 3.14159265359;
const double DEG = PI / 180.; // θ [deg] = θ * DEG [rad]
const vi dx4 = { 1, 0, -1, 0 }; // 4 近傍（下，右，上，左）
const vi dy4 = { 0, 1, 0, -1 };
const vi dx8 = { 1, 1, 0, -1, -1, -1, 0, 1 }; // 8 近傍
const vi dy8 = { 0, 1, 1, 1, 0, -1, -1, -1 };
const int INF = 1001001001; const ll INFL = 2002002002002002002LL;
const double EPS = 1e-10; // 許容誤差に応じて調整

// 入出力高速化
struct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } fastIOtmp;

// 汎用マクロの定義
#define all(a) (a).begin(), (a).end()
#define sz(x) ((int)(x).size())
#define distance (int)distance
#define Yes(b) {cout << ((b) ? "Yes" : "No") << endl;}
#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 から n-1 まで昇順
#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s から t まで昇順
#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s から t まで降順
#define repe(v, a) for(const auto& v : (a)) // a の全要素（変更不可能）
#define repea(v, a) for(auto& v : (a)) // a の全要素（変更可能）
#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d ビット全探索（昇順）
#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a の順列全て（昇順）
#define repit(it, a) for(auto it = (a).begin(); it != (a).end(); ++it) // イテレータを回す（昇順）
#define repitr(it, a) for(auto it = (a).rbegin(); it != (a).rend(); ++it) // イテレータを回す（降順）
#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod
#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // 重複除去

// 汎用関数の定義
template <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }
template <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // 最大値を更新（更新されたら true を返す）
template <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // 最小値を更新（更新されたら true を返す）

// 演算子オーバーロード
template <class T, class U> inline istream& operator>> (istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template <class T, class U> inline ostream& operator<< (ostream& os, const pair<T, U>& p) { os << "(" << p.first << "," << p.second << ")"; return os; }
template <class T, class U, class V> inline istream& operator>> (istream& is, tuple<T, U, V>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t); return is; }
template <class T, class U, class V> inline ostream& operator<< (ostream& os, const tuple<T, U, V>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << ")"; return os; }
template <class T, class U, class V, class W> inline istream& operator>> (istream& is, tuple<T, U, V, W>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t); return is; }
template <class T, class U, class V, class W> inline ostream& operator<< (ostream& os, const tuple<T, U, V, W>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << "," << get<3>(t) << ")"; return os; }
template <class T> inline istream& operator>> (istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }
template <class T> inline ostream& operator<< (ostream& os, const vector<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const list<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T, greater<T>>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const unordered_set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const unordered_map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, stack<T> s) { while (!s.empty()) { os << s.top() << " "; s.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, queue<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, deque<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop_front(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue_rev<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline vector<T>& operator--(vector<T>& v) { rep(_i_, sz(v)) --v[_i_]; return v; }
template <class T> inline vector<T>& operator++(vector<T>& v) { rep(_i_, sz(v)) ++v[_i_]; return v; }

// 手元環境（Visual Studio）
#ifdef _MSC_VER
#define popcount (int)__popcnt // 全ビット中の 1 の個数
#define popcountll (int)__popcnt64
inline int lsb(unsigned int n) { unsigned long i; _BitScanForward(&i, n); return i; } // 最下位ビットの位置（0-indexed）
inline int lsbll(unsigned long long n) { unsigned long i; _BitScanForward64(&i, n); return i; }
inline int msb(unsigned int n) { unsigned long i; _BitScanReverse(&i, n); return i; } // 最上位ビットの位置（0-indexed）
inline int msbll(unsigned long long n) { unsigned long i; _BitScanReverse64(&i, n); return i; }
template <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
#define dump(x) cout << "\033[1;36m" << (x) << "\033[0m" << endl;
#define dumps(x) cout << "\033[1;36m" << (x) << "\033[0m ";
#define dumpel(a) { int _i_ = -1; cout << "\033[1;36m"; repe(x, a) {cout << ++_i_ << ": " << x << endl;} cout << "\033[0m"; }
#define input_from_file(f) ifstream isTMP(f); cin.rdbuf(isTMP.rdbuf());
#define output_to_file(f) ofstream osTMP(f); cout.rdbuf(osTMP.rdbuf());
// 提出用（gcc）
#else
#define popcount (int)__builtin_popcount
#define popcountll (int)__builtin_popcountll
#define lsb __builtin_ctz
#define lsbll __builtin_ctzll
#define msb(n) (31 - __builtin_clz(n))
#define msbll(n) (63 - __builtin_clzll(n))
#define gcd __gcd
#define dump(x)
#define dumps(x)
#define dumpel(v)
#define input_from_file(f)
#define output_to_file(f)
#endif

#endif // 折りたたみ用


//-----------------AtCoder 専用-----------------
#include <atcoder/all>
using namespace atcoder;

//using mint = modint1000000007;
using mint = modint998244353;
//using mint = modint; // mint::set_mod(m);

istream& operator>> (istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }
ostream& operator<< (ostream& os, const mint& x) { os << x.val(); return os; }
using vm = vector<mint>;	using vvm = vector<vm>;		using vvvm = vector<vvm>;

template <class S, S(*op)(S, S), S(*e)()>ostream& operator<<(ostream& os, segtree<S, op, e> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
template <class S, S(*op)(S, S), S(*e)(), class F, S(*mp)(F, S), F(*cp)(F, F), F(*id)()>ostream& operator<<(ostream& os, lazy_segtree<S, op, e, F, mp, cp, id> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
ostream& operator<<(ostream& os, dsu d) { repe(g, d.groups()) { repe(v, g) { os << v << " "; } os << endl; } return os; };
//----------------------------------------------


int main() {
//	input_from_file("input.txt");
//	output_to_file("output.txt");

int n, k;
cin >> n >> k;

vl x(n);
cin >> x;

ll res = INFL;

// a[l..r] の k 本のろうそくに火を付ける場合を考える．
repi(l, 0, n - k) {
int r = l + k - 1;

// 0 → x[l] → x[r] と移動する場合
chmin(res, abs(x[l] - 0) + abs(x[r] - x[l]));

// 0 → x[r] → x[l] と移動する場合
chmin(res, abs(x[r] - 0) + abs(x[l] - x[r]));
}

cout << res << endl;
}

// Check Overflow
#ifdef DEBUG_BUILD
#define _GLIBCXX_DEBUG
#endif

// include
#include <bits/stdc++.h>

// Debugger
#ifdef DEBUG_BUILD
#include "debugger.hpp"
#else
#define debug(...)
#define debugdo(...)
#define debugtab(...)
#endif

// for alias
#define range(i, A, B) for (ll i = (ll)(A); i < (ll)(B); i++)
#define rep(i, N) range(i, 0, N)
#define rrep(i, N) for (ll i = (ll)(N)-1; i >= 0; i--)

// type alias
using namespace std;
using ll = long long;
using ld = long double;
using pll = std::pair<ll, ll>;
template <class T>
using vec = std::vector<T>;
template <class T>
using vec2 = std::vector<vec<T>>;
template <class T>
using vec3 = std::vector<vec2<T>>;
template <class T>
using priority_greater_queue = priority_queue<T, vector<T>, greater<T>>;

// number alias
constexpr int MOD = 1000000007;
constexpr ll INFL = std::numeric_limits<ll>::max() / 4;
constexpr array<ll, 4> DX = {1, 0, -1, 0};
constexpr array<ll, 4> DY = {0, 1, 0, -1};

// new vector
template <class T>
vec2<T> newVec2(size_t A, size_t B, ll a = T()) { return vec2<T>(A, vec<T>(B, a)); }
template <class T>
vec3<T> newVec3(size_t A, size_t B, size_t C, ll a = T()) { return vec3<T>(A, vec2<T>(B, vec<T>(C, a))); }

// vector input
template <class T>
std::istream &operator>>(std::istream &is, std::vector<T> &data)
{
for (T &in : data)
{
is >> in;
}
return is;
}

// functions
template <class T>
bool chmax(T &a, const T b)
{
if (a < b)
{
a = b;
return true;
}
return false;
}
template <class T>
bool chmin(T &a, const T b)
{
if (a > b)
{
a = b;
return true;
}
return false;
}
template <class T>
T pow(T x, T n)
{
T ret = 1;
while (n > 0)
{
if (n & 1)
ret *= x;
x *= x;
n >>= 1;
}
return ret;
}
/*****/

void Main()
{
ll N;
cin >> N;
vec<ll> X(N);
cin >> X;
ll L;
cin >> L;

ll PSize = log2(N) + 1;
vec2<ll> P = newVec2<ll>(N, PSize, -1);

range(i, 1, N)
{
auto itr = lower_bound(X.begin(), X.end(), X[i] - L);
P[i][0] = itr - X.begin();
debug(i, X[i], X[i] - L, *itr);
}

debug(P);

for (ll now = 0; now < N; now++)
{
for (ll i = 1; i < PSize; i++)
{
if (P[now][i - 1] != -1)
P[now][i] = P[P[now][i - 1]][i - 1];
}
}

debug(P);

ll Q;
cin >> Q;
rep(i, Q)
{
ll a, b;
cin >> a >> b;
a--, b--;

if (a > b)
swap(a, b);

ll ret = 0;
for (ll i = PSize - 1; i >= 0; i--)
{
debug(i);
if (P[b][i] >= a)
{
debugtab(1, a, b);
b = P[b][i];
ret += 1 << i;
debugtab(1, a, b);
}
}

debug(a, b, ret);

if (a != b)
ret++;

cout << ret << endl;
}
}

/*****/

int main()
{
cin.tie(nullptr);
ios::sync_with_stdio(false);
std::cout << std::fixed << std::setprecision(10);
std::cerr << std::fixed << std::setprecision(10);
Main();
std::cout << std::flush;
std::cerr << "--end--" << std::flush;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define IOS std::ios::sync_with_stdio(false);
#define rep(i, j, k) for(int i = j; i <= k; i++)
#define INF 0x3f3f3f3f
#define debug(x, l, r) for(int ii = l; ii <= r; ii++) cout << x[ii] << " \n"[ii==n]; 
#define foi freopen("/in", "r", stdin), freopen("/out", "w", stdout)
typedef long long ll;
typedef unsigned long long ull;
const int N = 1e5+5;
const int mod = 1000000007;
int n;
struct Node{
int x, y, id;
}node[N];
bool cmpx(Node a, Node b){
return a.x < b.x;
}
bool cmpy(Node a, Node b){
return a.y < b.y;
}

struct Line{
int u, v, w;
bool operator < (const Line xx) const{
return w < xx.w;
}
}line[N<<3]; int tot = 0;

int fa[N];
int Find(int x){
if(fa[x] != x) return fa[x] = Find(fa[x]);
return x;
}
void merge(int u, int v){
u = Find(u);
v = Find(v);
fa[u] = v;
}

ll ans = 0;
void kruskal(){
rep(i, 1, n) fa[i] = i;
rep(i, 1, tot){
int u = line[i].u;
int v = line[i].v;
if(Find(u) != Find(v)){
ans += line[i].w;
merge(u, v);
}
}
}

void solve(){
cin >> n;
rep(i, 1, n) cin >> node[i].x >> node[i].y, node[i].id = i;
sort(node+1, node+1+n, cmpx);
rep(i, 2, n){
int dif = abs(node[i].x - node[i-1].x);
int u = node[i].id, v = node[i-1].id;
line[++tot] = {u, v, dif};
line[++tot] = {v, u, dif};
}
sort(node+1, node+1+n, cmpy);
rep(i, 2, n){
int dif = abs(node[i].y - node[i-1].y);
int u = node[i].id, v = node[i-1].id;
line[++tot] = {u, v, dif};
line[++tot] = {v, u, dif};
}
sort(line+1, line+1+tot);
kruskal();
cout << ans << "\n";
}
int main(){
// foi;
IOS;
solve();
return 0;
}
#include<cstdio>
typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3fll;
const int MX=200005;
int n,m,x,y;
ll ad,f[MX],ans;
ll f1[MX],f2[MX];
inline ll min(ll a,ll b){return a<b?a:b;}
inline ll abs(ll a){return a<0?-a:a;}
inline void add1(int x,ll k){for(;x<=n&&k<f1[x];x+=x&-x) f1[x]=k;}
inline ll que1(int x){
ll k=inf;
while(x) k=min(k,f1[x]),x-=x&-x;
return k;
}
inline void add2(int x,ll k){
while(x&&k<f2[x]) f2[x]=k,x-=x&-x;
}
inline ll que2(int x){
ll k=inf;
for(;x<=n;x+=x&-x) k=min(k,f2[x]);
return k;
}
inline void wk(){
y=x;
scanf("%d",&x);
ll v=min(que1(x)+x,que2(x)-x)+ad;
ad+=abs(x-y);
if(v-ad<f[y]){
f[y]=v-ad;
add1(y,f[y]-y);
add2(y,f[y]+y);
}
}
int main(){
int i;
scanf("%d%d%d%d",&n,&m,&x,&y);
for(i=1;i<=n;i++) f[i]=f1[i]=f2[i]=inf;
add1(y,-y),add2(y,y);
for(f[y]=0;m--;) wk();
for(ans=inf,i=1;i<=n;i++) ans=min(ans,f[i]);
printf("%lld\n",ans+ad);
return 0;
}
#include <string>
#include <algorithm>
#include <bits/stdc++.h>
#define ll long long
#define str string
#define fi first
#define se second
#define FOR(i,a,n) for(int i = a; i <= n; i++)
#define par pair<int, int>
const int p = 1e5+25;
ll mod = 1e9+7;
using namespace std;

ll N, M;

ll solve(ll n){
if(n == 0)
return 1;
else if (n == 1)
return 1;
else if (n == 2)
return 2;
else 
return(solve(n-1) * n)%mod;
}

int main(){
cin >> N >> M;
if(abs(N - M) > 1)
cout << 0 << endl;
else if (N != M)
cout << (solve(N) * solve(M)) % mod << endl;
else 
cout << (2*solve(M) * solve(N)) % mod << endl;
}
#include <bits/stdc++.h>

#define For(i, a, b) for (int i = a; i <= b; ++i)
#define rFor(i, b, a) for (int i = b; i >= a; --i)
#define eFor(i, u, v) for (int i = head[u], v = e[i].to; i; i = e[i].next, v = e[i].to)

typedef long long ll;

using std::cin;
using std::cout;
using std::endl;

typedef std::pair<int, int> pii;
#define fi first
#define se second

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename T> T myrand(T l, T r) {
return std::uniform_int_distribution<T>(l, r)(rnd);
}

void close_stdio() {
std::ios::sync_with_stdio(false);
std::cerr << "DO NOT use scanf/printf!\n";
}

const int kN = 5e5 + 5;

int n, bd[kN];
bool pre[kN], suf[kN];
char s[kN];

int main() {
scanf("%s", s + 1);
n = strlen(s + 1);
bool flag = false;
For(i, 2, n) if (s[i] != s[i - 1]) {
flag = true;
break;
}
if (!flag) {
printf("%d\n%d", n, 1);
return 0;
}
bd[1] = 0;
for (int i = 2, j = 0; i <= n; ++i) {
while (j && s[j + 1] != s[i]) j = bd[j];
if (s[j + 1] == s[i]) ++j;
bd[i] = j;
}
For(i, 1, n) pre[i] = bd[i] && (i % (i - bd[i]) == 0);
if (!pre[n]) {
printf("1\n1");
return 0;
}
bd[n] = 0;
for (int i = n - 1, j = 0; i; --i) {
while (j && s[n - j] != s[i]) j = bd[n - j + 1];
if (s[n - j] == s[i]) ++j;
bd[i] = j;
}
For(i, 1, n) suf[i] = bd[i] && ((n - i + 1) % (n - i + 1 - bd[i]) == 0);
int cnt = 0;
For(i, 1, n - 1) if (!pre[i] && !suf[i + 1]) ++cnt;
printf("2\n%d", cnt);
return 0;
}
/* PAY ATTENTION TO: */
/* 1. Memory Limit, Array Size */
/* 2. Integer Overflow */
/* 3. Multi-test */
/* 4. Potential Constant-speedup */
/* Stay organized and write things down. */

#include<bits/stdc++.h>
using namespace std;
#define N 5005
const int mod=1e9+7;
typedef long long ll;
int n,dp[N][N],w[N],siz[N];
vector<int> G[N];
void dfs(int u,int fa){
dp[u][1]=1;
siz[u]=1;
for(auto v:G[u]){
if(v==fa)continue;
dfs(v,u);
static int g[N];
memset(g,0,sizeof(g));
#define update(x,y) x=(x+y)%mod
for(int i=0;i<=siz[u];++i){
for(int j=0;j<=siz[v];++j){
update(g[i+j],1LL*dp[u][i]*dp[v][j]);
}
}
memcpy(dp[u],g,sizeof(dp[u]));
siz[u]+=siz[v];
}
for(int i=2;i<=siz[u];i+=2){
dp[u][0]=(dp[u][0]+1LL*(mod-w[i])*dp[u][i])%mod;
}
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n;
for(int i=1;i<n;++i){
int u,v;
cin>>u>>v;
G[u].push_back(v);
G[v].push_back(u);
}
w[0]=1;
for(int i=2;i<=n;i+=2){
w[i]=1LL*w[i-2]*(i-1)%mod;
}
dfs(1,0);
cout<<(mod-dp[1][0])%mod<<'\n';
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int cnt[3];

int main() {
qread(n);
rep(i, 1, n) {
int x; qread(x);
int cn = 0;
while(x % 2 == 0 && cn < 2) {
x >>= 1;
++cn;
}
++cnt[cn];
}
int nw = cnt[0] + (cnt[1] != 0);
if(cnt[2] >= nw - 1) puts("Yes");
else puts("No"); 
return 0;
}
// Exported by Exporter.exe

// Included from C.cpp
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define F first
#define S second
#define MP make_pair
#define MTP make_tuple
#define R Read
#define RD Read_Digit
#define RP Read_P
#define RS Read_String
#define RL Read_Loop
#define RLD Read_Loop_Digit
#define RLP Read_Loop_P
#define RLS Read_Loop_String
#ifdef ONLINE_JUDGE
#define Debug(...) ;
#define Debug_Array(n,x) ;
#define Debugln_Array(n,x) ;
#define NL ;
#else
#define Debug(...) {printf("(%s) = ",(#__VA_ARGS__)),_print(__VA_ARGS__),printf("\n");}
#define Debug_Array(n,x) {printf("%s :",(#x));for(int i=1;i<=n;i++)printf(" "),_print(x[i]);printf("\n");}
#define Debugln_Array(n,x) {for(int i=1;i<=n;i++){printf("%s",(#x));printf("[%d] = ", i);_print(x[i]);printf("\n");}}
#define NL {printf("\n");}
#endif
typedef long long int ll;
typedef unsigned long long int ull;

constexpr int kN = int(2E5 + 10);
// constexpr int kMod = 998244353;
// constexpr int kMod = int(1E9 + 7);
// constexpr int kInf = 0x3f3f3f3f;
// constexpr ll kInf = 0x3f3f3f3f3f3f3f3f;
// constexpr double kPi = acos(-1);
// constexpr double kEps = 1E-9;
// constexpr int dx[4] = {0, 0, 1, -1};
// constexpr int dy[4] = {1, -1, 0, 0};
// constexpr int dx[8] = {0, 0, 1, -1, 1, -1, 1, -1};
// constexpr int dy[8] = {1, -1, 1, -1, -1, 1, 0, 0};


// Included from C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp
bool Fast_IO_activated = false;
bool IOS_activated = false;
// --- Get ---
static inline char Get_Raw_Char() {
static bool pre = Fast_IO_activated = true;
static char buf[1 << 16], *p = buf, *end = buf;
if (p == end) {
if ((end = buf + fread(buf, 1, 1 << 16, stdin)) == buf) return '\0';
p = buf;
}
return *p++;
}

// --- Read ---
template <typename T> static inline void Read_P(T &n) {
static_assert(is_integral<T>::value, "Read_P requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
return ;
}

template <typename T> static inline void Read(T &n) {
static_assert(is_integral<T>::value, "Read requires an integral type");
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
if (neg) n = -n;
return ;
}

template <typename T> static inline void Read_Digit(T &n) {
static_assert(is_integral<T>::value, "Read_Digit requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
return ;
}

static inline void Read_String(string &s) {
s.clear();
char c = Get_Raw_Char();
while (c == ' ' or c == '\n') c = Get_Raw_Char();
while (c != ' ' and c != '\n') {
s += c;
c = Get_Raw_Char();
}
return ;
}

// --- Read multiple ---
template <typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read(n); return Read(Fargs...);}
template <typename T, typename... Targs> static inline void Read_Digit(T &n, Targs&... Fargs) {Read_Digit(n); return Read_Digit(Fargs...);}
template <typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P(n); return Read_P(Fargs...);}
template <typename... Targs> static inline void Read_String(string &s, Targs&... Fargs) {Read_String(s); return Read_String(Fargs...);}

// --- Read Loop ---
template <typename T> static inline void Read_Loop_i(int i, T *a) {return Read(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_i(int i, T *a, Targs*... Fargs) {Read(a[i]); return Read_Loop_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_Digit_i(int i, T *a) {return Read_Digit(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_Digit_i(int i, T *a, Targs*... Fargs) {Read_Digit(a[i]); return Read_Loop_Digit_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_Digit(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_Digit_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_P_i(int i, T *a) {return Read_P(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_P_i(int i, T *a, Targs*... Fargs) {Read_P(a[i]); return Read_Loop_P_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_P(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_P_i(i, Fargs...);}

static inline void Read_Loop_String_i(int i, string *a) {return Read_String(a[i]);}
template <typename... Targs> static inline void Read_Loop_String_i(int i, string *a, Targs*... Fargs) {Read_String(a[i]); return Read_Loop_String_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_String(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_String_i(i, Fargs...);}

// --- Float ---
template <int mul, typename T> static inline void Read(T &n) {
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;

if (neg) n = -n;
return ;
}

template <int mul, typename T> static inline void Read_P(T &n) {
char c;
while (!isdigit(c = Get_Raw_Char())) ;

n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;
return ;
}

template <int mul, typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read<mul>(n); return Read<mul>(Fargs...);}
template <int mul, typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P<mul>(n); return Read_P<mul>(Fargs...);}

// --- init ---
inline void IOS() {
IOS_activated = true;
ios::sync_with_stdio(false); cin.tie(0);
}
inline void Freopen(const char *in, const char *out) {freopen(in, "r", stdin); freopen(out, "w", stdout); return ;}

// --- Output ---
#if defined(__SIZEOF_INT128__)
void Print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
} 
#endif
// End of C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp
template <typename T, typename T1> void make_vector_inner(vector<T>& vec, T1 c) {return vec.push_back(T(c));}
template <typename T, typename T1, typename... Targs> void make_vector_inner(vector<T> &vec, T1 c, Targs... targs) {
vec.push_back(T(c));
return make_vector_inner(vec, targs...);
}
template <typename T, typename... Targs> vector<T> make_vector(Targs... targs) {
vector<T> vec;
make_vector_inner(vec, targs...);
return vec;
}

template <typename T> inline void sort(vector<T> &v) {return sort(v.begin(), v.end());}
template <typename T> inline void sort_r(vector<T> &v) {return sort(v.begin(), v.end(), greater<T>());}
inline void sort(string &s) {return sort(s.begin(), s.end());}
inline void sort_r(string &s) {return sort(s.begin(), s.end(), greater<char>());}

template <typename T> inline void reverse(vector<T> &v) {return reverse(v.begin(), v.end());}
inline void reverse(string &s) {return reverse(s.begin(), s.end());}

template <typename T> inline void Merge(vector<T> &a, vector<T> &b, vector<T> &c) {
if (c.size() < a.size() + b.size()) c.resize(a.size() + b.size());
merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());
return ;
}
template <typename T> inline void Concatanate(vector<T> &a, vector<T> &b, vector<T> &c) {
int a_size = int(a.size()), b_size = int(b.size());
c.resize(a_size + b_size);
for (int i = 0; i < a_size; i++) c[i] = a[i];
for (int i = 0; i < b_size; i++) c[i + a_size] = b[i];
return ;
}
template <typename T> inline void Append(vector<T> &lhs, vector<T> rhs) {
int lsz = int(lhs.size()), rsz = int(rhs.size());
lhs.reserve(lsz + rsz);
for (int i = 0; i < rsz; i++) lhs.push_back(rhs[i]);
return ;
}

template <typename T> inline void Erase(vector<T> &vec, T x) {
int sz = int(vec.size());
for (int i = 0; i < sz; i++) if (vec[i] == x) {
swap(vec[i], vec.back());
vec.pop_back();
break;
}
return ;
}

template <typename T> inline void Discrete(vector<T> &v) {sort(v); v.resize(unique(v.begin(), v.end()) - v.begin()); return ;}
template <typename T> inline int Discrete_Id(vector<T> &v, T x) {return lower_bound(v.begin(), v.end(), x) - v.begin();}

template <typename T> using PQ = priority_queue<T>;
template <typename T> using PQ_R = priority_queue<T, vector<T>, greater<T>>;

template <typename T> inline T ABS(T n) {return n >= 0 ? n : -n;}
template <typename T> __attribute__((target("bmi"))) inline T gcd(T a, T b) {
if (a < 0) a = -a;
if (b < 0) b = -b;
if (a == 0 || b == 0) return a + b;
int n = __builtin_ctzll(a);
int m = __builtin_ctzll(b);
a >>= n;
b >>= m;
while (a != b) {
int m = __builtin_ctzll(a - b);
bool f = a > b;
T c = f ? a : b;
b = f ? b : a;
a = (c - b) >> m;
}
return a << min(n, m);
}
template <typename T> inline T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <typename T, typename... Targs> inline T gcd(T a, T b, T c, Targs... args) {return gcd(a, gcd(b, c, args...));}
template <typename T, typename... Targs> inline T lcm(T a, T b, T c, Targs... args) {return lcm(a, lcm(b, c, args...));}
template <typename T, typename... Targs> inline T min(T a, T b, T c, Targs... args) {return min(a, min(b, c, args...));}
template <typename T, typename... Targs> inline T max(T a, T b, T c, Targs... args) {return max(a, max(b, c, args...));}
template <typename T, typename... Targs> inline void chmin(T &a, T b, Targs... args) {a = min(a, b, args...); return ;}
template <typename T, typename... Targs> inline void chmax(T &a, T b, Targs... args) {a = max(a, b, args...); return ;}

vector<int> Primes(int n) {
if (n == 1) return {};
// 2 ~ n
vector<int> primes;
vector<bool> isPrime(n + 1, true);

primes.reserve(n / __lg(n));

for (int i = 2; i <= n; i++) {
if (isPrime[i]) primes.push_back(i);
for (int j : primes) {
if (i * j > n) break;
isPrime[i * j] = false;
if (i % j == 0) break;
}
}
return primes;
}

template <typename T> vector<T> factors(T x) {
// maybe use factorize would be faster?
vector<T> ans;
for (T i = 1; i * i <= x; i++) if (x % i == 0) ans.push_back(i);

int id = int(ans.size()) - 1;
if (ans[id] * ans[id] == x) id--;
for (int i = id; i >= 0; i--) ans.push_back(x / ans[i]);

return ans;
}

int mex(vector<int> vec) {
int n = int(vec.size());
vector<bool> have(n, false);
for (int i : vec) if (i < n) have[i] = true;
for (int i = 0; i < n; i++) if (!have[i]) return i;
return n;
}

template <typename T> T SQ(T x) {return x * x;}

// Euclidean distance
template <typename T> T Dist2(pair<T, T> lhs, pair<T, T> rhs) {return SQ(lhs.F - rhs.F) + SQ(lhs.S - rhs.S);}
template <typename T> T Dist2(T x1, T y1, T x2, T y2) {return SQ(x1 - x2) + SQ(y1 - y2);}

// Manhattan distance
template <typename T> T Mdist(pair<T, T> lhs, pair<T, T> rhs) {return ABS(lhs.first - rhs.first) + ABS(lhs.second - rhs.second);}
template <typename T> T Mdist(T x1, T y1, T x2, T y2) {return ABS(x1 - x2) + ABS(y1 - y2);}

template <typename T> bool Adj(pair<T, T> lhs, pair<T, T> rhs) {return Mdist(lhs, rhs) == 1;}

template <typename T> T LUBound(T LB, T val, T UB) {return min(max(LB, val), UB);}

template <typename T, typename Comp> T Binary_Search(T L, T R, Comp f) {
// L good R bad
static_assert(is_integral<T>::value, "Binary_Search requires an integral type");
while (R - L > 1) {
T mid = (L + R) >> 1;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename Comp> double Binary_Search(double L, double R, Comp f, int loop = 30) {
for (int i = 1; i <= loop; i++) {
double mid = (L + R) / 2;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename T> T nearest_dist(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin() - val;
else if (val >= *prev(se.end())) return val - *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);
return min(*u - val, val - *v);
}
}

template <typename T> T nearest_elem(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin();
else if (val >= *prev(se.end())) return *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);

if (*u - val > val - *v) return *v;
else return *u;
}
}

namespace MR32 {
using ull = unsigned long long int;
using uint = unsigned int;
ull PowMod(ull a, ull b, ull kMod) {
ull ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(uint x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 3, a[3] = {2, 7, 61};
if (x < 8) return low[x];

uint t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
ull tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}

#ifdef __SIZEOF_INT128__
namespace MR64 {
using uint128 = unsigned __int128;
using ull = unsigned long long int;
using uint = unsigned int;
uint128 PowMod(uint128 a, uint128 b, uint128 kMod) {
uint128 ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(ull x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 7, a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
if (x < 8) return low[x];
ull t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
uint128 tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}
#endif

bool IsPrime(unsigned long long int x) {
#ifdef __SIZEOF_INT128__
if ((x >> 32) == 0) return MR32::IsPrime(x);
else return MR64::IsPrime(x);
#endif
return MR32::IsPrime(x);
}

#ifdef __SIZEOF_INT128__
uint64_t PollardRho(uint64_t x) {
static mt19937 rng;
if (!(x & 1)) return 2;
if (IsPrime(x)) return x;
int64_t a = rng() % (x - 2) + 2, b = a;
uint64_t c = rng() % (x - 1) + 1, d = 1;
while (d == 1) {
a = (__int128(a) * a + c) % x;
b = (__int128(b) * b + c) % x;
b = (__int128(b) * b + c) % x;
d = gcd(uint64_t(abs(a - b)), x);
if (d == x) return PollardRho(x);
}
return d;
}

template <typename T> vector<T> factorize(T x) {
if (x <= 1) return vector<T>();
T p = PollardRho(x);
if (p == x) return vector<T>(1, x);
vector<T> ans, lhs = factorize(p), rhs = factorize(x / p);
Merge(lhs, rhs, ans);
return ans;
}
#endif

// vec must be sorted
template <typename T> vector<pair<T, int>> Compress(vector<T> vec) {
if (vec.empty()) return {};

vector<pair<T, int>> ans;
int cnt = 1, sz = int(vec.size());
T lst = vec[0];
for (int i = 1; i < sz; i++) {
if (lst != vec[i]) {
ans.push_back(make_pair(lst, cnt));
lst = vec[i];
cnt = 1;
}
else cnt++;
}
ans.push_back(make_pair(lst, cnt));
return ans;
}

template <typename T> int Divisors(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

int ans = 1;
for (pair<T, int> i : fac) ans *= i.second + 1;

return ans;
}

template <typename T> T phi(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

T ans = 1;
for (pair<T, int> i : fac) {
ans *= i.first - 1;
for (int j = 1; j < i.second; j++) ans *= i.first;
}

return ans;
}
// End of C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp
template <typename T> void _print(vector<T> v) ;
void _print(bool x) {printf("%s", x ? "True" : "False");}
void _print(char x) {printf("%c", x);}
void _print(short x) {printf("%hd", x);}
void _print(unsigned short x) {printf("%hu", x);}
void _print(int x) {printf("%d", x);}
void _print(unsigned int x) {printf("%u", x);}
void _print(long int x) {printf("%ld", x);}
void _print(unsigned long int x) {printf("%lu", x);}
void _print(long long int x) {printf("%lld", x);}
void _print(unsigned long long int x) {printf("%llu", x);}
void _print(float x) {printf("%f", x);}
void _print(double x) {printf("%lf", x);}
void _print(long double x) {printf("%Lf", x);}
void _print(const char* c) {int n = strlen(c); for (int i = 0; i < n; i++) printf("%c", c[i]);}
void _print(string s) {for (char c : s) printf("%c", c);}
template <size_t _size> void _print(bitset<_size> bs) {for (int i = 0; i < _size; i++) printf("%d", bs[i] ? 1 : 0);}
#ifdef __SIZEOF_INT128__
void _print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
void _print(unsigned __int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
#endif
template <typename T1, typename T2> void _print(pair<T1, T2> x) {printf("("); _print(x.first); printf(", "); _print(x.second); printf(")");}
template <typename T1, typename T2, typename T3> void _print(tuple<T1, T2, T3> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(")");}
template <typename T1, typename T2, typename T3, typename T4> void _print(tuple<T1, T2, T3, T4> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(", "); _print(get<3>(x)); printf(")");}
template <typename T> void _print(vector<T> v) {
if (v.empty()) printf(" empty");
else {
bool first = true;
for (T i : v) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(set<T> s) {
if (s.empty()) printf(" empty");
else {
bool first = true;
for (T i : s) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(stack<T> s) {
if (s.empty()) printf(" empty");
else {
_print(s.top()); s.pop();
while (!s.empty()) {printf(", "); _print(s.top()); s.pop();}
}
}
template <typename T> void _print(queue<T> q) {
if (q.empty()) printf(" empty");
else {
_print(q.front()); q.pop();
while (!q.empty()) {printf(", "); _print(q.front()); q.pop();}
}
}
template <typename T> void _print(deque<T> dq) {
if (dq.empty()) printf(" empty");
else {
_print(dq.front()); dq.pop_front();
while (!dq.empty()) {printf(", "); _print(dq.front()); dq.pop_front();}
}
}
template <typename T1, typename T2, typename T3> void _print(priority_queue<T1, T2, T3> pq) {
if (pq.empty()) printf(" empty");
else {
_print(pq.top()); pq.pop();
while (!pq.empty()) {printf(", "); _print(pq.top()); pq.pop();}
}
}
template <typename T1, typename T2> void _print(map<T1, T2> m) {
if (m.empty()) printf(" empty");
else {
bool first = true;
for (pair<T1, T2> i : m) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}

template <typename T> void _print(T& x) {return x.out();}
template <typename T, typename... Targs> void _print(T x, Targs... Fargs) {_print(x); printf(", "); _print(Fargs...);}
// End of C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp

int a[kN];
ll s[kN];

int main() {
int n; RP(n);
RL(n, a);

for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];

ll ans = ABS((s[n] - s[1]) - s[1]);
for (int i = 1; i < n; i++) chmin(ans, ABS(s[n] - s[i] - s[i]));

printf("%lld\n", ans);

}
// End of C.cpp

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=2005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m,a[49][49];
vector<array<int,3>> vec;
set<pii> st;

void orzck(){
cin >> n >> m;
rep(n) rep1(j,m) cin >> a[i][j];
rep(n) rep1(j,m-1) if(a[i][j]>a[i][j+1]){print("Impossible");return;}
rep(n-1) rep1(j,m) if(a[i][j]>a[i+1][j]){print("Impossible");return;}
rep(n) rep1(j,m){
int xl=0,xr=inf,yl=0,yr=inf;
if(i<n-1) chkmax(xl,a[i+1][j]-a[i][j]);
if(j<m-1) chkmax(yl,a[i][j+1]-a[i][j]);
if(i) chkmin(xr,a[i][j]-a[i-1][j]);
else chkmin(xr,a[i][j]);
if(j) chkmin(yr,a[i][j]-a[i][j-1]);
else chkmin(yr,a[i][j]);
bool flag=0;
rep2(x,xl,xr+1){
rep2(y,yl,yr+1){
int d=a[i][j]-x*(i+1)-y*(j+1);
if(d<0) continue;
bool ok=1;
rep1(ii,n) rep1(jj,m) if(x*(ii+1)+y*(jj+1)+d<a[ii][jj]) ok=0;
if(ok){
if(!st.count({x,y})){
vec.pb({x,y,d});
st.insert({x,y});
}
flag=1;
break;
}
}
if(flag) break;
}
if(!flag){print("Impossible");return;}
}
print("Possible");
print(300,200+sz(vec));
rep(100) print(i+1,i+2,'X');
rep(100) print(i+150,i+151,'Y');
for(auto& arr: vec) print(arr[0]+1,250-arr[1],arr[2]);
print(1,250);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>

using namespace std;

int main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int n;
cin>>n;
map<int,int> m;
for(int i=0;i<n;i++)
{
int x;
cin>>x;
m[x]++;
}
int s=0;
for(auto it=m.begin();it!=m.end();it++)
{
if((*it).second>(*it).first)
s=s+((*it).second-(*it).first);
else if((*it).second<(*it).first)
s=s+((*it).second);

}
cout<<s<<endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
typedef long double D;

const int maxn = 3e5 + 5;
const LL INF = 1e18;
int N; LL T[maxn], pT[maxn], f[maxn], g[maxn], h[maxn];

inline D slope(LL x1, LL y1, LL x2, LL y2) {
return 1.0 * (y2 - y1) / (x2 - x1);
}
inline LL fx(LL x) { return x; }
inline LL fy(LL x) { return f[x] + pT[x] + x * (x + 1) / 2; }
inline D fslope(LL a, LL b) { return slope(fx(a), fy(a), fx(b), fy(b)); }

inline LL gx(LL x) { return x; }
inline LL gy(LL x) { return g[x] + pT[x] + x * (x + 1) / 2; }
inline D gslope(LL a, LL b) { return slope(gx(a), gy(a), gx(b), gy(b)); }

int q[maxn], ql, qr;
void calc_f(LL* f, D (*fslope)(LL, LL)) {
q[ql = qr = 1] = pT[0] = 0;
for (int i = 1; i <= N + 1; i++) {
pT[i] = pT[i - 1] + T[i];
while (ql < qr && fslope(q[qr - 1], q[qr]) <= i) qr--;
f[i] = f[q[qr]] - (pT[i - 1] - pT[q[qr]]) + 1ll * (i - q[qr]) * (i - q[qr] - 1) / 2;
f[i] = max(f[i], f[i - 1]);
while (ql < qr && fslope(q[qr - 1], q[qr]) <= fslope(q[qr], i)) qr--;
q[++qr] = i;
}
}
void calc_g() {
reverse(T + 1, T + 1 + N);
calc_f(g, gslope);
reverse(g + 1, g + 1 + N), reverse(T + 1, T + 1 + N);
swap(g[0], g[N + 1]);
}

LL t[maxn];
inline LL hy_p(int x) { return f[x] + pT[x] + (x * x - x) / 2; }
inline D hslope_p(int x, int y) { return 1.0 * (hy_p(x) - hy_p(y)) / (x - y); }
inline LL hy_s(int x) { return g[x] + pT[x] + (x * x - x) / 2; }
inline D hslope_s(int x, int y) { return 1.0 * (hy_s(x) - hy_s(y)) / (x - y); }
void calc_h(int l, int r) {
if (l == r) {
h[l] = max(h[l], f[l - 1] + g[l + 1] - T[l] + 1);
return ;
}
int mid = (l + r) >> 1;
calc_h(l, mid), calc_h(mid + 1, r);
pT[l - 1] = pT[r + 1] = qr = 0;
for (int i = l; i <= r; i++) q[i - l + 1] = 0, t[i] = -INF, pT[i] = pT[i - 1] + T[i];
for (int i = l - 1; i <= mid; i++) {
while (qr > 1 && fslope(q[qr - 1], q[qr]) <= fslope(i, q[qr])) qr--;
q[++qr] = i;
}
LL mx = -INF;
for (int i = mid + 1; i <= r; i++) {
while (qr > 1 && hslope_p(q[qr - 1], q[qr]) <= i) qr--;
t[i] = f[q[qr]] - (pT[i] - pT[q[qr]]) + 1ll * (i - q[qr]) * (i - q[qr] + 1) / 2 + g[i + 1];
}
for (int i = r; i > mid; i--)
mx = max(mx, t[i]), h[i] = max(mx, h[i]);
qr = 0;
for (int i = r; i >= l; i--) q[i - l + 1] = 0, t[i] = -INF, pT[i] = pT[i + 1] + T[i];
for (int i = r + 1; i > mid; i--) {
while (qr > 1 && gslope(q[qr - 1], q[qr]) >= gslope(i, q[qr])) qr--;
q[++qr] = i;
}
for (int i = mid; i >= l; i--) {
while (qr > 1 && hslope_s(q[qr - 1], q[qr]) >= i) qr--;
t[i] = g[q[qr]] - (pT[i] - pT[q[qr]]) + 1ll * (q[qr] - i) * (q[qr] - i + 1) / 2 + f[i - 1];
}
mx = -INF;
for (int i = l; i <= mid; i++)
mx = max(mx, t[i]), h[i] = max(h[i], mx);
}


int main() {
// freopen("test.in", "r", stdin);
// freopen("test.out", "w", stdout);
scanf("%d", &N);
for (int i = 1; i <= N; i++) scanf("%lld", &T[i]), h[i] = -INF;
calc_f(f, fslope), calc_g(), calc_h(1, N);
int m; scanf("%d", &m);
while (m--) {
int x; LL y; scanf("%d%lld", &x, &y);
printf("%lld\n", max(f[x] + g[x], h[x] + T[x] - y));
}
return 0;
}
#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _6(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _5(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_6(get()))next();return next();}char*next_token(char*s){while(_6(get()))next();while(!_6(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_6(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}template<class _8>_8 next_integer(){_8 sign=_5();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}int next_int(){return next_integer<int>();}long long next_long(){return next_integer<long long>();}double next_double(){int sign=_5();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <algorithm>
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

constexpr int N = 100005;

std::pair<long long, int> dt[N];
std::pair<int, int>       edge[N];
std::vector<int>          e[N];

long long dis[N];
int       n, size[N], tot;

void dfs(int u, int fa)
{
for (int v : e[u])
if (v != fa)
{
dis[v] = dis[u] + 1;
dfs(v, u);
}
}

int main()
{
n = sc.next_int();

for (int i = 1; i <= n; i++)
{
long long d = sc.next_long();
dt[i]       = {d, i};
size[i]     = 1;
}

std::sort(dt + 1, dt + n + 1);
std::reverse(dt + 1, dt + n + 1);

for (int i = 1; i < n; i++)
{
long long delta = dt[i].first - n + 2 * size[i];
int       l = 1, r = n + 1, pos = 0;
while (l <= r)
{
int mid = (l + r) >> 1;
if (dt[mid].first <= delta)
{
r   = mid - 1;
pos = mid;
}
else
l = mid + 1;
}
if (dt[pos].first != delta)
{
puts("-1");
return 0;
}

int u = dt[i].second;
int v = dt[pos].second;
e[u].push_back(v);
e[v].push_back(u);
edge[++tot] = {u, v};
size[pos] += size[i];
}

dfs(dt[n].second, 0);
long long sum = 0;
for (int i = 1; i <= n; i++)
sum += dis[i];
if (sum == dt[n].first)
for (int i = 1; i <= tot; i++)
std::cout << edge[i].first << " " << edge[i].second << std::endl;
else
puts("-1");

return 0;
}

// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
string s; cin>>s;
int rock = 0, ans = 0;
for(int i=0; i<sz(s); i++){
if(s[i] == 'g' && rock){
--rock; ans++;
}
else if(s[i] == 'g'){
++rock;
}
else if(s[i] == 'p' && rock){
--rock; 
}
else {
rock++; ans--;
}
}
cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int a[N];
int cnt[N];

int main() {
qread(n);
rep(i, 1, n) {
int x; qread(x);
if(x) ++cnt[x - 1];
++cnt[x], ++cnt[x + 1];
}
cout << *max_element(cnt, cnt + (int)(1e5) + 1) << endl;
return 0;
}
#include <stdio.h>
#define Maxm 1000005

int min(int a, int b) { return a < b ? a : b; }
int d[Maxm];

int main() {
int n, m, x, y; scanf("%d%d", &n, &m);

for(int i = 1; i <= n; ++ i) {
scanf("%d%d", &x, &y); x --;

for(int l = 1, r; l <= x; l = r + 1) {
r = min(x / (x / l), y / (y / l));
if((x / l) < (y / l)) d[l] ++, d[r + 1] --; 
}

d[x + 1] ++, d[y + 1] --;
}

for(int i = 1, p = 0, ans = 0; i <= m; ++ i) {
ans += d[i];
printf("%d\n", ans);    
}

}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
int main(){
ll n,k;
cin >> n >> k;
for (int i = 0; i < n; i++)
{
ll a;
cin >> a;
}
if ((n-1)%(k-1)==0)
{
cout << (n-1)/(k-1) << endl;
}else{
cout << (n-1)/(k-1)+1 << endl;
}

}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=2005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m,val[maxn];
vector<pii> adj[maxn];
bool vis[maxn];

void dfs(int u){
vis[u]=1;
for(auto [v,w]: adj[u]){
if(vis[v]){
if(val[v]!=val[u]+w){
print("No");
exit(0);
}
continue;
}
val[v]=val[u]+w;
dfs(v);
}
}

void orzck(){
cin >> n >> m;
rep(m){
int u,v,w;
cin >> u >> v >> w;
u--,v--;
adj[u].pb({v,w}),adj[v].pb({u,-w});
}
rep(n) if(!vis[i]) dfs(i);
print("Yes");
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>

using namespace std;

int main(){
string s;cin >> s;
int k; cin >> k;
int n = (int)s.size();
set<string> m;
for(int i = 0;i < n;++i){
string tasu = "";
for(int j = i;j < min(i+5,n);++j){
tasu += s[j];
m.insert(tasu);
}
}

auto t = m.begin();
--k;

while(k > 0){
--k;
++t;
}

cout << *t << endl;

}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

ld dijkstra(int n) {
for (int i = 0; i < n; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int cur;
for(int j = 0; j < n; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], cur = j;
}
visited[cur] = true;
for (int adjVer: adjList[cur]) {
if (!visited[adjVer]) {
ld candid = dist[cur] + weight[cur][adjVer];
if (candid < dist[adjVer]) {
dist[adjVer] = candid;
}
}
}
}
return dist[n-1];
}

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
for (int j = 0; j < i; j++) {
adjList[i].insert(j);
adjList[j].insert(i);
weight[i][j] = weight[j][i] = calcDist(i, j);
}
}
for (int i = 0; i < n+1; i++) {
adjList[i].insert(n+1);
adjList[n+1].insert(i);
weight[i][n+1] = weight[n+1][i] = calcDist(i, n+1);
}

printf("%.9Lf\n", dijkstra(n+2));
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

struct circle {
ll x, y, r;
circle() {}
circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
};

ld calcDist(circle a, circle b) {
return max(0.0, sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) - a.r - b.r);
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

vector <circle> v(n+2);
// vector <ld> d(n+2, LDBL_MAX);
v[0] = circle(xs, ys, 0);
v[n+1] = circle(xt, yt, 0);
for(int i = 1; i <= n; i++) {
cin >> v[i].x >> v[i].y >> v[i].r;
dist[i] = calcDist(circle(xs, ys, 0), v[i]);
}
vector <bool> chk(n+2);
for (int i = 0; i < n+2; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n+2; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n+2; j++) {
if(chk[j]) continue;
if(mn > dist[j]) mn = dist[j], idx = j;
}
chk[idx] = true;
for(int j = 0; j < n+2; j++) {
if(chk[j]) continue;
dist[j] = min(dist[j], dist[idx] + calcDist(v[idx], v[j]));
}
}

printf("%.9Lf\n", dist[n+1]);
}
#include <iostream>
#include <array>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <algorithm>
#include <cmath>
#include <string>
#include <climits>
#include <cassert>
#include <iomanip>
#include <bitset>
#include <queue>
#include <deque>
#include <stack>
#include <functional>
#include <fstream>
#include <random>
#include <functional>

#define LEN(x) (long long)(x.size())
#define FOR(i, a, n) for(int i=(a);i<(n); ++i)
#define FOE(i, a) for(auto i : a)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SUM(x) std::accumulate(ALL(x), 0LL)
#define MIN(v) *std::min_element(v.begin(), v.end())
#define MAX(v) *std::max_element(v.begin(), v.end())
#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())
#define BIT_COUNT32(bit) (__builtin_popcount(bit))
#define BIT_COUNT64(bit) (__builtin_popcountll(bit))

typedef long long LL;
template<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}
template<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14
template<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}
template<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}
template<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }
void print() { std::cout << std::endl; }
template <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << " ";} print(std::forward<Tail>(tail)...); }
template <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << " ";} }std::cout << std::endl;}
template <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}
void debug() { std::cerr << std::endl; }
template <class Head, class... Tail> void debug(Head&& head, Tail&&... tail) { std::cerr << head; if (sizeof...(tail) != 0) {std::cerr << " ";} print(std::forward<Tail>(tail)...); }
template <class T> void debug(std::vector<T> &v) {for (auto& a : v) { std::cerr << a; if (&a != &v.back()) {std::cerr << " ";} }std::cerr << std::endl;}
template <class T> void debug(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}
inline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }
template<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }
template<class T> inline T manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }
template<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }
template<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }
bool is_bit_on(const unsigned long long bit, const unsigned int i) { return (bit >> i) & 1u; }
unsigned long long bit_set(const unsigned long long bit, const unsigned int i, const unsigned int b) {
assert(b == 0 or b == 1);
if (b == 0) { return bit & ~(1ull << i); }
else        {return bit | (1ull << i); }
}

template<class T> inline std::vector<T> unique(std::vector<T> v) {
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
return v;
}

// 初項s交差d長さnの数列の和
long long sum_of_arithmetic_progression(long long s, long long d, long long n) {
return n * (2 * s + (n - 1) * d) / 2;
}

// xが2の階乗かどうか判定
bool is_power_of_two(long long x) {
return !(x & (x - 1));
}

long long gcd(long long a, long long b) {
if (b == 0) { return a; }
return gcd(b, a % b);
}

long long gcd(std::vector<long long> &v) {
long long ans = v[0];
for (int i = 1; i < (int) v.size(); ++i) {
ans = gcd(ans, v[i]);
}
return ans;
}

long long lcm(long long a, long long b) {
long long g = gcd(a, b);
return a / g * b;
}

const int INF = 1u << 30u;  // 1,073,741,824
const long long LINF = 1ull << 60u;
const double EPS = 1e-9;
const long double PI = acos(-1.0);
const std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下
const std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};
const std::vector<int> dy6 = {0, -1, 0, 1, 1, 1}, dx6 = {1, 0, -1, 0, 1, -1};
const std::vector<int> dy8 = {0, -1, 0, 1, 1, -1, -1, 1}, dx8 = {1, 0, -1, 0, 1, 1, -1, -1};

using namespace std;

vector<vector<int>> hist(string &s, vector<int> &used) {
auto ans = make_v<int>(3, 3);
int N = LEN(s) / 3;
FOR(i, 0, 3 * N) {
if (used[i] != 0) {
continue;
}
if (i < N) {
ans[0][s[i] - 'A']++;
}
else if (N <= i and i < 2 * N) {
ans[1][s[i] - 'A']++;
}
else {
ans[2][s[i] - 'A']++;
}
}
return ans;
}

int main() {
LL N;
string S;
cin >> N >> S;

vector<int> ans(3 * N);

int now_no = 1;
while (true) {
auto h = hist(S, ans);

vector<int> v = {0, 1, 2};
int num = 0;
vector<int> pattern;
do {
int tmp = INF;
FOR(i, 0, 3) {
chmin(tmp, h[i][v[i]]);
}
if (tmp > num) {
num = tmp;
pattern = v;
}
} while(next_permutation(v.begin(), v.end()));

bool all_use = true;
int c1 = 0, c2 = 0, c3 = 0;
FOR(i, 0, LEN(S)) {
if (ans[i] != 0) {
continue;
}
all_use = false;
if (i < N) {
if (S[i] - 'A' == pattern[0] and c1 < num) {
ans[i] = now_no;
c1++;
}
}
else if (N <= i and i < 2 * N) {
if (S[i] - 'A' == pattern[1] and c2 < num) {
ans[i] = now_no;
c2++;
}
}
else {
if (S[i] - 'A' == pattern[2] and c3 < num) {
ans[i] = now_no;
c3++;
}
}
}
now_no++;
if (all_use) {
break;
}
}

FOE(a, ans) {
cout << a;
}
cout << endl;


return 0;
}

#include<bits/stdc++.h>
using namespace std;
int read()
{
int ret=0;bool f=0;char c=getchar();
while(c>'9'||c<'0')f|=(c=='-'),c=getchar();
while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
return f?-ret:ret;
}
const int maxn=2e3+5;
int n;
int pos[2][maxn];
struct per_seg
{
#define L(u) t[u].ls
#define R(u) t[u].rs
struct node{int ls,rs,sum;}t[maxn*100];int rt[maxn],cnt;
int clone(int u){t[++cnt]=t[u];return cnt;}
int change(int u,int p,int l=1,int r=2*n)
{
u=clone(u);
t[u].sum++;
if(l==r)return u;
int mid=(l+r)>>1;
if(mid>=p)L(u)=change(L(u),p,l,mid);
else R(u)=change(R(u),p,mid+1,r);
return u;
}
int query(int u,int nl,int nr,int l=1,int r=2*n)
{
if(l>=nl&&r<=nr)return t[u].sum;
int mid=(l+r)>>1,ret=0;
if(mid>=nl)ret+=query(L(u),nl,nr,l,mid);
if(mid+1<=nr)ret+=query(R(u),nl,nr,mid+1,r);
return ret;
}
#undef L
#undef R
}tr0,tr1;
int f[maxn][maxn];
int main()
{
n=read();
for(int i=1;i<=2*n;i++)
{
char c;scanf(" %c",&c);
if(c=='W')pos[0][read()]=i;
else pos[1][read()]=i;
}
for(int i=1;i<=n;i++)tr0.rt[i]=tr0.change(tr0.rt[i-1],pos[0][i]);
for(int i=1;i<=n;i++)tr1.rt[i]=tr1.change(tr1.rt[i-1],pos[1][i]);
for(int i=0;i<=n;i++)
for(int j=0;j<=n;j++)
{
if(!i&&!j)continue;
f[i][j]=1e9;
if(i)f[i][j]=min(f[i][j],f[i-1][j]+tr0.query(tr0.rt[i-1],pos[0][i],2*n)+tr1.query(tr1.rt[j],pos[0][i],2*n));
if(j)f[i][j]=min(f[i][j],f[i][j-1]+tr0.query(tr0.rt[i],pos[1][j],2*n)+tr1.query(tr1.rt[j-1],pos[1][j],2*n));
}
printf("%d\n",f[n][n]);
return 0;
}
/**
* https://vjudge.net/problem/AtCoder-arc084_b
* @anchor wzj
* @date 2022/1/14
*/

#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mp make_pair
#define P pair<int, int>
int k;
deque<P> que;
bool iscx[100005];
signed main() {
cin >> k;
que.push_back(mp(1, 1));
while (!que.empty()) {
P x = que.front();
que.pop_front();
if (iscx[x.first]) continue;
if (!x.first) {
cout << x.second << endl;
return 0;
}
iscx[x.first] = 1;
que.push_front(mp(x.first * 10 % k, x.second));
que.push_back(mp((x.first + 1) % k, x.second + 1));
}
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

int n, m;
map<pii, bool> p;

int main() {
qread(n, m);
rep(i, 1, m) {
int u, v;
qread(u, v);
p[mp(u, v)] = 1;
}
rep(i, 2, n - 1) {
if(p[mp(1, i)] && p[mp(i, n)]) {
puts("POSSIBLE");
return 0;
}
}
puts("IMPOSSIBLE");
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define endl                        '\n'
#define debug(e)                    cerr << #e << ": " <<  e << endl;
#define fast_io;                 ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);
const ll MOD=1e9+7;//998244353//1e9+9//1111211111;
//ll tavmd(ll a,ll b){if(b==0){return 1;}if(b%2==0){ll x=tavmd(a,b/2);return(x*x)%MOD;}else{return(a%MOD*tavmd(a,b-1)%MOD)%MOD;}}
const ll MAXN=2e5+10;
const ll INF=8e18;
const ll LOG=30;
ll n,d[MAXN];
vector<ll>e[MAXN],vv;
bool mark[MAXN];
void dfs(ll u,ll p){
vv.push_back(u);
for(auto v:e[u])
if(v!=p&&e[v].size()>1){
dfs(v,u);
return;
}
}
int main(){
cin>>n;
if(n==2){
cout<<1<<" "<<2;
return 0;
}
for(int i=1;i<n;i++){
ll u,v;
cin>>u>>v;
e[u].push_back(v);
e[v].push_back(u);
}
ll sum=0;
for(int i=1;i<=n;i++)
if(e[i].size()>1&&sum+1){
for(int v:e[i])
d[v]++;
sum++;
}
for(int i=1;i<=n;i++){
if(e[i].size()>1&&d[i]<=1){
for(auto v:e[i])
if(e[v].size()==1){
dfs(v,0);
break;
}
break;
}
}
if(sum+1!=vv.size()){
puts("-1");
return 0;
}
for(int v:e[vv.back()])
if(e[v].size()==1&&v!=vv[0]){
vv.push_back(v);
break;
}
for(int i=0;i<vv.size();i++)
if(e[vv[i]].size()>e[vv[vv.size()-i-1]].size()){
reverse(vv.begin(),vv.end());
break;
}
else if(e[vv[i]].size()<e[vv[vv.size()-i-1]].size())
break;
for(auto x:vv)
mark[x]=1;
vector<ll>ans;
ll st=0;
for(auto x:vv){
st++;
ll k=st;
for(auto v:e[x])
if(!mark[v]){
st++;
ans.push_back(st);
}
ans.push_back(k);
}
for(int i=0;i<n;i++)
cout<<ans[i]<<" ";
return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
long long k,hs,ans;
double ou(long long x)
{
long long ans=0,y=x;
while (x) ans+=x%10,x/=10;
return 1.0*y/ans;
}
int main()
{
cin>>k;
hs=1;
for (long long i=1;i<=k;i++)
{
while (1)
{
if (ou(ans+hs)>ou(ans+hs*10ll)) hs*=10ll;
else break;
}
ans+=hs;
printf("%lld\n",ans);
}
return 0;
}
#include <bits/stdc++.h>
#define int long long
#define pai 3.141592653589793238462643383279502884197169399375105820
#define MOD 1000000007
#define eps 0.00000001
inline int min(int a,int b) {return a<b?a:b;}
inline int max(int a,int b) {return a>b?a:b;}
#define ULL unsigned long long
#define LL long long
#define INF 0x3f3f3f3f
#define INF_LL 0x3f3f3f3f3f3f3f3f
static char buf[1000000],*pa=buf,*pd=buf;
static char buf2[1000000],*pp=buf2;
#define getchar() pa==pd&&(pd=(pa=buf)+fread(buf,1,1000000,stdin),pa==pd)?EOF:*pa++
inline void pc(char ch){
if(pp-buf2==1000000) fwrite(buf2,1,1000000,stdout),pp=buf2;
*pp++=ch;
}
inline void pcc(){
fwrite(buf2,1,pp-buf2,stdout);
pp=buf2;
}
inline int read(void){
int w=1;
register int x(0);register char c(getchar());
while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
return w*x;
}
void write(int x){
static int sta[20];
int top=0;
do{
sta[top++]=x%10,x/=10;
}while(x);
while(top) pc(sta[--top]+48);
}
void we(int x){
write(x);
pc('\n');
}
inline bool cmp_xi(int a,int b) {return a<b;}
inline bool cmp_da(int a,int b) {return a>b;}
char op[100009][2];int ak,anss,ans[100009],s[100009],kx,N,a[100009],v[100009];
signed main(void) {
N=read();
for(int i=1;i<N;i++) {
a[i]=read();
op[i+1][0]=getchar();
while(op[i+1][0]!='-'&&op[i+1][0]!='+') op[i+1][0]=getchar();
}
v[1]=1;
for(int i=2;i<=N;i++) if(op[i][0]=='-') v[i]=-1;else v[i]=1;
a[N]=read();
for(int i=1;i<=N;i++) s[i]=a[i]*v[i]+s[i-1];
for(int i=1;i<=N;i++) a[i]+=a[i-1];
for(int i=1;i<=N;i++) {
if(v[i]==-1) ans[++kx]=i;
}
for(int i=1;i<kx;i++) {
int tmp=s[ans[i]];
tmp-=(s[ans[i+1]-1]-s[ans[i]]);
tmp+=(a[N]-a[ans[i+1]-1]);
anss=max(anss,tmp); 
}
printf("%lld",max(anss,s[N]));
}

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <deque>
#include <map>
#include <cmath>
typedef long long LL;
using namespace std;
const int Mod = 1000000007;

int main() {
int n, q;
cin >> n;
vector<int> R(n), C(n);
for (int i = 0; i < n; i++) cin >> R[i];
for (int i = 0; i < n; i++) cin >> C[i];
cin >> q;
for (int i = 0; i < q; i++) {
int r, c;
cin >> r >> c;
r -= 1;
c -= 1;
if (n - R[r] < C[c]) cout <<'#';
else cout << '.';
}
cout << endl;
}
#include <bits/stdc++.h>
using namespace std;

int main() {

ios_base::sync_with_stdio(false);
cin.tie(nullptr);

int H, W;
cin >> H >> W;

if(H % 3 == 0 || W % 3 == 0) {
cout << "0\n";
return 0;
}
long long ans = min(H, W);
for(int i = 1; i < H; i++) {
long long a = 1LL*i*W, b = 1LL*(H-i)*(W/2), c = 1LL*(H-i)*(W-W/2);
ans = min(ans, max({abs(a-b), abs(b-c), abs(a-c)}));
}
for(int i = 1; i < W; i++) {
long long a = 1LL*i*H, b = 1LL*(W-i)*(H/2), c = 1LL*(W-i)*(H-H/2);
ans = min(ans, max({abs(a-b), abs(b-c), abs(a-c)}));
}
cout << ans << '\n';
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef long double ld;
typedef std::pair<int, int> pii;
typedef std::pair<int, ll> pil;
typedef std::pair<ll, int> pli;
typedef std::pair<ll, ll> pll;
typedef std::pair<int, ld> pid;
typedef std::pair<ll, ld> pld;
typedef std::pair<int, std::string> pis;
typedef std::pair<ll, std::string> pls;
typedef std::vector<int> vi;
typedef std::vector<vi> vvi;
typedef std::vector<vvi> vvvi;
typedef std::vector<vvvi> vvvvi;
typedef std::vector<ll> vl;
typedef std::vector<vl> vvl;
typedef std::vector<vvl> vvvl;
typedef std::vector<vvvl> vvvvl;
typedef std::vector<ld> vd;
typedef std::vector<vd> vvd;
typedef std::vector<std::string> vs;
#define sz(a) (int)(a).size()
#define rep(i,n) for(auto i=0; i<n; ++i)
#define repm(i,s,n) for(auto i=s; i<n; ++i)
#define repd(i,n) for(auto i=n-1; i>=0; --i)
#define repdm(i,e,n) for(auto i=n-1; i>=e; --i)
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()

constexpr int INF = std::numeric_limits<int>::max() >> 1;
constexpr long long INF_LL = std::numeric_limits<long long>::max() >> 1LL;
constexpr long long MOD1 = 1000000007;
constexpr long long MOD9 = 998244353;
using mint1 = atcoder::modint1000000007;
using mint9 = atcoder::modint998244353;
using vm1 = std::vector<mint1>;
using vvm1 = std::vector<vm1>;
using vvvm1 = std::vector<vvm1>;
using vvvvm1 = std::vector<vvvm1>;
using vm9 = std::vector<mint9>;
using vvm9 = std::vector<vm9>;
using vvvm9 = std::vector<vvm9>;
using vvvvm9 = std::vector<vvvm9>;

template <class T> inline bool chmax(T& a, T b, int eq = 0) { if (a < b || (a == b && eq)) { a = b; return 1; } return 0; }
template <class T> inline bool chmin(T& a, T b, int eq = 0) { if (a > b || (a == b && eq)) { a = b; return 1; } return 0; }

template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::istream& operator>>(std::istream& is, mint& x) noexcept {long long v = 0; std::cin >> v; x = v; return is;}
template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::ostream& operator<<(std::ostream& os, const mint& x) noexcept {os << x.val(); return os;}
inline void __n() { std::cout << "\n"; }
template <class T> inline void __(const T a) { std::cout << a; }
template <class T> inline void __l(const T a) { __(a); __n(); }
template <class T> inline void __s(const T a) { __(a); __(' '); }
template <class T1, class T2> inline void __l(const std::pair<T1, T2> a) { __s(a.first); __l(a.second); }
template <class T1, class T2> inline void __s(const std::pair<T1, T2> a) { __s(a.first); __s(a.second); }
template <class T> inline void __v(const std::vector<T> v) { for(auto a : v) __(a); }
template <class T> inline void __vl(const std::vector<T> v) { for(auto a : v) __l(a); }
template <class T> inline void __vs(const std::vector<T> v) { for(auto a : v) __s(a); __n(); }
template <class T> inline void __vvl(const std::vector<std::vector<T>> v) { for(auto a : v) { __v(a); __n(); } }
template <class T> inline void __vvs(const std::vector<std::vector<T>> v) { for(auto a : v) { __vs(a); } }
inline void __ynl(const bool b) {__l(b ? "yes" : "no");}
inline void __yns(const bool b) {__l(b ? "Yes" : "No");}
inline void __ynu(const bool b) {__l(b ? "YES" : "NO");}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

void solve() {


int N; cin >> N;

vi A(N);
int AM = -INF, Am = INF;
int AMi = -1, Ami = -1;
rep(i, N) {
cin >> A[i];
if (chmax(AM, A[i])) AMi = i;
if (chmin(Am, A[i])) Ami = i;
}

vector<pii> ans;
if (abs(AM) > abs(Am)) {
rep(i, N) if (i != AMi) ans.push_back({AMi+1, i+1});
repm(i, 1, N) ans.push_back({i, i+1});

} else {
rep(i, N) if (i != Ami) ans.push_back({Ami+1, i+1});
repdm(i, 1, N) ans.push_back({i+1, i});

}
__l(sz(ans));
__vl(ans);

//    vi Ac = A;
//    for (auto [x, y] : ans) {
//        Ac[--y] += Ac[--x];
//    }
//    __vs(Ac);






}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

int main() {

std::ifstream in("input.txt");
std::cin.rdbuf(in.rdbuf());

std::cin.tie(nullptr);
std::cout.tie(nullptr);
std::ios::sync_with_stdio(false);

solve();
std::cout << std::flush;

return 0;
}

#include<bits/stdc++.h>

using namespace std;

#define int long long

const int MAXN = 410;
const int INF = 0x3f3f3f3f3f3f3f;

struct edge{
int v, c, f;
};

vector<edge> edgs;
vector<int> g[MAXN];
int src, snk, h[MAXN], ptr[MAXN];

void add_edge (int u, int v, int c) {
int k = edgs.size();
edgs.push_back({v, c, 0});
edgs.push_back({u, 0, 0});
g[u].push_back(k);
g[v].push_back(k+1);
}

bool bfs() {
memset(h, 0, sizeof h);

queue<int> q;
h[src] = 1;
q.push(src);

while(!q.empty()) {
int u = q.front();

q.pop();

for(int i : g[u]) {
int v = edgs[i].v;

if(!h[v] && edgs[i].f < edgs[i].c){
q.push(v);
h[v] = h[u] + 1;
}
}
}
return h[snk];
}

int dfs (int u, int flow) {
if (!flow || u == snk) return flow;

for (int &i = ptr[u]; i < g[u].size(); ++i){
edge &ed = edgs[g[u][i]];
edge &red = edgs[(g[u][i] ^ 1)];

int v = ed.v;

if (h[v] != h[u] + 1)  continue;

int inc = min(flow, ed.c - ed.f);
inc = dfs(v, inc);
if(inc){
ed.f += inc;
red.f -= inc;
return inc;
}
}
return 0;
}

int dinic() {
int flow = 0;
while (bfs()) {
memset(ptr, 0, sizeof ptr);
while (int inc = dfs(src, INF)) flow += inc;
}
return flow;
}

int v[MAXN];

signed main(){
int n;
cin >> n;

src = 0, snk = n + 1;
int res = 0;
for(int i = 1;i <= n;i++){
cin >> v[i];

if(v[i] < 0){
add_edge(src,i,-v[i]);

for(int j = 2*i;j <= n;j += i){
if(v[j] >= 0){
add_edge(i,j,INF);
}
}
}
else{
add_edge(i,snk,v[i]);
res += v[i];
}    
}

int d = dinic();

//cout << res << " " << d << endl;
cout << res - d << endl;
}
#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include<math.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)
using namespace std;
typedef long long ll;
const ll inf=1e18;




using ll=long long;
using P= pair<ll, ll>;

const int MAX = 1000005;
// 今回採用する大きい素数
const ll MOD = 1e9+7;

// メモを保管する場所
ll fact[MAX], inv_fact[MAX], inv[MAX];

// メモを計算する
void init() {
// 初期値設定と1はじまりインデックスに直す
fact[0] = 1;
fact[1] = 1;
inv[0] = 1;
inv[1] = 1;
inv_fact[0] = 1;
inv_fact[1] = 1;
// メモの計算
repi(i, 2, MAX){
// 階乗
fact[i] = fact[i - 1] * i % MOD;
// 逆元
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
// 逆元の階乗
inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD;
}
}

// 二項係数の実体
ll nCk(int n, int k) {
ll x = fact[n]; // n!の計算
ll y = inv_fact[n-k]; // (n-k)!の計算
ll z = inv_fact[k]; // k!の計算
if (n < k) return 0; // 例外処理
if (n < 0 || k < 0) return 0; // 例外処理
return x * ((y * z) % MOD) % MOD; //二項係数の計算
}


ll pow_pow(ll x,ll n,ll mod){
if(n==0) return 1;
x%=mod;

ll res=pow_pow(x*x%mod,n/2,mod);
if(n&1)res=res*x%mod;
return res;
}



int extgcd(int a,int b,int &x,int &y){
int d=a;
if(b!=0){
d=extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else{
x=1;y=0;
}
return d;
}
int mod_inverse(int a,int m){
int x,y;
extgcd(a,m,x,y);
return (m+x%m)%m;
}

struct UnionFind {
vector<int> par, siz;

UnionFind(int n) : par(n, -1) , siz(n, 1) { }

// 根を求める
int root(int x) {
if (par[x] == -1) return x;
else return par[x] = root(par[x]);
}

// x と y が同じグループに属するかどうか (根が一致するかどうか)
bool issame(int x, int y) {
return root(x) == root(y);
}

// x を含むグループと y を含むグループとを併合する
bool unite(int x, int y) {
x = root(x), y = root(y);
if (x == y) return false; 
if (siz[x] < siz[y]) swap(x, y);
par[y] = x;
siz[x] += siz[y];
return true;
}

// x を含むグループのサイズ
int size(int x) {
return siz[root(x)];
}
};

//min(x,y)が0以下の場合はmax(x,y)が返される
//ユークリッドの互除法を元に実装
ll gcd(ll x,ll y){
if(y==0)return x;
return gcd(y,x%y);
}

//オーバフローしないようにかける順番を気を付ける
ll lcm(ll x,ll y){
return ll(x/gcd(x,y))*y;
}




template<class T> bool chmin(T& a, T b) {
if (a > b) {
a = b;
return true;
}
else return false;
}

//using Graph1=vector<vector<Edge> >;
//using Graph=vector<vector<int> >;

// auto mod int
// https://youtu.be/L8grWxBlIZ4?t=9858
// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize
// https://youtu.be/8uowVvQ_-Mo?t=1329 : division
const int mod =  1e9+7;
struct mint {
ll x; // typedef long long ll;
mint(ll x=0):x((x%mod+mod)%mod){}
mint operator-() const { return mint(-x);}
mint& operator+=(const mint a) {
if ((x += a.x) >= mod) x -= mod;
return *this;
}
mint& operator-=(const mint a) {
if ((x += mod-a.x) >= mod) x -= mod;
return *this;
}
mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}
mint operator+(const mint a) const { return mint(*this) += a;}
mint operator-(const mint a) const { return mint(*this) -= a;}
mint operator*(const mint a) const { return mint(*this) *= a;}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t>>1);
a *= a;
if (t&1) a *= *this;
return a;
}

// for prime mod
mint inv() const { return pow(mod-2);}
mint& operator/=(const mint a) { return *this *= a.inv();}
mint operator/(const mint a) const { return mint(*this) /= a;}
};
istream& operator>>(istream& is, const mint& a) { return is >> a.x;}
ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}
// combination mod prime
// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619
struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
//assert(n < mod);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
mint p(int n, int k) {
return fact[n]*ifact[n-k];
}
} c(1000005);




//const ll INF=1e18;


class segment_tree {
private:
int sz;
std::vector<int> seg;
std::vector<int> lazy;
void push(int k) {
if (k < sz) {
lazy[k * 2] = max(lazy[k * 2], lazy[k]);
lazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);
}
seg[k] = max(seg[k], lazy[k]);
lazy[k] = 0;
}
void update(int a, int b, int x, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = x;
push(k);
return;
}
update(a, b, x, k * 2, l, (l + r) >> 1);
update(a, b, x, k * 2 + 1, (l + r) >> 1, r);
seg[k] = max(seg[k * 2], seg[k * 2 + 1]);
}
int range_max(int a, int b, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return 0;
if (a <= l && r <= b) return seg[k];
int lc = range_max(a, b, k * 2, l, (l + r) >> 1);
int rc = range_max(a, b, k * 2 + 1, (l + r) >> 1, r);
return max(lc, rc);
}
public:
segment_tree() : sz(0), seg(), lazy() {};
segment_tree(int N) {
sz = 1;
while (sz < N) {
sz *= 2;
}
seg = std::vector<int>(sz * 2, 0);
lazy = std::vector<int>(sz * 2, 0);
}
void update(int l, int r, int x) {
update(l, r, x, 1, 0, sz);
}
int range_max(int l, int r) {
return range_max(l, r, 1, 0, sz);
}
//cin.tie(0);
//ios_base::sync_with_stdio(false); これらをmain関数の先頭に
};

const int seg_size=200005;
ll seg[seg_size*2];

ll seg_take(int l,int r){
ll tot=0;
l+=seg_size;
r+=seg_size;
while(l<r){
if(l%2==1){
tot+=seg[l];
l++;
}
l/=2;
if(r%2==1){
tot+=seg[r-1];
r--;
}
r/=2;

}
return tot;
}

void seg_up(int ind,int val){
ind+=seg_size;
seg[ind]+=val;
while(true){
ind/=2;
if(ind==0)break;
seg[ind]=seg[ind*2]+seg[ind*2+1];
}
}
struct  Edge{
int to;ll w;
Edge() {}
Edge(int to,ll w):to(to),w(w) {}
};

using graph= vector<vector<int > >;

void comp(vector<int>&a){
set<int>s(a.begin(),a.end());
map<int,int>d;
int cnt=0;
for(auto x:s)d[x]=cnt++;
for(auto&x:a)x=d[x];
}


int main(){
int n; cin >> n;
vector<int> p(n);
rep(i,n){
cin >> p[i];
p[i]--;
}
int ans=0;
rep(i,n){
if(i==n-1){
if(p[i]==i){
swap(p[i],p[i-1]);
ans++;
}
}
else if(p[i]==i){
swap(p[i],p[i+1]);
ans++;
}
}
cout << ans << endl;
}
/*
--------------              |   /
|                     |  /
|                     | /
|             *       |/          |    |         ------            *
|                     |           |    |        /      \
|             |       |\          |    |       |       |\          |
\  |             |       | \         |    |       |       | \         |
\ |             |       |  \        |    |        \     /   \        |
V              |       |   \        \__/|         -----     \       |
*/
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cerr << "\e[1;31m" << #x << " = " << (x) << "\e[0m\n"
#define print(x) emilia_mata_tenshi(#x, begin(x), end(x))
template<typename T> void emilia_mata_tenshi(const char *s, T l, T r) {
cerr << "\e[1;33m" << s << " = [";
while(l != r) {
cerr << *l;
cerr << (++l == r ? ']' : ',');
}
cerr << "\e[0m\n";
}

#define EmiliaMyWife ios::sync_with_stdio(0); cin.tie(NULL);
using ll = int64_t;
using ull = uint64_t;
using ld = long double;
using uint = uint32_t;
const double EPS  = 1e-7;
const int INF     = 0x3F3F3F3F;
const ll LINF     = 4611686018427387903;
const int MOD     = 1e9+7;
static int Lamy_is_cute = []() {
EmiliaMyWife
return 48763;
}();
/*--------------------------------------------------------------------------------------*/

const int N = 2e5 + 25;
struct segtree {
int arr[N << 1], tag[N], n;
void init(int _n) {
n = _n;
memset(arr, 0x3f, sizeof arr);
}
void upd(int p, int v) {
arr[p] += v;
if(p < n)
tag[p] += v;
}
void push(int p) {
for(int h = __lg(p); ~h; h--) {
int i = p >> h;
upd(i, tag[i >> 1]);
upd(i ^ 1, tag[i >> 1]);
tag[i >> 1] = 0;
}
}
void pull(int p) {
for(; p > 1; p >>= 1)
arr[p >> 1] = min(arr[p], arr[p ^ 1]) + tag[p >> 1];
}
void edt(int p, int v) {
p += n;
push(p);
arr[p] = min(arr[p], v);
pull(p);
}
void add(int l, int r, int v) {
int tl = l + n, tr = r + n - 1;
for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
if(l & 1)
upd(l++, v);
if(r & 1)
upd(--r, v);
}
pull(tl); pull(tr);
}
int que(int l, int r) {
int res = INF;
push(l + n); push(r + n - 1);
for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
if(l & 1)
res = min(res, arr[l++]);
if(r & 1)
res = min(res, arr[--r]);
}
return res;
}
} tree;

signed main() {
int n;
cin >> n;
vector<int> arr(n + 1);
for(int i = 1; i <= n; i++)
cin >> arr[i];
tree.init(n + 1);
tree.edt(0, 0);

vector<vector<int>> que(n + 1);
int q;
cin >> q;
for(int i = 0; i < q; i++) {
int l, r;
cin >> l >> r;
que[l].push_back(r);
}
for(int i = 1; i <= n; i++) {
for(int r : que[i]) {
tree.edt(r, tree.que(0, r + 1));
}
if(arr[i])
tree.add(0, i, 1);
else
tree.add(i, n + 1, 1);
}
cout << tree.que(0, n + 1) << '\n';
}

#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include<math.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)
using namespace std;
typedef long long ll;
const ll inf=1e18;




using ll=long long;
using P= pair<ll, ll>;

const int MAX = 1000005;
// 今回採用する大きい素数
const ll MOD = 1e9+7;

// メモを保管する場所
ll fact[MAX], inv_fact[MAX], inv[MAX];

// メモを計算する
void init() {
// 初期値設定と1はじまりインデックスに直す
fact[0] = 1;
fact[1] = 1;
inv[0] = 1;
inv[1] = 1;
inv_fact[0] = 1;
inv_fact[1] = 1;
// メモの計算
repi(i, 2, MAX){
// 階乗
fact[i] = fact[i - 1] * i % MOD;
// 逆元
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
// 逆元の階乗
inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD;
}
}

// 二項係数の実体
ll nCk(int n, int k) {
ll x = fact[n]; // n!の計算
ll y = inv_fact[n-k]; // (n-k)!の計算
ll z = inv_fact[k]; // k!の計算
if (n < k) return 0; // 例外処理
if (n < 0 || k < 0) return 0; // 例外処理
return x * ((y * z) % MOD) % MOD; //二項係数の計算
}


ll pow_pow(ll x,ll n,ll mod){
if(n==0) return 1;
x%=mod;

ll res=pow_pow(x*x%mod,n/2,mod);
if(n&1)res=res*x%mod;
return res;
}



int extgcd(int a,int b,int &x,int &y){
int d=a;
if(b!=0){
d=extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else{
x=1;y=0;
}
return d;
}
int mod_inverse(int a,int m){
int x,y;
extgcd(a,m,x,y);
return (m+x%m)%m;
}

struct UnionFind {
vector<int> par, siz;

UnionFind(int n) : par(n, -1) , siz(n, 1) { }

// 根を求める
int root(int x) {
if (par[x] == -1) return x;
else return par[x] = root(par[x]);
}

// x と y が同じグループに属するかどうか (根が一致するかどうか)
bool issame(int x, int y) {
return root(x) == root(y);
}

// x を含むグループと y を含むグループとを併合する
bool unite(int x, int y) {
x = root(x), y = root(y);
if (x == y) return false; 
if (siz[x] < siz[y]) swap(x, y);
par[y] = x;
siz[x] += siz[y];
return true;
}

// x を含むグループのサイズ
int size(int x) {
return siz[root(x)];
}
};

//min(x,y)が0以下の場合はmax(x,y)が返される
//ユークリッドの互除法を元に実装
ll gcd(ll x,ll y){
if(y==0)return x;
return gcd(y,x%y);
}

//オーバフローしないようにかける順番を気を付ける
ll lcm(ll x,ll y){
return ll(x/gcd(x,y))*y;
}




template<class T> bool chmin(T& a, T b) {
if (a > b) {
a = b;
return true;
}
else return false;
}

//using Graph1=vector<vector<Edge> >;
//using Graph=vector<vector<int> >;

// auto mod int
// https://youtu.be/L8grWxBlIZ4?t=9858
// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize
// https://youtu.be/8uowVvQ_-Mo?t=1329 : division
const int mod =  1e9+7;
struct mint {
ll x; // typedef long long ll;
mint(ll x=0):x((x%mod+mod)%mod){}
mint operator-() const { return mint(-x);}
mint& operator+=(const mint a) {
if ((x += a.x) >= mod) x -= mod;
return *this;
}
mint& operator-=(const mint a) {
if ((x += mod-a.x) >= mod) x -= mod;
return *this;
}
mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}
mint operator+(const mint a) const { return mint(*this) += a;}
mint operator-(const mint a) const { return mint(*this) -= a;}
mint operator*(const mint a) const { return mint(*this) *= a;}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t>>1);
a *= a;
if (t&1) a *= *this;
return a;
}

// for prime mod
mint inv() const { return pow(mod-2);}
mint& operator/=(const mint a) { return *this *= a.inv();}
mint operator/(const mint a) const { return mint(*this) /= a;}
};
istream& operator>>(istream& is, const mint& a) { return is >> a.x;}
ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}
// combination mod prime
// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619
struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
//assert(n < mod);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
mint p(int n, int k) {
return fact[n]*ifact[n-k];
}
} c(1000005);




//const ll INF=1e18;


class segment_tree {
private:
int sz;
std::vector<int> seg;
std::vector<int> lazy;
void push(int k) {
if (k < sz) {
lazy[k * 2] = max(lazy[k * 2], lazy[k]);
lazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);
}
seg[k] = max(seg[k], lazy[k]);
lazy[k] = 0;
}
void update(int a, int b, int x, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = x;
push(k);
return;
}
update(a, b, x, k * 2, l, (l + r) >> 1);
update(a, b, x, k * 2 + 1, (l + r) >> 1, r);
seg[k] = max(seg[k * 2], seg[k * 2 + 1]);
}
int range_max(int a, int b, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return 0;
if (a <= l && r <= b) return seg[k];
int lc = range_max(a, b, k * 2, l, (l + r) >> 1);
int rc = range_max(a, b, k * 2 + 1, (l + r) >> 1, r);
return max(lc, rc);
}
public:
segment_tree() : sz(0), seg(), lazy() {};
segment_tree(int N) {
sz = 1;
while (sz < N) {
sz *= 2;
}
seg = std::vector<int>(sz * 2, 0);
lazy = std::vector<int>(sz * 2, 0);
}
void update(int l, int r, int x) {
update(l, r, x, 1, 0, sz);
}
int range_max(int l, int r) {
return range_max(l, r, 1, 0, sz);
}
//cin.tie(0);
//ios_base::sync_with_stdio(false); これらをmain関数の先頭に
};

const int seg_size=200005;
ll seg[seg_size*2];

ll seg_take(int l,int r){
ll tot=0;
l+=seg_size;
r+=seg_size;
while(l<r){
if(l%2==1){
tot+=seg[l];
l++;
}
l/=2;
if(r%2==1){
tot+=seg[r-1];
r--;
}
r/=2;

}
return tot;
}

void seg_up(int ind,int val){
ind+=seg_size;
seg[ind]+=val;
while(true){
ind/=2;
if(ind==0)break;
seg[ind]=seg[ind*2]+seg[ind*2+1];
}
}
struct  Edge{
int to;ll w;
Edge() {}
Edge(int to,ll w):to(to),w(w) {}
};

using graph= vector<vector<int > >;

void comp(vector<int>&a){
set<int>s(a.begin(),a.end());
map<int,int>d;
int cnt=0;
for(auto x:s)d[x]=cnt++;
for(auto&x:a)x=d[x];
}

const int maxx=100001;
int main(){
int n; cin >> n;
map<int,int> mp;
rep(i,n){
int a;cin >> a;
mp[a]++;
}
int ans=0;
rep(i,maxx)ans=max(ans,mp[i]+mp[i-1]+mp[i+1]);
cout << ans << endl;
}
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
ll n; cin>>n;
ll k; cin>>k;
ll a[n]; for(int i=0; i<n; ++i) cin>>a[i];
int flag[n+1] = {0};
for(int i=0; i<n; ++i){
flag[a[i]] += 1;
}
sort(flag,flag+(n+1));
ll sum = 0;
for(int i=0; i<n+1; ++i){
if(flag[i]){
sum += flag[i];
}
if(i == n-k) break;
}
cout<<sum<<endl;

}

#include <bits/stdc++.h>

using namespace std;

#define N 100005
#define mod 1000000007
#define ll long long int
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>b;i--)
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define clr(x) x.clear()
#define sz(x) ((int)(x).size())
#define tr(container, it)\
for (__typeof__ (container.begin()) it = container.begin(); it != container.end(); it++)
#define present(container, element)(container.find(element) != container.end())
#define cpresent(container, element)(find(all(container), element) != container.end())
#define ff first
#define ss second
#define inf INT_MAX

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int, int> pii;
typedef vector<pii> vpii;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef pair<ll, ll> pll;
typedef vector<pll> vpll;

void solve()
{
ll n; cin >> n;
vll a(3*n);
rep(i,0,3*n) 
{
cin >> a[i];
}

priority_queue < ll > pq;
priority_queue < ll, vll, greater < ll > > rpq;
vll l, r;

ll sum = 0;
rep(i,0,2*n)
{
rpq.push(a[i]);
sum+=a[i];
if(sz(rpq) > n) 
{
sum-=rpq.top();
rpq.pop();
}
if(sz(rpq) == n)
{
// cerr << sum << endl;
l.pb(sum);
} 
}

sum = 0;

rrep(i,3*n - 1,n - 1)
{
pq.push(a[i]);
sum+=a[i];
if(sz(pq) > n) 
{
sum-=pq.top();
pq.pop();
}
if(sz(pq) == n)
{
// cerr << sum << endl;
r.pb(sum);
} 
}

ll ans = -1e18;
rep(i,0,sz(l))
{
// cerr << l[i] << " " << r[sz(r) - i - 1] << endl;
ans = max(ans, l[i] - r[sz(r) - i - 1]);
}

cout << ans;
}


int main()
{
#ifndef ONLINE_JUDGE
freopen("../input.txt", "r", stdin);
freopen("../output.txt", "w", stdout);
#endif

ios::sync_with_stdio(false);
cin.tie(NULL); 

int t = 1;
// cin >> t;

while (t--)
{
solve();
}

return 0;
}
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }
ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}
const int inf = 1001001001;
const ll INF = 1001001001001001001;
const double PI = 3.1415926535;

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

//const int MOD = 998244353;
//using mint = modint998244353;
using mint = modint1000000007;
const int MOD = 1000000007;
ll div_floor(ll a, ll b) {
return a / b - (((a ^ b) < 0) and a % b);
}
ll div_ceil(ll a, ll b) {
return a / b + (((a ^ b) >= 0) and a % b);
}

signed main() {
cout << fixed << setprecision(15);

int N;
cin >> N;
vector<int> A(N);
rep(i, N) cin >> A[i];
vector<int> cnt(N);
rep(i, N) cnt[A[i]]++;

if(N%2 == 1){
bool ok = true;
mint ans = 1;
rep(i, N){
if(cnt[0] != 1) ok = false;
if(i%2 == 1 && cnt[i]) ok = false;
if(i%2 == 0 && i >= 2 && cnt[i] != 2) ok = false;
if(i%2 == 0)ans *= cnt[i];
}
if(!ok) cout << 0 << endl;
else cout << ans.val() << endl;
}
else{
bool ok = true;
mint ans = 1;
rep(i, N){
if(i%2 == 0 && cnt[i]) ok = false;
if(i%2 == 1 && cnt[i] != 2) ok = false;
if(i%2 == 1) ans *= cnt[i];
}
if(!ok) cout << 0 << endl;
else cout << ans.val() << endl;
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, k, n) for(int i = k; i < n; i++)
#define MAX_N 110000
typedef long long ll;
typedef pair<ll, ll> P;
const ll INF = 100000000000;
using Graph = vector<vector<ll>>;
using Field = vector<vector<char>>;

int main(void) {
int n;
cin >> n;

vector<int> p(n);
rep(i, 0, n) cin >> p[i];

if(is_sorted(p.begin(), p.end())) {
cout << 0 << endl;
} else {
cout << min(p[0], n-p[0]) + 1 << endl;
}
}
#include <bits/stdc++.h>

using namespace std;

int main(){
int n, k; cin >> n >> k;

for(int i = 0; i < n; i++){
int a; cin >> a;
}

cout << (n + k - 3)/(k - 1) << endl;

return 0;
}

// 7 3
// 2 1 3
// (n - 1 + (k - 2))/(k - 1)
// (n + k - 3)/(k - 1)
// time-limit: 2000
// problem-url: https://atcoder.jp/contests/arc095/tasks/arc095_c

// Remember this: Whoever sows sparingly will also reap sparingly,
// and whoever sows generously will also reap generously.
// 2 Corinthians 9:6
#include <bits/stdc++.h> 
using namespace std;

template <class T>
inline bool mnto(T& a, T b) {return a > b ? a = b, 1 : 0;}
template <class T>
inline bool mxto(T& a, T b) {return a < b ? a = b, 1: 0;}
#define REP(i, s, e) for (int i = s; i < e; i++)
#define RREP(i, s, e) for (int i = s; i >= e; i--)
typedef long long ll;
typedef long double ld;
#define MP make_pair
#define FI first
#define SE second
typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
#define MT make_tuple
typedef tuple<int, int, int> iii;
#define ALL(_a) _a.begin(), _a.end()
#define pb push_back
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;

#ifdef DEBUG
#define debug(args...) printf(args)
#else
#define debug(args...)
#endif

#define INF 1000000005
#define LINF 1000000000000000005
#define MOD 1000000007
#define MAXN 13

int h, w;
char s[MAXN][MAXN];

int pr[MAXN];
bool visr[MAXN], visc[MAXN];
bool recc(int u, bool skip) {
if (u >= w) {
return 1;
}
if (visc[u]) {
return recc(u + 1, skip);
}
REP (i, u + 1, w) {
if (visc[i]) continue;
bool pos = 1;
REP (j, 0, h) {
if (s[j][u] != s[pr[j]][i]) {
pos = 0;
break;
}
}
if (pos) {
visc[u] = 1;
visc[i] = 1;
if (recc(u + 1, skip)) {
return 1;
}
visc[u] = 0;
visc[i] = 0;
}
}
if (skip) {
return recc(u + 1, 0);
}
return 0;
}
bool recr(int u, bool skip) {
if (u >= h) {
return recc(0, w % 2);
}
if (visr[u]) {
return recr(u + 1, skip);
}
REP (i, u + 1, h) {
if (visr[i]) continue;
visr[u] = 1;
visr[i] = 1;
pr[u] = i;
pr[i] = u;
if (recr(u + 1, skip)) {
return 1;
}
visr[u] = 0;
visr[i] = 0;
}
if (skip) {
pr[u] = u;
return recr(u + 1, 0);
}
return 0;
}

int main() {
scanf("%d%d", &h, &w);
REP (i, 0, h) {
scanf(" %s", s[i]);
}
memset(pr, -1, sizeof pr);
if (recr(0, h % 2)) {
printf("YES\n");
} else {
printf("NO\n");
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ll,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
ll n;
cin>>n;
vi a(n);
rep(i,n) cin>>a[i];
ll ans=0;
bool update=true;
while(update){
update=false;
vi d(n);
ll s=0;
rep(i,n){
if(a[i]>=n) update=true;
d[i]=a[i]/n;
s+=d[i];
a[i]%=n;
a[i]-=d[i];
}
ans+=s;
rep(i,n) a[i]+=s;
}
cout<<ans<<endl;
}
#include<cstdio>
#include<iomanip>
#include<queue>
using namespace std;
const int N=1e5+50;
struct edge{
int to,nxt,val;
}a[N<<1];
int head[N],cnt,k;
bool vis[N];
deque<pair<int,int> > que;
int main()
{
scanf("%d",&k);
que.push_front(make_pair(1,1));
while(!que.empty()){

pair<int,int> f=que.front();
que.pop_front();
if(vis[f.first]) continue;
vis[f.first]=true;
if(f.first==0){
printf("%d\n",f.second);
return 0;
}
que.push_back(make_pair((f.first+1)%k,f.second+1));
que.push_front(make_pair((f.first*10)%k,f.second));
}
return 0;
}
#pragma GCC optimize("Ofast","unroll-loops","omit-frame-pointer","inline")
#include <bits/stdc++.h>
#ifdef __LOCAL
#include <debug/debugger.h>
#endif
#include <ext/pb_ds/assoc_container.hpp>
#define PB push_back
#define vi vector<ll>
#define vb vector<bool>
#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define F first
#define AS assign
#define S second
#define mod 1000000007
#define RZ resize
#define X real()
#define Y imag()
#define INF (((1LL<<62LL)-1LL)*2)-1LL
#define EPS 1e-9
#define all(x) x.begin(),x.end()
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
typedef tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>indexed_set;
typedef unsigned long long ull;
typedef long double d64;
typedef complex<ll>P;
ll modpow(ll x,ll n,ll m) {if(n==0)return 1%m;long long u = modpow(x,n/2,m);u = (u*u)%m;if(n%2==1)u=(u*x)%m;return u;}



ll n,m;
vi link,siz;
ll Find(int x){
if(link[x]==x)return x;
return link[x]=Find(link[x]);
}

void Union(ll a,ll b){
a=Find(a);b=Find(b);
if(siz[a]>siz[b])swap(a,b);
link[a]=link[b];
siz[b]+=siz[a];
}

int main(){
fast

cin>>n>>m;

vi ar(n+5);
link.RZ(2*n+5);
siz.AS(2*n+5,1);

for(int i=1;i<=n;i++){
cin>>ar[i];
}

for(int i=1;i<=2*n;i++){
link[i]=i;

}

for(int i=1;i<=n;i++){
Union(i,ar[i]+n);
}

while(m--){
ll a,b;
cin>>a>>b;
Union(a,b);
}

ll sol=0;

for(int i=1;i<=n;i++){
if(Find(i)==Find(i+n))sol++;
}

cout<<sol;


return 0;
}
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
template<typename T> void cmin(T &a,const T &b){a=min(a,b);}
template<typename T> void cmax(T &a,const T &b){a=max(a,b);}

const int N=500005;
int n,a[N],l[N],r[N];
bool vis[N];
int c[N];
void Add(int p,int v){
while(p<=n)
c[p]+=v,p+=p&-p;
}
int Ask(int p){
int s=0;
while(p)
s+=c[p],p&=p-1;
return s;
}

int main(){
ll s=0;
scanf("%d",&n);
for(int i=1;i<=n;++i)
scanf("%d%d",l+i,r+i);
for(int i=1;i<=n;++i){
if(l[i]!=l[i+1]){
if(vis[l[i]])
goto fail;
vis[l[i]]=true;
a[i]=l[i];
}
if(r[i]!=r[i-1]){
if((a[i] && a[i]!=r[i]) || (!a[i] && vis[r[i]]))
goto fail;
vis[r[i]]=true;
a[i]=r[i];
}
}
for(int i=1,j=1;i<=n;++i)
if(!a[i]){
while(vis[j])
++j;
a[i]=j++;
}
for(int i=1,mx=1;i<=n;++i){
cmax(mx,a[i]);
if(mx!=r[i])
goto fail;
}
for(int i=n,mn=n;i>=1;--i){
cmin(mn,a[i]);
if(mn!=l[i])
goto fail;
}
for(int i=n;i;--i){
Add(a[i],1);
s+=Ask(a[i]-1);
}
printf("%lld\n",s);
return 0;
fail: return puts("-1"),0;
}

#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back
#define em emplace
#define all(v) v.begin(), v.end()
#define reset(x) memset(x, 0, sizeof(x))

using namespace std;
typedef long long ll;
typedef long double ld;
typedef complex <double> cpx;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;

const int MAX = 1010;
const int INF = 1e9;
const ll LINF = 1e18;

struct circle {
ll x, y, r;
circle() {}
circle(ll x, ll y, ll r) : x(x), y(y), r(r) {}
};

ld dist(circle a, circle b) {
return max(0.0, sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)) - a.r - b.r);
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

vector <circle> v(n+2);
vector <ld> d(n+2, LDBL_MAX);
v[0] = circle(xs, ys, 0);
v[n+1] = circle(xt, yt, 0);
for(int i = 1; i <= n; i++) {
cin >> v[i].x >> v[i].y >> v[i].r;
d[i] = dist(circle(xs, ys, 0), v[i]);
}
vector <bool> chk(n+2);
d[0] = 0;
for(int i = 0; i < n+2; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n+2; j++) {
if(chk[j]) continue;
if(mn > d[j]) mn = d[j], idx = j;
}
chk[idx] = true;
for(int j = 0; j < n+2; j++) {
if(chk[j]) continue;
d[j] = min(d[j], d[idx] + dist(v[idx], v[j]));
}
}

// ld ans = dist(circle(xt, yt, 0), circle(xs, ys, 0));
// for(int i = 0; i < n; i++) {
// ans = min(ans, dist(circle(xt, yt, 0), v[i]) + d[i]);
// }
printf("%.9Lf\n", d[n+1]);
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

ld dijkstra(int n) {
for (int i = 0; i < n; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
// auto compare = [] (int a, int b) -> bool {return dist[b] < dist[a];};
// priority_queue<int, vector<int>, decltype(compare)> pq(compare);
// pq.push(0);
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int cur;
for(int j = 0; j < n; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], cur = j;
}
// int cur = pq.top(); pq.pop();
if (visited[cur]) {
continue;
}
visited[cur] = true;
for (int adjVer: adjList[cur]) {
if (!visited[adjVer]) {
ld candid = dist[cur] + weight[cur][adjVer];
if (candid < dist[adjVer]) {
dist[adjVer] = candid;
// pq.push(adjVer);
}
}
}
}
return dist[n-1];
}

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
for (int j = 0; j < i; j++) {
adjList[i].insert(j);
adjList[j].insert(i);
weight[i][j] = weight[j][i] = calcDist(i, j);
}
}
for (int i = 0; i < n+1; i++) {
adjList[i].insert(n+1);
adjList[n+1].insert(i);
weight[i][n+1] = weight[n+1][i] = calcDist(i, n+1);
}

printf("%.9Lf\n", dijkstra(n+2));
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=105,maxm=2005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[2][maxn],pre[maxn],suf[maxn];

void orzck(){
cin >> n;
rep(2) rep1(j,n) cin >> a[i][j];
pre[0]=a[0][0];
rep2(i,1,n) pre[i]=pre[i-1]+a[0][i];
suf[n-1]=a[1][n-1];
rep3(i,n-2,0) suf[i]=suf[i+1]+a[1][i];
int res=0;
rep(n) chkmax(res,pre[i]+suf[i]);
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
int main()
{
string s;
int k;
cin >> s;
cin >> k;

set<string> p;

for (int i = 0; i < s.length(); ++i) {
for (int j = 0; j < k; ++j) {
if (i + j < s.length()) {
p.insert(s.substr(i, j + 1));
}
}
}
auto x = p.begin();
for (int i = 1; i < k; ++i) {
x = next(x);
}
cout << *x << endl;
}
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using VI = vector<int>;
using P = pair<int, int>;

#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define FOR(i, a, b) for (ll i = a; i < (ll)(b); i++)
#define ALL(a) (a).begin(),(a).end()

constexpr int INF = 1001001001;
constexpr ll LINF = 1001001001001001001ll;
constexpr int DX[] = {1, 0, -1, 0};
constexpr int DY[] = {0, 1, 0, -1};

template< typename T1, typename T2>
inline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true); }
template< typename T1, typename T2>
inline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true); }

const ll MOD = 1000000007;

int main() {
int N, K, A;
cin >> N >> K;
REP(i, N) cin >> A;
cout << (N - 1 + K - 2) / (K - 1) << endl;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n, m;
cin >> n;
string s;
cin >> s;
m = s.length();
vector<VLL> f(n + 1, VLL(n + 1, 0));
f[0][0] = 1;
for(int i = 1; i <= n; i++)
{
for(int j = 0; j <= i - 1; j++)
{
f[i][j + 1] = (f[i][j + 1] + f[i - 1][j]) % mod;
if(j > 0)
f[i][j - 1] = (f[i][j - 1] + f[i - 1][j]) % mod;
}
}
VLL pw(n + n + 1);
pw[0] = 1;
for(int i = 1; i <= n + n; i++)
pw[i] = pw[i - 1] * 2 % mod;
VLL dp(n + 1, 0);
dp[0] = 1;
for(int i = 1; i <= n; i++)
{
for(int j = 0; j < i; j++)
{
int val = i - j - 1;
if(val & 1)
continue;
dp[i] = (dp[i] + f[val][0] * dp[j] % mod * pw[val / 2]) % mod;
}
//cerr << i << ' ' << dp[i] << '\n';
}
ll ans = 0;
for(int i = 0; i <= n; i++)
{
int nw = n - i;
if(nw < m)
continue;
if((nw - m) & 1)
continue;
ans = (ans + dp[i] * f[nw][m] % mod * pw[(nw - m) / 2]) % mod;
//cerr << ans << '\n';
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include<cassert>
#include<cctype>
#include<cerrno>
#include<cfloat>
#include<ciso646>
#include<climits>
#include<clocale>
#include<cmath>
#include<csetjmp>
#include<csignal>
#include<cstdarg>
#include<cstddef>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<bitset>
#include<complex>
#include<deque>
#include<exception>
#include<fstream>
#include<functional>
#include<iomanip>
#include<ios>
#include<iosfwd>
#include<iostream>
#include<istream>
#include<iterator>
#include<limits>
#include<list>
#include<locale>
#include<map>
#include<memory>
#include<new>
#include<numeric>
#include<ostream>
#include<queue>
#include<set>
#include<sstream>
#include<stack>
#include<stdexcept>
#include<streambuf>
#include<string>
#include<typeinfo>
#include<utility>
#include<valarray>
#include<vector>
using namespace std;
typedef long long ll;
inline long long read()
{
long long tmptmp=0,f=1;
char tt=getchar();
while (!isdigit(tt))
{
if (tt=='-') f=-1;
tt=getchar();
}
while (isdigit(tt)) tmptmp=(tmptmp<<1)+(tmptmp<<3)-'0'+tt,tt=getchar();
return tmptmp*f;
}
inline void write(long long numnum)
{
static char buf[40];
static int len=-1;
if (numnum>=0)
do
{
buf[++len]=numnum%10+48,numnum/=10;
} while(numnum);
else
{
putchar('-');
do
{
buf[++len]=-(numnum%10)+48,numnum/=10;
} while(numnum);
}
while (len>=0)
putchar(buf[len--]);
}
inline void write(long long numnum,char cccc)
{
static char buf[40];
static int len=-1;
if (numnum>=0)
do
{
buf[++len]=numnum%10+48,numnum/=10;
} while(numnum);
else
{
putchar('-');
do
{
buf[++len]=-(numnum%10)+48,numnum/=10;
} while(numnum);
}
while (len>=0)
putchar(buf[len--]);
putchar(cccc);
}
const ll p=1000000007;
ll n,k,f[10001];
ll qpow(ll a,ll x)
{
if (x<0)
return 1;
ll s=1;
while (x)
{
if (x&1) s=s*a%p;
a=a*a%p;
x>>=1;
}
return s;
}
int main()
{
n=read(),k=read();
f[0]=1;
for (int i=1;i<n;++i)
{
for (int j=i;j;--j)
f[j]=(f[j+1]+f[j-1])%p;
f[0]=f[1];
}
write(f[n-k]*qpow(2,n-k-1)%p);
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <iomanip>
#include <utility>
#include <tuple>
#include <functional>
#include <bitset>
#include <cassert>
#include <complex>
#include <stdio.h>
#include <time.h>
#include <numeric>
#include <random>
#include <unordered_set>
#include <unordered_map>
#define all(a) (a).begin(), (a).end()
#define rep(i, n) for (ll i = 0; i < (n); i++)
//#define rep(i, n) for (int i = 0; i < (n); i++)
#define range(i, a, b) for (ll i = (a); i < (b); i++)
#define pb push_back
#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << (x) << '\n'
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<ll, ll> P;
typedef pair<ll, P> Q;
//typedef complex<ld> com;
template<class T> using pri_s = priority_queue<T, vector<T>, greater<T>>;
template<class T> using pri_b = priority_queue<T>;
constexpr int inf = 1000000010;
constexpr int inf2 = 2000000010;
constexpr ll INF = 1000000000000000010;
constexpr int mod1e9 = 1000000007;
constexpr int mod998 = 998244353;
constexpr ld eps = 1e-12;
constexpr ld pi = 3.141592653589793238;
constexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };
int dx[] = { 1,0,-1,0,1,1,-1,-1 }; int dy[] = { 0,1,0,-1,1,-1,1,-1 };
ll mul(ll a, ll b) { return (a > INF / b ? INF : a * b); }
void fail() { cout << "-1\n"; exit(0); } void no() { cout << "No\n"; exit(0); }
template<class T> void er(T a) { cout << a << '\n'; exit(0); }
template<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }
template<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }
template<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }
template<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }
template<class T, class U> ostream &operator << (ostream &s, const pair<T, U> &p) { s << p.first << ' ' << p.second; return s; }

struct fastio {
fastio() {
cin.tie(0); cout.tie(0);
ios::sync_with_stdio(false);
cout << fixed << setprecision(20);
cerr << fixed << setprecision(20);
}
}fastio_;

ll ppow(ll a, ll b, ll mod) {
ll res = 1;
while (b) {
if (b & 1) res *= a, res %= mod;
a *= a, a %= mod;
b >>= 1;
}
return res;
}

int find(int p) {
random_device seed_gen;
mt19937_64 engine(seed_gen());
vector<int> div;
for (int i = 1; i * i <= p - 1; i++) {
if ((p - 1) % i == 0) {
div.pb(i);
if (i != 1 && i * i != p - 1) div.pb((p - 1) / i);
}
}
while (1) {
int r = engine() % p;
if (r == 0) continue;
bool f = true;
for (int d : div) {
if (ppow(r, d, p) == 1) f = false;
}
if (f) return r;
}
}

ll modinv(ll a, ll mod) {
a %= mod;
if (a == 0) abort();
ll b = mod, u = 1, v = 0;
while (b) {
ll t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
u %= mod;
if (u < 0) u += mod;
return u;
}

int log(ll n, ll p, ll r) {
ll s = sqrt(p) + 1;
unordered_map<ll, ll> big, small;
rep(i, s) small[ppow(r, i, p)] = i;
rep(i, s) big[ppow(r, i * s, p)] = i * s;
rep(i, s) {
ll v = ppow(r, i, p);
ll nn = n * modinv(v, p) % p;
if (big.count(nn)) {
return (i + big[nn]) % (p - 1);
}
}
abort();
}

constexpr ll mod = mod998;
template <int mod> class modint {
public:
int n;
modint() : n(0) {};
modint(ll n_) {
n = n_ % mod;
if (n < 0) n += mod;
}
modint operator -() const { return n > 0 ? mod - n : -n; }
bool operator == (const modint &m) const { return n == m.n; }
bool operator != (const modint &m) const { return n != m.n; }
modint &operator += (const modint &m) { n += m.n; if (n >= mod) n -= mod; return *this; }
modint &operator -= (const modint &m) { n -= m.n; if (n < 0) n += mod; return *this; }
modint &operator *= (const modint &m) { n = ll(n) * m.n % mod; return *this; }
modint &operator /= (const modint &m) { n = ll(n) * modinv(m).n % mod; return *this; }
modint operator +(modint m) const { return modint(*this) += m; }
modint operator -(modint m) const { return modint(*this) -= m; }
modint operator *(modint m) const { return modint(*this) *= m; }
modint operator /(modint m) const { return modint(*this) /= m; }
modint &operator ++ () { *this += 1; return *this; }
modint operator ++ (int) { *this += 1; return *this - 1; }
modint &operator -- () { *this -= 1; return *this; }
modint operator -- (int) { *this -= 1; return *this + 1; }
modint pow(ll b) const {
modint res = 1, a = modint(*this);
while (b) {
if (b & 1) res *= a;
a *= a;
b >>= 1;
}
return res;
}
friend istream &operator >> (istream &s, modint<mod> &a) { s >> a.n; return s; }
friend ostream &operator << (ostream &s, modint<mod> &a) { s << a.n; return s; }
};

using mint = modint<mod>;
vector<mint> fac, inv, facinv;

mint modinv(mint x) {
ll a = x.n;
if (a == 0) abort();
if (a < (ll)inv.size()) return inv[a];
ll b = mod, u = 1, v = 0;
while (b) {
ll t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
mint res = u;
return res;
}

void modcalc(int n) {
fac.resize(n); inv.resize(n); facinv.resize(n);
fac[0] = 1; fac[1] = 1; inv[1] = 1;
facinv[0] = 1; facinv[1] = 1;
for (ll i = 2; i < n; i++) {
fac[i] = fac[i - 1] * i;
inv[i] = -inv[mod % i] * (mod / i);
facinv[i] = facinv[i - 1] * inv[i];
}
}

mint comb(ll n, ll k) {
if (n < 0 || k < 0 || n < k) return 0;
return fac[n] * facinv[k] * facinv[n - k];
}

mint perm(ll n, ll k) {
if (n < 0 || k < 0 || n < k) return 0;
return fac[n] * facinv[n - k];
}

mint hom(ll n, ll k) {
if (n < 0 || k < 0 || n == 0 && k > 0) return 0;
if (n == 0 && k == 0) return 1;
return fac[n + k - 1] * facinv[k] * facinv[n - 1];
}

template<class T> class segtree {
int n;
vector<T> data;
T id = { 0,0 };
T operation(T a, T b) { return a + b; }
public:
segtree(int _n) {
n = 1;
while (n < _n + 2) n <<= 1;
data = vector<T>(2 * n, id);
}
segtree(vector<T> vec) {
int _n = vec.size();
n = 1;
while (n < _n + 2) n <<= 1;
data = vector<T>(2 * n, id);
for (int i = 0; i < _n; i++) data[i + n] = vec[i];
for (int i = n - 1; i >= 1; i--) data[i] = operation(data[i << 1], data[i << 1 | 1]);
}
void change(int i, T x) {
i += n;
data[i] = x;
while (i > 1) {
i >>= 1;
data[i] = operation(data[i << 1], data[i << 1 | 1]);
}
}
void add(int i, T x) { change(i, data[i + n] + x); }
T get(int a, int b) {
T left = id; T right = id;
a += n; b += n;
while (a < b) {
if (a & 1) left = operation(left, data[a++]);
if (b & 1) right = operation(data[--b], right);
a >>= 1; b >>= 1;
}
return operation(left, right);
}
T get_all() { return data[1]; }
T operator[](int i) { return data[i + n]; }
};

class unionfind {
vector<int> par;
vector<int> sz;
public:
unionfind(int n) {
par = vector<int>(n);
for (int i = 0; i < n; i++) par[i] = i;
sz = vector<int>(n, 1);
}
int find(int x) {
if (par[x] == x) return x;
else return par[x] = find(par[x]);
}
int size(int x) { return sz[find(x)]; }
bool same(int x, int y) { return find(x) == find(y); }
void unite(int x, int y) {
x = find(x);
y = find(y);
if (x == y) return;
if (sz[x] < sz[y]) {
par[x] = y;
sz[y] += sz[x];
}
else {
par[y] = x;
sz[x] += sz[y];
}
}
};

template<class T> vector<vector<T>> mat_mul(vector<vector<T>> a, vector<vector<T>> b) {
int n = a.size();
vector<vector<T>> ans(n, vector<T>(n));
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
for (int k = 0; k < n; k++) {
ans[i][j] += a[i][k] * b[k][j];
}
}
}
return ans;
}

template<class T> vector<vector<T>> mat_pow(vector<vector<T>> a, ll b) {
int n = a.size();
vector<vector<T>> ans(n, vector<T>(n));
for (int i = 0; i < n; i++) ans[i][i] = 1;
while (b) {
if (b & 1) ans = mat_mul(ans, a);
a = mat_mul(a, a);
b >>= 1;
}
return ans;
}

vector<ll> compress(vector<ll> vec) {
int vecsize = vec.size();
vector<ll> tmpvec = vec;
sort(tmpvec.begin(), tmpvec.end());
tmpvec.erase(unique(tmpvec.begin(), tmpvec.end()), tmpvec.end());
vector<ll> res(vecsize);
for (int i = 0; i < vecsize; i++) res[i] = lower_bound(tmpvec.begin(), tmpvec.end(), vec[i]) - tmpvec.begin();
return res;
}

int main() {
ll n;
cin >> n;
vector<int> x(n), y(n);
rep(i, n) cin >> x[i] >> y[i];
vector<mint> p(201);
p[0] = 1;
rep(i, 200) p[i + 1] = p[i] * 2;
vector<vector<bool>> ok(n, vector<bool>(n, true));
mint ans = p[n];
rep(i, n) {
for (int j = i + 1; j < n; j++) {
if (ok[i][j]) {
vector<int> v;
v.pb(i); v.pb(j);
for (int k = j + 1; k < n; k++) {
if (x[i] == x[j]) {
if (x[j] == x[k]) v.pb(k);
}
else {
if ((y[j] - y[k]) * (x[i] - x[j]) == (y[i] - y[j]) * (x[j] - x[k])) v.pb(k);
}
}
int vs = v.size();
ans -= p[vs];
ans += vs + 1;
rep(q, vs) {
for (int r = q + 1; r < vs; r++) ok[v[q]][v[r]] = false;
}
}
}
}
ans -= n + 1;
cout << ans << '\n';
} 
#include <stdio.h>
#include <sstream>
#include <string.h>
#include <vector>
#include <map>
#include <algorithm>
#include <utility>
#include <set>
#include <cctype>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <deque>
#include <limits>
#include <iomanip>
#include <ctype.h>
#include <unordered_map>
#include <random>
#include <numeric>
#include <iostream>
#include <array>

#define _USE_MATH_DEFINES
#include <iostream>
#include <math.h>
#include <bitset>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ll, double> pld;
typedef pair<double, double> pdd;
typedef pair<double, ll> pdl;
typedef pair<int, char> pic;
typedef vector<ll> vl;
typedef vector<pll> vpll;
typedef vector<int> vi;
typedef vector<string> table;
typedef priority_queue<ll, vector<ll>, greater<ll>> llgreaterq;
typedef priority_queue<pll, vector<pll>, greater<pll>> pllgreaterq;
typedef priority_queue<pair<ll, pll>, vector<pair<ll, pll>>, greater<pair<ll, pll>>> plpllgreaterq;
typedef priority_queue<vi, vector<vi>, greater<vi>> vigreaterq;
typedef priority_queue<vl, vector<vl>, greater<vl >> vlgreaterq;
typedef vector<vl> mat;
typedef vector<mat> thd;
template <class o, class p, class q>
using tuple3q = priority_queue<tuple<o, p, q>, vector<tuple<o, p, q>>, greater<tuple<o, p, q>>>;
template <class o, class p, class q, class r>
using tuple4q = priority_queue<tuple<o, p, q, r>, vector<tuple<o, p, q, r>>, greater<tuple<o, p, q, r>>>;
template <class o, class p, class q, class r, class s>
using tuple5q = priority_queue<tuple<o, p, q, r, s>, vector<tuple<o, p, q, r, s>>, greater<tuple<o, p, q, r, s>>>;
int dx[] = { -1,0,1,0 };
int dy[] = { 0,1,0,-1 };
#define bit(x,v) ((ll)x << v)
#define rep(x,n) for(ll x = 0;x < n;x++)
#define rep2(x,f,v) for(ll x=f;x<v;x++)
#define repe(v,x) for(auto v : x)
// 許容する誤差ε
#define EPS (1e-10)
// 2つのスカラーが等しいかどうか
#define EQ(a,b) (std::abs(a-b) < EPS)
// 2つのベクトルが等しいかどうか
#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )
#define all(a) a.begin(),a.end()
#define all0(a) memset(a,0,sizeof(a))
#define allm1(a) memset(a,-1,sizeof(a))
#define set_float() cout << fixed << setprecision(10);
#define coutl(s) cout <<s <<endl;
#define pln(s) cout<<s<<"\n";
#define put_float(v) 	set_float() \
pln(v)
#define vinsert(v,p,x) v.insert(v.begin() + p,x)
#define vsort(v) sort(all(v));
#define vdesc(v) vsort(v); \
reverse(all(v))
#define dup(v) v.erase(unique(all(v)),v.end())
#define ion(i,j) ((i & (1LL << j)) > 0)
#define next(i) i++;i%=2
#define Len size()
#define psp(a,b) push_back(make_pair(a,b))
#define psp2(a,b) push(make_pair(a,b))
#define cini(a) a; cin >> a
#define infa(a,b) (a + b) % INF
#define infm(a,b) (a * b) % INF
#define infd(a,b) (a * INFinv(b)) % INF
#define infs(a,b) (a + INF - inff(b)) % INF
#define inf(a) (a) %= INF
#define inff(a) ((a + INF) % INF)
#define No cout << "No" << endl
#define Yes cout << "Yes" << endl
#define NO cout << "NO" << endl
#define YES cout << "YES" << endl
#define smal -INF*INF
#define big INF*INF
#define frontpop(q) q.front();q.pop()
#define toppop(q) q.top();q.pop()
#define arr(a,s) a[s]; all0(a);
#define nxt(cu) (cu+1) % 2 
#define chkover(x,y,h,w) (x<0||y<0||x>=h||y>=w)
ll n, m;

bool chmin(ll& a, ll b) { if (a > b) { a = b; return 1; } return 0; }
ll INF = 1000000007;
const int MAX = 2000010;
void cout2(ll val) {
if (val == big) {
pln(-1);
}
else {
pln(val);
}
}
string padleft(string x, ll dig, char c) {
ll si = x.size();
for (ll i = 0; i < dig - si; i++)
{
x = c + x;
}
return x;
}
long long fac[MAX], finv[MAX], inv[MAX];
void COMinit() {
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++) {
fac[i] = fac[i - 1] * i % INF;
inv[i] = INF - inv[INF % i] * (INF / i) % INF;
finv[i] = finv[i - 1] * inv[i] % INF;
}
}

// 二項係数計算
long long COM(int n, int k) {
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % INF) % INF;
}

ll getpow(ll b, ll x, ll md) {
ll t = b % md;
ll res = 1;
while (x > 0)
{
if (x & 1) {
res *= t;
res %= md;
}
x >>= 1;
t *= t;
t %= md;
}
return res % md;
}
ll getpow(ll b, ll x) {

return getpow(b, x, INF);
}
/// 素数を法とする場合
ll modinv(ll x) {
return getpow(x, INF - 2);
}

ll extgcd(ll a, ll b, ll& x, ll& y) {
ll d = a;
if (b != 0) {
d = extgcd(b, a % b, y, x);
y -= (a / b) * x;
}
else {
x = 1; y = 0;
}
return d;
}

/// <summary>
/// 素数を法としない場合
/// </summary>
/// <param name="a"></param>
/// <param name="m"></param>
/// <returns></returns>
ll modinv(ll a, ll m) {
ll x, y;
extgcd(a, m, x, y);
return (m + x % m) % m;
}

ll gcd(ll a, ll b) {
if (b == 0) return a;
return gcd(b, a % b);
}

class mint {
public:
long long x = 0;
mint(ll x = 0) {
this->x = (x % INF + INF) % INF;
}
mint operator-() const {
return mint(-x);
}
mint& operator+=(const mint& a) {
if ((x += a.x) >= INF) x -= INF;
return *this;
}
mint& operator-=(const mint& a) {
if ((x += INF - a.x) >= INF) x -= INF;
return *this;
}
mint& operator*=(const  mint& a) {
(x *= a.x) %= INF;
return *this;
}
mint operator+(const mint& a) const {
mint res(*this);
return res += a;
}
mint operator-(const mint& a) const {
mint res(*this);
return res -= a;
}
mint operator*(const mint& a) const {
mint res(*this);
return res *= a;
}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t >> 1);
a *= a;
if (t & 1) a *= *this;
return a;
}
// for prime INF
mint inv() const {
return pow(INF - 2LL);
}
mint& operator/=(const mint& a) {
return (*this) *= a.inv();
}
mint operator/(const mint& a) const {
mint res(*this);
return res /= a;
}

friend ostream& operator<<(ostream& os, const mint& m) {
os << m.x;
return os;
}
};
typedef vector<mint> vml;
typedef vector<vml> matm;
// Union find
vl pr;
vl lank;
vl udpt;
void uini(int _n) {
_n++; // 一個拡張しておく
pr = vl(_n + 1);
lank = vl(_n + 1);
udpt = vl(_n + 1, 0);
for (ll i = 0; i <= _n; i++)
{
pr[i] = i;
lank[i] = 1;
}
}

int parent(int x) {
if (x == pr[x]) return x;
auto paren = parent(pr[x]);
udpt[x] = udpt[paren] + 1;
return pr[x] = paren;
}

int same(int x, int y) {
return parent(x) == parent(y);
}

bool unit(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}

bool unitm(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;
if (lank[py] < lank[px]) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
/// <summary>
/// 数字の小さい方を親にするように処理
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
bool unitlow(int x, int y) {

int px = parent(x);
int py = parent(y);

if (px == py) return false;

if (py < px) {
pr[py] = px;
lank[px] += lank[py];
}
else {
pr[px] = py;
lank[py] += lank[px];
}
return true;
}
ll wit[500010];
map<ll, ll> mp[100010];
ll parent2(ll x) {
if (x == pr[x]) return x;
// 元々の親から変わっている時、wit[pr[x]]には親からの距離が入っている
// 同じところを二度通らないので大丈夫なはず
ll o = pr[x];
pr[x] = parent2(o);
wit[x] += wit[o]; // 親の重みを足す
return pr[x];
}
int same2(int x, int y) {
return parent2(x) == parent2(y);
}
bool relate(int x, int y, int v) {

auto px = parent2(x);
auto py = parent2(y);
// 自分の距離が取れる
ll xd = wit[x];
ll yd = wit[y];
// ↑のydにvを足した値とxdを比較する
// yd+v> xdであれば、pyが親となる
// yの直接の親はxとしてしまう?
// wit[y] = v;
if (px == py)
return false;
if (xd + v > yd) {
pr[py] = px;

wit[py] = xd + v - yd; // 親同士の距離を入れておく
}
else {
pr[px] = py;
wit[px] = yd - (xd + v);
}
return true;
}

int ci = 0;
struct Node {
int key = 0;
int priority;
Node* parent, * left, * right;
Node(int key, int priority);
Node() {}
};
Node NIL;
Node::Node(int key, int priority) : key(key), priority(priority) {
left = &NIL;
right = &NIL;
}
Node* root = new Node();
void cenrec(Node* k) {
if (k->key == NIL.key) return;
cenrec(k->left);
cout << " " << k->key;
cenrec(k->right);
}
void fastrec(Node* k)
{
if (k->key == NIL.key) return;
cout << " " << k->key;
fastrec(k->left);
fastrec(k->right);
}
void insert(Node* v) {
Node* y = &NIL;
Node* x = root;
while (x->key != NIL.key)
{
y = x;
if (v->key < x->key) {
x = x->left;
}
else {
x = x->right;
}
}
v->parent = y;
if (y->key == NIL.key) {
root = v;
}
else if (v->key < y->key) {
y->left = v;
}
else {
y->right = v;
}

}

Node* find(Node* k, ll v)
{
if (k->key == NIL.key) return &NIL;
if (k->key == v) return k;
if (v < k->key) return find(k->left, v);
return find(k->right, v);
}
void delp12(Node* x) {
if (x->key == NIL.key)  return;
Node* l = x->left;
Node* r = x->right;
Node* pr = x->parent;

if (l->key == NIL.key
&& r->key == NIL.key) {
if (pr->left == x) {
pr->left = &NIL;
}
else pr->right = &NIL;
}
else if (l->key != NIL.key) {
if (pr->left == x) {
pr->left = l;
}
else pr->right = l;
l->parent = pr;
}
else if (r->key != NIL.key) {
if (pr->left == x) {
pr->left = r;
}
else pr->right = r;
r->parent = pr;
}
}
Node* get_next(Node* k) {
if (k->key == NIL.key) return &NIL;
Node* res = get_next(k->left);
if (res->key != NIL.key) return res;
return k;
}
void del(Node* x) {

if (x->key == NIL.key) return;
Node* l = x->left;
Node* r = x->right;

if (l->key != NIL.key && r->key != NIL.key) {
Node* nex = get_next(r);
x->key = nex->key;
delp12(nex);
}
else {
delp12(x);
}
}
Node* rightRotate(Node* t) {
Node* s = t->left;
t->left = s->right;
s->right = t;
return s;
}
Node* leftRotate(Node* t) {
Node* s = t->right;
t->right = s->left;
s->left = t;
return s;
}
Node* _insert(Node* t, int key, int priority) {
if (t->key == NIL.key) {
return new Node(key, priority);
}
if (key == t->key) {
return t;
}

if (key < t->key) {
t->left = _insert(t->left, key, priority);
if (t->priority < t->left->priority) {
t = rightRotate(t);
}
}
else {
t->right = _insert(t->right, key, priority);
if (t->priority < t->right->priority) {
t = leftRotate(t);
}
}
return t;
}
Node* delete1(Node* t, int key);
Node* _delete(Node* t, int key) {
if (t->left->key == NIL.key && t->right->key == NIL.key) {
return &NIL;
}
else if (t->left->key == NIL.key) {
t = leftRotate(t);
}
else if (t->right->key == NIL.key) {
t = rightRotate(t);
}
else
{
if (t->left->priority > t->right->priority) {
t = rightRotate(t);
}
else
t = leftRotate(t);
}
return delete1(t, key);
}
Node* delete1(Node* t, int key) {
if (t->key == NIL.key) {
return &NIL;
}
if (key < t->key) {
t->left = delete1(t->left, key);
}
else if (key > t->key) {
t->right = delete1(t->right, key);
}
else return _delete(t, key);
return t;
}
int H;
int left(int i) {
return i * 2 + 1;
}
int right(int i) {
return i * 2 + 2;
}
class edge {
public:
int from, to, i;
ll val;
ll cap, rev;
edge() {}
edge(ll to) : to(to) {}
edge(ll to, ll i) : to(to), i(i) {}
edge(ll from, ll to, ll val) : from(from), to(to), val(val) {}
void flowEdge(ll _to, ll _cap, ll _rev) {
to = _to;
cap = _cap;
rev = _rev;
}
};
typedef vector<vector<edge>> vve;

class LCA {
private:
vector<vector<edge>> v;
vector<vector<int>> parent;
vector<int> depth;
ll root;
void dfs(int n, int m, int d) {
parent[0][n] = m;
depth[n] = d;
for (auto x : v[n]) {
if (x.to != m) dfs(x.to, n, d + 1);
}
}
public:
LCA(ll N, ll root, vector<vector<edge>>& tree) {
v = tree;
this->root = root;
parent = vector<vector<int>>(21, vector<int>(N + 1, 0));
depth = vector<int>(N + 1, 0);
dfs(root, -1, 0);
for (int j = 0; j + 1 < 20; j++) {
for (int i = 1; i <= N; i++) {
if (parent[j][i] < 0) parent[j + 1][i] = -1;
else parent[j + 1][i] = parent[j][parent[j][i]];
}
}
}
int lca(int n, int m) {
if (depth[n] > depth[m]) swap(n, m);
if (n == root)
return root;
for (int j = 0; j < 20; j++) {
if ((depth[m] - depth[n]) >> j & 1) m = parent[j][m];
}
if (n == m) return n;
for (int j = 19; j >= 0; j--) {
if (parent[j][n] != parent[j][m]) {
n = parent[j][n];
m = parent[j][m];
}
}
return parent[0][n];
}
int dep(int n) { return depth[n]; }
};
ll k;
int _rank[1010];
int temp[1010];
bool compare_sa(int i, int j) {
if (_rank[i] != _rank[j]) return _rank[i] < _rank[j];
else {
int ri = i + k <= n ? _rank[i + k] : -1;
int rj = j + k <= n ? _rank[j + k] : -1;
return ri < rj;
}
}
void construct_sa(string S, int* sa) {
n = S.length();

for (ll i = 0; i <= n; i++)
{
sa[i] = i;
_rank[i] = i < n ? S[i] : -1;
}

for (k = 1; k <= n; k *= 2)
{
sort(sa, sa + n + 1, compare_sa);

// saはソート後の接尾辞の並びになっている、rankは元の位置のindexを保持したまま、更新されている。
// ピンとこなかった部分
temp[sa[0]] = 0;
for (ll i = 1; i <= n; i++)
{
temp[sa[i]] = temp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);
}
for (ll i = 0; i <= n; i++)
{
_rank[i] = temp[i];
}
}
}
bool contain(string S, int* sa, string T) {
int a = 0, b = S.length();
// sa は 接尾辞が辞書順に並んでいる、入っているのはその位置のインデックス
while (b - a > 1) {
int c = (a + b) / 2;
if (S.compare(sa[c], T.length(), T) < 0) a = c;
else b = c;
}
return S.compare(sa[b], T.length(), T) == 0;
}


#define bit(x,v) ((ll)x << v)

class BIT {

static const int MAX_N = 500010;
public:
BIT() { memset(bit, 0, sizeof(bit)); }
ll bit[MAX_N + 1], n;
ll sum(int i) {
ll s = 0;
while (i > 0)
{
s += bit[i];
i -= i & -i;
}
return s;
}

void add(int i, int x) {
while (i <= n)
{
bit[i] += x;
i += i & -i;
}
}


};
struct UnionFind {
vector<int> A;
UnionFind(int n) : A(n, -1) {}
int find(int x) {
if (A[x] < 0) return x;
return A[x] = find(A[x]);
}
void unite(int x, int y) {
x = find(x), y = find(y);
if (x == y) return;
if (A[x] > A[y]) swap(x, y);
A[x] += A[y];
A[y] = x;
}
int ngroups() {
int ans = 0;
for (auto a : A) if (a < 0) ans++;
return ans;
}
};
vector<ll> getp(ll n) {

vector<ll> res;
if (n % 2 == 0) {
res.push_back(2);
while (n % 2 == 0)n /= 2;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(i);
while (n % i == 0)n /= i;
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<ll> getp2(ll n) {

vector<ll> res;
if (n % 2 == 0) {

while (n % 2 == 0) { n /= 2; res.push_back(2); }
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {

while (n % i == 0) { n /= i; res.push_back(i); }
}
}
if (n != 1) res.push_back(n);
return res;
}
vector<pll> getp3(ll n) {
vector<pll> res;
int si = 0;
if (n % 2 == 0) {

res.push_back(make_pair(2, 0));
while (n % 2 == 0) { n /= 2; res[si].second++; }
si++;
}

for (ll i = 3; i * i <= n; i += 2)
{
if (n % i == 0) {
res.push_back(make_pair(i, 0));
while (n % i == 0) { n /= i; res[si].second++; }
si++;
}
}
if (n != 1) { res.push_back(make_pair(n, 1)); }
return res;
}

vector<ll> getDivisors(ll n) {

vector<ll> res;
res.push_back(1);
for (ll i = 2; i * i <= n; i++)
{

if (n % i == 0) {
res.push_back(i);
if (n / i != i)
res.push_back(n / i);
}
}
return res;
}

struct ve {
public:
vector<ve> child;
int _t = INF;
ve(int t) :_t(t) {}
ve(ve _left, ve _right) {
_t = _left._t + _right._t;
child.push_back(_left);
child.push_back(_right);
}
bool operator<(const ve& t) const {
return _t > t._t;
}
};

vector<bool> elas(ll n) {
n++;
vector<bool> r(n, 1);
r[0] = 0;
r[1] = 0;
ll tw = 4;
while (tw < n) {
r[tw] = false;
tw += 2;
}
ll th = 6;
while (th < n) {
r[th] = false;
th += 3;
}
ll fv = 10;
while (fv < n) {
r[fv] = false;
fv += 5;
}

for (ll i = 6; i * i < n; i += 6)
{
ll bf = i - 1;
if (r[bf]) {
ll ti = bf * 2;
while (ti < n)
{
r[ti] = false;
ti += bf;
}
}
ll nx = i + 1;
if (r[nx]) {
ll ti = nx * 2;
while (ti < n)
{
r[ti] = false;
ti += nx;
}
}
}
return r;
}
bool isPrime(ll v) {
for (ll i = 2; i * i <= v; i++)
{
if (v % i == 0) return false;
}
return true;
}


class SegTree {

public:
const static int MAX_N = 1000100;
const static int DAT_SIZE = (1 << 20) - 1;
int N, Q;
int A[MAX_N];
ll MAX = big;

ll data[DAT_SIZE], datb[DAT_SIZE];
void init(int _n) {
N = 1;
while (N < _n) N <<= 1;
memset(data, 0, sizeof(data));
memset(datb, 0, sizeof(datb));
}
void init(int _n, ll iv) {
N = 1;
while (N < _n) N <<= 1;
rep(i, DAT_SIZE) {
data[i] = iv;
datb[i] = iv;
}
}
void initRMQ(int _n) {
N = 1;
while (N < _n) N *= 2;
// 全ての値をbigに
rep(i, 2 * N - 1)
data[i] = MAX;
}
void updateRMQ(int k, ll a) {
k += N - 1;
data[k] = a;
while (k > 0) {
k = (k - 1) / 2;
data[k] = min(data[k * 2 + 1], data[k * 2 + 2]);
}
}
ll RMQ(int a, int b) {

return queryRMQ(a, b + 1, 0, 0, N);
}
ll queryRMQ(int a, int b, int k, int l, int r) {
if (r <= a || b <= l)
return MAX;

// [a,b)が[l,r)を完全に含んでいれば
if (a <= l && r <= b)
return data[k];

// そうでなければ２つの子の最小値
// n=16
// 0,16→0,8 8,16
// 0,4 4,8 8,12 12,16
ll vl = queryRMQ(a, b, k * 2 + 1, l, (l + r) / 2);
ll vr = queryRMQ(a, b, k * 2 + 2, (l + r) / 2, r);
return min(vl, vr);
}

void add(int a, int b, int x) {
add(a, b + 1, x, 0, 0, N);
}
void add(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] += x;
}
else if (l < b && a < r) {
datb[k] += (min(b, r) - max(a, l)) * x;
add(a, b, x, k * 2 + 1, l, (l + r) / 2);
add(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

void change(int a, int b, int x) {
change(a, b + 1, x, 0, 0, N);
}
void change(int a, int b, int x, int k, int l, int r) {
if (a <= l && r <= b) {
data[k] = x;
}
else if (l < b && a < r) {
datb[k] = x;
change(a, b, x, k * 2 + 1, l, (l + r) / 2);
change(a, b, x, k * 2 + 2, (l + r) / 2, r);
}
}

ll sum(int a, int b) {
return sum(a, b + 1, 0, 0, N);
}
ll sum(int a, int b, int k, int l, int r) {
if (b <= l || r <= a) {
return 0;
}
if (a <= l && r <= b) {
return data[k] * (r - l) + datb[k];
}

ll res = (min(b, r) - max(a, l)) * data[k];
res += sum(a, b, k * 2 + 1, l, (l + r) / 2);
res += sum(a, b, k * 2 + 2, (l + r) / 2, r);
return res;
}
};

class Segment;
class Circle;

class Point {
public:
double x, y;

Point(double x = 0, double y = 0) :x(x), y(y) {}

Point operator + (Point p) { return Point(x + p.x, y + p.y); }
Point operator - (Point p) { return Point(x - p.x, y - p.y); }
Point operator * (double a) { return Point(a * x, a * y); }
Point operator / (double a) { return Point(x / a, y / a); }

double abs() { return sqrt(norm()); }
double norm() { return x * x + y * y; }

bool operator < (const Point& p)const {
return x != p.x ? x < p.x : y < p.y;
}
bool operator == (const Point& p) const {
return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;
}
// 内積
static double dot(Point a, Point b) {
return a.x * b.x + a.y * b.y;
}
// 外積
static double cross(Point a, Point b) {
return a.x * b.y - a.y * b.x;
}
static bool isOrthogonal(Point a, Point b) {
return EQ(dot(a, b), 0.0);
}
static bool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {
return isOrthogonal(a1 - a2, b1 - b2);
}
static bool isOrthogonal(Segment s1, Segment s2);

static bool isPalallel(Point a, Point b) {
return EQ(cross(a, b), 0.0);
}
static bool isPalallel(Point a1, Point a2, Point b1, Point b2) {
return isPalallel(a1 - a2, b1 - b2);
}
static bool isPalallel(Segment s1, Segment s2);

static const int COUNTER_CLOCKWISE = 1;
static const int CLOCKWISE = -1;
static const int ONLINE_BACK = 2;
static const int ONLINE_FRONT = -2;
static const int ON_SEGMENT = 0;
static int ccw(Point p0, Point p1, Point p2) {
// 線分はp0とp1でp2がどこにあるかを探る
Point a = p1 - p0;
Point b = p2 - p0;
if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;
if (cross(a, b) < -EPS) return CLOCKWISE;
if (dot(a, b) < -EPS) return ONLINE_BACK;
if (a.norm() < b.norm()) return ONLINE_FRONT;
return ON_SEGMENT;
}

// 交差しているか
static bool intersect(Point p1, Point p2, Point p3, Point p4) {
return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0
&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);
}
static bool intersect(Segment s1, Segment s2);
static Point project(Segment s, Point p);

static Point reflect(Segment s, Point p);

static Point getDistance(Point a, Point b) {
return (a - b).abs();
}

static double getDistanceLP(Segment s, Point p);

static double getDistanceSP(Segment s, Point p);

static double getDistance(Segment s1, Segment s2);

static Point getIntersection(Segment s1, Segment s2);

static pair<Point, Point> crossPoints(Circle c, Segment s);

static int contains(vector<Point> g, Point p) {
int n = g.size();
bool x = false;
rep(i, n) {
Point a = g[i] - p, b = g[(i + 1) % n] - p;
// 線の上に載っているか
if (std::abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;

// pを基準として上下にあるか
// または外積が正か?(→にあるか)
if (a.y > b.y) swap(a, b);
if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;
}
return x ? 2 : 0;
}

static vector<Point> andrewScan(vector<Point> s) {
vector<Point> u, l;
ll si = s.size();
if (si < 3) return s;
sort(all(s));
u.push_back(s[0]);
u.push_back(s[1]);
l.push_back(s[si - 1]);
l.push_back(s[si - 2]);
for (int i = 2; i < si; i++) {

for (int _n = u.size(); _n >= 2 && ccw(u[_n - 2], u[_n - 1], s[i]) > CLOCKWISE; _n--) {
u.pop_back();
}
u.push_back(s[i]);
}

for (int i = s.size() - 3; i >= 0; i--) {

for (int _n = l.size(); _n >= 2 && ccw(l[_n - 2], l[_n - 1], s[i]) > CLOCKWISE; _n--) {
l.pop_back();
}
l.push_back(s[i]);
}

reverse(all(l));
for (int i = u.size() - 2; i >= 1; i--)
{
l.push_back(u[i]);
}

return l;
}
void get_cin() {
cin >> x >> y;
}

static Point rotate(double r, Point p) {
Point ret;
ret.x = cos(r) * p.x - sin(r) * p.y;
ret.y = sin(r) * p.x + cos(r) * p.y;
return ret;
}
};

class Segment {
public:
Point p1, p2;
Segment() {}
Segment(Point p1, Point p2) :p1(p1), p2(p2) {}
void get_cin() {
cin >> p1.x >> p1.y >> p2.x >> p2.y;
}
Point p1tp2() {
return p2 - p1;
}
Point p2tp1() {
return p1 - p2;
}
double abs() {
return (p2 - p1).abs();
}
double norm() {
return (p2 - p1).norm();
}
};

// 直行
bool Point::isOrthogonal(Segment s1, Segment s2) {
return EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}

// 平行
bool Point::isPalallel(Segment s1, Segment s2) {
return EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);
}
// 交差しているか
bool Point::intersect(Segment s1, Segment s2) {
return intersect(s1.p1, s1.p2, s2.p1, s2.p2);
}
Point Point::project(Segment s, Point p) {
Point base = s.p2 - s.p1;
double r = Point::dot(p - s.p1, base) / base.norm();
return s.p1 + base * r;
}
Point Point::reflect(Segment s, Point p) {
return (project(s, p) * 2) - p;
}
double Point::getDistanceLP(Segment s, Point p) {
return std::abs(cross(s.p2 - s.p1, p - s.p1) / (s.p2 - s.p1).abs());
}
double Point::getDistanceSP(Segment s, Point p) {
if (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();
if (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();
return getDistanceLP(s, p);
}
double Point::getDistance(Segment s1, Segment s2) {
if (intersect(s1, s2)) return 0.0;
return min({ getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)
,getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2) });
}

Point Point::getIntersection(Segment s1, Segment s2) {
// (s1.p1 - s2.p1).norm()
auto bs = s1.p2 - s1.p1;
auto n1 = s2.p1 - s1.p1;
auto n2 = s2.p2 - s1.p1;
auto c1 = std::abs(cross(n1, bs)) / bs.norm();
auto c2 = std::abs(cross(n2, bs)) / bs.norm();
return s2.p1 + (s2.p2 - s2.p1) * (c1 / (c1 + c2));
// c1:c2=t:1-t
// c2t=(1-t)c1
// t/(1-t)=c1/(c1+c2)
// 
}

double arg(Point p) { return atan2(p.y, p.x); }
Point polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }
class Circle {
public:
Point c;
double r;
Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}
void get_cin() {
cin >> c.x >> c.y >> r;
}
static pair<Point, Point> getCrossPoints(Circle c1, Circle c2) {
double d = (c1.c - c2.c).abs(); // 中心点どうしの距離
double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
double t = arg(c2.c - c1.c);
return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));

}
};

pair<Point, Point> Point::crossPoints(Circle c, Segment s) {
auto pp = project(s, c.c);
auto f = (pp - c.c).norm();
auto mu = sqrt(c.r * c.r - f);

// 単位ベクトル
auto e = s.p1tp2() / s.p1tp2().abs();
return make_pair(pp + e * mu, pp - e * mu);

}

ll divRm(string s, ll x) {

ll r = 0;
for (ll i = 0; i < s.size(); i++)
{
r *= 10;
r += s[i] - '0';
r %= x;
}
return r;
}
ll cmbi(ll x, ll b) {

ll res = 1;
for (size_t i = 0; i < b; i++)
{
res *= x - i;
res %= INF;
res *= inv[b - i];
res %= INF;
}
return res;
}

ll digsum(ll x) {
ll res = 0;
while (x > 0)
{
res += x % 10;
x /= 10;
}
return res;
}
bool check_parindrome(string s) {
int n = s.size();
rep(i, n / 2) {
if (s[i] != s[n - i - 1]) {
return false;
}

}
return true;
}
ll npr(ll n, ll r) {
if (r == 0)
return 1;
return inff(fac[n] * modinv(fac[n - r]));
}

vl zalgo(string s) {
ll c = 0;
vl a(s.size());
ll si = s.size();
rep2(i, 1, s.size()) {
if (i + a[i - c] < c + a[c])
{
a[i] = a[i - c];
}
else {
ll j = max(0LL, a[c] - (i - c));
while (i + j < si && s[j] == s[i + j])
{
j++;
}

a[i] = j;
c = i;
}

}
a[0] = s.size();
return a;
}
// 数値文字列の除算
string divStrNum(string s, ll v) {
ll si = s.size();
ll val = 0;
string res = "";
for (ll i = 0; i < si; i++)
{
val *= 10;
val += s[i] - '0';
ll add = val / v;
val %= v;
if (add == 0 && res == "")
continue;
res += add + '0';
}
if (res == "")
return "0";

return res;
}

// 数値文字列の減算
string difStrNum(string s, ll v) {
ll si = s.size();
bool dec = false;
for (ll i = si - 1; i >= 0; i--)
{
if (v == 0)
break;
ll t = v % 10;
v /= 10;
ll u = (s[i] - '0');
if (dec) {
if (u == 0) {
s[i] = 9 - t;
dec = true;
continue;
}
u--;
}
if (u < t) {
s[i] = 10 - (t - u);
dec = true;
}
else {
s[i] -= t;
dec = false;
}

}
return s;
}
// 数値文字列を1減らした数
string decStrNum(string s) {
ll si = s.size();
for (int i = si - 1; i >= 0; i--)
{
if (s[i] == '0') {
s[i] = '9';
continue;
}
s[i] = s[i] - 1;

break;
}
return s;
}
void dateCal(int x) {
int lp = x / 7;
string date[] = { "月曜日","火曜日","水曜日","木曜日","金曜日","土曜日","日曜日" };
rep(i, 7) {
int st = i;
rep(j, lp) {
cout << "\t" << date[i] << x << "-" << st << "\t" << "NULL" << "\t" << x << "\t" << st << "\t" << 0 << endl;
st += 7;
}
}
}
// 行列べき乗計算
mat mul(mat& A, mat& B) {
ll as = A.size();
ll bs = B.size();
mat C(A.size(), vl(B[0].size()));
rep(i, as) {
rep(t, bs) {
ll bz = B[0].size();
rep(j, bz) {
C[i][j] = inff(C[i][j] + A[i][t] * B[t][j]);
}
}
}
return C;
}

mat pow(mat A, ll x) {
mat B(A.size(), vl(A.size()));
rep(i, A.size()) {
B[i][i] = 1;
}
while (x > 0)
{
if (x & 1)B = mul(B, A);
A = mul(A, A);
x >>= 1;
}
return B;
}

class dinic {
public:
vve G;

vl level;
vl iter;
dinic(int _n) : dinic(vve(_n + 1)) {

}
dinic(vve g) {
G = g;
level = vl(g.size());
iter = vl(g.size());
}

void add_edge(ll from, ll to, ll cap) {
auto e1 = edge();
auto e2 = edge();

e1.flowEdge(to, cap, G[to].size());
G[from].push_back(e1);
e2.flowEdge(from, 0, G[from].size() - 1);
G[to].push_back(e2);
}

void bfs(ll s) {
fill(all(level), -1);
queue<ll> q;
level[s] = 0;
q.push(s);
while (!q.empty())
{
ll v = frontpop(q);
for (auto e : G[v]) {
if (e.cap > 0 && level[e.to] < 0) {
level[e.to] = level[v] + 1;
q.push(e.to);
}
}
}
}

ll dfs(ll v, ll t, ll f) {
if (v == t)
return f;
for (ll& i = iter[v]; i < G[v].size(); i++) {
edge& e = G[v][i];
if (e.cap > 0 && level[v] < level[e.to]) {
ll d = dfs(e.to, t, min(f, e.cap));
if (d > 0) {
e.cap -= d;
G[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}

ll max_flow(ll s, ll t) {
ll flow = 0;
for (;;) {
bfs(s);
if (level[t] < 0)
return flow;
fill(all(iter), 0);
ll f;
while ((f = dfs(s, t, big)) > 0)
{
flow += f;
}
}
}
};
const ull BS = 1000000007;
// aはbに含まれているか？
bool rolling_hash(string a, string b) {
int al = a.size(), bl = b.size();
if (al > bl)
return false;

// BSのal乗を計算
ull t = 1;
rep(i, al)t *= BS;

// aとbの最初のal文字に関するハッシュ値を計算
ull ah = 0, bh = 0;
rep(i, al) ah = ah * BS + a[i];
rep(i, al) bh = bh * BS + b[i];

// bの場所を一つずつ進めながらハッシュ値をチェック
for (ll i = 0; i + al <= bl; i++)
{
if (ah == bh)
return true;
if (i + al < bl)bh = bh * BS + b[i + al] - b[i] * t;
}
return false;
}

mat sans(9, vl(9, -1));
bool srec(ll x, ll y) {
if (x == 9)
return true;
vl use(10, 0);
rep(i, 9) {
if (sans[i][y] == -1)
continue;
use[sans[i][y]] = 1;
}
rep(j, 9) {
if (sans[x][j] == -1)
continue;
use[sans[x][j]] = 1;
}
ll px = x % 3;
ll py = y % 3;
ll tx = x - px + 3;
ll ty = y - py + 3;
rep2(i, x - px, tx) {
rep2(j, y - py, ty) {
if (sans[i][j] == -1)
continue;
use[sans[i][j]] = 1;
}
}
ll nx, ny;
if (y == 8) {
nx = x + 1;
ny = 0;
}
else {
nx = x;
ny = y + 1;
}

if (sans[x][y] != -1) {
if (srec(nx, ny)) {
return true;
}
return false;
}

rep2(i, 1, 10) {
if (use[i])
continue;
sans[x][y] = i;
if (srec(nx, ny)) {
return true;
}
sans[x][y] = -1;
}
return false;
}
void sudoku() {
vector<string> tb;

rep(i, 9) {
string s;
cin >> s;
tb.push_back(s);
rep(j, 9) {
if (tb[i][j] != '.') {
sans[i][j] = tb[i][j] - '0';
}
}
}
srec(0, 0);
rep(i, 9) {
rep(j, 9) {
cout << sans[i][j];
}
cout << endl;
}
}

//　ここまでライブラリ
// ここからコード

void solv() {
string s;
cin >> s;
n = s.size();
if (s[0] == '0' || s[n - 1] == '1') {
pln(-1); return;
}
rep(i, n / 2) {
if (s[i] != s[n - i - 2]) {
pln(-1);
return;
}
}
mat es(n + 1);
ll b = 1;
queue<ll> q;
rep2(i, 2, n) {
if (s[i - 1] == '1') {
while (!q.empty())
{
es[q.front()].push_back(i);
q.pop();
}
es[b].push_back(i);
b = i;
}
else {
q.push(i);
}
}
es[b].push_back(n);
rep2(i, 1, n) {
for (auto v : es[i]) {
pln(i << " " << v);
}
}
}
int main()
{
cin.tie(0);
ios::sync_with_stdio(false);
COMinit();
solv();
return 0;
}




#include <bits/stdc++.h>
#define int long long
#define Mid ((l + r) / 2)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
const int mod = 1e9 + 7;
const int N = 2e5 + 1009;
int n, m, k, vis[N];
int cut[N], dfn[N], low[N], dfntot, dc;
int head[N], nxt[N], ver[N], tot = 1;
vector<int> dcc[N];
void add(int x, int y) {
nxt[++tot] = head[x]; head[x] = tot; ver[tot] = y;
}
namespace v_dcc {
int s[N], t, root;
int es[N], et;
void tarjan(int x) {
dfn[x] = low[x] = ++dfntot;
s[++t] = x;
if(x == root && head[x] == 0) {
dcc[++dc].clear();
dcc[dc].push_back(x);
return ;
}
int flag = 0;
for(int i = head[x]; i; i = nxt[i]) {
int y = ver[i];
if(!dfn[y]) {
tarjan(y);
low[x] = min(low[x], low[y]);
if(low[y] >= dfn[x]) {
flag++;
if(x != root || flag > 1) cut[x] = true;
dcc[++dc].clear();
int z = -1;
while(z != y) {
z = s[t--];
dcc[dc].push_back(z);
}
dcc[dc].push_back(x);
}
} else low[x] = min(low[x], dfn[y]);
}
}
void get_cut() {
for(int i = 1; i <= n; i++)
if(!dfn[i])
tarjan(root = i);
}
}
int fac[N], inv[N];
int Pow(int a, int p) {
int ans = 1;
for( ; p; p >>= 1, a = a * a % mod)
if(p & 1)
ans = ans * a % mod;
return ans % mod;
}
void init() {
fac[0] = fac[1] = inv[0] = inv[1] = 1;
for(int i = 2; i < N; i++) fac[i] = fac[i - 1] * i % mod;
for(int i = 2; i < N; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for(int i = 2; i < N; i++) inv[i] = inv[i - 1] * inv[i] % mod;
}
int C(int n, int m) {
if(m < 0 || m > n) return 0;
return fac[n] * inv[n - m] % mod * inv[m] % mod;
}
signed main() {
#ifndef ONLINE_JUDGE
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
ios::sync_with_stdio(0);
cin.tie(0);
init();
cin >> n >> m >> k;
for(int i = 1; i <= m; i++) {
int x, y;
cin >> x >> y;
add(x, y);
add(y, x);
}
int ans = 1;
v_dcc::get_cut();
for(int t = 1; t <= dc; t++) {
memset(vis, 0, sizeof(int) * (n + 10));
for(auto x : dcc[t]) vis[x] = 1;
int mtot = 0;
for(auto x : dcc[t]) {
for(int i = head[x]; i; i = nxt[i]) {
if(vis[ver[i]]) {
mtot++;
}
}
}
mtot /= 2;
if(mtot == dcc[t].size()) {
int tmp = 0;
for(int i = 1; i <= dcc[t].size(); i++) {
tmp = (tmp + Pow(k, __gcd((int)dcc[t].size(), i))) % mod;
}
//            cout << tmp << endl;
tmp = tmp * Pow(dcc[t].size(), mod - 2) % mod;
//            cout << tmp << endl;
//            cout << dcc[t].size() << endl;
ans = (ans * tmp) % mod;
} else if(mtot > dcc[t].size()) {
//            cout << mtot << endl;
ans = (ans * C(mtot + k - 1, k - 1)) % mod;
} else {
//            cout << mtot << endl;
ans = (ans * Pow(k, mtot)) % mod;
}
}
cout << ans << endl;
return 0;
}
#include<bits/stdc++.h>
typedef long long int ll; typedef long double ld; using namespace std; const ll mod = 1e9 + 7, inf = 9e18; const ld pi = 2 * acos (0.0), eps = 1e-12;

const ll maxn = 100;
vector<ll> a(maxn + 10);
vector dp(maxn, vector(3, vector<ll> (2)));
ll n, m = 0;;

int main() {
ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
cin >> n;
for (; n; n >>= 1)
a[m++] = n & 1;
dp[0][1][0] = 1;
for (ll i = 0; i < m; ++i) {
for (ll j = 0; j < 3; ++j) {
for (ll k = 0; k < 2; ++k) {
for (ll x = 0; x < 2; ++x) {
for (ll y = 0; y <= x; ++y) {
ll v = (x + y + k) & 1, u = 0, w = (x + y + k) >> 1;
if (v == a[i])
u = j;
else if (v > a[i])
u = 2;
dp[i + 1][u][w] = (dp[i + 1][u][w] + dp[i][j][k]) % mod;
}
}
}
}
}
cout << (dp[m][0][0] + dp[m][1][0]) % mod << "\n";
return 0;
}
#include<bits/stdc++.h>
#define endl "\n"
using namespace std;
int main()
{
ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);

int n,i,x,mx=0,r=0;
cin>>n;
map<int,int>mp;
for(i=0;i<n;i++){
cin>>x;
if(mp.count(x)==1)mp[x]++;
else mp[x]=1;
if(mp[x]==x)r+=x;
}

cout<<n-r<<endl;

return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll maxn = 1e5 + 5;
const ll maxm = 1e3 + 5;
namespace IO{
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc(){
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread(){}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls){
T1 __ = 0, ___ = 1;
char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do{
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
inline void flush(){
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x){
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite(){}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls){
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
struct Flusher_{~Flusher_(){flush();}}io_flusher;
}
namespace rndom{
mt19937 mtrnd(std::chrono::system_clock::now().time_since_epoch().count());
ll rnd(ll x){return mtrnd() % x;}
ll rndrg(ll l, ll r){return l + rnd(r - l + 1);}
template<class T>
void rndshfl(T *pt, T *ed){
ll len = ed - pt;
for(int i = 0;i < len;i++) swap(pt[i], pt[rnd(len)]);
return ;
}
}
using namespace IO; using namespace rndom;
ll A, B;
ll d[15][15];
ll p[105][105];
ll n = 202, s = 1, t = 102;
set<pair<ll, ll>> se;
ll G[305][305];
void add(ll u, ll v, ll w){
G[u][v] = w; se.insert(make_pair(u, v)); return ;
}
int main(){
ios::sync_with_stdio(0);
cin.tie(0); cout.tie(0);
cin >> A >> B;
for(int i = 1;i <= A;i++){
for(int j = 1;j <= B;j++){
cin >> d[i][j];
}
}
for(int i = 0;i <= 100;i++){
for(int j = 0;j <= 100;j++){
for(int k = 1;k <= A;k++){
for(int w = 1;w <= B;w++){
p[i][j] = max(p[i][j], d[k][w] - k * i - w * j);
}
}
// cout << p[i][j] << " \n"[j == 100];
}
}
for(int i = 1;i <= 300;i++){
for(int j = 1;j <= 300;j++){
G[i][j] = 1e9;
}
}
for(int i = 1;i <= 100;i++) add(i, i + 1, -1);
for(int i = 102;i <= 201;i++) add(i + 1, i, -2);
for(int i = 1;i <= A;i++){
for(int j = 1;j <= B;j++){
ll tx = -1, ty = -1;
for(int k = 0;k <= 100;k++){
for(int w = 0;w <= 100;w++){
if(p[k][w] + k * i + w * j == d[i][j]) tx = k, ty = w;
}
}
if(tx == -1 && ty == -1){
cout << "Impossible" << endl; return 0;
}
add(tx + 1, ty + 102, p[tx][ty]);
}
}
cout << "Possible" << endl;
cout << n << " " << se.size() << endl;
for(auto [u, v] : se){
if(G[u][v] == -1) cout << u << " " << v << " X" << endl;
else if(G[u][v] == -2) cout << u << " " << v << " Y" << endl;
else cout << u << " " << v << " " << G[u][v] << endl;
}
cout << s << " " << t << endl;
return 0;
}


#include<bits/stdc++.h>
using namespace std;
int disF[100000+5],disS[100000+5];
vector <int> G[100000+5];
int main()
{
ios::sync_with_stdio(0);
cin.tie(0);
int n,Fen=0,Snu=0;
cin>>n;
int m=n-1;
while(m--)
{
int u,v;
cin>>u>>v;
G[u].push_back(v);
G[v].push_back(u);
}
for(int i=0;i<=n;++i)
{
disF[i]=disS[i]=-1;
}
queue <int> Q;
Q.push(1);
disF[1]=0;
while(!Q.empty())
{
int x=Q.front();
Q.pop();
for(int i=0;i<G[x].size();++i)
{
if(disF[G[x][i]]==-1)
{
disF[G[x][i]]=disF[x]+1;
Q.push(G[x][i]);
}
}
}
Q.push(n);
disS[n]=0;
while(!Q.empty())
{
int x=Q.front();
Q.pop();
for(int i=0;i<G[x].size();++i)
{
if(disS[G[x][i]]==-1)
{
disS[G[x][i]]=disS[x]+1;
Q.push(G[x][i]);
}
}
}
for(int i=1;i<=n;++i)
{
if(disF[i]<=disS[i])
{
++Fen;
}
else
{
++Snu;
}
}
if(Fen>Snu)
{
cout<<"Fennec"<<endl;
}
else
{
cout<<"Snuke"<<endl;
}
return 0;
}

#include<bits/stdc++.h>
/*
#include<atcoder/all>
using namespace atcoder;
//using mint = modint1000000007;
using mint = modint998244353;
*/
//g++ -I/opt/ac-library ./**.cpp
using namespace std;
using ll = long long;
using ull = unsigned long long;
//const long long MOD = 1000000007;
const long long MOD = 998244353;
const long double PI = 3.14159265358979;
const long long INF = 1LL<<60;
template <typename T> bool chmax(T &a, const T& b){if(a < b){a = b;return true;}return false;}
template <typename T> bool chmin(T &a, const T& b){if(a > b){a = b;return true;}return false;}
#define deb(var) do{cout << #var << " : "; view(var);}while(0)
template<typename T> void view(T e){cout << e << endl;}
void view(vector<string>& v){cout << endl;for(auto& s :v){view(s);}cout << endl;}
template<typename T> void view(vector<T>& v){for(auto& e :v){cout << e << " ";}cout << endl;}
template<typename T> void view(vector<vector<T>>& vv){cout << endl;for(auto& v:vv){view(v);}}
ll gcd(ll a, ll b){if (b == 0) return a;else return gcd(b, a % b);}
ll lcm(ll x,ll y){return ll(x/gcd(x,y))*y;}
template<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define int long long

bool valid(int i, int j, int h, int w) {
if(0<=i and 0<=j and i<h and j<w) return true;
else return false;
}

int32_t main() {
int h, w; cin >> h >> w;
int n; cin >> n;
vector<int> A(n), vec;
for (int i=0; i<n; i++) {
cin >> A[i];
for (int j=0; j<A[i]; j++) vec.push_back(i);
}

vector<vector<int>> ans(h, vector<int> (w));
int di = 1;
for (int i=0; i<h; i++) {
for (int j=0; j<w; j++) {
if (i % 2 == 0) {
ans[i][j] = vec[w * i + j];
}
else {
ans[i][w - 1 - j] = vec[w * i + j];
}
}
}
for (int i=0; i<h; i++) {
for (int j=0; j<w; j++) {
cout << ans[i][j] + 1 << " ";
}
cout << endl;
}
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
int dp[55][55][55*55], n, a, x[55];
int go(int pos, int tkn, int sum){
if(pos == n){
if(tkn && a*tkn == sum)
return 1;
return 0;
}
int &e = dp[pos][tkn][sum];
if(e == -1){
e = go(pos + 1, tkn, sum);
e += go(pos + 1, tkn + 1, sum + x[pos]);
}
return e;
}
void solve(){ 
cin>>n>>a;
for(int i=0; i<n; i++)
cin>>x[i];
mem(dp, -1);
cout<<go(0, 0, 0)<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>
using namespace std;
long long c[2010][2010],n,a,b,moddr,result,m;

int main(){
cin>>n>>m;
moddr=1e9+7;
result=1;
a=max(n,m);
b=min(n,m);
if((a-b)>1){
cout<<0<<endl;
return 0;
}
if((a-b)==0){
result =2;
for(long long i=1;i<=a;i++){
result=(result*i)%(moddr);
result=(result*i)%(moddr);
}
cout<<result<<endl;
return 0;
}
else{
for(long long i=1;i<=a;i++){
if(i==a){
result=(result*i)%(moddr);
}
else{
result=(result*i)%(moddr);
result=(result*i)%(moddr);
}
}
cout<<result<<endl;
return 0;
}
}

#include<bits/stdc++.h>
using namespace std;
#define N 100010
typedef long long ll;
int n,a[N];
class BIT{
int Len;
vector<int> b;
inline int lowbit(int x){
return x&(-x);
}
public:
BIT(int _n):Len(_n){
b.resize(_n+1);
}
inline void Add(int x,int d){
while(x<=Len)b[x]+=d,x+=lowbit(x);
}
inline int Ask(int x){
int ans=0;
while(x)ans+=b[x],x-=lowbit(x);
return ans;
}
};
ll check(int t){
BIT B(n<<1|1);
B.Add(n+1,1);
int now=0;
ll jb=0;
for(int i=1;i<=n;++i){
now+=a[i]>=t?1:-1;
jb+=B.Ask(now+n+1);
B.Add(now+n+1,1);
}
return jb;
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n;
for(int i=1;i<=n;++i){
cin>>a[i];
}
ll MD=(1LL*n*(n+1)/2+1)/2;
int l=1,r=1e9+1,ans=0;
while(l<r){
int mid=(l+r)>>1;
if(check(mid)>=MD){
ans=mid,l=mid+1;
}
else{
r=mid;
}
}
cout<<ans<<'\n';
return 0;
}



#include<cstdio>
#include<algorithm>
using namespace std;
const int N=2e5+10;
struct point{
long long valx,valy,tag;
int ls,rs;
}t[N*4];
int tot;
int n,q,a,b;
long long pos[N];
void pushupx(int k)
{
t[k].valx=1e14;
if(t[k].ls)
t[k].valx=min(t[t[k].ls].valx,t[k].valx);
if(t[k].rs)
t[k].valx=min(t[t[k].rs].valx,t[k].valx);
}
void pushupy(int k)
{
t[k].valy=1e14;
if(t[k].ls)
t[k].valy=min(t[t[k].ls].valy,t[k].valy);
if(t[k].rs)
t[k].valy=min(t[t[k].rs].valy,t[k].valy);
}
void pushdown(int k)
{
if(t[k].tag)
{
if(t[k].ls)
t[t[k].ls].valx+=t[k].tag,t[t[k].ls].valy+=t[k].tag,t[t[k].ls].tag+=t[k].tag;
if(t[k].rs)
t[t[k].rs].valx+=t[k].tag,t[t[k].rs].valy+=t[k].tag,t[t[k].rs].tag+=t[k].tag;
t[k].tag=0;
}
}
void changex(int &k,int l,int r,int pos,long long val)
{
if(!k)
k=++tot,t[k].valx=t[k].valy=1e14;
if(l==r)
{
t[k].valx=val;
return ;
}
pushdown(k);
int mid=(l+r)>>1;
if(pos<=mid)
changex(t[k].ls,l,mid,pos,val);
else
changex(t[k].rs,mid+1,r,pos,val);
pushupx(k);
}
void changey(int &k,int l,int r,int pos,long long val)
{
if(!k)
k=++tot,t[k].valx=t[k].valy=1e14;
if(l==r)
{
t[k].valy=val;
return ;
}
pushdown(k);
int mid=(l+r)>>1;
if(pos<=mid)
changey(t[k].ls,l,mid,pos,val);
else
changey(t[k].rs,mid+1,r,pos,val);
pushupy(k);
}
long long queryx(int k,int l,int r,int x,int y)
{
if(!k)
return 1e14;
if(x<=l&&r<=y)
return t[k].valx;
pushdown(k);
int mid=(l+r)>>1;
long long ret=1e14;
if(x<=mid)
ret=min(ret,queryx(t[k].ls,l,mid,x,y));
if(y>mid)
ret=min(ret,queryx(t[k].rs,mid+1,r,x,y));
return ret;
}
long long queryy(int k,int l,int r,int x,int y)
{
if(!k)
return 1e14;
if(x<=l&&r<=y)
return t[k].valy;
pushdown(k);
int mid=(l+r)>>1;
long long ret=1e14;
if(x<=mid)
ret=min(ret,queryy(t[k].ls,l,mid,x,y));
if(y>mid)
ret=min(ret,queryy(t[k].rs,mid+1,r,x,y));
return ret;
}
int rt=0;
long long ff(long long x)
{
if(x<0)
return -x;
return x;
}
long long query(int k,int l,int r)
{
if(!k)
return 1e14;
if(l==r)
return t[k].valx+l;
pushdown(k);
int mid=(l+r)>>1;
long long ret=1e14;
ret=min(ret,query(t[k].ls,l,mid));
ret=min(ret,query(t[k].rs,mid+1,r));
return ret;
}
int main()
{
scanf("%d %d %d %d",&n,&q,&a,&b);
for(int i=1;i<=q;i++)
scanf("%lld",pos+i);
pos[0]=a;
changex(rt,1,n,b,-b),changey(rt,1,n,b,b);
for(int i=1;i<=q;i++)
{
long long sum=min(queryx(rt,1,n,1,pos[i])+pos[i],queryy(rt,1,n,pos[i],n)-pos[i]),num=ff(pos[i]-pos[i-1]);
t[rt].valx+=num;
t[rt].valy+=num;
t[rt].tag+=num;
changex(rt,1,n,pos[i-1],sum-pos[i-1]);
changey(rt,1,n,pos[i-1],sum+pos[i-1]);
}
printf("%lld\n",query(rt,1,n));
return 0;
}
#include<bits/stdc++.h>
using namespace std;

int main(int argc, char const *argv[])
{
int n;
cin >> n;

map<int, int>mp;
for (int i = 0; i < n; i++){
int x;
cin >>  x;
mp[x]++;
}

// for (auto it = mp.begin(); it!=mp.end() ; it++){
//     cout << it->first << " " << it->second << endl;
// }
int sum=0;
for (auto it = mp.begin(); it!=mp.end() ; it++)
{
if(it->second < it->first){
sum += (it->second);
}
if(it->second > it->first){
sum += (it->second - it->first);
}
}
cout << sum << endl;
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }
int h, w;
int fa() {
//縦割り
if (w % 3 == 0) return 0;
return h;
}
int fb() {
//横割り
if (h % 3 == 0) return 0;
return w;
}
int fc() {
int tmp = 1LL << 60;
for (int i = 1; i < w; i++) {
int cur = i * h;
if (h % 2 == 0) {
int sec = (h * w - cur) / 2;
chmin(tmp, max({cur, sec}) - min({cur, sec}));
} else {
int mid = (h + 1) / 2;
int sec = mid * (w - i);
int third = h * w - cur - sec;
chmin(tmp, max({cur, sec, third}) - min({cur, sec, third}));
}
}
return tmp;
}
int f() { return min({fa(), fb(), fc()}); }
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
cin >> h >> w;
int ans = 1LL << 60;
chmin(ans, f());
swap(h, w);
chmin(ans, f());
cout << ans << endl;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

inline void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

inline int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
n = read();
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
c[i][j] = read();
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
printf("%lld\n", ans / 6);
return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5e7 + 10;
const int MOD = 1e9 + 7;
bool vis[maxn];
int prime[maxn / 10], tot;
void init(int n)
{
vis[1] = 1;
int up = sqrt(n);
for(int i = 1; i <= n; i++)if(!vis[i])
{
prime[++tot] = i;
if(i <= up)
for(int j = i * i; j <= n; j += i)
vis[j] = 1;
}
//cout<<tot<<endl;
}

bool not_prime[maxn];
void Prime_sieve(int n)
{
not_prime[1] = 1;
for(int i = 1; i <= n; i++)
{
if(!not_prime[i])prime[++tot] = i;
for(int j = 1; j <= tot && 1LL * prime[j] * i <= n; j++)
{
not_prime[prime[j] * i] = 1;//每个合数x由它最小素因子prime[j]筛掉
if(i % prime[j] == 0)break;//如果i % prime[j] == 0,不停止循环
//那么接下来将用prime[j+1]筛去i*prime[j+1]，但实际上应该用prime[i]筛去,因为i%prime[j]==0
}
}
///cout<<tot<<endl;
}

int f(int n, int x)
{
int ans = 0;
while(n)
{
ans += n / x;
n /= x;
}
return ans;
}
int main()
{
int n;
cin >> n;
Prime_sieve(n);
ll ans = 1;
for(int i = 1; i <= tot; i++)
ans = ans * (f(n, prime[i]) + 1) % MOD;
cout<<ans<<endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std;

#ifdef DEBUG
#include "debug.hpp"
#else
#define dbg(...) void(37)
#endif

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
int n;
cin >> n;
vector<int> a(n + 2);
vector<long long> b(n + 2);
for (int i = 1; i <= n; ++i) {
cin >> a[i];
b[i] = b[i - 1] + abs(a[i] - a[i - 1]);
}
b[n + 1] = b[n] + abs(0 - a[n]);
dbg(b);
for (int i = 1; i <= n; ++i) {
long long ans = b[i - 1] + abs(a[i - 1] - a[i + 1]) + (b[n + 1] - b[i + 1]);
cout << ans << '\n';
}
}

#include<bits/stdc++.h>

using namespace std;

#define debug(x) cout << '[' << #x << " is: " << x << "] " << endl;
#define imod(a , n) (a % n + n ) % n

#define ll long long
#define int ll
#define logar(x , y) log(x) / log(y)
#define __sum(n) n * (n + 1) / 2
#define __lcm(a , b) a / __gcd(a , b) * b
#define pii pair<int , int >
const int N = 3e5 + 1 ,  M = N * 4 , MX = 2e4 + 40;
const ll MOD = 1e9+ 7 , oo = 1e9 + 9 , OO = 1e18 ;//, mod = MOD ;
const double pi = acos(-1) , eps = 1e-17 ;

int di[] = {1 , -1 , 0 , 0};
int dj[] = {0 , 0 , -1 , 1};

//challenge : 97915 left





int32_t main()
{   //inF;
//inF;outF;
//    fastio;


int n ;
cin >> n ;


string ans = "Yes";
int x = 0 , y = 0 ;
int t = 0;

while(n--){
int a , b , ti;
cin >> ti >> a >> b ;

int dt = ti - t ;
int dxy = abs(x - a) + abs(y - b);

if(dt < dxy)ans = "No";
else {
dt -= dxy ;
if(dt % 2)ans = "No";
}
x = a , y = b;

t = ti ;

}

cout << ans ;

}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
int n,z,w;
cin>>n>>z>>w;
vi a(n);
rep(i,n) cin>>a[i];
int l=-1,h=1e9+7,max_l=-1,min_h=1e9+7;
for(int i=n-2;i>=0;i--){
h=max(max_l,abs(a[i]-a[n-1]));
l=min(min_h,abs(a[i]-a[n-1]));
min_h=min(h,min_h);
max_l=max(l,max_l);
// cout<<min_h<<" "<<max_l<<endl;
}
h=max(max_l,abs(w-a[n-1]));
// cout<<min_h<<" "<<max_l<<endl;
cout<<h<<endl;
}
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x; i<=y; ++i)

using namespace std;
const int N=3005,mod=1000000007;
typedef long long LL;
int n,m,sum[N],tot;
char s[N];
LL c[N][N],f[N][N];
struct D{int l,r;} dat[N];

int get(D a,D b)
{
if(a.r<b.l) return 0;
return a.r-b.l+1;
}

int get(int l,int r)
{
if(l>r) return 0;
return sum[r]-sum[l-1];
}

int main()
{
scanf("%d%d",&n,&m);
scanf("%s",s+1);
rep(i,1,m) scanf("%d%d",&dat[i].l,&dat[i].r);
tot=0;
rep(i,1,m)
{
if(i==1 || dat[tot].l<dat[i].l && dat[tot].r<dat[i].r) dat[++tot]=dat[i];
else if(dat[tot].l==dat[i].l && dat[tot].r<dat[i].r) dat[tot]=dat[i];
}
rep(i,0,n) c[i][0]=1;
rep(i,1,n) rep(j,1,i) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
rep(i,1,n) sum[i]=sum[i-1]+(s[i]=='1');
m=tot,dat[m+1]=(D){n+1,n+1};
f[0][0]=1;
rep(i,1,m)
{
rep(j,0,n) if(f[i-1][j])
{
LL tmp=f[i-1][j];
int x=j+get(max(dat[i-1].r+1,dat[i].l),dat[i].r);
int y=get(dat[i],dat[i+1]);
int z=dat[i].r-dat[i].l+1;
rep(k,0,min(x,y)) f[i][k]=(f[i][k]+tmp*c[z-y][x-k])%mod;
}
}
printf("%lld\n",f[m][0]);
return 0;
}
// clang-format off
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
template<class T> using V = vector<T>;
using VI = V<int>;
using VL = V<ll>;
using VS = V<string>;
template<class T> using PQ = priority_queue<T, V<T>, greater<T>>;
using graph = V<VI>;
template<class T> using w_graph = V<V<pair<int, T>>>;
#define FOR(i,a,n) for(int i=(a);i<(n);++i)
#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)
#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)
#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define inside(h,w,y,x) (unsigned(y)<h&&unsigned(x)<w)
#ifndef ONLINE_JUDGE
#define line cout << "-----------------------------\n"
#define stop system("pause")
#endif
constexpr ll INF = 1000000000;
constexpr ll LLINF = 1LL << 61;
constexpr ll mod = 1000000007;
constexpr ll MOD = 998244353;
constexpr ld eps = 1e-10;
constexpr int dy[]{ -1,0,1,0 }, dx[]{ 0,1,0,-1 };
template<class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }
template<class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }
inline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }
template<class T> inline istream& operator>>(istream& is, V<T>& v) { for (auto& a : v)is >> a; return is; }
template<class T, class U> inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template<class T> inline V<T> vec(size_t a) { return V<T>(a); }
template<class T> inline V<T> defvec(T def, size_t a) { return V<T>(a, def); }
template<class T, class... Ts> inline auto vec(size_t a, Ts... ts) { return V<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }
template<class T, class... Ts> inline auto defvec(T def, size_t a, Ts... ts) { return V<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }
template<class T> inline void print(const T& a) { cout << a << "\n"; }
template<class T, class... Ts> inline void print(const T& a, const Ts&... ts) { cout << a << " "; print(ts...); }
template<class T> inline void print(const V<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? "\n" : " "); }
template<class T> inline void print(const V<V<T>>& v) { for (auto& a : v)print(a); }
template<class T> inline constexpr const T cumsum(const V<T>& a, int l, int r) { return 0 <= l && l <= r && r < a.size() ? a[r] - (l == 0 ? 0 : a[l - 1]) : 0; }//[l,r]
template<class T> inline constexpr const T min(const V<T>& v) { return *min_element(all(v)); }
template<class T> inline constexpr const T max(const V<T>& v) { return *max_element(all(v)); }
// clang-format on

template <class T> class compress {
vector<T> xs;

public:
compress() {}
compress(const vector<T>& vs) { add(vs); }
inline void add(const vector<T>& vs) { copy(all(vs), back_inserter(xs)); }
inline void add(const T& x) { xs.emplace_back(x); }
inline void build() {
sort(all(xs));
xs.erase(unique(all(xs)), xs.end());
}
inline int idx(const T& x) const { return lower_bound(all(xs), x) - xs.begin(); }
inline T operator[](int k) const { return xs[k]; }
inline int size() const { return xs.size(); }
};

template <class T> class BinaryIndexedTree {
int n;
vector<T> dat;

public:
BinaryIndexedTree(int n) : n(n), dat(n + 1){};
BinaryIndexedTree(int n, T a) : n(n), dat(n + 1) {
eFOR(i, 1, n) {
dat[i] += a;
if (i + (i & -i) <= n) dat[i + (i & -i)] += dat[i];
}
}
BinaryIndexedTree(VI v) : n(v.size()), dat(n + 1) {
eFOR(i, 1, n) {
dat[i] += v[i - 1];
if (i + (i & -i) <= n) dat[i + (i & -i)] += dat[i];
}
}
void add(int i, T a) {
for (++i; i <= n; i += i & -i) dat[i] += a;
}
T sum(int r) {  // sum of [0,r)
T res = 0;
for (; r; r -= r & -r) res += dat[r];
return res;
}
T sum(int l, int r) {  // sum of [l,r)
if (l < 0 || n < r || l > r) return 0;
return sum(r) - sum(l);
}
int lower_bound(T a) {
int res = 0, k = 1;
for (; k * 2 <= n; k *= 2)
;
for (; k; k /= 2) {
if (res + k <= n && a > dat[res + k]) {
a -= dat[res + k];
res += k;
}
}
return res;
}
};

int main() {
init();

int n, k;
cin >> n >> k;
VL a(n);
FOR(i, 0, n) {
cin >> a[i];
a[i] -= k;
}
VL b = a;
FOR(i, 1, n) b[i] += b[i - 1];
compress comp(b);
comp.add(0);
comp.build();
BinaryIndexedTree<int> bit(comp.size());
bit.add(comp.idx(0), 1);
ll ans = 0;
FOR(i, 0, n) {
ans += bit.sum(0, comp.idx(b[i]) + 1);
bit.add(comp.idx(b[i]), 1);
}
print(ans);

return 0;
}
#include <iostream>
#include <cmath>
using namespace std;
long long x,y;
int main()
{
cin>>x>>y;
if(abs(x-y)<=1)
{
cout<<"Brown"<<endl;
}
else
{
cout<<"Alice"<<endl;
}
return 0;
} 
//2 1
//Brown
//5 0
//Alice
//
//
//
//
//
// 
#include<bits/stdc++.h>

#define     ll      long long
#define     ld      long double
#define     ull     unsigned long long
#define     fi      first
#define     se      second
#define     ii      pair<int,int>
#define     li      pair<ll,int>
#define     il      pair<ll,ll>
#define     spei    pair<il,il>
#define     iii     pair<int,ii>

using namespace std;
///===========================================
void rose()
{
ios::sync_with_stdio(0);
cin.tie(0);cout.tie(0);
}
void pk()
{
#ifndef ONLINE_JUDGE
freopen("dtsumxor.INP","r",stdin);
freopen("dtsumxor.OUT","w",stdout);
#endif // ONLINE_JUDGE
}
///===========================================
const ll mod = 1e9+7;
const ll md = 1e18;
const int base = 1e6 + 3;
///===========================================
int n , a[200005] , vt ;
ll kq = 0, st[800005];
///===========================================
bool check(int v1,int val)
{
for (int i = 0; i <= 20; i++)
if ( ((a[v1]>>i)&1) && ((val>>i)&1) ) return false;
return true;
}
///===========================================
void build(int id,int i,int j)
{
if ( i == j )
{
st[id] = a[i];
return ;
}
int m = (i+j)/2;
build(2*id,i,m);
build(2*id+1,m+1,j);
st[id] = st[2*id] | st[2*id+1];
}
///===========================================
ll get(int id,int i,int j,int l,int r)
{
if ( l > j || r < i ) return 0;
if ( l <= i && j <= r ) return st[id];
int m = (i+j)/2;
return get(2*id,i,m,l,r) | get(2*id+1,m+1,j,l,r);
}
///===========================================
///===========================================
///===========================================
///===========================================
int main()
{
pk(); rose();
cin >> n;
for (int i = 1; i <= n; i++) cin >> a[i];
/*if ( n <= 10000 )
{
for (int i = 1; i <= n; i++)
{
ll xr = 0 , s = 0;
for (int j = i; j <= n; j++)
{
xr ^= a[j];
s += a[j];
if ( xr == s ) kq ++;
}
}
cout << kq;
return 0;
}*/
build(1,1,n);
int gt = 0;
vt = 1;
for (int i = 1; i <= n; i++)
{
if ( check(i,gt) == false )
{
int v1 = vt , v2 = i-1 , pos = i;
while ( v1 <= v2 )
{
int mid = (v1+v2)/2;
if ( check(i,get(1,1,n,mid,i-1)) )
{
pos = mid;
v2 = mid - 1;
}
else v1 = mid + 1;
}
gt = get(1,1,n,pos,i-1);
vt = pos;
}
gt |= a[i];
kq += i-vt+1;
//cout << vt <<" "<< i <<" "<< gt <<"\n";
}
cout << kq;
}
///===========================================


#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=3005,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int a,b,c,d,e,f,dp1[maxn],dp2[maxn],res1=1,res2=0;

void orzck(){
cin >> a >> b >> c >> d >> e >> f;
dp1[0]=dp2[0]=1;
rep2(i,1,maxn){
if(i>=a) dp1[i]|=dp1[i-a];
if(i>=b) dp1[i]|=dp1[i-b];
if(i>=c) dp2[i]|=dp2[i-c];
if(i>=d) dp2[i]|=dp2[i-d];
}
rep(31) rep1(j,maxn) if(dp1[i]&&dp2[j]&&j<=i*e&&i*100+j<=f){
if(j*res1>=res2*i) res1=i,res2=j;
}
print(100*res1+res2,res2);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
#include<tr1/unordered_map>
using namespace std;
#define ll long long
#define ull unsigned long long
#define int long long
#define N 5005
const ll mod = 1e9+7;
const ll inf = 1e17;
const double eps = 1e-3;
const int INF = 1e7;
inline ll read()
{
ll f=0,g=1;
char ch=getchar();
while(ch<'0'||ch>'9') {if(ch=='-') g=-1;ch=getchar();}
while(ch>='0'&&ch<='9') {f=(f<<1)+(f<<3)+ch-'0';ch=getchar();}
return f*g;
}

struct Edge
{
int to,next;
}e[N<<2];

ll f[N][N],g[N],tmp[N];
int n,siz[N];
int head[N],cnt;

void add_edge(int x,int y)
{
e[++cnt]={y,head[x]};
head[x]=cnt;
}

void dfs(int now,int fa)
{
f[now][siz[now]=1]=1;
for(int i=head[now];i;i=e[i].next)
{
int to=e[i].to;
if(to==fa) continue;
dfs(to,now);
for(int i=1;i<=siz[now]+siz[to];i++) tmp[i]=0;
for(int i=1;i<=siz[now];i++) for(int j=0;j<=siz[to];j++) 
(tmp[i+j]+=f[now][i]*f[to][j]%mod)%=mod;
for(int i=1;i<=siz[now]+siz[to];i++) f[now][i]=tmp[i];
siz[now]+=siz[to];
}
for(int i=2;i<=siz[now];i+=2) (f[now][0]+=mod-f[now][i]*g[i]%mod)%=mod;
}

signed main()
{ 
g[0]=1;
n=read();
for(int i=2;i<=n;i+=2) g[i]=g[i-2]*(i-1)%mod;
for(int i=1,x,y;i<n;i++) x=read(),y=read(),add_edge(x,y),add_edge(y,x);
dfs(1,0);
printf("%lld\n",mod-f[1][0]);
return 0;
}

/*
5 6 1 5
1 2 3
1 3 5
2 3 1
3 4 10
4 5 1
3 5 8

*/

#include<stdio.h>

#define int long long
int s[200010], n;
int abs(int a) {
return a > 0 ? a : -a;
}
int min(int i, int j) {
return i < j ? i : j;
}
signed main() {
scanf("%lld", &n);
for(int i = 1; i <= n; ++i) {
int a;
scanf("%lld", &a);
s[i] = s[i - 1] + a;
}
int ans = (int)1e15;
for(int i = 1; i < n; ++i) {
int S = s[i], R = s[n] - s[i];
ans = min(ans, abs(S - R));
}
printf("%lld", ans);
return 0;
}
#include "bits/stdc++.h"
using namespace std;

#define rep(i, a, b) for(int i=a; i<=b; i++)
#define all(x) begin(x), end(x)
#define sz(x) (int) x.size()
#define f first
#define s second
#define nl "\n"
#define pb push_back
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
const int MOD=1e9+7;

const int N=100001;
int n, m;
vector<pii> adj[N];
int par[N];
int dist[N];
bool vis[N];

int find(int x){
if(par[x]==x) return x;
return par[x]=find(par[x]);
}

void join(int x, int y, int d){
if(find(x)==find(y)) return;
adj[x].push_back({y, d});
adj[y].pb({x, -d});
par[find(x)]=find(y);
}

void dfs(int x){
vis[x]=1;
for(auto e:adj[x]){
if(vis[e.f]) continue;
dist[e.f]=e.s+dist[x];
dfs(e.f);
}
}

int main(){
cin.tie(0)->sync_with_stdio(0);

cin >> n >> m;
rep(i,1,n) par[i]=i;
vector<vi> edges;
while(m--){
int l, r, d; cin >> l >> r >> d;
join(l, r, d);
edges.pb({l, r, d});
}

rep(i,1,n){
if(!vis[i]) dfs(i);
}
for(auto e:edges){
if(dist[e[1]]-dist[e[0]]!=e[2]){
cout << "No"; return 0;
}
}
cout << "Yes";
}

// but it's always been you
#include<bits/stdc++.h>
using namespace std;
#define inf 1e9
const int maxn=2e5+10;
const int mod=1e9+7;
inline int read(){
int x=0,f=1;char c=getchar();
while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
return x*f;
}
vector<int>G[maxn];
#define pb push_back
int n,m,cd[maxn],p[maxn],vis[maxn];
queue<int>q;
int flg[maxn],col[maxn];
int st[maxn],top,rt;
int main(){
n=read();
for(int i=1,x;i<=n;i++){
x=read(),cd[x]++;
G[x].pb(i),p[i]=x;
}
for(int i=1;i<=n;i++)
if(!cd[i])q.push(i);
while(!q.empty()){
int x=q.front();q.pop();vis[x]=1;
for(int i=0;i<G[x].size();i++)
flg[col[G[x][i]]]=1;
while(flg[col[x]])++col[x];
for(int i=0;i<G[x].size();i++)
flg[col[G[x][i]]]=0;
--cd[p[x]];if(!cd[p[x]])q.push(p[x]);
}
for(int i=1;i<=n;i++)
if(!vis[i]){rt=i;break;}
int now=p[rt];st[++top]=rt;
while(now!=rt)st[++top]=now,now=p[now];
for(int i=0;i<G[rt].size();i++)
if(vis[G[rt][i]])flg[col[G[rt][i]]]=1;
while(flg[col[rt]])++col[rt];
for(int i=0;i<G[rt].size();i++)
if(vis[G[rt][i]])flg[col[G[rt][i]]]=0;
for(int i=2;i<=top;i++){
for(int j=0;j<G[st[i]].size();j++)
flg[col[G[st[i]][j]]]=1;
while(flg[col[st[i]]])++col[st[i]];
for(int j=0;j<G[st[i]].size();j++)
flg[col[G[st[i]][j]]]=0;
}
int res=0;
for(int i=0;i<G[rt].size();i++)
flg[col[G[rt][i]]]=1;
while(flg[res])++res;
for(int i=0;i<G[rt].size();i++)
flg[col[G[rt][i]]]=0;
if(res==col[rt])return puts("POSSIBLE")&0;
col[rt]++;
for(int i=0;i<G[rt].size();i++)
if(vis[G[rt][i]])flg[col[G[rt][i]]]=1;
while(flg[col[rt]])++col[rt];
for(int i=0;i<G[rt].size();i++)
if(vis[G[rt][i]])flg[col[G[rt][i]]]=0;
for(int i=2;i<=top;i++){
col[st[i]]=0;
for(int j=0;j<G[st[i]].size();j++)
flg[col[G[st[i]][j]]]=1;
while(flg[col[st[i]]])++col[st[i]];
for(int j=0;j<G[st[i]].size();j++)
flg[col[G[st[i]][j]]]=0;
}
res=0;
for(int i=0;i<G[rt].size();i++)
flg[col[G[rt][i]]]=1;
while(flg[res])++res;
for(int i=0;i<G[rt].size();i++)
flg[col[G[rt][i]]]=0;
if(res==col[rt])return puts("POSSIBLE")&0;
puts("IMPOSSIBLE");
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

int a, b, c, d, e, f;

int main() {
qread(a, b, c, d, e, f);
Ld mx = 1.0 * e / 100;
Ld ans = -1; int w, s;
rep(i, 0, f / (100 * a)) rep(j, 0, f / (100 * b)) {
if(!i && !j) continue;
int nww = (i * a + j * b) * 100;
if(nww > f) continue;
rep(k, 0, f / c) rep(l, 0, f / d) {
int nws = k * c + l * d;
if(nww + nws > f || 1.0 * nws / nww > mx) continue;
if(1.0 * nws / (nww + nws) > ans) {
ans = 1.0 * nws / (nww + nws);
w = nww;
s = nws;
}
}
}
cout << s + w << ' ' << s << endl;
return 0;
}
#include<bits/stdc++.h>
const int N = 1e5 + 10;
const int M = 1e6 + 10;
using namespace std;
int n, m, t;
priority_queue<pair<int,int>> q;
vector<int> v[N];
int val[N], flag = 0;
bool vis[N];
void check(int x, int fa) {
for(int i = 0; i < v[x].size(); i ++) {
if(v[x][i] == fa) continue;
if(abs(val[v[x][i]] - val[x]) != 1) flag = 1;
check(v[x][i], x);
}
}
signed main(){
cin >> n;
for(int i = 1; i < n; i ++) {
int x, y;
cin >> x >> y;
v[x].push_back(y); v[y].push_back(x);
}
cin >> m;
for(int i = 1; i <= m; i ++) {
int x, y;
cin >> x >> y;
q.push({y, x});
vis[x] = 1; val[x] = y;
}
while(!q.empty()) {
int x = q.top().second; q.pop();
for(int i = 0; i < v[x].size(); i ++) {
if(vis[v[x][i]]) continue;
vis[v[x][i]] = 1; val[v[x][i]] = val[x] - 1;
q.push({val[v[x][i]], v[x][i]});
}
}
check(1, 0);
if(flag) cout << "No" << endl;
else {
cout << "Yes" << endl;
for(int i = 1; i <= n;  i ++) {
cout << val[i] << endl;
}
}
return 0;
}
// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline ll read(){
ll x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

//#define zz

const int maxn=300005;

int P[maxn],N;

void WA(int type){
#ifdef zz
printf("No %d\n",type);
#else
puts("No");
#endif
exit(0);
}
void sol(int l,int r){
while(l<=r&&P[l]==l)l++;
while(l<=r&&P[r]==r)r--;
if(l>r)return;
int mn=1e9,mx=-1e9;
for(int i=l;i<=r;i++){
ckmin(mn,P[i]),ckmax(mx,P[i]);
}
if(mx!=r||mn!=l)WA(0);
int las=-1e9;
for(int i=l;i<=r;i++){
if(i<P[i]){
if(las>P[i])WA(1);
las=P[i];
}
}
las=-1e9;
for(int i=l;i<=r;i++){
if(i>P[i]){
if(las>P[i])WA(2);
las=P[i];
}
}
}

int main(){
N=read();
rep(i,1,N)P[i]=read();
int las=0;
rep(i,1,N){
if((P[i]==i)==(P[i-1]==i-1)){
sol(las+1,i-1);
las=i-1;
}
}
sol(las+1,N);
puts("Yes");
return 0;
}
#include<iostream>
using namespace std;
const int N=1e5+10;
int a[N];
int main()
{
long long x; cin>>x;
long long sum=0;
for(int i=1;i<=x;i++)
{
sum+=i;
if(sum>=x)
{
cout<<i<<endl;
break;
}
}
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define N 200020
typedef long long ll;
int nxt[N][26],n,las[26],dp[N],jb[N];
char s[N];
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>(s+1);
n=strlen(s+1);
memset(las,-1,sizeof(las));
for(int i=n;i>=0;--i){
memcpy(nxt[i],las,sizeof(las));
if(i>0)las[s[i]-'a']=i;
}
for(int i=n;i>=0;--i){
dp[i]=1e9;
for(int c=0;c<26;++c){
if(!~nxt[i][c]){
dp[i]=1;jb[i]=c;break;
}
if(dp[nxt[i][c]]+1<dp[i]){
dp[i]=dp[nxt[i][c]]+1;jb[i]=c;
}
}
}
for(int u=0;~u;u=nxt[u][jb[u]]){
cout<<(char)(jb[u]+'a');
}
return 0;
}



#include <bits/stdc++.h>
#define fi first
#define se second
#define eb emplace_back
#define em emplace
#define all(v) v.begin(), v.end()
#define reset(x) memset(x, 0, sizeof(x))

using namespace std;
typedef long long ll;
typedef long double ld;
typedef complex <double> cpx;
typedef pair <int, int> pii;
typedef pair <ll, ll> pll;

const int MAX = 101010;
const int INF = 1e9;
const ll LINF = 1e18;

int main() {
ios::sync_with_stdio(false); cin.tie(nullptr);

string s;
cin >> s;
int n = s.size();
s = " " + s;
if(s[1] == '0' || s[n] == '1') return !(cout << -1);
for(int i = 1; i < n; i++) {
if(s[i] != s[n-i]) return !(cout << -1);
}

vector <pii> E;
int cur = 2;
E.eb(1, 2);
for(int i = 2; i < n; i++) {
E.eb(cur, i + 1);
if(s[i] == '1') {
cur = i + 1;
}
}
for(auto i : E) {
cout << i.fi << ' ' << i.se << '\n';
}
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for (int i=x;i<y;i++)
#define per(i,x,y) for (int i=y-1;i>=x;i--)
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define sz(x) ((int)(x.size()))
#define all(x) (x).begin(), (x).end()
using ll = long long;
using ld = long double;
using db = double;
using pie = pair<int,int>;
int main() {
int n;
scanf("%d",&n);
map<ll,int> f;
ll ans = 0;
rep(i,0,n) {
int x;
scanf("%d",&x);
f[x]++;
}
vector<ll> t,q;
for(auto [u,v]:f) {
if(v >= 2) t.pb(u);
}
sort(all(t));
reverse(all(t));
if(sz(t)>=1) ans=max(ans,t[0]*t[1]);
for(auto [u,v]:f) {
if(v >= 4) ans=max(ans, u*u);
}
printf("%lld\n",ans);
}

#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}

const int inf = 1001001001;
const ll INF = 1001001001001001001;

const double PI = acos(-1);

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

using mint = modint998244353;
const int MOD = 998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;
ll dp[55][2525];
ll ndp[55][2525];
signed main(){
cout << fixed << setprecision(15);

int N, A;
cin >> N >> A;
dp[0][0] = 1;
rep(i, N){
int x;
cin >> x;
rep(j, 55)rep(k, 2525) ndp[j][k] = 0;
rep(j, 55)rep(k, 2525){
if(j+1 <= 55 && k+x <= 2525) ndp[j+1][k+x] += dp[j][k];
ndp[j][k] += dp[j][k];
}
swap(dp, ndp);
}

ll ans = 0;
rep2(i, 1, N) ans += dp[i][i*A];

cout << ans << endl;
return 0;
}
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map> 
#include<bitset>
#include<vector>
using namespace std;
//#define int long long
#define re int
inline int read(){
int x=0,ff=1;char c=getchar();
while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
return x*ff;
}
const int MN=(1<<18)+5;
int n,a[MN],f[MN],g[MN],mx[MN];
inline void upd(int &x,int &y,int xx,int yy){
if(xx>x){
y=x;x=xx;
if(yy>y)y=yy;
}
else if(xx>y)y=xx;
}
signed main(){
n=read();
for(re i=0;i<(1<<n);i++)a[i]=read(),f[i]=a[i];
for(re i=0;i<n;i++){
for(re j=1<<i;j<(1<<n);j++){
if(j&(1<<i))upd(f[j],g[j],f[j^(1<<i)],g[j^(1<<i)]);
}
}
for(re i=1;i<(1<<n);i++)mx[i]=max(f[i]+g[i],mx[i-1]);
for(re i=1;i<(1<<n);i++)printf("%d\n",mx[i]);
return 0;
}

#include <iostream>
#include <bits/stdc++.h>
#include <vector>
#include <cstdio>
using namespace std;

typedef long long ll; 

typedef pair<ll,ll> pii;
typedef vector<ll> vll;
typedef vector<int> vi;
typedef vector<string> vs;
typedef map<ll,ll> mp;
typedef set<ll> SET;
typedef multiset<ll> MSETI;
#define MP make_pair
#define pb push_back
#define INF (int)1e9
#define sort(a) sort(a.begin(),a.end());
#define reverse(a) reverse(a.begin(),a.end());
#define int long long


int dx[] = {1,0,-1,0};
int dy[] = {0,1,0,-1};

ll mod=1000000007;
ll MOD=998244353;

const int N=2e5+5;

ll gcd(ll a, ll b){
if (a == 0)
return b;
return gcd(b % a, a);}
ll power(ll a,ll b,ll mod){
if(b == 0){
return 1;
}
ll ans = power(a,b/2,mod);
ans *= ans;
ans %= mod;
if(b % 2){
ans *= a;
}
return ans % mod;}
ll power1(ll a,ll b){
if(b == 0){
return 1;
}
ll ans = power1(a,b/2);
ans *= ans;
// ans %= mod;
if(b % 2){
ans *= a;
}
return ans ;}
vi parent;
vi ranks;
int get(int x) {

return parent[x] = (x == parent[x]) ? x : get(parent[x]);}
void Union(int a, int b) {
int x = get(a);
int y = get(b);
if (ranks[x] > ranks[y]) {
parent[y] = x;
ranks[x] += ranks[y];
ranks[y] = 0;
}
else {
parent[x] = y;
ranks[y] += ranks[x];
ranks[x] = 0;
}}


// --------------------------------------------------------------------------------------------------//

void solve1()
{
int n;
cin>>n;
map<int,int>mp;
for(int i=2;i<=n;i++)
{
int tar=i;
for(int j=2;j*j<=tar;j++)
{
int cnt=0;
while(tar%j==0)
{
cnt++;
tar=tar/j;
}
mp[j]+=cnt;
}
if(tar>1)mp[tar]++;
}
// for(int i=2;i<=n;i++)
// {
//     cout<<mp[i]<<" ";
// }
int ans=1;
for(int i=2;i<=n;i++)
{
ans=ans*(mp[i]+1);
ans%=mod;
}
cout<<ans<<"\n";






}


int32_t main() {

#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
ios_base::sync_with_stdio(false);
cin.tie(NULL);
ll t;
// cin>>t;
t=1;
while(t--)
{
solve1();
}

return 0;
}


#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>
#include <stack>
#include <climits>
#include <fstream>
#include <cassert>
#include <string>
#include <map>
#include <set>

using namespace std;

#define int long long

int calc(string s) {
int ans = 0, sum = 0;
for (int i = 0; i < s.size(); i++) {
if (s[i] == '+') ans += sum, sum = 0;
else sum = sum * 10 + (s[i] - '0');
}
return ans + sum;
}

int32_t main() {
string s;
cin >> s;
int n = (s.size());
int sum = 0;
for (int i = 0; i < (1 << (n - 1)); i++) {
string str;
for (int j = 0; j < n - 1; j++) {
str += s[j];
if (i & (1 << j)) str += "+";
}
str += s[n - 1];
sum += calc(str);
}
cout << sum << '\n';
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
long long N, M, O;
cin >> N >> M;
if (min(N, M) == 1) {
if (N * M == 1)
cout << 1;
else
cout << N * M - 2;
}
else {
O = (N - 2) * (M - 2);
cout << O;
}
}
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <iomanip>
#include <queue>
#include <cassert>
#include <bitset>
#include <iomanip>
#include <deque>
#include <cassert>
#include <numeric>

using namespace std;

#define debug(x) cout << #x << " is " << x << '\n';
#define ld long double
#define int long long

const int mod = 1e9 + 7, N = 5e6, M = 1e13;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);

int n, k; cin >> n >> k;
int ans = 0;
for (int i = k + 1; i <= n; ++i) {
int b = n / i;
ans += (i - k) * b;
int lst = n % i;
ans += max(0ll, lst - k + 1);
}
cout << ans - (k == 0) * n << '\n';

return 0;
}
# include <bits/stdc++.h>
//# include <ext/pb_ds/assoc_container.hpp>
//# include <ext/pb_ds/tree_policy.hpp>
# define ull unsigned long long
# define ll long long
# define double long double
# define pll pair<ll,ll>
# define pb push_back
# define pf push_front
# define fi first
# define se second
# define mp make_pair
# define max3(a,b,c) max(a,max(b,c))
# define min3(a,b,c) min(a,min(b,c))
# define all(x) x.begin(),x.end()
# define fill(a,b) memset(a,b,sizeof(a))
# define gcd(m,n)  __gcd(m, n)
# define read(a,s,n) for(ll i = s; i<=n;i++) cin>>a[i]
# define pr_double(x) cout << fixed << setprecision(15) << x
# define PI 3.1415926535897932384626
# define endl '\n'


//using namespace __gnu_pbds;
using namespace std;

//template<typename T>
//using pbds = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\"' << x << '\"';}
void __print(const string &x) {cerr << '\"' << x << '\"';}
void __print(bool x) {cerr << (x ? "true" : "false");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i : x) cerr << (f++ ? "," : ""), __print(i); cerr << "}";}
void _print() {cerr << "]\n";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << ", "; _print(v...);}

#define debug(x...) cerr << "[" << #x << "] = ["; _print(x)

struct custom_hash {
static uint64_t splitmix64(uint64_t x) {
x += 0x9e3779b97f4a7c15;
x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
return x ^ (x >> 31);
}

size_t operator()(uint64_t x) const {
static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
return splitmix64(x + FIXED_RANDOM);
}
};

const ll INF = 9223372036854775807;
const ll N = 1e6;//500005;
const ll mod = 1e9+7; //998244353; //67280421310721
const ll M = 22;

ll a[N];
int main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);
//freopen("input8.txt","r",stdin);
//freopen("output8.txt","w",stdout);
ll t = 1;
while(t--)
{
ll n; cin>>n; ll sum=0,ans=0;
for(ll i=0;i<n;i++)
{
cin>>a[i]; a[i]-=i;
sum+=a[i];
}
sort(a,a+n);
for(ll i=0;i<n;i++) ans+=abs(a[i]-a[n/2]);
cout<<ans<<endl;
}
}

#include <bits/stdc++.h>

using namespace std;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
int n, x;
cin >> n >> x;
int a[n];
for (int i = 0; i < n; i++)
cin >> a[i];
long long ans = 0;
vector<vector<long long>> d(x * n + 1, vector<long long> (n + 1));
d[0][0] = 1;
for (int i = 0; i < n; i++) {
for (int len = n; len >= 1; len--) {
for (int j = x * n - a[i]; j >= 0; j--) {
d[j + a[i]][len] += d[j][len - 1];
}
}
}
for (int len = 1; len <= n; len++) {
ans += d[x * len][len];
}
cout << ans << '\n';
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>
#include <stack>
#include <climits>
#include <fstream>
#include <cassert>
#include <string>
#include <map>
#include <set>

using namespace std;

#define int long long

int dx[] = {-1, -1, 1, 1, 0, 1, 0, -1};
int dy[] = {1, -1, -1, 1, 1, 0, -1, 0};

int32_t main() {
int n, m, q;
cin >> n >> m >> q;
int ans[10] = {0};
map<pair<int, int>, int> mp;
while (q --) {
int i, j;
cin >> i >> j;
mp[{i, j}] = 1;
for (int k = 0; k < 8; k++) {
int ni = i + dx[k];
int nj = j + dy[k];
if (ni >= 1 && ni <= n && nj >= 1 && nj <= m) {
if (!mp.count({ni, nj})) mp[{ni, nj}] = 0;
}
}
}
for (auto it : mp) {
int i = it.first.first, j = it.first.second;
int cnt = it.second, ok = 1;
for (int k = 0; k < 8; k++) {
int ni = i + dx[k];
int nj = j + dy[k];
if (ni >= 1 && ni <= n && nj >= 1 && nj <= m) {
if (mp.count({ni, nj}))
cnt += mp[{ni,nj}];
} else ok = 0;
}
if (ok) ans[cnt]++;
}
int all = (n - 2) * (m - 2), nozero = 0;
for (int i = 1; i <= 9; i++) nozero += ans[i];
ans[0] = all - nozero;
for (int i = 0; i <= 9; i++) {
cout << ans[i] << '\n';
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;

/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, 
rb_tree_tag, tree_order_statistics_node_update>;
*/

#define MOD 1000000007
typedef long long ll;
//#define int ll 

typedef pair<int, int> ii;
typedef vector<ll> vi;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define ff first
#define ss second
#define pb push_back
#define all(s) s.begin(), s.end()
#define tc int t; cin>>t; while(t--)
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
#define file_read(x,y) freopen(x, "r", stdin); \
freopen(y, "w", stdout);
#define fightFight cin.tie(0) -> sync_with_stdio(0)
#define show_vi(a)        \
cout << #a << "-->";  \
for (auto &x : a) cout << x << " "; \
cout << endl;
#define MAXN (ll)1e6
ll binpow(ll a, ll b) {
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % MOD;
a = a * a % MOD;
b >>= 1;
}
return res;
}

vi isprime(MAXN);
void sieve() {
for (int i = 0; i < MAXN; i++) {
isprime[i] = i;
}
for (int i = 2; i < MAXN; i++) {
if (isprime[i] == i) {
for (int j = 2 * i; j < MAXN; j += i) {
isprime[j] = i;
}
}
}
}
int main(){
fightFight;
sieve();
ll ans = 1;
ll n;
cin >> n;
vi primecount(n + 1, 0);
for (int i = 1; i <= n; i++) {
ll x = i;
while (x != 1) {
ll a = isprime[x];
while (x % a == 0) {
x /= a;
primecount[a]++;
}
}
}
for (int i = 1; i <= n; i++) {
ans = ans * (primecount[i] + 1) % MOD; 
}
cout << ans << "\n";
}

#include<bits/stdc++.h>
using namespace std;
#define sz(a) (int)a.size()
#define de(a) cout<<#a<<" = "<<a<<endl
#define dd(a) cout<<#a<<" = "<<a<<" "
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define mp make_pair
#define pb push_back
const int N = 202020, M = 26;
int n;
char s[N];
vector<int> pos[M];
int G[N][M];
bool vis[N];
int get_id(int a) {
return a - 'a';
}
void outans(vector<array<int, 3>> & q) {
int cur = q.size() - 1;
vector<char> ans;
while(cur != 0) {
ans.push_back(q[cur][2] + 'a');
cur = q[cur][1];
}
reverse(ans.begin(), ans.end());
string s(ans.begin(), ans.end());
printf("%s\n", s.c_str());
}
int main() {
scanf("%s", s + 1);
n = strlen(s + 1);
for(int i = 1; i <= n; i++) {
pos[get_id(s[i])].push_back(i);
}
int st = 0, ed = n + 1;
for(int i = 0; i < M; i++) {
pos[i].push_back(ed);
}
for(int i = 0; i <= n; i++) {
for(int j = 0; j < M; j++) {
const vector<int> & p = pos[j];
int nxt = lower_bound(p.begin(), p.end(), i + 1) - p.begin();
G[i][j] = p[nxt];
}
}
vector<array<int, 3>> q;
q.push_back({0, -1, -1});
for(int f = 0; f < q.size(); f++) {
array<int, 3> sb = q[f];
int c = sb[0];
for(int i = 0; i < M; i++) {
int nxt = G[c][i];
if (!vis[nxt]) {
q.push_back({nxt, f, i});	
vis[nxt] = 1;
}
if (nxt == ed) {
outans(q);
return 0;
}
}
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define DBG cerr << __LINE__ << ' ' << __FUNCTION__ << endl
#define CLOSE ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define mem(t, v) memset ((t) , v, sizeof(t))
#define pb push_back
#define mk make_pair
#define sz(x) (int)(x).size()
#define PI acos(-1.0)
#define INF 0x3f3f3f3f
#define eps 1e-8
#define LL long long
#define ULL unsigned long long
#define LF putchar('\n')
#define SP putchar(' ')

template<typename T>
void read(T &x) {x = 0;char ch = getchar();LL f = 1;while(!isdigit(ch)){if(ch == '-')f *= -1;ch = getchar();}while(isdigit(ch)){x = x * 10 + ch - 48; ch = getchar();}x *= f;}
template<typename T, typename... Args>
void read(T &first, Args& ... args) {read(first);read(args...);}
template<typename T>
void write(T arg) {T x = arg;if(x < 0) {putchar('-'); x =- x;}if(x > 9) {write(x / 10);}putchar(x % 10 + '0');}
template<typename T, typename ... Ts>
void write(T arg, Ts ... args) {write(arg);if(sizeof...(args) != 0) {putchar(' ');write(args ...);}}

const LL mod = 1e9 + 7;
const int N = 1e5 + 50;

int n, a[N];

int main() {
// while(cin >> n) {
// 	if(!n) {
// 		break;
// 	}
cin >> n;
int p = 0;
for(int i = 1; i <= n; ++i) {
cin >> a[i];
if(a[i] == 1) {
p = i;
}
}
if(p == 1) {
if(a[2] == 2) {
cout << 0 << endl;
} else {
cout << 2 << endl;
}
} else if(p == n) {
if(a[n-1] == 2) {
cout << 1 << endl;
} else {
cout << 3 << endl;
}
} else {
if(a[p-1] == 2) {
cout << min(p + 1, n - p + 1) << endl;
} else {
cout << min(p - 1, n - p + 3) << endl;
}
}
// }
return 0;
}
#include<bits/stdc++.h>
using namespace std;

#define fast ios::sync_with_stdio(false); cin.tie(0);
#define fi first
#define se second
#define pb push_back
#define em emplace
#define eb emplace_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define pre(x) cout<<fixed; cout.precision(x);

typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 1e9;
const ll INF = 1e18;
const ll Mod = 998244353;

int n;
string s;

int main() {
fast;

cin >> s;
n = s.size();
s = "*" + s;

if(s[n] == '1') {
cout << -1;
return 0;
}

if(s[1] == '0') {
cout << -1;
return 0;
}

for(int i=1; i<n; i++) {
if(s[i] + s[n-i] == '0' + '1') {
cout << -1;
return 0;
}
}

int cnt = n-1;
int r = n;

for(int i=n/2; i>=1; i--) {
if(s[i] == '0') continue;

while(cnt > i) {
cout << r << " " << cnt << "\n";
cnt--;
}

cout << r << " " << cnt << "\n";
r = cnt--;
}
}
#include <bits/stdc++.h>
using namespace std;

int main(){
int N;
cin >> N;
map<int, int> mp;
for(int i = 0; i < N; i++){
int a; 
cin >> a;
mp[a]++;
}
vector<int> v(1), u(1);

for(auto p : mp){
if(2 <= p.second) v.push_back(p.first);
if(4 <= p.second) u.push_back(p.first);
}

sort(v.begin(), v.end(), greater());
sort(u.begin(), u.end(), greater());

cout << max(1LL * u[0] * u[0], 1LL * v[0] * v[1]) << endl;
}
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 1e6;
int x, y, z, a[N];
int main()
{
int i,n,s;
cin >> n;
s = 0;
for ( i = 1; s < n; i++) {
s += i;
}
--i;
cout << i << endl;
return 0;
}
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e5+10;

vector<int>G[maxn];
int w[maxn];

priority_queue< pair<int,int> >Q;
bool vis[maxn];

int main(){
int n;
scanf("%d",&n);
for (int i=1;i<n;i++) {
int x,y;
scanf("%d%d",&x,&y);
G[x].push_back(y);
G[y].push_back(x);
}
for (int i=1;i<=n;i++) w[i]=-100;
int k;
scanf("%d",&k);
for (int i=1;i<=k;i++){
int x,num;
scanf("%d%d",&x,&num);
w[x]=num;
Q.push(make_pair(num,x));
}

while(!Q.empty()){
int val=Q.top().first;
int id=Q.top().second;
Q.pop();
vis[id]=1;
for (int i=0;i<G[id].size();i++){
int v=G[id][i];
if(w[v]==-100){
w[v]=val-1;
Q.push(make_pair(w[v],v));
continue;
}
if(!vis[v] && w[v]!=w[id]-1){
printf("No\n");
return 0;
}
}
}
printf("Yes\n");
for (int i=1;i<=n;i++) printf("%d\n",w[i]);
return 0;
}
#include<bits/stdc++.h>

using namespace std;
using ll = long long;

inline ll cnt(ll one,ll two,ll three){
int tmp = 1;
if(one == two || two == three || one == three) tmp = 2;
if(one == two && two == three) tmp = 3;
if(tmp == 1) return 6LL;
if(tmp == 2) return 3LL;
return 1LL;
}

int main(){
ll n,k;
cin >> n >> k;

ll one = n/k;
ll two = 0;
if(k % 2 == 0){
n += (k/2);
two = (n/k);
}
ll ans = one*one*one + two*two*two;
cout << ans << endl;

}
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;

//only for atcoder
#include<atcoder/all>
using namespace atcoder;

#define rep(i,l,r) for(ll i=(l); i<(r); i++)
#define rrep(i,l,r) for(ll i=(r)-1; i>=(l); i--)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MINV(c) *min_element(ALL(c))
#define MAXV(c) *max_element(ALL(c))

using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using VS = vector<string>;
using VVS = vector<VS>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VC = vector<char>;
using VVC = vector<VC>;
using VD = vector<ld>;
using VVD = vector<VD>;
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
const ll LINF = 2e18;
const int INF = 2e9;
const int MAXN = 1010;
const int MAX = 5010;
int ans[MAXN];
bool seen[MAXN];

void dfs(int s, int p, VVI &G, VI &vec){
if(G[s].size() == 1 && s != 0){
ans[s] = 0;
seen[s] = true;
return;
}
int c = 0;
rep(i,0,G[s].size()){
if(G[s][i] == p){
continue;
}
dfs(G[s][i],s,G,vec);
c++;
}
VVI dp(c+1,VI(MAX,INF));
dp[0][0] = 0;
c = 0;
rep(i,0,G[s].size()){
if(G[s][i] == p || ans[G[s][i]] == -1){
continue;
}
int x = vec[G[s][i]];
int y = ans[G[s][i]];
rrep(j,0,MAX){
//use x
if(j + x < MAX){
dp[c+1][j+x] = min(dp[c+1][j+x], dp[c][j] + y);
}
//use y
swap(x,y);
if(j + x < MAX){
dp[c+1][j+x] = min(dp[c+1][j+x], dp[c][j] + y);
}
}
c++;
}
int add = INF;
rep(j,0,vec[s]+1){
if(dp[c][j] != INF){
add = min(add, dp[c][j]);
}
if(j == vec[s] && add == INF){
add = -1;
}
}
ans[s] = add;
seen[s] = true;
}

int main(){
int N;
cin >> N;
if(N <= 2){
cout << "POSSIBLE" << endl;
return 0;
}
VVI G(N,VI(0));
rep(i,1,N){
int x;
cin >> x;
x--;
G[i].push_back(x);
G[x].push_back(i);
}
VI vec(N);
rep(i,0,N){
cin >> vec[i];
}
dfs(0,-1,G,vec);

/*rep(i,0,N){
cout << ans[i] << " ";
}*/

rep(i,0,N){
if(ans[i] == -1){
cout << "IMPOSSIBLE" << endl;
return 0;
}
}
cout << "POSSIBLE" << endl;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long

ll N, arr[55];

bool check(ll X){
ll sum = 0;

for(int i = 0; i < N; i++){
ll curr = (arr[i] + X + 1) / (N + 1);
sum += curr;
}

return sum <= X;
}

int main(){
ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

ll sum = 0;

cin >> N;
for(int i = 0; i < N; i++){
cin >> arr[i]; sum += arr[i];
}

ll l = 0, r = 1e18, memo = -1;

for(ll mid = max((ll) 0, sum - N * N); mid <= sum; mid++){
if(check(mid)){
cout << mid << '\n';
return 0;
}
}
}
#include "bits/stdc++.h"
using namespace std;

#define rep(i, a, b) for(int i=a; i<=b; i++)
#define all(x) begin(x), end(x)
#define sz(x) (int) x.size()
#define f first
#define s second
#define nl "\n"
#define pb push_back
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
const int MOD=1e9+7;

int pref[101];
int suf[102];
int n;
int a[101][2];

int main(){
cin.tie(0)->sync_with_stdio(0);

cin >> n;
rep(i,0,1){
rep(j,1,n) cin >> a[j][i];
}

rep(i, 1, n) pref[i]=pref[i-1]+a[i][0];
for(int i=n ;i>=1; i--) suf[i]=suf[i+1]+a[i][1];

int ans=0;
rep(i, 1, n) ans=max(ans, pref[i]+suf[i]);
cout << ans;
}
#include <iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;

vector<int> edge[100005];
queue<int> q;
int vis[100005];
int step[100005];
int pre[100005];
int flag[100005];
int n;
int x=1,y=1;

int bfs1()
{
vis[1]=1;
step[1]=0;
pre[1]=0;
q.push(1);
while(!q.empty())
{
int head=q.front();
q.pop();
if(head==n) return step[head];
for(int i=0; i<(int)edge[head].size(); i++)
{
int nxt=edge[head][i];
if(vis[nxt]) continue;
step[nxt]=step[head]+1;
vis[nxt]=1;
pre[nxt]=head;
q.push(nxt);
}
}
return -1;
}

void bfs2()
{
while(!q.empty()) q.pop();
memset(vis,0,sizeof(vis));
vis[1]=1;
q.push(1);
while(!q.empty())
{
int head=q.front();
q.pop();
for(int i=0; i<(int)edge[head].size(); i++)
{
int nxt=edge[head][i];
if(vis[nxt]||flag[nxt]==2||nxt==n) continue;
vis[nxt]=1;
x++;
q.push(nxt);
}
}
}

int main()
{
scanf("%d",&n);
for(int i=1; i<=n-1; i++)
{
int a,b;
scanf("%d%d",&a,&b);
edge[a].push_back(b);
edge[b].push_back(a);
}
int tmp=bfs1();
tmp--,tmp/=2;
int now=pre[n];
int cnt=0;
while(pre[now]!=0)
{
flag[now]=2;
cnt++;
if(cnt>tmp) flag[now]=1;
now=pre[now];
}
bfs2();
y=n-x;
if(x<=y) printf("Snuke\n");
else printf("Fennec\n");
return 0;
}

#include<bits/stdc++.h>
#include<tr1/unordered_map>
using namespace std;
#define ll long long
#define ull unsigned long long
#define int long long
#define N 5005
const ll mod = 1e9+7;
const ll inf = 1e17;
const double eps = 1e-3;
const int INF = 1e7;
inline ll read()
{
ll f=0,g=1;
char ch=getchar();
while(ch<'0'||ch>'9') {if(ch=='-') g=-1;ch=getchar();}
while(ch>='0'&&ch<='9') {f=(f<<1)+(f<<3)+ch-'0';ch=getchar();}
return f*g;
}

struct Edge
{
int to,next;
}e[N<<2];

ll f[N][N],g[N],tmp[N];
int n,siz[N];
int head[N],cnt;

void add_edge(int x,int y)
{
e[++cnt]={y,head[x]};
head[x]=cnt;
}

void dfs(int now,int fa)
{
f[now][siz[now]=1]=1;
for(int i=head[now];i;i=e[i].next)
{
int to=e[i].to;
if(to==fa) continue;
dfs(to,now);
for(int i=1;i<=siz[now]+siz[to];i++) tmp[i]=0;
for(int i=1;i<=siz[now];i++) for(int j=0;j<=siz[to];j++) 
(tmp[i+j]+=f[now][i]*f[to][j]%mod)%=mod;
for(int i=1;i<=siz[now]+siz[to];i++) f[now][i]=tmp[i];
siz[now]+=siz[to];
}
for(int i=2;i<=siz[now];i+=2) (f[now][0]+=mod-f[now][i]*g[i]%mod)%=mod;
}

signed main()
{ 
g[0]=1;
n=read();
for(int i=2;i<=n;i+=2) g[i]=g[i-2]*(i-1)%mod;
for(int i=1,x,y;i<n;i++) x=read(),y=read(),add_edge(x,y),add_edge(y,x);
dfs(1,0);
printf("%lld\n",mod-f[1][0]);
return 0;
}

/*
5 6 1 5
1 2 3
1 3 5
2 3 1
3 4 10
4 5 1
3 5 8

*/
#include <algorithm>
#include <cassert>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>
/*
#include <atcoder/all>
template <int m, std::enable_if_t<(1 <= m)> * = nullptr>
ostream &operator<<(ostream &os, const atcoder::static_modint<m> &v) {
os << v.val();
return os;
}
*/

/*
cd $dir && g++ -std=c++17 -Wall -Wextra -O2 -DATCODERDEBUG
-I/home/moritanian/projects/atcoder/lib/ac-library $fileName && \
echo 'compilation ok!'
&&  ./a.out
*/
using namespace std;
#define REP(i, n) for (ll i = 0; i < ll(n); i++)
#define FOR(i, a, b) for (ll i = a; i <= ll(b); i++)
#define ALL(x) x.begin(), x.end()
#define dame(a)        \
{                    \
cout << a << endl; \
return 0;          \
}
typedef long long ll;

ll __per__(ll a, ll b) {
if (a >= 0) return a % b;
return (((-a - 1LL) / b) + 1LL) * b + a;
}

class dstream : private std::streambuf, public ostream {
public:
dstream() : std::ostream(this) {}
dstream &operator<<(__attribute__((unused))
ostream &(*endl)(std::ostream &out)) {
#ifdef ATCODERDEBUG
cout << endl;
#endif
return *this;
}
};

dstream dout;

template <typename T>
dstream &operator<<(dstream &os, const T &v) {
#ifdef ATCODERDEBUG
cout << "\033[1;31m" << v << "\033[0m";
#endif
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<T> &v) {
os << "[ ";
for (auto const &x : v) {
os << x;
if (&x != &v.back()) {
os << " , ";
}
}
os << " ]";
return os;
}

ostream &operator<<(ostream &os, const vector<bool> &v) {
os << "[ ";
for (size_t i = 0; i < v.size(); i++) {
os << v[i];
if (i != v.size() - 1) {
os << " : ";
}
}
os << " ]";
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<vector<T>> &v) {
os << "[" << endl;
for (auto const &x : v) {
os << " ";
os << x;
os << endl;
}
os << "]";
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const map<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const unordered_map<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const multimap<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const set<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const unordered_set<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const multiset<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &v) {
os << "< " << v.first << " : " << v.second << " >";
return os;
}

template <class tTuple, std::size_t... indices>
void _print_tuple(ostream &os, tTuple const &iTuple,
std::index_sequence<indices...>) {
using swallow = int[];
os << "[ ";
(void)swallow{(os << std::get<indices>(iTuple) << " , ", 0)...};
os << " ]" << endl;
}

template <class... ARGS>
ostream &operator<<(ostream &os, const tuple<ARGS...> &v) {
constexpr size_t N = tuple_size<tuple<ARGS...>>::value;
_print_tuple(os, v, std::make_index_sequence<N>{});
return os;
}

template <typename T, typename U, typename Comp = less<>>
bool chmax(T &xmax, const U &x, Comp comp = {}) {
if (comp(xmax, x)) {
xmax = x;
return true;
}
return false;
}

template <typename T, typename U, typename Comp = less<>>
bool chmin(T &xmin, const U &x, Comp comp = {}) {
if (comp(x, xmin)) {
xmin = x;
return true;
}
return false;
}

ll log10ll(ll n) {
ll res = 0;
while (n >= 10) {
n /= 10LL;
res++;
}
return res;
}

ll powll(ll a, ll b) {
ll res = 1LL;
while (b) {
if (b & 1) res *= a;
a *= a;
b >>= 1;
}
return res;
}

struct UF {
vector<ll> data;
UF(ll size) : data(size, -1) {}
bool unite(ll x, ll y) {
x = root(x);
y = root(y);
if (x != y) {
if (-data[y] > -data[x]) swap(x, y);
data[x] += data[y];
data[y] = x;
}
return x != y;
}
bool findSet(ll x, ll y) { return root(x) == root(y); }
ll root(ll x) { return data[x] < 0 ? x : data[x] = root(data[x]); }
ll size(ll x) { return -data[root(x)]; }
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

ll N;
cin >> N;
vector<vector<ll>> A(N, vector<ll>(N));
REP(i, N) {
REP(j, N) { cin >> A[i][j]; }
}

vector<vector<bool>> B(N, vector<bool>(N, true));

REP(i, N) {
REP(j, N) {
REP(k, N) {
if (j == i || i == k) continue;
ll v = A[j][i] + A[i][k];
if (A[j][k] > v) {
cout << -1 << endl;
return 0;
} else if (A[j][k] == v) {
dout << j << " " << k << " " << v << endl;
B[j][k] = false;
}
}
}
}

ll ans = 0;
REP(i, N) {
for (ll j = 0; j < i; j++)
if (B[i][j]) ans += A[i][j];
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; --i)

int main() {
int n;
string s;
cin >> n >> s;

vi cl(n + 1), cr(n + 1);
rep(i, n) {
cl[i + 1] = cl[i];
if (s[i] == 'W') cl[i + 1]++;
}
repr(i, n) {
cr[i] = cr[i + 1];
if (s[i] == 'E') cr[i]++;
}
vi ret(n);
rep(i, n) ret[i] = cl[i] + cr[i + 1];
int ans = *min_element(ret.begin(), ret.end());
cout << ans << endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std;
#define rep(i,n) for(long long i=0;i<n;++i)
#define rep1(i,n) for(long long i=1;i<=n;++i)
#define rrep(i,n) for(long long i=n-1;i>=0;--i)
#define debug(output) if(debugFlag)cout<<#output<<"= "<<output<<endl
using lint = long long;
typedef pair<int,int> P;
const bool debugFlag=true;
const lint linf=1.1e18;const lint inf=1.01e9;
constexpr int MOD=1000000007;
template<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }

template<class T>
vector<T> press(vector<T> a){
auto b=a;
sort(a.begin(),a.end());
auto it=unique(a.begin(),a.end());
for(auto& e:b)e=lower_bound(a.begin(),it,e)-a.begin();
return b;
}

template<class T>
class SegTree{
int n;
vector<T> node;
T e;
function<T(T,T)> operation;
function<T(T,T)> update;
public:
SegTree(int _n,T _e,function<T(T,T)> _operation,function<T(T,T)> _update):n(_n),e(_e),operation(_operation),update(_update){node.resize(n*2,e);}
void change(int i,T x){
i+=n;
node[i]=update(node[i],x);
while(i>1){
i>>=1;
node[i]=operation(node[i<<1|0],node[i<<1|1]);
}
}
T get(int l,int r){
T a=e;
T b=e;
l+=n;r+=n;
while(l<r){
if(l&1)a=operation(a,node[l++]);
if(r&1)b=operation(node[--r],b);
l>>=1;r>>=1;
}
return operation(a,b);
}
void input(vector<T>& _input){
for(int i=0;i<n;++i){
change(i,_input[i]);
}
}
};

signed main(){
int n,k;cin>>n>>k;
vector<int> a(n);
rep(i,n)cin>>a[i];
rep(i,n)a[i]-=k;
vector<lint> sm(n+1,0);
rep1(i,n)sm[i]=sm[i-1]+a[i-1];
auto b=press(sm);
lint res=0;
auto op=[](lint x,lint y){return x+y;};
SegTree<lint> tree(n+10,0,op,op);
tree.change(b[0],1);
rep1(i,n){
res+=tree.get(0,b[i]+1);
tree.change(b[i],1);
}
cout<<res<<"\n";
return 0;
}
#include<bits/stdc++.h>
#define rep(i,x,y) for(int i=x; i<=y; ++i)

using namespace std;
const int N=3005,mod=1000000007;
typedef long long LL;
int n,m,sum[N],tot;
char s[N];
LL c[N][N],f[N][N];
struct D{int l,r;} dat[N];

int get(D a,D b)
{
if(a.r<b.l) return 0;
return a.r-b.l+1;
}

int get(int l,int r)
{
if(l>r) return 0;
return sum[r]-sum[l-1];
}

int main()
{
scanf("%d%d",&n,&m);
scanf("%s",s+1);
rep(i,1,m) scanf("%d%d",&dat[i].l,&dat[i].r);
tot=0;
rep(i,1,m)
{
if(i==1 || dat[tot].l<dat[i].l && dat[tot].r<dat[i].r) dat[++tot]=dat[i];
else if(dat[tot].l==dat[i].l && dat[tot].r<dat[i].r) dat[tot]=dat[i];
}
rep(i,0,n) c[i][0]=1;
rep(i,1,n) rep(j,1,i) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
rep(i,1,n) sum[i]=sum[i-1]+(s[i]=='1');
m=tot,dat[m+1]=(D){n+1,n+1};
f[0][0]=1;
rep(i,1,m)
{
rep(j,0,n) if(f[i-1][j])
{
LL tmp=f[i-1][j];
int x=j+get(max(dat[i-1].r+1,dat[i].l),dat[i].r);
int y=get(dat[i],dat[i+1]);
int z=dat[i].r-dat[i].l+1;
rep(k,max(0,x-z+y),min(x,y)) f[i][k]=(f[i][k]+tmp*c[z-y][x-k])%mod;
}
}
printf("%lld\n",f[m][0]);
return 0;
}
// Problem: D - Alice&Brown
// Contest: AtCoder - AtCoder Regular Contest 072
// URL: https://atcoder.jp/contests/arc072/tasks/arc072_b
// Memory Limit: 256 MB
// Time Limit: 2000 ms
//
// Powered by CP Editor (https://cpeditor.org)

/*
Name:
Author: xiaruize
Date:
*/
/*
#pragma GCC optimize(3)
#pragma GCC target("avx")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#pragma GCC optimize(2)
#pragma GCC optimize("-ofast")
*/
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ull unsigned long long
#define MOD 1000000007
#define ALL(a) (a).begin(), (a).end()
#define pb push_back
#define mk make_pair
#define pii pair<int, int>
#define pis pair<int, string>
#define sec second
#define ll long long
#define fir first
#define sz(a) int((a).size())
#define double long double
#define INF 0x3f3f3f3f
#define debug(c, x) cerr << c << ':' << x << endl;
const int N = 1e5 + 10;

// bool st;
int x, y;
// bool en;

signed main()
{
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
// freopen(".in","r",stdin);
// freopen(".out","w",stdout);
// cerr<<(&en-&st)/1024.0/1024.0<<endl;
cin >> x >> y;
if (abs(x - y) > 1)
cout << "Alice" << endl;
else
cout << "Brown" << endl;
return 0;
}

#include<cstdio>
#include<atcoder/maxflow>
using namespace atcoder;
using ll = long long;
using ull = unsigned long long;
constexpr ll INF = 100000000000;

int main(){
int N;
scanf("%d", &N);
int A[N];
for(int i = 0; i < N; ++i) scanf("%d", A + i);
mf_graph<ll> graph(N+2);
ll answer = 0;
for (int i = 0; i < N; i++)
{
if(A[i] > 0){
answer += A[i];
graph.add_edge(i+1, N+1, A[i]);
}else graph.add_edge(0, i+1, -A[i]);
for (int j = (i+1)<<1; j <= N; j+=i+1)
{
graph.add_edge(i+1, j, INF);
}
}
printf("%lld\n", answer - graph.flow(0, N+1));
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <iomanip>
#include <utility>
#include <tuple>
#include <functional>
#include <bitset>
#include <cassert>
#include <complex>
#include <stdio.h>
#include <time.h>
#include <numeric>
#include <random>
#include <unordered_set>
#include <unordered_map>
#define all(a) (a).begin(), (a).end()
#define rep(i, n) for (ll i = 0; i < (n); i++)
//#define rep(i, n) for (int i = 0; i < (n); i++)
#define range(i, a, b) for (ll i = (a); i < (b); i++)
#define pb push_back
#define debug(x) cerr << __LINE__ << ' ' << #x << ':' << (x) << '\n'
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<ll, ll> P;
typedef pair<ll, P> Q;
//typedef complex<ld> com;
template<class T> using pri_s = priority_queue<T, vector<T>, greater<T>>;
template<class T> using pri_b = priority_queue<T>;
constexpr int inf = 1000000010;
constexpr int inf2 = 2000000010;
constexpr ll INF = 1000000000000000010;
constexpr int mod1e9 = 1000000007;
constexpr int mod998 = 998244353;
constexpr ld eps = 1e-12;
constexpr ld pi = 3.141592653589793238;
constexpr ll ten(int n) { return n ? 10 * ten(n - 1) : 1; };
int dx[] = { 1,0,-1,0,1,1,-1,-1 }; int dy[] = { 0,1,0,-1,1,-1,1,-1 };
ll mul(ll a, ll b) { return (a > INF / b ? INF : a * b); }
void fail() { cout << "-1\n"; exit(0); } void no() { cout << "No\n"; exit(0); }
template<class T> void er(T a) { cout << a << '\n'; exit(0); }
template<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }
template<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }
template<class T> istream &operator >> (istream &s, vector<T> &v) { for (auto &e : v) s >> e; return s; }
template<class T> ostream &operator << (ostream &s, const vector<T> &v) { for (auto &e : v) s << e << ' '; return s; }
template<class T, class U> ostream &operator << (ostream &s, const pair<T, U> &p) { s << p.first << ' ' << p.second; return s; }

struct fastio {
fastio() {
cin.tie(0); cout.tie(0);
ios::sync_with_stdio(false);
cout << fixed << setprecision(20);
cerr << fixed << setprecision(20);
}
}fastio_;

ll ppow(ll a, ll b, ll mod) {
ll res = 1;
while (b) {
if (b & 1) res *= a, res %= mod;
a *= a, a %= mod;
b >>= 1;
}
return res;
}

int find(int p) {
random_device seed_gen;
mt19937_64 engine(seed_gen());
vector<int> div;
for (int i = 1; i * i <= p - 1; i++) {
if ((p - 1) % i == 0) {
div.pb(i);
if (i != 1 && i * i != p - 1) div.pb((p - 1) / i);
}
}
while (1) {
int r = engine() % p;
if (r == 0) continue;
bool f = true;
for (int d : div) {
if (ppow(r, d, p) == 1) f = false;
}
if (f) return r;
}
}

ll modinv(ll a, ll mod) {
a %= mod;
if (a == 0) abort();
ll b = mod, u = 1, v = 0;
while (b) {
ll t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
u %= mod;
if (u < 0) u += mod;
return u;
}

int log(ll n, ll p, ll r) {
ll s = sqrt(p) + 1;
unordered_map<ll, ll> big, small;
rep(i, s) small[ppow(r, i, p)] = i;
rep(i, s) big[ppow(r, i * s, p)] = i * s;
rep(i, s) {
ll v = ppow(r, i, p);
ll nn = n * modinv(v, p) % p;
if (big.count(nn)) {
return (i + big[nn]) % (p - 1);
}
}
abort();
}

constexpr ll mod = mod998;
template <int mod> class modint {
public:
int n;
modint() : n(0) {};
modint(ll n_) {
n = n_ % mod;
if (n < 0) n += mod;
}
modint operator -() const { return n > 0 ? mod - n : -n; }
bool operator == (const modint &m) const { return n == m.n; }
bool operator != (const modint &m) const { return n != m.n; }
modint &operator += (const modint &m) { n += m.n; if (n >= mod) n -= mod; return *this; }
modint &operator -= (const modint &m) { n -= m.n; if (n < 0) n += mod; return *this; }
modint &operator *= (const modint &m) { n = ll(n) * m.n % mod; return *this; }
modint &operator /= (const modint &m) { n = ll(n) * modinv(m).n % mod; return *this; }
modint operator +(modint m) const { return modint(*this) += m; }
modint operator -(modint m) const { return modint(*this) -= m; }
modint operator *(modint m) const { return modint(*this) *= m; }
modint operator /(modint m) const { return modint(*this) /= m; }
modint &operator ++ () { *this += 1; return *this; }
modint operator ++ (int) { *this += 1; return *this - 1; }
modint &operator -- () { *this -= 1; return *this; }
modint operator -- (int) { *this -= 1; return *this + 1; }
modint pow(ll b) const {
modint res = 1, a = modint(*this);
while (b) {
if (b & 1) res *= a;
a *= a;
b >>= 1;
}
return res;
}
friend istream &operator >> (istream &s, modint<mod> &a) { s >> a.n; return s; }
friend ostream &operator << (ostream &s, modint<mod> &a) { s << a.n; return s; }
};

using mint = modint<mod>;
vector<mint> fac, inv, facinv;

mint modinv(mint x) {
ll a = x.n;
if (a == 0) abort();
if (a < (ll)inv.size()) return inv[a];
ll b = mod, u = 1, v = 0;
while (b) {
ll t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
mint res = u;
return res;
}

void modcalc(int n) {
fac.resize(n); inv.resize(n); facinv.resize(n);
fac[0] = 1; fac[1] = 1; inv[1] = 1;
facinv[0] = 1; facinv[1] = 1;
for (ll i = 2; i < n; i++) {
fac[i] = fac[i - 1] * i;
inv[i] = -inv[mod % i] * (mod / i);
facinv[i] = facinv[i - 1] * inv[i];
}
}

mint comb(ll n, ll k) {
if (n < 0 || k < 0 || n < k) return 0;
return fac[n] * facinv[k] * facinv[n - k];
}

mint perm(ll n, ll k) {
if (n < 0 || k < 0 || n < k) return 0;
return fac[n] * facinv[n - k];
}

mint hom(ll n, ll k) {
if (n < 0 || k < 0 || n == 0 && k > 0) return 0;
if (n == 0 && k == 0) return 1;
return fac[n + k - 1] * facinv[k] * facinv[n - 1];
}

template<class T> class segtree {
int n;
vector<T> data;
T id = { 0,0 };
T operation(T a, T b) { return a + b; }
public:
segtree(int _n) {
n = 1;
while (n < _n + 2) n <<= 1;
data = vector<T>(2 * n, id);
}
segtree(vector<T> vec) {
int _n = vec.size();
n = 1;
while (n < _n + 2) n <<= 1;
data = vector<T>(2 * n, id);
for (int i = 0; i < _n; i++) data[i + n] = vec[i];
for (int i = n - 1; i >= 1; i--) data[i] = operation(data[i << 1], data[i << 1 | 1]);
}
void change(int i, T x) {
i += n;
data[i] = x;
while (i > 1) {
i >>= 1;
data[i] = operation(data[i << 1], data[i << 1 | 1]);
}
}
void add(int i, T x) { change(i, data[i + n] + x); }
T get(int a, int b) {
T left = id; T right = id;
a += n; b += n;
while (a < b) {
if (a & 1) left = operation(left, data[a++]);
if (b & 1) right = operation(data[--b], right);
a >>= 1; b >>= 1;
}
return operation(left, right);
}
T get_all() { return data[1]; }
T operator[](int i) { return data[i + n]; }
};

class unionfind {
vector<int> par;
vector<int> sz;
public:
unionfind(int n) {
par = vector<int>(n);
for (int i = 0; i < n; i++) par[i] = i;
sz = vector<int>(n, 1);
}
int find(int x) {
if (par[x] == x) return x;
else return par[x] = find(par[x]);
}
int size(int x) { return sz[find(x)]; }
bool same(int x, int y) { return find(x) == find(y); }
void unite(int x, int y) {
x = find(x);
y = find(y);
if (x == y) return;
if (sz[x] < sz[y]) {
par[x] = y;
sz[y] += sz[x];
}
else {
par[y] = x;
sz[x] += sz[y];
}
}
};

template<class T> vector<vector<T>> mat_mul(vector<vector<T>> a, vector<vector<T>> b) {
int n = a.size();
vector<vector<T>> ans(n, vector<T>(n));
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
for (int k = 0; k < n; k++) {
ans[i][j] += a[i][k] * b[k][j];
}
}
}
return ans;
}

template<class T> vector<vector<T>> mat_pow(vector<vector<T>> a, ll b) {
int n = a.size();
vector<vector<T>> ans(n, vector<T>(n));
for (int i = 0; i < n; i++) ans[i][i] = 1;
while (b) {
if (b & 1) ans = mat_mul(ans, a);
a = mat_mul(a, a);
b >>= 1;
}
return ans;
}

vector<ll> compress(vector<ll> vec) {
int vecsize = vec.size();
vector<ll> tmpvec = vec;
sort(tmpvec.begin(), tmpvec.end());
tmpvec.erase(unique(tmpvec.begin(), tmpvec.end()), tmpvec.end());
vector<ll> res(vecsize);
for (int i = 0; i < vecsize; i++) res[i] = lower_bound(tmpvec.begin(), tmpvec.end(), vec[i]) - tmpvec.begin();
return res;
}

struct S {
ll from, to, cost;
};

int main() {
int a, b;
cin >> a >> b;
vector<vector<int>> d(a, vector<int>(b));
rep(i, a) rep(j, b) cin >> d[i][j];
vector<vector<int>> e(a, vector<int>(b, inf));
vector<S> ans;
ans.pb({ 202,0,0 });
rep(i, 100) ans.pb({ i,i + 1,-1 });
rep(i, 100) ans.pb({ i + 101,i + 102,-2 });
ans.pb({ 201,203,0 });
rep(i, 101) {
rep(j, 101) {
//ix+jy+k
ll m = 0;
rep(aa, a) {
rep(bb, b) {
chmax(m, d[aa][bb] - (aa + 1) * i - (bb + 1) * j);
}
}
ans.pb({ i,201 - j,m });
rep(aa, a) {
rep(bb, b) {
chmin(e[aa][bb], (aa + 1) * i + (bb + 1) * j + m);
}
}
}
}
if (d == e) {
cout << "Possible\n";
cout << 204 << ' ' << ans.size() << '\n';
for (S s : ans) {
cout << s.from + 1 << ' ' << s.to + 1 << ' ';
if (s.cost >= 0) cout << s.cost << '\n';
else if (s.cost == -1) cout << "X\n";
else cout << "Y\n";
}
cout << 203 << ' ' << 204 << '\n';
}
else cout << "Impossible\n";
} 
#include<bits/stdc++.h>
#define File(name) freopen(#name".in", "r", stdin); freopen(#name".out", "w", stdout);
#define ri int
#define Int inline int
#define Void inline void
#define Bool inline bool
#define LL inline long long
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
template<typename T>
inline T read(){
T n = 0; int f = 1; char ch = getchar();
while(!isdigit(ch)){
if(ch == '-') f = -1;
ch = getchar();
}
while(isdigit(ch)){
n = n * 10 + ch - '0';
ch = getchar();
}
return f * n;
}
template<typename T>
void write(T n){
if(n/10) write(n/10);
putchar(n%10+'0');
}
void input() {}
template<typename Type, typename... Types>
void input(Type &arg, Types&... args){
arg = read<Type>();
input(args...);
}
namespace Main{
const int N = 18;
const int MOD = 1e9 + 7;
int n, m, a[N], f[N][1<<N];
ll ans, fac[1<<N], ifac[1<<N];
ll qpow(ll n, ll k){
ll res = 1;
while(k > 0){
if(k & 1) res = res * n % MOD;
n = n * n % MOD;
k >>= 1;
}
return res;
}
ll c(int n, int k){
if(n < k) return 0ll;
return fac[n] * ifac[n-k] % MOD * ifac[k] % MOD;
}
void Main(){
input(n, m);
for(int i = 1; i <= m; i++) input(a[i]);
sort(a + 1, a + m + 1, greater<int>());
fac[0] = 1;
for(int i = 1; i <= 1 << n; i++) fac[i] = fac[i-1] * i % MOD;
ifac[1<<n] = qpow(fac[1<<n], MOD - 2);
for(int i = (1 << n) - 1; i >= 0; i--) ifac[i] = ifac[i+1] * (i + 1) % MOD;
f[0][0] = 1;
for(int i = 1; i <= m; i++){
for(int s = 0; s < 1 << n; s++){
f[i][s] = (f[i][s] + f[i-1][s]) % MOD;
for(int j = 0; j < n; j++){
if((s >> j) & 1) continue;
f[i][s|(1<<j)] = (f[i][s|(1<<j)] + f[i-1][s] * c((1<<n)-s-a[i], (1<<j)-1) % MOD * fac[1<<j]) % MOD;
}
}
}
for(int s = 0; s < 1 << n; s++){
if(__builtin_popcount(s) & 1) ans = (ans - f[m][s] * fac[(1<<n)-s-1] % MOD + MOD) % MOD;
else ans = (ans + f[m][s] * fac[(1<<n)-s-1] % MOD) % MOD;
}
ans = ans * (1 << n) % MOD;
write(ans);
return;
}
} // namespace
int main(){
#ifdef Liuxizai
freopen("in", "r", stdin);
freopen("out", "w", stdout);
#endif // Liuxizai
Main::Main();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n, m;
ll a[5005];
int b[5005][205][15], lg[5005];
ll res = -1e18;

int get_max(int i, int l, int r) {
int k = lg[r-l+1];
return max(b[l][i][k], b[r-(1<<k)+1][i][k]);
}

ll get_cost(int l, int r) {
ll cost = -(a[r-1] - a[l-1]);
for (int i = 1; i <= m; ++ i) {
cost += get_max(i, l, r);
}
return cost;
}

void solve(int idL, int idR, int posL, int posR) {
if (idL > idR) return;
int mid = (idL + idR) >> 1, best_id = 1;
ll best_cost = -1e18;
for (int i = max(mid, posL); i <= posR; ++ i) {
ll tmp = get_cost(mid, i);
if (best_cost < tmp) {
best_cost = tmp;
best_id = i;
}
}
res = max(res, best_cost);
solve(idL, mid - 1, posL, best_id);
solve(mid + 1, idR, best_id, posR);
}

void solve() {
cin >> n >> m;
for (int i = 1; i < n; ++ i) {
cin >> a[i];
a[i] += a[i-1];
}
for (int i = 1; i <= n; ++ i)
for (int j = 1; j <= m; ++ j) {
cin >> b[i][j][0];
}
for (int i = 2; i <= n; ++ i) {
lg[i] = lg[i>>1] + 1;
}
for (int i = 1; i <= m; ++ i)
for (int j = 1; (1 << j) <= n; ++ j) {
for (int u = 1; u + (1 << j) - 1 <= n; ++ u) {
b[u][i][j] = max(b[u][i][j-1], b[u+(1<<(j-1))][i][j-1]);
}
}
solve(1, n, 1, n);
cout << res;
}

int main() {
cin.tie(0)->sync_with_stdio(0);
solve();
return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define reps(i, a, b) for(long long (i) = (a); (i) < (b); ++(i))
#define rep(i, n) for(long long (i) = 0; (i) < (n); ++(i))
#define repr(i, b, a) for(long long (i) = (b); (i) >= (a); --(i))
using ll = long long;
using vl = vector<long long>;
using vvl = vector<vector<long long> >;
using pl = pair<long long, long long>;
using tl = tuple<long long, long long, long long>;
using graph = vector<vector<int> >;
struct Edge{
int to;
long long cost;
Edge(int t, long long c) : to(t), cost(c) {}
bool operator<(const Edge &a) const{return cost < a.cost;}
bool operator>(const Edge &a) const{return cost > a.cost;}
};
using wgraph = vector<vector<Edge> >;
constexpr long long INF = numeric_limits<long long>::max() / 8;
constexpr long long dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};
constexpr long long dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T, typename U> inline bool chmax(T &a, const U& b) {if(a<b){a=b;return true;}return false;}
template<typename T, typename U> inline bool chmin(T &a, const U& b) {if(a>b){a=b;return true;}return false;}
template<typename T, typename U> inline T POW(T x, U n) {T ret=1;while(n>0){if(n&1){ret=ret*x;}if(n>>=1){x=x*x;}}return ret;}
template<typename T, typename U> inline T MOD(T n, U m) {if(n >= 0) {return n % m;} else return (n%m + m)%m;}
template<typename T, typename U, typename V> inline T POWMOD(T x, U n, V m){T ret=1;x%=m;while(n>0){if(n&1)ret=ret*x%m;if(n>>=1){x=x*x%m;}}return ret%m;}
template<typename T, typename U> inline T div_ceil(T a, U b){return (a + b - 1) / b;}
template<typename T> inline long long KETA(T n, long long base = 10){long long ret = 0;while(n){ret++; n /= base;} return ret;}
template<typename T> inline long long popcount(T a){return __builtin_popcount(a);}
template<typename T> inline bool contains(T S, T i){return (S & (T(1) << i)) != 0;}
template<typename T> inline void fin(T a){cout << a << '\n'; exit(0);}
template<typename T> inline T SUM(const vector<T> &v){return accumulate(v.begin(), v.end(), (T)0);}
template<typename T> inline T MIN(const vector<T> &v){return *min_element(v.begin(), v.end());}
template<typename T> inline T MAX(const vector<T> &v){return *max_element(v.begin(), v.end());}
template<typename T> inline void decr(vector<T> &v, T d = T(1)){for(auto &c : v){c -= d;}}

template<typename T,typename S> ostream&operator<<(ostream&os,const pair<T,S>&p){os<<"("<<p.first<<", "<<p.second<<")";return os;}
template<typename T,typename S> ostream&operator<<(ostream&os,const map<T,S>&ma){for(auto [a,b]:ma){os<<"("<<a<<", "<<b<<")"<<" ";}return os;}
template<typename T> ostream &operator<<(ostream&os,const set<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const multiset<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const vector<T>&v){os<<"[";for(int i=0;i<v.size();i++){os<<v[i]<<(i==v.size()-1?"":" ");}os<<"]";return os;}

void dump_func() {cerr << endl;}
template<class Head, class... Tail>
void dump_func(Head&& head, Tail&&... tail){
cerr << head;
if(sizeof...(Tail) == 0) cerr << " ";
else cerr << ", ";
dump_func(std::move(tail)...);
}



//#define ONLINE_JUDGE
#ifdef ONLINE_JUDGE
#define dump(...) true
#else
#define dump(...) cerr << __LINE__ << " : (" << #__VA_ARGS__ << ") = "; \
dump_func(__VA_ARGS__)
#endif


#include "atcoder/maxflow"
using namespace atcoder;

void solve(){
ll H, W; cin >> H >> W;
vector<string> a(H);
rep(i, H) cin >> a[i];
mf_graph<ll> G(H + W + 2);
ll sx, sy, tx, ty;
rep(i, H) rep(j, W){
if(a[i][j] == 'o'){
G.add_edge(i + 1, H + (j + 1), 1);
G.add_edge(H + (j + 1), i + 1, 1);
}
if(a[i][j] == 'S'){
G.add_edge(0, i + 1, INF);
G.add_edge(0, H + (j + 1), INF);
sx = i;
sy = j;
}
if(a[i][j] == 'T'){
G.add_edge(i + 1, H + W + 1, INF);
G.add_edge(H + (j + 1), H + W + 1, INF);
tx = i;
ty = j;
}
}
if(sx == tx || sy == ty) cout << -1 << '\n';
else cout << G.flow(0, H + W + 1) << '\n';
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout << std::fixed << std::setprecision(15);

solve();

return 0;
}

#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

inline int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
n = read();
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
c[i][j] = read();
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
printf("%lld\n", ans / 6);
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

bool f(vi v,int s){
int n=v.size();
if(s<0) return false;
if(n==0) return s==0;
vector<vector<bool>> dp(n+1,vector<bool>(s+1));
dp[0][0]=true;
rep(i,n){
rep(j,s+1){
if(!dp[i][j]) continue;
dp[i+1][j]=dp[i][j];
if(j+v[i]<=s) dp[i+1][j+v[i]]=dp[i][j];
}
}
return dp[n][s];
}

int main(){
string s;
int x,y;
cin>>s>>x>>y;
int cnt=0,n=s.size(),k=0,sx=0,sy=0;
vi vx,vy;
rep(i,n){
if(s[i]=='T'){
if(cnt==0) x-=k;
else if(cnt%2==0) vx.push_back(2*k),sx-=k;
else vy.push_back(2*k),sy-=k;
k=0;
cnt++;
}else{
k++;
}
}
if(cnt==0) x-=k;
else if(cnt%2==0) vx.push_back(2*k),sx-=k;
else vy.push_back(2*k),sy-=k;
int dx=x-sx,dy=y-sy;
cout<<((f(vx,dx)&&f(vy,dy)) ? "Yes" : "No")<<endl;
}
#include <iostream>
#include<bits/stdc++.h>
#include<iostream>
#include<stack>
#include<queue>
#include<string>
#include<map>
#include<limits.h>

using namespace std;
typedef long long ll;



int main()
{
map<int,int>mp;
int T,n,sum=0;
cin>>T;

for(int i=1;i<=T;i++)
{
cin>>n;
if(mp.find(n)==mp.end())
{
mp.insert(pair<int,int>(n,1));
}
else
{
mp[n]++;
}
}
for(map<int,int>::iterator it = mp.begin();it!=mp.end();++it)
{
int key = it->first;
int value = it->second;
if(key>value)
{
sum=sum+value;
}
else if(key<value)
{
sum=sum+(value-key);
}
}


cout<<sum<<endl;
return 0;
}

#include <bits/stdc++.h>

#define FOR(i, l, r) for (int i = (l); i < (r); ++i)
#define RFOR(i, l, r) for (int i = (r)-1; (l) <= i; --i)
#define REP(i, n) FOR(i, 0, n)
#define RREP(i, n) RFOR(i, 0, n)

using namespace std;
using ll = long long;
static const ll MOD = 1000000007;

int main(){
ll n;
cin >> n;

int ex[1001];
for(int i = 2; i <= n; i++){
ex[i] = 0;
int temp = i;
//素因数分解
for(int j = 2; j * j <= i; j++){
while(temp % j == 0){
ex[j]++;
temp /= j;
}
}
//残った素数を追加
if(temp > 1){
ex[temp]++;
}
}

ll result = 1;
for(int i = 2; i <= n; i++){
result *= ex[i]+1;
result %= MOD;
}

cout << result % MOD << endl;
}


#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

inline void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

inline void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}
#include <bits/stdc++.h>

using namespace std;

const int MAXN=2e5+50,P=998244353;

string c;
int N,a[MAXN];
long long f[MAXN][3][3][2];
int tot,Add=1;
bool flag1;
vector<string>Vec,Now;
map<string,bool>Mp;
int main()
{
cin>>c;
N=c.length();

for(int i=1;i<=N;i++)
{
a[i]=int(c[i-1]-49);
tot+=a[i];
if(i>1&&a[i]==a[i-1])
Add=0;
if(i>1&&a[i]!=a[i-1])
flag1=true;
}	
if(flag1==false)
{
cout<<1;
return 0;
}
if(N<=3)
{
string x;
Vec.push_back(c);
Mp[c]=true;
while(true)
{
bool flag=false;
x.clear();
Now.clear();
for(int i=0;i<Vec.size();i++)
{
for(int j=1;j<N;j++)
{
if(Vec[i][j]!=Vec[i][j-1])
{
if(Vec[i][j]!='a'&&Vec[i][j-1]!='a')
{
x=Vec[i];
x[j]='a';
x[j-1]='a';
if(Mp[x]==false)
{
Mp[x]=true;
Now.push_back(x);
flag=true;
}

}
if(Vec[i][j]!='b'&&Vec[i][j-1]!='b')
{
x=Vec[i];
x[j]='b';
x[j-1]='b';
if(Mp[x]==false)
{
Mp[x]=true;
Now.push_back(x);
flag=true;
}
}
if(Vec[i][j]!='c'&&Vec[i][j-1]!='c')
{
x=Vec[i];
x[j]='c';
x[j-1]='c';
if(Mp[x]==false)
{
Mp[x]=true;
Now.push_back(x);
flag=true;
}
}
}
}
}
for(int i=0;i<Now.size();i++)
{
Vec.push_back(Now[i]);
}
if(flag==false)
break;
}
cout<<Vec.size();
return 0;
}
tot%=3;
for(int i=0;i<=2;i++)
f[1][i][i][0]=1ll;
for(int i=1;i<N;i++)
{
for(int j=0;j<=2;j++)
{
for(int k=0;k<=2;k++)
{
for(int l=0;l<=2;l++)
{
for(int op=0;op<=1;op++)
{
f[i+1][(j+l)%3][l][op|(k==l)]=(f[i+1][(j+l)%3][l][op|(k==l)]+f[i][j][k][op])%P;
}
}
}
}
}
printf("%lld",(f[N][tot][0][1]+f[N][tot][1][1]+f[N][tot][2][1]+Add)%P);
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
#include <atcoder/segtree>
using namespace atcoder;


// References:
//   mint:
//     <https://github.com/atcoder/live_library/blob/master/mint.cpp>
//     <https://noshi91.hatenablog.com/entry/2019/03/31/174006>
//     <https://ei1333.github.io/luzhiled/snippets/math/mod-int.html>
//     <https://gist.github.com/MiSawa/dc78c3eb3ca16051818759ea069e8ccb>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>
//   combination:
//     <https://github.com/atcoder/live_library/blob/master/comb.cpp>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>

struct mint {
ll x;
constexpr mint(ll x = 0) noexcept : x((x % MOD + MOD) % MOD) {}

constexpr mint& operator+=(const mint& a) noexcept {
if ((x += a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator-=(const mint& a) noexcept {
if ((x += MOD - a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator*=(const mint& a) noexcept { (x *= a.x) %= MOD; return *this; }
constexpr mint& operator/=(const mint& a) noexcept { return *this *= a.inv(); }

constexpr mint operator-() const noexcept { return mint(-x); }
constexpr mint operator+(const mint& a) const noexcept { return mint(*this) += a; }
constexpr mint operator-(const mint& a) const noexcept { return mint(*this) -= a; }
constexpr mint operator*(const mint& a) const noexcept { return mint(*this) *= a; }
constexpr mint operator/(const mint& a) const noexcept { return mint(*this) /= a; }
constexpr bool operator==(const mint& a) const noexcept { return x == a.x; }
constexpr bool operator!=(const mint& a) const noexcept { return x != a.x; }

constexpr mint pow(ll n) const {
if (n == 0) return 1;
mint res = pow(n >> 1);
res *= res;
if (n & 1) res *= *this;
return res;
}
constexpr mint inv() const { return pow(MOD - 2); }

friend istream& operator>>(istream& is, mint& a) noexcept {
ll v; is >> v;
a = mint(v);
return is;
}
friend ostream& operator<<(ostream& os, const mint& a) noexcept {
return os << a.x;
}
};
using VM = vector<mint>;
using VVM = vector<VM>;
using VVVM = vector<VVM>;
using VVVVM = vector<VVVM>;


struct combination {
vector<mint> fact_, ifact_, inv_;
int n_;
combination() {}
combination(int n) : fact_(n+1,0), ifact_(n+1,0), inv_(n+1,0) {
assert(n != 0);
assert(n < MOD);
n_ = n;
fact_[0] = 1; fact_[1] = 1;
ifact_[0] = 1; ifact_[1] = 1;
inv_[1] = 1;
for(int i = 2; i <= n; ++i) {
fact_[i] = fact_[i-1] * i;
inv_[i] = -inv_[MOD%i] * (MOD/i);
ifact_[i] = ifact_[i-1] * inv_[i];
}
}

mint P(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k];
}
mint C(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k] * ifact_[k];
}
mint H(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0) return 0;
assert(n + k - 1 <= n_);
return C(n + k - 1, k);
}
mint fact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return fact_[n];
}
mint ifact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return ifact_[n];
}
mint inv(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return inv_[n];
}
};


// References:
//   <https://github.com/atcoder/ac-library/blob/v1.4/atcoder/dsu.hpp>
//   <https://en.wikipedia.org/wiki/Disjoint-set_data_structure>

// Disjoint-set data structure (Union Find)
// 
struct dsu {
public:
dsu() : N(0) {}
explicit dsu(int n) : N(n), parent_or_size(n, -1), n_edge(n, 0) {}

// 辺 (a, b) を張って連結成分番号を返す : amortized O(α(N))
int merge(int a, int b) {
assert(0 <= a && a < N);
assert(0 <= b && b < N);
int x = leader(a), y = leader(b);
if (x == y) { n_edge[x]++; return x; }
if (-parent_or_size[x] < -parent_or_size[y]) swap(x, y);
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
n_edge[x] += n_edge[y] + 1;
return x;
}

// 頂点 a, b が連結か判定する : amortized O(α(N))
bool same(int a, int b) {
assert(0 <= a && a < N);
assert(0 <= b && b < N);
return leader(a) == leader(b);
}

// 頂点 a の属する連結成分のルートを返す : amortized O(α(N))
int leader(int a) {
assert(0 <= a && a < N);
if (parent_or_size[a] < 0) return a;
return parent_or_size[a] = leader(parent_or_size[a]);
}

// 頂点 a が属する連結成分のサイズを返す : amortized O(α(N))
int size(int a) {
assert(0 <= a && a < N);
return -parent_or_size[leader(a)];
}

// a が属する連結成分の辺の数を返す : amortized O(α(N))
int size_e(int a) {
assert(0 <= a && a < N);
return n_edge[leader(a)];
}

// 「一つの連結成分の頂点番号リスト」のリストを返す : O(N)
vector<vector<int>> groups() {
vector<int> leader_buf(N), group_size(N);
for (int i = 0; i < N; i++) {
leader_buf[i] = leader(i);
group_size[leader_buf[i]]++;
}
vector<vector<int>> result(N);
for (int i = 0; i < N; i++) {
result[i].reserve(group_size[i]);
}
for (int i = 0; i < N; i++) {
result[leader_buf[i]].push_back(i);
}
result.erase(
remove_if(result.begin(), result.end(),
[&](const vector<int>& v) { return v.empty(); }),
result.end());
return result;
}

private:
int N;
// [x < 0] -x が連結成分のサイズに対応
// [0 <= x] x が parent に対応
vector<int> parent_or_size;
vector<int> n_edge;
};


// References:
//   <https://cp-algorithms.com/graph/hld.html>
//   <https://codeforces.com/blog/entry/53170>
//   <https://ei1333.github.io/luzhiled/snippets/tree/heavy-light-decomposition.html>
//   <https://atcoder.jp/contests/past202010-open/submissions/21473312>
//   <https://math314.hateblo.jp/entry/2014/06/24/220107>
//   <https://qiita.com/Pro_ktmr/items/4e1e051ea0561772afa3>

// HL 分解 (Heavy Light Decomposition)
//   - 頂点に (単位元ではない) 初期値を与える場合の注意点
//     - hld.build() の実行後に行う
//     - 頂点 u は hld 内部では hld.in[u] となることに注意
//   - 辺に値がある場合は子側の頂点に持たせて edge = true で関数を呼び出す
struct HLD {
int N, root;
vector<vector<int>> G;
vector<int> parent;  // 頂点 u の親
vector<int> depth;  // 頂点 u の深さ
vector<int> sz;  // 頂点 u を根とする部分木のサイズ (heavy)
vector<int> in;  // HL 分解時の探索順序 (Euler Tour)
vector<int> out;  // 後述
vector<int> head;  // 頂点 u が属する HL 分解後の連結成分の根
vector<int> rev;  // 探索順序番号から元の頂点番号への逆引き
int t = 0;  // 探索順序の計算用

// [ in[u], out[u] )      := 頂点 u を根とする部分木に対応
// [ in[head[u]], in[u] ] := HL 分解後の連結成分における頂点 u からその head までのパスに対応

HLD() {}
HLD(int n, int r = 0) : N(n), root(r) {
G.resize(N); parent.resize(N); depth.resize(N); sz.resize(N);
in.resize(N); out.resize(N); head.resize(N); rev.resize(N);
}

// 双方向に辺を張る
void add_edge(int u, int v) {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
G[u].push_back(v);
G[v].push_back(u);
}

// 各部分木のサイズを求める
void dfs_sz(int u, int p, int d) {
parent[u] = p;
depth[u] = d;
sz[u] = 1;
// heavy edge が先頭に来るように維持しながら探索する
if (G[u].size() && G[u][0] == p) swap(G[u][0], G[u].back());
for (int& v : G[u]) if (v != p) {  // NOTE: swap のために int& が必要
dfs_sz(v, u, d + 1);
sz[u] += sz[v];
if (sz[G[u][0]] < sz[v]) swap(G[u][0], v);
}
}

// HL 分解 (Heavy Light Decomposition)
void dfs_hld(int u, int p) {
in[u] = t++;
rev[in[u]] = u;
for (const int& v : G[u]) if (v != p) {
head[v] = (v == G[u][0] ? head[u] : v);  // heavy or light
dfs_hld(v, u);
}
out[u] = t;
}

void build() {
dfs_sz(root, -1, 0);
dfs_hld(root, -1);
}

// 頂点 u から深さ d だけ親を辿る (level-ancestor) : O(log N)
// 辿った先が木上にあることを想定している
//   - d <= depth[u]
int la(int u, int d) const {
assert(0 <= u && u < N);
while (true) {
int v = head[u];
if (in[u] - d >= in[v]) return rev[in[u] - d];
d -= in[u] - in[v] + 1;
u = parent[v];
}
}

// 頂点 u, v の LCA : O(log N)
int lca(int u, int v) const {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
while (true) {
if (in[u] > in[v]) swap(u, v);  // in[u] <= in[v]  (u が根側)
if (head[u] == head[v]) return u;
v = parent[head[v]];
}
}

// (u, v) パス間の辺数 : O(log N)
int distance(int u, int v) const {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
return depth[u] + depth[v] - 2*depth[lca(u, v)];
}

// 頂点 w が (u, v) パス上に存在するか : O(log N)
bool on_path(int u, int v, int w) const {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
assert(0 <= w && w < N);
return distance(u, w) + distance(w, v) == distance(u, v);
}

// パス [u,v] に対する更新クエリ : O((log N)^2)
template<class F>
void apply_path(int u, int v, bool edge, const F& func) {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
while (true) {
if (in[u] > in[v]) swap(u, v);  // in[u] <= in[v]  (u が根側)
if (head[u] == head[v]) break;
func(in[head[v]], in[v]);
v = parent[head[v]];
}
func(in[u] + edge, in[v]);
}

// パス [u,v] に対する取得クエリ : O((log N)^2)
template <class S, S (*op)(S, S), S (*e)(), class F>
S prod_path(int u, int v, bool edge, const F& func) const {
assert(0 <= u && u < N);
assert(0 <= v && v < N);
S Su = e(), Sv = e();
while (true) {
if (in[u] > in[v]) { swap(u, v); swap(Su, Sv); }  // in[u] <= in[v]  (u が根側)
if (head[u] == head[v]) break;
Sv = op(Sv, func(in[head[v]], in[v]));
v = parent[head[v]];
}
return op(Su, op(Sv, func(in[u] + edge, in[v])));
}

// 頂点 u を根とする部分木に対する更新クエリ : O(log N)
template<class F>
void apply_subtree(int u, bool edge, const F& func) {
assert(0 <= u && u < N);
func(in[u] + edge, out[u] - 1);
}

// 頂点 u を根とする部分木に対する取得クエリ : O(log N)
template <class S, class F>
S prod_subtree(int u, bool edge, const F& func) const {
assert(0 <= u && u < N);
return func(in[u] + edge, out[u] - 1);
}
};


// 区間最大
using S = int;
S op(S a, S b) { return max(a, b); }
S e() { return -inf; }


// Editorial AC

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N, M; cin >> N >> M;
ll X; input(X);
VLL U(M),V(M),W(M); REP(i,M) { input(U[i],V[i],W[i]); U[i]--; V[i]--; }

VP E(M);
REP(i,M) E[i] = {W[i], i};
SORT(E);

ll sum = 0;
HLD hld(N,0);
dsu uf(N);
VB used_edge(M,false);
for (const auto& [w, i] : E) {
ll u = U[i], v = V[i];
if (uf.same(u, v)) continue;
uf.merge(u, v);
hld.add_edge(u, v);
used_edge[i] = true;
sum += w;
}
hld.build();
bool edge = true;

vector<S> XX(N, 0);
REP(i,M) if (used_edge[i]) {
ll u = U[i], v = V[i], w = W[i];
(hld.parent[u] == v ? XX[hld.in[u]] : XX[hld.in[v]]) = w;
}
segtree<S, op, e> seg(XX);

if (sum > X) { print(0); return 0; }
ll n_upper = 0;
ll n_equal = 0;
REP(i,M) if (not used_edge[i]) {
ll u = U[i], v = V[i], w = W[i];

S res = hld.prod_path<S,op,e>(u, v, edge, [&](int l, int r) {
return seg.prod(l, r+1);
});

ll diff = w - res;
assert(diff >= 0);
if (diff == X - sum) {
n_equal++;
} else if (diff > X - sum) {
n_upper++;
}
}

mint ans = 0;
if (sum == X) {
ans += (mint(2).pow(N-1) - 2) * mint(2).pow(M-(N-1));
ans += mint(2) * (mint(2).pow(n_equal) - 1) * mint(2).pow(n_upper);
} else {
ans += mint(2) * (mint(2).pow(n_equal) - 1) * mint(2).pow(n_upper);
}
print(ans);

return 0;
}

#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <iomanip>
#include <queue>
#include <cassert>
#include <bitset>
#include <iomanip>
#include <deque>
#include <cassert>
#include <numeric>

using namespace std;

#define debug(x) cout << #x << " is " << x << '\n';
#define ld long double
#define int long long

const int mod = 1e9 + 7, N = 5e6, M = 1e13;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
int n, A, B; cin >> n >> A >> B;
vector <int> a(n);
for (auto& x : a) cin >> x;

vector <vector <int>> dp(2, vector <int>(n));
for (int i = n - 1; i >= 0; --i) {
vector <int> pr = { A, B };
if (i) pr = { a[i - 1], a[i - 1] };
dp[0][i] = abs(pr[1] - a[n - 1]);
dp[1][i] = abs(pr[0] - a[n - 1]);
for (int j = i + 1; j < n; ++j) {
dp[0][i] = max(dp[0][i], dp[1][j]);
dp[1][i] = min(dp[1][i], dp[0][j]);
}
}
cout << dp[0][0] << '\n';
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
ll X,Y;
cin>>X>>Y;
if(abs(X-Y)<2LL){
cout<<"Brown";
}
else{
cout<<"Alice";
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
char s[100009];
bool check(){
int last=0;
int pos=0,len=strlen(s);
while(pos<len){
if(s[pos]=='d'){
if(s[pos+1]!='r' || s[pos+2]!='e' || s[pos+3]!='a' || s[pos+4]!='m')return false;
last=1;
pos+=5;
if(s[pos]=='e' && s[pos+1]=='r'){
last=2;
pos+=2;
}
}
else if(s[pos]=='e'){
if(s[pos+1]!='r' || s[pos+2]!='a' || s[pos+3]!='s' || s[pos+4]!='e')return false;
last=3;
pos+=5;
if(s[pos]=='r'){
last=4;
pos+=1;
}
}
else if(s[pos]=='a' && last==2){
if(s[pos+1]!='s' || s[pos+2]!='e')return false;
last=3;pos+=3;
if(s[pos]=='r'){
last=4;
pos+=1;
}
}
else return false;
}
return true;
}
int main(){
scanf("%s",s);
if(check())printf("YES\n");
else printf("NO\n");
return 0;
}
#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <queue>
#include <cmath>
#include <map>
#include <algorithm>
#include <numeric>
#include <stack>
#include <cstring>
#include <bitset>
using namespace std;
#define int long long int
#define mod 1000000007
#define endl '\n'
int par[100000];
struct edge{
int u,v,w;
};
bool comp(edge e1, edge e2){
return e1.w < e2.w;
}
int find(int n){
if (n == par[n]) return par[n];
return par[n] = find(par[n]);
}
bool unite(int a, int b){
a = find(a);
b = find(b);
if (a != b){
par[a] = b;
return true;
}
return false;
}
signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
int n; cin >> n;
pair<int, int> x[n], y[n];
for (int i = 0; i < n; i++){
cin >> x[i].first >> y[i].first;
x[i].second = i;
y[i].second = i;
par[i] = i;
}
sort(x, x+n);
sort(y, y+n);
vector<edge> edges;
for (int i = 0; i < n-1; i++){
edge e;
e.u = x[i].second;
e.v = x[i+1].second;
e.w = abs(x[i].first-x[i+1].first);
edges.push_back(e);
e.u = y[i].second;
e.v = y[i+1].second;
e.w = abs(y[i].first-y[i+1].first);
edges.push_back(e);
}
sort(edges.begin(), edges.end(), comp);
int ans = 0;
for (int i = 0; i < edges.size(); i++){
if (unite(edges[i].u, edges[i].v)){
ans += edges[i].w;
}
}
cout << ans << endl;
return 0;
}


#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=305,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn][maxn],res;

void orzck(){
cin >> n;
rep(n) rep1(j,n) cin >> a[i][j];
rep(n) rep2(j,i+1,n){
bool flag=1;
rep1(k,n) if(i!=k&&j!=k){
if(a[i][k]+a[k][j]<a[i][j]){
print(-1);
return;
}
if(a[i][k]+a[k][j]==a[i][j]) flag=0;
}
if(flag) res+=a[i][j];
}
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

#define N 5005
#define hf 500000004
#define mod 1000000007

typedef long long ll;
using namespace std;

int en,sz[N],head[N];
ll h[N],ft[N],inv[N],ftv[N],f[N][N][2],fu[N][2];
struct edge
{
int v,nxt;
}e[N*2];

void dfs(int,int);
void adde(int,int);

int main()
{
int i,n,u,v;
scanf("%d",&n);
h[0]=1;h[1]=hf;
ft[0]=inv[1]=ft[1]=ftv[1]=1;
for(i=2;i<=n;++i)
{
h[i]=h[i-1]*hf%mod;
ft[i]=ft[i-1]*i%mod;
inv[i]=(mod-mod/i)*inv[mod%i]%mod;
ftv[i]=ftv[i-1]*inv[i]%mod;
}
for(i=1;i<n;++i)
{
scanf("%d %d",&u,&v);
adde(u,v);adde(v,u);
}
dfs(1,0);
printf("%lld\n",(f[1][0][1]-f[1][0][0]+mod)%mod);
return 0;
}
void dfs(int u,int fa)
{
int i,j,k,v;
sz[u]=1;f[u][1][0]=1;
for(i=head[u];i;i=e[i].nxt)
if((v=e[i].v)!=fa)
{
dfs(v,u);
for(j=0;j<=sz[u]+sz[v];++j)
fu[j][0]=fu[j][1]=0;
for(j=sz[u];j>=0;--j)
for(k=sz[v];k>=0;--k)
{
(fu[j+k][0]+=f[u][j][0]*f[v][k][0]+f[u][j][1]*f[v][k][1])%=mod;
(fu[j+k][1]+=f[u][j][0]*f[v][k][1]+f[u][j][1]*f[v][k][0])%=mod;
}
for(j=0;j<=sz[u]+sz[v];++j)
{f[u][j][0]=fu[j][0];f[u][j][1]=fu[j][1];}
sz[u]+=sz[v];
}
for(i=2;i<=sz[u];i+=2)
{
(f[u][0][0]+=f[u][i][1]*ft[i]%mod*ftv[i/2]%mod*h[i/2])%=mod;
(f[u][0][1]+=f[u][i][0]*ft[i]%mod*ftv[i/2]%mod*h[i/2])%=mod;
}
}
void adde(int u,int v)
{
e[++en].v=v;
e[en].nxt=head[u];
head[u]=en;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
int N; cin >> N;
vector<long long> A(N);
for(int i = 0; i < N; i++) cin >> A[i];
int r = 0;
long long ans = 0;
long long tot = 0;
for(int l = 0; l < N; l++) {
while(r < N && ((tot + A[r]) == (tot ^ A[r]))) {
//cout << tot + A[r] << " " << (tot^A[r]) << endl;
tot += A[r];
r++;
}
ans += r-l;
if(l == r) r++;
tot -= A[l];
}
cout << ans << endl;
}
#include <stdio.h>
const int maxn = 2e5 + 10;
int a[maxn];
long long sum[maxn];

long long myabs(long long x)
{
return  x > 0 ? x : -x;
}
int main()
{
int n;
scanf("%d", &n);

for (int i = 0; i < n; i++) {
scanf("%d", &a[i]);

if(i == 0) {
sum[i] = a[i];
} else {
sum[i] = sum[i - 1] + a[i];
}
}

long long ans = 1e15;

for (int i = 0; i < n - 1; i++) {
long long tmp = myabs(sum[n - 1] - sum[i] - sum[i]);

//printf("t = %lld\n", tmp);
if (tmp  < ans) ans = tmp;
}

printf("%lld\n", ans);
return 0;
}

// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
int oks[3030], okw[3030];
void solve(){ 
int a,b,c,d,e,f; cin>>a>>b>>c>>d>>e>>f;
int num = 0, den = a*100;
for(int i=0; i<=f; i+=a*100){
for(int j=0; j<=f; j+=b*100){
if(i + j > f)continue;
okw[i+j] = 1;
}
}
for(int i=0; i<=f; i+=c){
for(int j=0; j<=f; j+=d){
if(i + j > f)continue;
oks[i+j] = 1;
}
}
for(int i=1; i<=f; i++){
for(int j=1; j<=f-i; j++){
if(oks[i] && okw[j]){
int numx = i, denx = i + j;
if(i*100 <= j*e && numx*den > num*denx){
num = numx; den = denx;
}
}
}
}
cout<<den<<" "<<num<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<stdio.h>
#include<iostream>
int main()
{
int x,sum=0,a=0;
scanf("%d", &x);
while(sum<x){
a++;
sum+=a;
}
printf("%d\n", a);
return 0;
}
#include <bits/stdc++.h>
#define int long long
namespace mystd {
inline int read() {
char c = getchar();
int x = 0, f = 1;
while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
return x * f;
}
inline void write(int x) {
if (x < 0) x = ~(x - 1), putchar('-');
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}
}
using namespace std;
using namespace mystd;

const int mod = 998244353;
const int maxn = 4e3 + 400;
int n, k, ans[maxn], fac[maxn], inv[maxn], ifac[maxn];

void init() {
fac[0] = inv[1] = ifac[0] = 1;
for (int i = 1; i <= n + k; i++) fac[i] = fac[i - 1] * i % mod;
for (int i = 2; i <= n + k; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for (int i = 1; i <= n + k; i++) ifac[i] = ifac[i - 1] * inv[i] % mod;
//	for (int i = 1; i <= 10; i++) cout << fac[i] << " " << inv[i] << " " << ifac[i] << endl;
}

int C(int n, int m) {
if (m > n) return 0;
return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

int calc(int a, int b, int n) {
int res = 0;
for (int i = 0; i <= n; i++) {
res += C(a, i) * C(b + n - i - 1, n - i) % mod;
res %= mod;
}
return res;
}

signed main() {
k = read(), n = read();
init();
for (int i = 2; i <= k + 1; i += 2) {
ans[i] = calc(i / 2, k - i + 1 + (i - 1) / 2, n);
ans[i + 1] = ans[i];
}
for (int i = 2; i <= k + 1; i++) write(ans[i]), puts("");
for (int i = k; i >= 2; i--) write(ans[i]), puts("");
return 0;
}
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace IN {
#define BUF_SIZE 1 << 17
static char buf[BUF_SIZE], *fs = buf, *ft = buf;
inline int nc() {
return fs == ft && (ft = (fs = buf) + fread(buf, 1, BUF_SIZE, stdin), fs == ft) ? EOF : *fs++;
}
template <typename T>
inline int rn(T &x) {
x = 0;
int f = 0;
char ch = nc();
while (ch < '0' || ch > '9') {
if (ch == '-')
f = 1;
ch = nc();
if (ch == EOF)
return EOF;
}
while (ch >= '0' && ch <= '9') {
x = x * 10 + ch - 48;
ch = nc();
}
x = f ? -x : x;
return 0;
}
template <typename T>
inline int read(T &x) {
return rn(x);
}
template <typename T, typename... Args>
inline int read(T &x, Args &...args) {
rn(x);
return read(args...);
}
#undef BUF_SIZE
}  // namespace IN
using IN::read;
using namespace std;

#define INF 0x3f3f3f3f
#define P 1000000007
#define LL long long
#define MP make_pair
#define VI vector<int>
#define VLL vector<long long>
#define PII pair<int, int>
#define PLL pair<LL, LL>
#define ALL(A) A.begin(), A.end()
#define REP(i, n) for (LL i = 0; i < (LL)n; ++i)
#define REP1(i, n) for (LL i = 1; i <= (LL)n; ++i)
#define ZERO(arr) memset(arr, 0, sizeof(arr))

// Debug
#define DISP(arr, n)                     \
do {                                 \
REP(i, n) cout << arr[i] << ' '; \
cout << endl;                    \
} while (0)
#define DISP1(arr, n)                     \
do {                                  \
REP1(i, n) cout << arr[i] << ' '; \
cout << endl;                     \
} while (0)
#define DISP_T(arr, n, m)                       \
do {                                        \
REP(i, n) {                             \
REP(j, m) cout << arr[i][j] << ' '; \
cout << endl;                       \
}                                       \
} while (0)
#define DISP_T1(arr, n, m)                       \
do {                                         \
REP1(i, n) {                             \
REP1(j, m) cout << arr[i][j] << ' '; \
cout << endl;                        \
}                                        \
} while (0)
#define DISP_V(vec)              \
do {                         \
for (auto elem : vec)    \
cout << elem << ' '; \
cout << endl;            \
} while (0)
#define DISP_VP(vec)                                          \
do {                                                      \
for (auto elem : vec)                                 \
cout << elem.first << ' ' << elem.second << endl; \
cout << endl;                                         \
} while (0)

#define SIZE 300010

VI E[SIZE];
int col[SIZE];
int hi[SIZE], lo[SIZE];
void dfs(int x, int fa) {
for (int v : E[x]) {
if (v == fa)
continue;
hi[v] = min(hi[v], hi[x] + 1);
lo[v] = max(lo[v], lo[x] - 1);
dfs(v, x);
hi[x] = min(hi[x], hi[v] + 1);
lo[x] = max(lo[x], lo[v] - 1);
}
}
void dfs1(int x, int fa) {
for (int v : E[x]) {
if (v == fa)
continue;
if (col[x] + 1 >= lo[v] && col[x] + 1 <= hi[v]) {
col[v] = col[x] + 1;
} else if (col[x] - 1 >= lo[v] && col[x] - 1 <= hi[v]) {
col[v] = col[x] - 1;
} else {
cout << "No" << endl;
exit(0);
}
dfs1(v, x);
}
}

int main() {
int n, k;
cin >> n;
memset(hi, 0x3f, sizeof(hi));
memset(lo, -0x3f, sizeof(hi));
REP(i, n - 1) {
int u, v;
cin >> u >> v;
E[u].push_back(v);
E[v].push_back(u);
}
cin >> k;
REP(i, k) {
int v, p;
cin >> v >> p;
col[v] = p;
hi[v] = lo[v] = p;
}
dfs(1, 0);
if (hi[1] < lo[1]) {
cout << "No" << endl;
return 0;
}
col[1] = hi[1];
dfs1(1, 0);
cout << "Yes\n";
REP1(i, n) cout << col[i] << "\n";
return 0;
}

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 210000
using namespace std;
char s[N];
int n,nxt[N][26],f[N];
int main(){
scanf("%s",s+1);n=strlen(s+1);
memset(nxt,-1,sizeof(nxt));
for(int i=n;i;i--)
for(int j=0;j<26;j++){
nxt[i][j]=('a'+j==s[i]?i:nxt[i+1][j]);
}
memset(f,0x3f,sizeof(f));
for(int i=n;i;i--){
for(int j=0;j<26;j++){
if(nxt[i][j]==-1) {f[i]=1;break;}
f[i]=min(f[i],f[nxt[i][j]+1]+1);
}
}
int len=f[1],pos=1;
while(len--){
if(!len) for(int i=0;i<26;i++){
if(nxt[pos][i]==-1) return 0*putchar(i+'a');
}
for(int i=0;i<26;i++){
if(f[pos]==f[nxt[pos][i]+1]+1) {putchar(i+'a');pos=nxt[pos][i]+1;break;}
} 
}
return 0;
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define sz(a) (int)a.size()
#define all(a) a.begin(),a.end()
#define rep(i,n) for(int i=0;i<n;i++)
#define crep(i,x,n) for(int i=x;i<n;i++)
#define drep(i,n) for(int i=n-1;i>=0;i--)
#define vec(...) vector<__VA_ARGS__>
#define _34raRxL ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
typedef long double ld;

void print(){
cout<<"\n";
}

template<class te,class ...ti>
void print(const te&v, const ti&...nv) { 
cout<<v;
if(sizeof...(nv)){
cout<<" ";
print(nv...);
}
}

#define yare {cout<<"YES\n"; exit(0);}
#define nare {cout<<"NO\n"; exit(0);}

using pll=pair<long long,long long>;
using pii=pair<int,int>;
using vi=vector<int>;
using vll=vector<long long>;


char dirtochar(int dir){
if(dir==0)
return 'R';
else if(dir==1)
return 'L';
else if(dir==2)
return 'U';
return 'D';
}

int getdir(int t0,int t1){
if(t0==0 and t1==0)
return 0;
if(t0==1 and t1==1)
return 1;
if(t0==1 and t1==0)
return 2;
return 3;
};

signed main(){
_34raRxL;
int n;
cin>>n;
vec(pll) a(n);
rep(i,n){
cin>>a[i].fi>>a[i].se;
}
int ore=-1;
rep(i,n){
ll x=a[i].fi,y=a[i].se;
int re=(abs(x)%2)^(abs(y)%2);
if(ore!=-1 and ore!=re){
print(-1);
exit(0);
}
ore=re;
a[i]={x-y,x+y};
}
vec(vi) pans;
auto f=[&](ll u,ll v){
vi carry(2,0);
drep(i,31){
pans.back().pb(getdir(carry[0]^(u<0),carry[1]^(v<0)));
carry[0]=((abs(u)>>i)&1)^1;
carry[1]=((abs(v)>>i)&1)^1;
}
if(carry[0] and carry[1]){
int dir=0;
if(u>=0){
if(v>=0) dir=1;
else dir=2;
}else{
if(v<0) dir=0;
else dir=3;
}
pans.back().pb(dir);
}
};
rep(i,n){
ll u=a[i].fi,v=a[i].se;
pans.pb({});
f(u,v);
}
print(31+(ore^1),"\n");
drep(i,31){
print(1ll<<i,"");
}
print(ore%2?"\n":"1\n");
for(auto vc : pans){
for(auto x : vc){
print(dirtochar(x));
}
print();
}
//	
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=200005,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,par[maxn][18],id[maxn],dep[maxn];
vector<int> adj[maxn],adj2[maxn],vec[maxn];
bool good[maxn];
modint dp[maxn][2],res;

void dfs1(int u){
static int cur=0;
id[u]=cur++;
dep[u]=par[u][0]==-1?0:dep[par[u][0]]+1;
vec[dep[u]].pb(u);
bug(u,dep[u],par[u][0]);
for(auto v: adj[u]) dfs1(v);
}

int lca(int u, int v){
if(dep[u]>dep[v]) swap(u,v);
rep(18) if((dep[v]-dep[u])>>i&1) v=par[v][i];
if(u==v) return u;
rep3(i,17,0) if(par[u][i]!=par[v][i]) u=par[u][i],v=par[v][i];
return par[u][0];
}

vector<pii> virtual_tree(vector<int> vec){
sort(all(vec),[](int i, int j){return id[i]<id[j];});
vector<int> stk;
stk.pb(0);
vector<pii> res;
for(auto u: vec){
int x=lca(stk.back(),u);
while(sz(stk)&&dep[stk.back()]>dep[x]){
if(dep[stk[sz(stk)-2]]<=dep[x]) res.pb({x,stk.back()});
else res.pb({stk[sz(stk)-2],stk.back()});
stk.pop_back();
}
if(stk.back()!=x) stk.pb(x);
if(x!=u) stk.pb(u);
}
while(sz(stk)>=2) res.pb({stk[sz(stk)-2],stk.back()}),stk.pop_back();
return res;
}

void dfs2(int u){
dp[u][0]=dp[u][1]=0;
for(auto v: adj2[u]) dfs2(v);
dp[u][0]=1;
for(auto v: adj2[u]) dp[u][0]*=dp[v][0]+dp[v][1];
modint tmp=1;
for(auto v: adj2[u]) tmp*=dp[v][0];
if(adj2[u].empty()) dp[u][0]=2,dp[u][1]=1;
else for(auto v: adj2[u]) dp[u][1]+=dp[v][1]*tmp/dp[v][0];
dp[u][0]-=dp[u][1];
bug(u,dp[u][0],dp[u][1]);
bug(adj2[u]);
}

void orzck(){
cin >> n;
n++;
par[0][0]=-1;
rep(n-1){
int u;
cin >> u;
par[i+1][0]=u;
adj[u].pb(i+1);
}
rep2(i,1,18) rep1(u,n) par[u][i]=par[u][i-1]==-1?-1:par[par[u][i-1]][i-1];
dfs1(0);
rep(n) if(sz(vec[i])){
vector<pii> edges=virtual_tree(vec[i]);
for(auto& [u,v]: edges) adj2[u].clear(),adj2[v].clear();
for(auto& [u,v]: edges) adj2[u].pb(v);
dfs2(0);
bug(dp[0][1]);
res+=dp[0][1]*(modint(2).Pow(n-sz(vec[i])));
}
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int a[N];
map<int, int> p;

int main() {
qread(n);
rep(i, 1, n) qread(a[i]), ++p[a[i]];
vector<int> c;
rep(i, 1, n) {
if(p[a[i]] >= 2) c.pb(a[i]);
if(p[a[i]] >= 4) c.pb(a[i]);
p[a[i]] = 0;
}
sort(all(c), greater<int>());
if(c.size() < 2) puts("0");
else cout << 1ll * c[0] * c[1] << endl;
return 0;
}
#include<bits/stdc++.h>
#pragma GCC optimize("-Ofast")
#define File(name) freopen(#name".in", "r", stdin); freopen(#name".out", "w", stdout);
#define ri int
#define Int inline int
#define Void inline void
#define Bool inline bool
#define LL inline long long
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
template<typename T>
inline T read(){
T n = 0; int f = 1; char ch = getchar();
while(!isdigit(ch)){
if(ch == '-') f = -1;
ch = getchar();
}
while(isdigit(ch)){
n = n * 10 + ch - '0';
ch = getchar();
}
return f * n;
}
template<typename T>
void write(T n){
if(n/10) write(n/10);
putchar(n%10+'0');
}
void input() {}
template<typename Type, typename... Types>
void input(Type &arg, Types&... args){
arg = read<Type>();
input(args...);
}
namespace Main{
const int N = 1005;
const int M = 200005;
int n, m;
bool can[N][N], vis[N], flag[M];
vector<pair<int, int> > g[N], edges;
void dfs(int s, int u){
can[s][u] = true;
for(pair<int, int> v: g[u]){
if(can[s][v.first]) continue;
dfs(s, v.first);
}
}
void dfs2(int u){
vis[u] = true;
for(pair<int, int> v: g[u]){
if(vis[v.first]) continue;
dfs2(v.first);
}
}
void Main(){
input(n, m);
for(int i = 0, u, v; i < m; i++){
input(u, v);
g[u].push_back(make_pair(v, i));
edges.push_back(make_pair(u, v));
}
for(int i = 1; i <= n; i++) dfs(i, i);
for(int i = 1; i <= n; i++){
memset(vis, 0, sizeof(vis));
vis[i] = true;
for(pair<int, int> v: g[i]){
if(vis[v.first]) { flag[v.second] = true; continue; }
dfs2(v.first);
}
memset(vis, 0, sizeof(vis));
vis[i] = true;
for(int j = g[i].size() - 1; j >= 0; j--){
pair<int, int> v = g[i][j];
if(vis[v.first]) { flag[v.second] = true; continue; }
dfs2(v.first);
}
}
for(int i = 0; i < m; i++)
puts(can[edges[i].second][edges[i].first] ^ flag[i] ? "diff" : "same");
return;
}
} // namespace
int main(){
#ifdef Liuxizai
freopen("in", "r", stdin);
freopen("out", "w", stdout);
#endif // Liuxizai
Main::Main();
return 0;
}
#include <cstdio>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>

using namespace std;

const int NR = 1e6 + 5;

struct Edge {
int v, next;
} e[NR];

int n, m, en, cnt, h[NR], father[NR], vp[NR], dis[NR], vis[NR];
set < int > s;
vector < int > vec[NR], p;
vector < pair < int, int > > g;
priority_queue < pair < int, int >, vector < pair < int, int > >, greater < pair < int, int > > > q;

inline void add(int u, int v) {
en ++;
e[en].v = v, e[en].next = h[u], h[u] = en;
}

inline int find(int x) {
if (father[x] == x) return x;
return father[x] = find(father[x]);
}

inline void merge(int x, int y) {
father[find(x)] = find(y);
return;
}

inline void dij(int s) {
for (int i = 1; i <= cnt; ++i) dis[i] = 1e9 / 2;
dis[s] = 0, q.push(make_pair(dis[s], s));
while (!q.empty()) {
int k = q.top().second; q.pop();
if (!vis[k]) {
vis[k] = 1;
for (int i = h[k]; i; i = e[i].next) {
int v = e[i].v;
if (dis[k] + 1 < dis[v]) 
dis[v] = dis[k] + 1, q.push(make_pair(dis[v], v));
}
}
}
}

int main() {
scanf("%d %d", &n, &m), cnt = n;
for (int i = 1; i <= m; ++i) {
int u, v, c; scanf("%d %d %d", &u, &v, &c);
vec[c].push_back(i - 1), g.push_back(make_pair(u, v));
}
for (int i = 1; i <= 1e6; ++i) 
if (vec[i].size()) {
p.clear();
for (auto x : vec[i]) s.insert(g[x].first), s.insert(g[x].second);
for (set < int > :: iterator it = s.begin(); it != s.end(); ++it) p.push_back(*it);
s.clear();
for (auto x : p) father[x] = x, vp[x] = 0;
for (auto x : vec[i]) merge(g[x].first, g[x].second);
for (auto x : p) {
if (!vp[find(x)]) vp[find(x)] = ++ cnt;
add(x, vp[find(x)]), add(vp[find(x)], x);
}
}
dij(1);
if (dis[n] == 1e9 / 2) printf("-1");
else printf("%lld\n", dis[n] / 2);
return 0;
}
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
ll read()
{
ll ret=0;bool f=0;char c=getchar();
while(c>'9'||c<'0')f|=(c=='-'),c=getchar();
while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
return f?-ret:ret;
}
ll n,s;
int sqr;
ll calc(ll n,int b)
{
ll ret=0;
while(n)
{
ret+=n%b;
n/=b;
}
return ret;
}
int main()
{
n=read();s=read();
if(n==s){printf("%lld\n",n+1);return 0;}
sqr=sqrt(n);
for(int i=2;i<=sqr;i++)
if(calc(n,i)==s){printf("%d\n",i);return 0;}
for(ll l=sqr+1,r;l<=n;l=r+1)
{
r=n/(n/l);
ll val=n/l;
if((n-s)%val==0&&(n-s)/val+1>=l&&(n-s)/val+1<=r){printf("%lld\n",(n-s)/val+1);return 0;}
}
puts("-1");
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;
pair<int,int> sum[(1<<18)+5];
pair<int,int> max(pair<int,int> x,pair<int,int> y){
int num[5]={x.first,y.first,x.second,y.second};
sort(num,num+4);
return make_pair(num[3],num[2]);
}
int main(){
scanf("%d",&n);
for(int i=0;i<(1<<n);i++)scanf("%d",&sum[i].first);
for(int i=0;i<n;i++)
for(int j=1;j<(1<<n);j++)
if(j&(1<<i))sum[j]=max(sum[j],sum[j^(1<<i)]);
int ans=0;
for(int i=1;i<(1<<n);i++){
ans=max(ans,sum[i].first+sum[i].second);
printf("%d\n",ans);
}
return 0;
}
#include <vector>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <algorithm>
#include <map>
#include <cmath>
#include <queue>
#include <sstream>
#include <set>
#include<stack>
#include <utility>
#include <tuple>
#include <unordered_map>
#include <string.h>
#include <iomanip>
#include <deque>
#include <climits>
//#include<bits/stdc++.h>
//const long long MOD = 1000000007;
//const long long MOD = 1000000000000000007;
const long long MOD = 1000000000000000000+1;
using namespace std;
typedef long long llong;
typedef unsigned long long ullong;
#define INF (llong)1<<30
#define debug cout << "Hello" << endl;
//int isalpha(char ch): ch がアルファベットなら true を返す
//int isdigit(char ch): ch が数字なら true を返す
//int islower(char ch): ch が小文字なら true を返す
//int isupper(char ch): ch が大文字なら true を返す
//int tolower(char ch): ch の小文字を返す
//int toupper(char ch): ch の大文字を返す

//string型
//sort(s.begin(), s.end(), greater<char>())
//size()	文字数を返す
//Insert()	（指定した場所に）文字・文字列を挿入する
//erase()	（指定した場所の）文字・文字列を削除する
//clear()	すべての文字を削除する
//substr()	文字列の（指定した）部分文字列を返す
//replace()	（指定した）部分文字列を新しい文字列に置換する
//c_str()変換
//文字列の比較は、<=や==などを使え
//replace関数を使い、簡単に文字列を置換
//リバース関数：reverse(str.begin(), str.end());
//map<type, type> dict;で宣言
//グラフ理論用変数
//vector<vector<llong> > graph(N);

//ソート
//降順sort(v.begin(), v.end(), std::greater<Type>());

//大文字から小文字へんかん
//w[i] = w[i]-'A'+'a';

//vector
//assignメソッド　引数：サイズ、値
//与えられたサイズと値でvectorを初期化する

//queueクラス
//find()次に取り出す値の表示をする。
//pop()値を取り出す。戻り値はなし
//push()キューに値をプッシュする

//priority_queueクラス

//切り上げ
//ceil
//floor

//size()で返すのは、符号無し整数
//vectorが0の時は、
//for(int k=0; k<(int)temp_list.size()-1; k++)

/***
vector<llong> v;
do{

}while(next_permutation(v.begin(), v.end()));
***/

int main(){ 
llong N, M;
scanf("%lld %lld", &N, &M);
if(N==M){
if(N==1){
cout << 1 << endl;
return 0;
}
cout << (N-2)*(N-2) << endl;
}else{
if(M==1){
swap(N, M);
}
if(N==1){
cout << M-2 << endl;
}else{
cout << (N-2)*(M-2) << endl;
}
}
}  


#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n;
int a[200005];
int LOG = 31;

bool bit(int mask, int x){
return (mask >> x) & 1;
}

bool extendable(int mask, int v){
for(int i=0; i<LOG; i++){
if(bit(mask, i) && bit(v, i))
return false;
}
return true;
}

void switchOff(int &mask, int v){
mask ^= v;
}

int main() {
ios_base :: sync_with_stdio(false);
cin >> n;
for(int i=0; i<n; i++) cin >> a[i];

ll ans = 0;
int l = 0, r = 0, mask = a[0];
while(l < n){
while(r+1 < n && extendable(mask, a[r+1])){
r++;
mask |= a[r];
}

int len = r-l+1;
ans += 1ll * len;
switchOff(mask, a[l]);
l++;
}

cout << ans << endl;
} 
#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <algorithm>
#include <numeric>
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

int main()
{
int n = sc.next_int();
int m = sc.next_int();

std::vector<int> a(n);
std::vector<int> b(n);
for (int i = 0; i < n; i++)
{
a[i] = sc.next_int();
b[i] = sc.next_int();
}
std::vector<int> c(n);
for (int i = 0; i < n; i++)
c[i] = std::max(0, a[i] - b[i]);

std::vector<int> ord(n, 0);
std::iota(ord.begin(), ord.end(), 0);
std::sort(ord.begin(), ord.end(), [&](int x, int y) { return c[x] < c[y]; });
std::vector<std::vector<int>> g0(n);
for (int i = 0; i < m; i++)
{
int u = sc.next_int() - 1;
int v = sc.next_int() - 1;
g0[u].emplace_back(v);
g0[v].emplace_back(u);
}
std::vector<std::vector<int>> g(n);
std::vector<int>              p(n, 0);
std::iota(p.begin(), p.end(), 0);
auto find = [&](int x) {
while (x != p[x])
{
x = p[x] = p[p[x]];
}
return x;
};
std::vector<bool> vis(n, false);
for (auto u : ord)
{
for (auto v : g0[u])
{
if (vis[v] && find(v) != u)
{
g[u].emplace_back(find(v));
p[find(v)] = u;
}
}
vis[u] = true;
}

std::vector<long long> s(n, 0);
std::vector<long long> dp(n, 1e18);

std::function<void(int)> dfs = [&](int u) {
s[u] = b[u];
if (g[u].empty())
dp[u] = std::max(a[u], b[u]);
else
{
for (auto v : g[u])
{
dfs(v);
s[u] += s[v];
}
for (auto v : g[u])
dp[u] = std::min(dp[u], s[u] - s[v] + std::max(dp[v], (long long)c[u]));
}
};

dfs((int)ord.back());
std::cout << dp[(int)ord.back()] << std::endl;

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; --i)

int main() {
ll n, m;
cin >> n >> m;
if (n > m) swap(n, m);
if (n == 1) {
if (m == 1)
cout << 1 << endl;
else
cout << m - 2 << endl;
} else {
cout << (n - 2) * (m - 2) << endl;
}
return 0;
}

//#define _GLIBCXX_DEBUG
#pragma GCC target("avx")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")

#include <bits/stdc++.h>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
using mint = modint998244353;
#endif

using ll = long long;
using ld = long double;
using vi = vector<int>;
using vll = vector<ll>;
using vii = vector<vector<int>>; 
using vvll = vector<vector<ll>>;
const ll INF = 1ll<<60;
const ld EPS = 1.0/1e9;
#define endl "\n"
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)
#define all(x) (x).begin(),(x).end()
#define del(x) sort(all(x)); x.erase(unique(all(x)),x.end());

#define DEBUG_

template <typename T>
istream &operator>>(istream &is, vector<T> &vec) {
for (T &x : vec) is >> x;
return is;
}
template<typename T>
ostream& operator << (ostream &os, vector<T>& vec){
os << "{";
for(int i=0;i<vec.size();i++){
os << vec[i] << (i+1==vec.size() ? "" : ", ");
}
os << "}";
return os;
}
template <typename T, typename U>
ostream &operator<<(ostream &os, pair<T, U> &pair_var) {
os << "(" << pair_var.first << ", " << pair_var.second << ")";
return os;
}
template <typename T, typename U>
ostream &operator<<(ostream &os, map<T, U> &map_var) {
os << "{";
repi(itr, map_var) {
os << *itr;
itr++;
if (itr != map_var.end()) os << ", ";
itr--;
}
os << "}";
return os;
}
template <typename T>
ostream &operator<<(ostream &os, set<T> &set_var) {
os << "{";
repi(itr, set_var) {
os << *itr;
itr++;
if (itr != set_var.end()) os << ", ";
itr--;
}
os << "}";
return os;
}

#define DUMPOUT cerr

void dump_func() {
DUMPOUT << endl;
}
template <class Head, class... Tail>
void dump_func(Head &&head, Tail &&... tail) {
DUMPOUT << head;
if (sizeof...(Tail) > 0) {
DUMPOUT << ", ";
}
dump_func(std::move(tail)...);
}
#ifdef DEBUG_
#define DEB
#define dump(...)                                                              \
DUMPOUT << "  " << string(#__VA_ARGS__) << ": "                            \
<< "[" << to_string(__LINE__) << ":" << __FUNCTION__ << "]"        \
<< endl                                                            \
<< "    ",                                                         \
dump_func(__VA_ARGS__)
#else
#define DEB if (false)
#define dump(...)
#endif


int main(){
ios_base::sync_with_stdio(0);
cin.tie(0);
ll h,w,n; cin >> h >> w >> n;
vll a(n),b(n); map<pair<ll,ll>,bool>mp;
rep(i,0,n){
cin >> a[i] >> b[i];
mp[{a[i],b[i]}]=true;
}
vector<ll>ans(10);
map<pair<ll,ll>,bool>seen;
int dx[]={-1,-1,-1,0,0,0,1,1,1};
int dy[]={-1,0,1,-1,0,1,-1,0,1};
rep(i,0,n){
rep(j,0,9){
ll cnt=0; bool f=false;
ll x=a[i]+dx[j], y=b[i]+dy[j];
if(x<1 or y<1 or x>h or y>w) continue;
if(seen[{x,y}]) continue;
seen[{x,y}]=true;
rep(k,0,9){
ll nx=x+dx[k], ny=y+dy[k];
if(nx<1 or ny<1 or nx>h or ny>w){
f=true; break;
}
if(mp[{nx,ny}]) cnt++;
}
if(not f) ans[cnt]++;
}
}
ll sum=0;
rep(i,1,10) sum += ans[i]; 
ans[0] = (h-2)*(w-2)-sum;
rep(i,0,10) cout << ans[i] << endl;
}
#include<bits/stdc++.h>
#define maxn 1000005
#define int long long
#define put() putchar('\n')
using namespace std;
inline void read(int &x){
int f=1;x=0;char c=getchar();
while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
x*=f;
}
int n;
struct node{
int x,y;
node(int a=0,int b=0) {x=a;y=b;}
node operator +(const node &tmp) const {
int rt[5];
rt[1]=x;rt[2]=tmp.x;rt[3]=y;rt[4]=tmp.y;
sort(rt+1,rt+5);
return node(rt[4],rt[3]);
}
}dp[maxn];
int a[maxn];
signed main(void){
int i,j;
read(n);
for (i=0;i<(1<<n);i++) read(a[i]),dp[i]=node(a[i],-1);
for (j=0;j<n;j++)
for (i=1;i<(1<<n);i++)
if ((i>>j)%2==1) dp[i]=dp[i]+dp[i^(1<<j)];
int ans=0;
for (i=1;i<(1<<n);i++) {
ans=max(ans,dp[i].x+dp[i].y);
printf("%lld\n",ans);
}
return 0;
}

// #include <bits/stdc++.h>
#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream> 
#include <iterator>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>
using namespace std;
// #include <boost/multiprecision/cpp_int.hpp>
// using bint = boost::multiprecision::cpp_int;
using ll = long long;
using vl = vector<ll>;
using vvl = vector<vl>;
using pll = pair<ll, ll>;
#define rep(i, s, n) for (ll i = (ll)(s); i < (ll)(n); i++)
#define repr(i, n, s) for (ll i = (ll)(n); (ll)(s) < i; i--)
#define fore(e, a) for (auto&& e: (a))
#define len(a) (ll)(a).size()
#define all(a) (a).begin(), (a).end()
#define pb push_back
#define eb emplace_back
#define fi first
#define se second
/*********       P R I N T       **********/
template<class T> void print(const T& e);
template<class T> void print(const vector<T>& v);
template<class T> void print(const vector<vector<T>>& vv);
template<class H, class... T> void print(const H& h, const T&... t);  // スペース区切り
/*********       D E B U G       **********/
#ifdef __LOCAL
#define debug(...) if(DEBUG) do{cout << '[' << #__VA_ARGS__ << "] ";debug_(__VA_ARGS__);}while(0)
#else
#define debug(...)
#endif
template<class T> void debug_(const T& e);
template<class T> void debug_(const vector<T>& v);
template<class T> void debug_(const vector<vector<T>>& vv);
template<class T, class U> void debug_(const map<T, U>& mp);
template<class T, class U> void debug_(const vector<map<T, U>>& vm);
template<class T> void debug_(const set<T>& st);
template<class T> void debug_(const multiset<T>& st);
template<class T> void debug_(const vector<set<T>>& vs);
template<class T> void debug_(const vector<multiset<T>>& vs);
template<class H, class... T> void debug_(const H& h, const T&... t);  // 改行区切り
/*********       M  O  D       **********/
// #include <atcoder/modint>  // https://atcoder.github.io/ac-library/production/document_ja/
// using namespace atcoder;
// using mint = modint1000000007;     // modint998244353;
// const long long MOD = 1000000007;  // 998244353;
// using vm = vector<mint>;
// using vvm = vector<vm>;
// void print_(const mint& e){cout << e.val();}
// void dbg_(const mint& e){cout << e.val();}
/*********       O T H E R S       **********/
template<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}  // bは値渡し!
template<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}
template<class T> inline T mod(const T& a, const T& m) {return (a % m + m) % m;}
template<class T> inline T div_ceil(const T& x, const T& y) {return (x + y - 1) / y;}
template<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;
const long long INF64 = LONG_LONG_MAX / 2 - 10000LL;  // 4,611,686,018,427,377,903  ~= 4.6e+18, 19桁
const double PI = acos(-1);
const bool DEBUG = true;



int main() {
ll N, A, M;
cin >> N >> A;
vl X(N);
rep(i, 0, N) cin >> X[i];
// solve
M = 2510;
// M = 50;
vvl dp(N + 1, vl(M, 0));  // (足した数, 和)
dp[0][0] = 1;
rep(i, 0, N) {
ll x = X[i];
auto dp2 = dp;
rep(n, 0, N) {
rep(j, 0, M) {
if ((dp[n][j] == 0) || (j + x >= M)) continue;
dp2[n + 1][j + x] += dp[n][j];
}
}
swap(dp, dp2);
}
ll ans = 0;
rep(n, 1, N + 1) {
ll s = n * A;
ans += dp[n][s];
}
debug(dp);
print(ans);
}




/*********       P R I N T       **********/
// mint, pairの場合と処理を分けるために定義
template<class T> void print_(const T& e){
cout << e;
}

// pairの入れ子やvector<pll>に対応しているが、vector<pll>はpllごとに改行しないので注意
template<class T, class U> void print_(const pair<T, U>& p){
print_(p.first);
cout << ' ';
print_(p.second);
}

template<class T> void print(const T& e){
print_(e);
cout << '\n';
}

template<class T> void print(const vector<T>& v){
if (v.size()) {
auto iter = v.begin();
print_(*iter++);
for(; iter != v.end(); ++iter) {
cout << ' ';
print_(*iter);
}
}
cout << '\n';
}

template<class T> void print(const vector<vector<T>>& vv){
for(auto&& v : vv){
print(v);
}
}

// スペース区切りで出力。引数にpairやvectorは不可。
template<class H, class... T> void print(const H& h, const T&... t) {
cout << h << ' ';
print(t...);
}

/*********       D E B U G       **********/
void dbg_(const long long& e){
if (e >= INF64) cout << "INF";
else if (e <= -INF64) cout << "-INF";
else cout << e;
}

template<class T> void dbg_(const T& e){
cout << e;
}

// 再帰によりpairの入れ子を出力
template<class T, class U> void dbg_(const pair<T, U>& p) {
cout << '(';
dbg_(p.first);
cout << ' ';
dbg_(p.second);
cout << ')';
}

template<class T> void debug_(const T& e) {
dbg_(e);
cout << '\n';
}

template<class T> void debug_(const vector<T>& v){
if (v.size()) {
auto iter = v.begin();
dbg_(*iter++);
for(; iter != v.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const vector<vector<T>>& vv){
cout << '\n';
ll cnt = 0;
for(auto&& v : vv){
cout << cnt++ << ": ";
debug_(v);
}
}

template<class T, class U> void debug_(const map<T, U>& mp){
if (mp.size()) {
auto iter = mp.begin();
dbg_(*iter++);
for(; iter != mp.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T, class U> void debug_(const vector<map<T, U>>& vm){
cout << '\n';
ll cnt = 0;
for(auto&& mp : vm){
cout << cnt++ << ": ";
debug_(mp);
}
}

template<class T> void debug_(const set<T>& st){
if (st.size()) {
auto iter = st.begin();
dbg_(*iter++);
for(; iter != st.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const multiset<T>& st){
if (st.size()) {
auto iter = st.begin();
dbg_(*iter++);
for(; iter != st.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const vector<set<T>>& vs){
cout << '\n';
ll cnt = 0;
for(auto&& st : vs){
cout << cnt++ << ": ";
debug_(st);
}
}

template<class T> void debug_(const vector<multiset<T>>& vs){
cout << '\n';
ll cnt = 0;
for(auto&& st : vs){
cout << cnt++ << ": ";
debug_(st);
}
}

// 改行区切りで出力。引数にpairやvectorもOK。
template<class H, class... T> void debug_(const H& h, const T&... t) {
debug_(h);
debug_(t...);
}

#include <atcoder/all>
using namespace atcoder;
using namespace std;

int main(){
int N, A[101], B[101], C[101], D[101];
cin >> N;
mf_graph<int> graph(2*N+2);
int s=2*N, t=2*N+1;

for(int i=0;i<N;i++){
cin >> A[i] >> B[i];
graph.add_edge(s, i, 1);
}
for(int i=0;i<N;i++){
cin >> C[i] >> D[i];
graph.add_edge(i+N, t, 1);
}

for(int i=0;i<N;i++){
for(int j=0;j<N;j++){
if (A[i] < C[j] && B[i] < D[j]){
graph.add_edge(i, j+N, 1);
} 
}
}

cout << graph.flow(s,t) << endl;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

vector <vector <int>> a;
void xorRow(int i) {
for (auto& x : a[i])
x ^= 1;
}
void xorCol(int i) {
for (auto& x : a)
x[i] ^= 1;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);
int n, m; cin >> n >> m;
a.resize(n, vector <int>(m));
for (int i = 0; i < n; ++i) {
string s; cin >> s;
for (int j = 0; j < m; ++j) {
a[i][j] = (s[j] == '#' ? 0 : 1);
}
}
vector <vector <int>> grid(2 * n - 1, vector <int>(2 * m - 1));
for (int i = 0; i + 1 < n; ++i) {
for (int j = 0; j + 1 < m; ++j) {
vector <int> cnt(2);
for (int p1 : {0, 1})
for (int p2 : {0, 1})
cnt[a[i + p1][j + p2]]++;
if (max(cnt[0], cnt[1]) == 3) {
grid[2 * i + 1][2 * j + 1] = 1;
}
}
}
int ans = 0;
vector <int> h(2 * m - 1, 0);
for (int i = 0; i < 2 * n - 1; ++i) {
for (int j = 0; j < 2 * m - 1; ++j) {
h[j] = (grid[i][j] ? 0 : h[j] + 1);
}
vector <int> lx(2 * m - 1, -1), rx(2 * m - 1, 2 * m - 1);
vector <int> st;
for (int j = 0; j < 2 * m - 1; ++j) {
while (!st.empty() and h[st.back()] >= h[j])
st.pop_back();
if (!st.empty())
lx[j] = st.back();
st.push_back(j);
}
st = {};
for (int j = 2 * m - 2; j >= 0; --j) {
while (!st.empty() and h[st.back()] >= h[j])
st.pop_back();
if (!st.empty())
rx[j] = st.back();
st.push_back(j);
}
if (i & 1) continue;
for (int j = 0; j < 2 * m - 1; ++j) {
int X = (h[j] + 1) / 2, Y = (rx[j] - lx[j]) / 2;
ans = max(ans, X * Y);
}
}
cout << ans << '\n';
return 0;
}
#include<bits/stdc++.h>
using namespace std;
struct node{
long long v;
int id;
}a[100010];
int n,sz[100010],dep[100010];
vector<int>v[100010];
vector<pair<int,int> >ans;
bool cmp(node a,node b){
return a.v>b.v;
}
void dfs(int x,int fa){
dep[x]=dep[fa]+1;
for(int i=0;i<v[x].size();i++){
int to=v[x][i];
if(to==fa)continue;
dfs(to,x);
}
}
int main(){
scanf("%d",&n);
for(int i=1;i<=n;i++){
scanf("%lld",&a[i].v),a[i].id=i;
sz[i]=1;
}
sort(a+1,a+n+1,cmp);
for(int i=1;i<n;i++){
long long now=a[i].v-n+2*sz[i];
int l=1,r=n+1,res=0; 
while(l<=r){
int mid=(l+r)/2;
if(a[mid].v<=now)r=mid-1,res=mid;
else l=mid+1;
}
if(a[res].v!=now){
printf("-1\n");
return 0;
}
int x=a[i].id,y=a[res].id;
ans.push_back(make_pair(x,y));
v[x].push_back(y);
v[y].push_back(x);
sz[res]+=sz[i];
}
dfs(a[n].id,0);
long long sum=0;
for(int i=1;i<=n;i++)sum+=dep[i]-1;
if(sum==a[n].v){
for(int i=0;i<n-1;i++)printf("%d %d\n",ans[i].first,ans[i].second);
return 0;
}
printf("-1\n");
}
//xzh ak IOI,CTT,WC,APIO,NOI,CSP-S,NOIp
#pragma GCC optimize("Ofast,unroll-loops,fast-math,no-stack-protector")
#include<stdio.h>
#include<bits/stdc++.h>
#define fir first
#define sec second
#define all(x) begin(x),end(x)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned uint;
typedef double db;
typedef long double ldb;
typedef pair<int,int> pii;
typedef __int128 int128;
constexpr int Max=2e5+100;
int n,nxt[Max][26],f[Max];
char str[Max];
signed main()
{
ios::sync_with_stdio(false);
cin.tie(nullptr),cout.tie(nullptr);
cin>>(str+1),n=strlen(str+1);
for(int i=n;i;--i)
memcpy(nxt[i],nxt[i+1],sizeof(nxt[i+1])),nxt[i][str[i]-'a']=i;
memset(f,0x3f,sizeof(f));
for(int i=n;i;--i)
for(int j=0;j<26;++j)
if(!nxt[i][j])
f[i]=1;
else
f[i]=min(f[i],f[nxt[i][j]+1]+1);
int x=1;
while(true)
for(int i=0;i<26;++i)
{
if(!nxt[x][i])
cout.put(i+'a'),cout<<"\n",exit(0);
if(f[x]==f[nxt[x][i]+1]+1)
{
cout.put(i+'a'),x=nxt[x][i]+1;
break;
}
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep(i, n) for(int i=0; i<(n); i++)

int main(){
int n, k;
cin >> n >> k;
vector<int> a(n), cnt(n+1, 0);
rep(i, n){
cin >> a[i];
cnt[a[i]]++;
}
int now = 0;
rep(i, n+1){
if(cnt[i]!=0) now++;
if(cnt[i]==0) cnt[i] = 1000000000;
}
sort(cnt.begin(), cnt.end());
//rep(i, n+1) cout << cnt[i] << " ";
//cout << now << endl;
int ans = 0;
int j = 0;
while(now>k){
ans += cnt[j];
j++;
now--;
}
cout << ans << endl;
return 0 ;
}
#include<bits/stdc++.h>
using namespace std;
#define N 4040
const int mod=998244353;
typedef long long ll;
int fac[N],ifac[N],n,K,pw2[N],ans[N];
int qpow(int a,int b){
int ans=1;
while(b){
if(b&1)ans=1LL*ans*a%mod;
a=1LL*a*a%mod;
b>>=1;
}
return ans;
}	
void init(int n){
fac[0]=1;
for(int i=1;i<=n;++i){
fac[i]=1LL*fac[i-1]*i%mod;
}
ifac[n]=qpow(fac[n],mod-2);
for(int i=n-1;i>=0;--i){
ifac[i]=1LL*ifac[i+1]*(i+1)%mod;
}
pw2[0]=1;
for(int i=1;i<=n;++i){
pw2[i]=(pw2[i-1]<<1)%mod;
}
}
inline int C(int n,int m){
if(n<0||m<0||n<m)return 0;
return 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>K>>n;
init(max(n,K)<<1);
for(int i=3;i<=K+2;i+=2){
for(int j=0;j<=i/2;++j){
ans[i]=(ans[i]+1LL*pw2[j]*C(i/2,j)%mod*C(n+K-i,K-i+j))%mod;
}
ans[i-1]=ans[i];
}
for(int i=2;i<=K;++i)ans[2*K-i+2]=ans[i];
for(int i=2;i<=2*K;++i)cout<<ans[i]<<'\n';
return 0;
}
#include<bits/stdc++.h>
#define rg register
#define il inline
#define endl '\n'
#define maxn 1000005
#define int long long
using namespace std;
il int read(){rg int x=0,w=1;char ch=getchar();while (ch<'0' || ch>'9') {if (ch=='-') w=-1;ch=getchar();}while (ch>='0' && ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}return x * w;}
struct edge{
int to , next;	
}e[maxn];
int cnt , head[maxn];
void add(int u , int v){
e[++cnt].next = head[u];
head[u] = cnt;
e[cnt].to = v;
} 
int q[maxn] , vis[maxn];
int l = 1 , r , leftt[maxn] , rightt[maxn];
int ok = 1;
void bfs(){
while (l <= r){
rg int now = q[l++];
for (rg int i = head[now] ; i ; i = e[i].next){
rg int to = e[i].to;

if (!vis[to]){
vis[to] = 1 ;
q[++r] = to;
leftt[to] = leftt[now] - 1 , rightt[to] = rightt[now] + 1;	
}else{
rg int lf = leftt[now] - 1 , rf = rightt[now] + 1 , y1 = leftt[to] - 1 , y2 = rightt[to] + 1;
if (((leftt[to] + lf) & 1) || leftt[to] > rf || rightt[to] < lf){
ok = 0;		
}else{
rg int x1 = leftt[now] - 1 , x2 = rightt[now] + 1 , y1 = leftt[to] - 1 , y2 = rightt[to] +1;
leftt[to] = max(leftt[to] , x1);
rightt[to] = min(rightt[to] , x2);
leftt[now] = max(leftt[now] , y1);
rightt[now] = min(rightt[now] , y2);
}	
}
}
}
}
int val[maxn];
void bfs2(){
while (l <= r){
rg int now = q[l++];
vis[now] = 1;
val[now] = leftt[now];
leftt[now] = rightt[now] = val[now];
for (rg int i = head[now] ; i ; i = e[i].next){
rg int to = e[i].to;
rg int x1 = leftt[now] - 1 , x2 = rightt[now] + 1 , y1 = leftt[to] - 1 , y2 = rightt[to] +1;
leftt[to] = max(leftt[to] , x1);
rightt[to] = min(rightt[to] , x2);
if (!vis[to]){
q[++r] = to;
vis[to] = 1;	
}
}
}

}	
int a1[maxn] , a2[maxn] , kk[maxn] , ans[maxn];
int tot;
struct node{
int id , val;	
bool operator <(const node &x) const{
return val < x.val;	
}
};
priority_queue<node , vector<node> > pq;
signed main(){
rg int n = read();
for (rg int i = 1 ; i < n ; ++i){
rg int u = read() , v = read();
add(u , v);
a1[i] = u;
a2[i] = v;
add(v , u);	
}
rg int k = read();
for (rg int i = 1 ; i <= k ; ++i){
rg int x = read();
ans[x] = val[x] = read();
vis[x] = 1; 
pq.push((node){x , ans[x]});
}
while (!pq.empty()){
rg node now = pq.top();
pq.pop();
for (rg int i = head[now.id] ; i ; i = e[i].next){
rg int to = e[i].to;
if (!vis[to]){
ans[to] = now.val - 1;
vis[to] = 1;
pq.push((node){to , ans[to]});
}
else{
if (abs(ans[to] - ans[now.id]) != 1){
puts("No");
return 0;	
}
}
}
}
puts("Yes");
for (rg int i = 1 ; i <= n ; ++i)
cout << ans[i] << endl; 
return 0;
}

#include<iostream>
typedef long long ll;
ll n;
ll sum=0;
using namespace std;
int main()
{

cin>>n;

for(int i=1;;i++)
{
sum+=i;
if(sum>=n)
{
cout<<i<<endl;
return 0;
}
}
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
int n; cin>>n;
vector<vector<int>> a, b(n, vi(n));
for(int i=0; i<n; i++){
for(int j=0; j<n; j++){
cin>>b[i][j];
}
}
a = b;
for(int k=0; k<n; k++)
for(int j=0; j<n; j++)
for(int i=0; i<n; i++)
mni(a[j][i], a[j][k] + a[k][i]);
if(a != b){
cout<<-1<<endl; return;
}
int ans = 0;
for(int i=0; i<n; i++){
for(int j=i+1; j<n; j++){
int ok = 1;
for(int k=0; k<n; k++){
if(k == i || k == j)
continue;
if(a[i][k] + a[k][j] == a[i][j]){
ok = 0; break;
}
}
ans += ok*a[i][j];
}
}
cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<iostream>
#include<cstdio> 
#include<cstring>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
int n,a,b,x,y,sp1[100005]={},sp2[100005]={},cnt=0;
vector<int> graph[100005];
queue<int> q1,q2;
int main(){
scanf("%d",&n);
memset(sp1,63,sizeof(sp1));
memset(sp2,63,sizeof(sp2));
for(int i=1;i<n;i++){
scanf("%d%d",&a,&b);
graph[a].push_back(b),graph[b].push_back(a);
}
q1.push(1),q2.push(n),sp1[1]=sp2[n]=0;
while(!q1.empty()){
x=q1.front();
q1.pop();
for(int i=0;i<graph[x].size();i++){
y=graph[x][i];
if(sp1[x]+1<sp1[y]){
sp1[y]=sp1[x]+1;
q1.push(y);
} 
}
}
while(!q2.empty()){
x=q2.front();
q2.pop();
for(int i=0;i<graph[x].size();i++){
y=graph[x][i];
if(sp2[x]+1<sp2[y]){
sp2[y]=sp2[x]+1;
q2.push(y);
} 
}
}
for(int i=1;i<=n;i++) cnt+=-1+(sp1[i]<=sp2[i])*2;
printf((cnt>0)?"Fennec":"Snuke");
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
int N; cin >> N;
vector<long long> A(N);
for(int i = 0; i < N; i++) cin >> A[i];
int r = 0;
long long ans = 0;
long long tot = 0;
for(int l = 0; l < N; l++) {
while(r < N && ((tot + A[r]) == (tot ^ A[r]))) {
//cout << tot + A[r] << " " << (tot^A[r]) << endl;
tot += A[r];
r++;
}
ans += r-l;
if(l == r) r++;
tot -= A[l];
}
cout << ans << endl;
}
#include <iostream>
#include <cstdio>
#include <vector>

typedef long long ll;

const int N = 5010;
const int mod = 1e9 + 7;

int n;
std::vector<int> e[N];
int siz[N], tmp[N], f[N][N], g[N];

inline int read() {
int x = 0, f = 1;
char ch = std::getchar();
while (ch < '0' || ch > '9') {
if (ch == '-') f = -1;
ch = std::getchar();
}
while ('0' <= ch && ch <= '9') {
x = (x<<3) + (x<<1) + ch - '0';
ch = std::getchar();
}
return x * f;
}

void dfs(int u, int fa) {
f[u][siz[u]=1] = 1;
for (int v : e[u]) {
if (v == fa) continue;
dfs(v, u);
for (int i = 1; i <= siz[u] + siz[v]; i++)
tmp[i] = 0;
for (int i = 1; i <= siz[u]; i++)
for (int j = 0; j <= siz[v]; j++)
(tmp[i+j] += (ll)f[u][i] * f[v][j] % mod) %= mod;
for (int i = 1; i <= siz[u] + siz[v]; i++)
f[u][i] = tmp[i];
siz[u] += siz[v];
}
for (int i = 2; i <= siz[u]; i += 2)
(f[u][0] += mod - (ll)f[u][i] * g[i] % mod) %= mod;
}

int main() {
n = read();
for (int i = 1; i < n; i++) {
int u = read(), v = read();
e[u].push_back(v); e[v].push_back(u);
}
g[0] = 1;
for (int i = 2; i <= n; i += 2)
g[i] = (ll)g[i-2] * (i-1) % mod;
dfs(1, 0);
std::printf("%d\n", (mod-f[1][0])%mod);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=1005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],dp[maxn];
vector<int> adj[maxn];

void dfs(int u){
for(auto v: adj[u]) dfs(v);
bitset<maxm> bs;
bs[0]=1;
int tot=0;
for(auto v: adj[u]){
tot+=a[v]+dp[v];
if(dp[v]>=maxm) bs<<=a[v];
else bs=(bs<<a[v])|(bs<<dp[v]);
}
bool flag=0;
rep3(i,a[u],0) if(bs[i]){
flag=1;
dp[u]=tot-i;
break;
}
if(!flag){
print("IMPOSSIBLE");
exit(0);
}
}

void orzck(){
cin >> n;
rep(n-1){
int u;
cin >> u;
u--;
adj[u].pb(i+1);
}
rep(n) cin >> a[i];
dfs(0);
print("POSSIBLE");
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define int long long
std::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());

struct UFDS {
int n, c;
vector<int> len, par;
void init(int x, int y = 1) {
n = x;
c = y;
par.resize(n+2);
len.assign(n+2, 1);
iota(par.begin(), par.end(), 0);
}
int fin(int v) { return par[v] == v ? v : par[v] = fin(par[v]); }
bool join(int a, int b) {
a = fin(a); b = fin(b);
if(a == b) return false;
if(rng() % 2) swap(a, b);
if(c && len[a] < len[b])
swap(a, b);
par[b] = a;
if(c) len[a] += len[b];
return true;
}
int sz(int x) { return len[fin(x)]; }
};

signed main() {
std::ios::sync_with_stdio(0);
std::cout.tie(0);
std::cin.tie(0);
int n; cin >> n;
UFDS dsu; dsu.init(n);
vector<array<int, 2>> x(n), y(n);
vector<array<int, 3>> ed;
for(int i = 0; i < n; i++) {
cin >> x[i][0] >> y[i][0];
x[i][1] = y[i][1] = i;
}
sort(x.begin(), x.end());
sort(y.begin(), y.end());
for(int i = 1; i < n; i++) {
ed.push_back({x[i][0] - x[i - 1][0], x[i][1], x[i - 1][1]});
ed.push_back({y[i][0] - y[i - 1][0], y[i][1], y[i - 1][1]});
}
sort(ed.begin(), ed.end());
int ans = 0;
for(auto edge : ed) {
int w = edge[0], u = edge[1], v = edge[2];
if(dsu.join(u, v)) ans += w;
}
cout << ans << '\n';
return 0;
}
#include <bits/stdc++.h>
//#define CinCout
#define rep(i,n) for(int i=0,_##i##__end=(n);i<_##i##__end;++i)
#define per(i,n) for(int i=(n)-1;i>=0;--i)
#define rep1(i,n) for(int i=1,_##i##__end=(n);i<=_##i##__end;++i)
#define per1(i,n) for(int i=(n);i>=1;--i)
#define repk(i,a,b) for(int i=(a),_##i##__end=(b);i<=_##i##__end;++i)
#define perk(i,a,b) for(int i=(a),_##i##__end=(b);i>=_##i##__end;++i)
#define rep0(i,a,b) for(int i=(a),_##i##__end=(b);i<_##i##__end;++i)
#define pb push_back
#define mp make_pair
#define debugv(x) cout<<#x<<'='<<x<<",line "<<__LINE__-1<<endl
#define debug cout<<"at line "<<__LINE__-1<<" in function "<<__FUNCTION__<<endl
#define nextp next_permutation
#define pq priority_queue
#define fi first
#define se second
#ifdef CinCout
#define Yes cout<<"Yes"<<endl
#define No cout<<"No"<<endl
#define YES cout<<"YES"<<endl
#define NO cout<<"NO"<<endl
#else
#define Yes puts("Yes")
#define No puts("No")
#define YES puts("YES")
#define NO puts("NO")
#endif
typedef long long ll;
using namespace std;
const ll mod1=998244353;
const ll mod2=1000000007;
//ios_base::sync_with_stdio(false);加快cin
ll x,y;
int main()
{
cin>>x>>y;
if(abs(x-y)<=1)
{
cout<<"Brown"<<endl;
}
else
{
cout<<"Alice"<<endl;
}
return 0;
} 
/* things to check
1.  int overflow or long long memory need
2.  recursion/array/binary search/dp/loop bounds
3.  precision
4.  special cases(n=1,bounds)
5.  delete debug statements
6.  initialize(especially multi-tests)
7.  = or == , n or m ,++ or -- , i or j , > or >= , < or <=
8.  keep it simple and stupid
9.  do not delete, use // instead
10. operator priority
11. is there anything extra to output?
12. ...
*/

/* something to think about
1. greedy? dp? searching? dp with matrix/ segment tree? binary search?
2. If contains "not", why not 正难则反 or few affect?
*/


#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

struct UnionFind {
vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2

UnionFind(int N) : par(N) { //最初は全てが根であるとして初期化
for(int i = 0; i < N; i++) par[i] = i;
}

int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}
if (par[x] == x) return x;
return par[x] = root(par[x]);
}

void unite(int x, int y) { // xとyの木を併合
int rx = root(x); //xの根をrx
int ry = root(y); //yの根をry
if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま
par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける
}

bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す
int rx = root(x);
int ry = root(y);
return rx == ry;
}
};

int main(){
int n,k,l;
cin>>n>>k>>l;
UnionFind d(n),d2(n);
rep(i,k){
int p,q;
cin>>p>>q;
p--;q--;
d.unite(p,q);
}
rep(i,l){
int r,s;
cin>>r>>s;
r--;s--;
d2.unite(r,s);
}
vi v(n),v2(n);
map<pii,int> mp;
rep(i,n){
v[i]=d.root(i);
v2[i]=d2.root(i);
mp[{v[i],v2[i]}]++;
}
rep(i,n){
cout<<mp[{v[i],v2[i]}]<<" ";
}
cout<<endl;
}
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <iomanip>
#include <queue>
#include <cassert>
#include <bitset>
#include <iomanip>
#include <deque>
#include <cassert>
#include <numeric>

using namespace std;

#define debug(x) cout << #x << " is " << x << '\n';
#define ld long double
#define int long long

const int mod = 1e9 + 7, N = 5e6, M = 1e13;

struct edge {
int c, f;
edge(int c = 0, int f = 0) : c(c), f(f) {}
int left() {
return c - f;
}
};

vector <edge> edges;
vector <vector <pair <int, int>>> g;
vector <bool> used;

int make(int c, int f) {
edges.push_back(edge(c, f));
return edges.size() - 1;
}

void add(int u, int v, int c) {
g[u].push_back({ v, make(c, 0) });
g[v].push_back({ u, make(0, 0) });
}

int dfs(int v, int t, int cur) {
if (v == t) return cur;
used[v] = true;
for (auto u : g[v]) {
if (used[u.first] or !edges[u.second].left()) continue;
int got = dfs(u.first, t, min(cur, edges[u.second].left()));
if (got) {
edges[u.second].f += got;
edges[u.second ^ 1].f -= got;
return got;
}
}
return 0;
}

int minCut(int S, int T) {
int got = 0, res = 0;
while (true) {
got = dfs(S, T, mod * mod);
if (!got) break;
used.assign(g.size(), false);
res += got;
}
return res;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
int n; cin >> n;
vector <int> a(n);
int ans = 0;
for (int i = 0; i < n; ++i) {
cin >> a[i];
ans += a[i] * (a[i] > 0);
}
g.resize(n + 2);
used.resize(n + 2);
int S = n, T = n + 1;

for (int i = 0; i < n; ++i) {
if (a[i] > 0) add(i, T, a[i]);
else add(S, i, -a[i]);
for (int j = 2 * i + 1; j < n; j += i + 1) {
add(i, j, mod * mod);
}
}

ans -= minCut(S, T);
cout << ans << '\n';

return 0;
}
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 200005;
const ll mod = 998244353;

int n, Map[N];
ll f[N][5][5][5];
char c[N];

int main(){
scanf("%s",c+1);
n = strlen(c+1); int nan = 0, Add = 1;
for(int i=1;i<=n;i++)
Map[i] = c[i] - 'a', nan += Map[i];
for(int i=1;i<n;i++)
if(Map[i] == Map[i+1]){
Add = 0; break;
}
int nwn = Map[1], OK = 0;
for(int i=2;i<=n;i++) 
if(Map[i] != nwn) {
OK = 1; break;
}
if(OK == 0){
printf("1\n"); return 0;
}
if(n < 4){
if(n == 2) printf("2\n");
if(n == 3){
if(Map[1] == Map[3]) printf("7\n");
else if(Map[1] == Map[2] || Map[2] == Map[3]) printf("6\n");
else printf("3\n");
} return 0;
}
f[1][0][0][0] = f[1][0][1][1] = f[1][0][2][2] = 1;
nan %= 3;
for(int i=1;i<=n;i++)
for(int j=0;j<=1;j++)
for(int k=0;k<=2;k++)
for(int z=0;z<=2;z++)
for(int s=0;s<=2;s++)
f[i+1][j|(s==k)][s][(z+s)%3] = (f[i+1][j|(s==k)][s][(z+s)%3]+f[i][j][k][z]) % mod;

printf("%lld", ( (f[n][1][0][nan]+f[n][1][1][nan]) % mod + f[n][1][2][nan] + Add) % mod );
return 0;
}
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,b) for(int i=b-1;i>=0;i--)
#define rbit(i,a) for(int i=0;i<(1<<a);i++)
typedef long long ll;
typedef long double lld;
const ll mod=998244353;
using namespace std;
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
const string zton="0123456789";
const string atoz="abcdefghijklmnopqrstuvwxyz";
ll gcd(ll a,ll b){
ll r;
r=a%b;
if(r==0){
return b;
}
else{
return gcd(b,r);
}
}
typedef pair<ll,int> P;


int main(void){
int A,B;cin >> A >> B;
char ans[100][100];
rep(i,0,50)rep(j,0,100)ans[i][j]='#';
rep(i,50,100)rep(j,0,100)ans[i][j]='.';

A--;
B--;
rep(i,1,49)rep(j,1,99){
if(A==0)continue;
if(i%2==1&&j%2==1){
ans[i][j]='.';
A--;
}
}

rep(i,51,99)rep(j,1,99){
if(B==0)continue;
if(i%2==1&&j%2==1){
ans[i][j]='#';
B--;
}
}    
cout << 100 << " " << 100 << endl;
rep(i,0,100){
rep(j,0,100)cout << ans[i][j];
cout << endl;
}
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

inline void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

inline void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

inline void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n, m;
ll a[5005];
int b[5005][205][15], lg[5005];
ll res = -1e18;

/*
- ta cần chọn 1 đoạn [left, right], với mỗi ticket cần dùng ở nhà hàng có độ ngon lớn nhất
- gọi opt[i] là đoạn [i, opt[i]] tối ưu nhất với mỗi i
dễ thấy opt[i-1] <= opt[i] (phản chứng)
=> dùng DnC để tính đáp án  
*/

int get_max(int i, int l, int r) {
int k = lg[r-l+1];
return max(b[l][i][k], b[r-(1<<k)+1][i][k]);
}

ll get_cost(int l, int r) {
ll cost = -(a[r-1] - a[l-1]);
for (int i = 1; i <= m; ++ i) {
cost += get_max(i, l, r);
}
return cost;
}

void solve(int idL, int idR, int posL, int posR) {
if (idL > idR) return;
int mid = (idL + idR) >> 1, best_id = 1;
ll best_cost = -1e18;
for (int i = max(mid, posL); i <= posR; ++ i) {
ll tmp = get_cost(mid, i);
if (best_cost < tmp) {
best_cost = tmp;
best_id = i;
}
}
res = max(res, best_cost);
solve(idL, mid - 1, posL, best_id);
solve(mid + 1, idR, best_id, posR);
}

void solve() {
cin >> n >> m;
for (int i = 1; i < n; ++ i) {
cin >> a[i];
a[i] += a[i-1];
}
for (int i = 1; i <= n; ++ i)
for (int j = 1; j <= m; ++ j) {
cin >> b[i][j][0];
}
for (int i = 2; i <= n; ++ i) {
lg[i] = lg[i>>1] + 1;
}
for (int i = 1; i <= m; ++ i)
for (int j = 1; (1 << j) <= n; ++ j) {
for (int u = 1; u + (1 << j) - 1 <= n; ++ u) {
b[u][i][j] = max(b[u][i][j-1], b[u+(1<<(j-1))][i][j-1]);
}
}
solve(1, n, 1, n);
cout << res;
}

int main() {
cin.tie(0)->sync_with_stdio(0);
solve();
return 0;
}
///Bishmillahir Rahmanir Raheem
//sajeedreefy
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
typedef long long int ll;
#define pb push_back
#define pf push_front
#define ull unsigned long long
#define fr0(i,n) for (ll i=0;i<n;i++)
#define fr1(i,n) for (ll i=1;i<=n;i++)
#define ff first
#define ss second
#define sp " "
#define debug cout<<"dhukse ekhane "<<endl;
inline ll MOD(ll a){return (a%mod + mod) %mod ;}
inline ll modAdd(ll a,ll b){return MOD( MOD(a) + MOD(b) ) ;}
inline ll modSub(ll a,ll b){return MOD( MOD(a) - MOD(b) ) ;}
inline ll modMul(ll a,ll b){return MOD( MOD(a) * MOD(b) ) ;}
void fastIO(){ios_base::sync_with_stdio(false); cin.tie(NULL);}
ll dx[]={-1,1,0,0};
ll dy[]={0,0,-1,1};
//ll dx[8]={-1,1,0,0,-1,-1,1,1};
//ll dy[8]={0,0,-1,1,-1,1,-1,1};
/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds ;
template <typename PB>
using ordered_set = tree<PB,null_type,less<PB>,rb_tree_tag,tree_order_statistics_node_update> ;
*x.find_by_order(pos) ----> returns the value at "pos" index in the set 0-based
x.order_of_key(value)     ----> returns the position of "value" in the set 0-based
*/
bool isprime(ll x)
{
if(x<2) return false;
if(x<4) return true;
if(!(x&1)) return false;
for(int i=3; i*i<=x; i+=2) if(x%i==0) return false;
return true;
}

string toBinary(ll n)
{
string r;
while(n!=0)
{
r=(n%2==0 ?"0":"1")+r;
n/=2;
}
return r;
}
ll bi_ex(ll x,ll n)
{
ll pro=1;
while(n>0)
{
if(n%2==1) pro=((pro%mod)*(x%mod))%mod;
x=((x%mod)*(x%mod))%mod;
n>>=1;
}
return pro%mod;
}
ll powr(ll n,ll x)
{
if(x==0) return 1;
if(!(x&1)) return powr(n*n,x>>1);
else return n*powr(n*n,(x-1)>>1);
}

signed main()
{
fastIO();
//    freopen("input.txt", "r", stdin);
//    freopen("output.txt", "w", stdout);
ll t=1,mn,q,p,c,i,j,m,ans,a,b,d,x,y,k,n,mx;
//scanf("%lld",&t);
c=0;
//cin >> t;
while(t--)
{
cin >> n;
map <ll,ll> mp;
fr0(i,n)
{
cin >> x;
mp[x]++;
}
ans=0;
for(auto it: mp)
{
if(it.ff>it.ss) ans+=it.ss;
else ans+=it.ss-it.ff;
}
cout << ans << endl;
}
return 0;
}


#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e6 + 10;
const ll MOD = 1e9 + 7;
bool vis[maxn];
int prime[maxn / 10], tot;
void init(ll n)
{
vis[1] = 1;
for(ll i = 1; i <= n; i++)if(!vis[i])
{
prime[++tot] = i;
for(ll j = i * i; j <= n; j += i)
vis[j] = 1;
}
//cout<<tot<<endl;
//for(int i = 1; i <= tot; i++)
//    cout<<prime[i]<<endl;
}
ll f(ll n, ll x)
{
ll ans = 0;
while(n)
{
ans += n / x;
n /= x;
}
return ans;
}
int main()
{
ll n;
cin >> n;
init(n);
ll ans = 1;
for(int i = 1; i <= tot; i++)
ans = ans * (f(n, prime[i]) + 1) % MOD;
cout<<ans<<endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

inline void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

inline void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

inline int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
n = read();
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
c[i][j] = read();
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
printf("%lld\n", ans / 6);
return 0;
}

#include <bits/stdc++.h>
//#pragma comment(linker, "/STACK:50000000")
using namespace std;

#define mp make_pair
#define ll long long
#define all(_v) _v.begin(),_v.end()
#define ld long double
#define pb push_back
#define fi first
#define se second
#define pii pair<int, int>
const int mod = (int)1e9 + 7;
const int N = (int)2e5 + 100;
int nxt[N][3],ptr;
void add(string s){
int n = s.size();
int v = 0;
for(int i = 0;i < n;i++){
if(nxt[v][s[i] - '0'] == 0){
nxt[v][s[i] - '0'] = ++ptr;
}
v = nxt[v][s[i] - '0'];
}
}
int n;
ll l;
ll res;
void dfs(int v, int d){
for(int x = 0;x < 2;x++){
if(nxt[v][x] == 0){
ll tm = l - d;
ll p = tm & -tm;
res ^= p;
}else{
dfs(nxt[v][x], d + 1);
}
}
}
void work(){
cin >> n >> l;

for(int i = 1;i <= n;i++){
string s;
cin >> s;
add(s);
}
dfs(0, 0);
if(res)cout << "Alice"; else cout << "Bob";
}
int main(){
ios_base::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
int CNTT = 1;
//cin >> CNTT;
for(int NUM = 1;NUM <= CNTT;NUM++){
work();
}
return 0;
}

// 解き直し.
// https://img.atcoder.jp/arc093/editorial.pdf
// C++(GCC 9.2.1)
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using P = pair<int, int>;
using vi = vector<int>;
using vs = vector<set<int>>;
using T3 = tuple<LL, int, int>;
#define repex(i, a, b, c) for(int i = a; i < b; i += c)
#define repx(i, a, b) repex(i, a, b, 1)
#define rep(i, n) repx(i, 0, n)
#define repr(i, a, b) for(int i = a; i >= b; i--)
#define all(x) x.begin(), x.end()
const LL MOD = 1e9 + 7;
LL w[2020], mPow2[2020];
int u[2020], v[2020];

// https://github.com/atcoder/live_library/blob/master/uf.cpp
// UnionFind
// coding: https://youtu.be/TdR816rqc3s?t=726
// comment: https://youtu.be/TdR816rqc3s?t=6822
// -> 一部改変.
struct UnionFind{
vi d;
UnionFind(int n = 0): d(n, -1) {}
int find(int x){
return (d[x] < 0) ? x : (d[x] = find(d[x]));
}
bool unite(int x, int y){
x = find(x);
y = find(y);
if(x == y) return false;
if(d[x] > d[y]) swap(x, y);
d[x] += d[y];
d[y] = x;
return true;
}
bool same(int x, int y){
return find(x) == find(y);
}
int size(int x){
return -d[find(x)];
}
};

int main(){

// 1. 入力情報.
int N, M;
LL X;
scanf("%d %d %lld", &N, &M, &X);
map<P, LL> m;
rep(i, M){
scanf("%d %d %lld", &u[i], &v[i], &w[i]);
u[i]--;
v[i]--;
m[{u[i], v[i]}] = w[i];
m[{v[i], u[i]}] = w[i];
}

// 2. sort.
vector<T3> t;
rep(i, M) t.emplace_back(w[i], u[i], v[i]);
sort(all(t));

// 3. 最小全域木(Kruskal's Algorithm).
// 競プロ典型 90 問 (049 - Flip Digits 2)
// https://github.com/E869120/kyopro_educational_90/blob/main/sol/049.cpp
LL S = 0;
vs T(N);
UnionFind uf(N + 2);
rep(i, t.size()){
int a = get<1>(t[i]);
int b = get<2>(t[i]);
LL c = get<0>(t[i]);
if(!uf.same(a, b)){
uf.unite(a, b);
T[a].insert(b);
T[b].insert(a);
S += c;
}
}

// 4. D.
LL D = X - S;

// 5. bfs.
// https://ja.wikipedia.org/wiki/幅優先探索
auto bfs = [&](vs &G, int s, int* d){
// 空のキュー.
queue<int> q;

// 探索地点 s をキュー q に追加.
q.push(s);
while(!q.empty()){
// キューから取り出す.
int u = q.front();
q.pop();

// 隣接頂点をチェック.
for(auto &e : G[u]) if(!d[e] && e != s) d[e] = d[u] + 1, q.push(e);
}
};

// 6. 最短経路上 の 辺の重み の 最大値.
auto f = [&](vs &G, int g, int* d) -> LL{
// 返却用.
LL ret = 0;

// 空のキュー.
queue<int> q;

// 探索地点 g をキュー q に追加.
q.push(g);
while(!q.empty()){
// キューから取り出す.
int u = q.front();
q.pop();

// 隣接頂点をチェック.
for(auto &e : G[u]){
if(d[e] == d[u] - 1){
// 距離が 1 小さい頂点を追加.
q.push(e);

// 最短経路を構成する辺とみて, 辺の重みの最大値 を 更新.
ret = max(ret, m[{u, e}]);
}
}
}

// 返却.
return ret;
};

// 7. D との 比較.
// -> グラフ G に含まれるが, グラフ T に 含まれない 辺 のみ 計算.
int eLower = 0, eEqual = 0, eUpper = 0;
rep(i, M){
// グラフ T に 含まれる辺か？
if(T[u[i]].count(v[i])) continue;

// 最短距離.
int d[1010];
rep(j, 1010) d[j] = 0;
bfs(T, u[i], d);

// グラフ T 上で, pathMax 計算.
LL pathMax = f(T, v[i], d);

// diff の 値 に応じて, カウント.
LL diff = w[i] - pathMax;
if(diff < D)  eLower++;
if(diff == D) eEqual++;
if(diff > D)  eUpper++;
}

// 8. 2 の 冪乗.
mPow2[0] = 1;
repx(i, 1, 2020){
mPow2[i] = mPow2[i - 1] << 1;
mPow2[i] %= MOD;
}

// 9. 塗り方の個数.
LL ans = 1;

// 9-1. D < 0.
if(D < 0) ans = 0;

// 9-2. D == 0.
if(D == 0){
// T の 辺 に 2種類の色 を 両方用いる場合.
LL t1 = 1;
t1 *= (mPow2[N - 1] - 2);
t1 %= MOD;
t1 *= mPow2[M - N + 1];
t1 %= MOD;

// それ以外.
LL t2 = 1;
t2 *= 2;
t2 %= MOD;
t2 *= (mPow2[eEqual] - 1);
t2 %= MOD;
t2 *= mPow2[M-N+1-eEqual];
t2 %= MOD;

// 合計.
ans = t1 + t2;
ans %= MOD;
}

// 9-3. D > 0.
if(D > 0){
ans *= 2;
ans %= MOD;
ans *= (mPow2[eEqual] - 1);
ans %= MOD;
ans *= mPow2[eUpper];
ans %= MOD;
}

// 10. 出力.
printf("%lld\n", ans);
return 0;

}
#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
vector<int>g1[200001];
vector<int>g2[200001];
int col1[200001];
int col2[200001];
map<pair<int,int>,int>freq;

void dfs1(int node,int c) {
col1[node] = c;
for (auto &adj: g1[node]) {
if (col1[adj] == 0 ) {
dfs1(adj, c);
}
}
}
void dfs2(int node,int c) {
col2[node] = c;
for (auto &adj: g2[node]) {
if (col2[adj] == 0 ) {
dfs2(adj, c);
}
}
}
void solve() {
int n;
cin>>n;
int k,l;
cin>>k>>l;
for(int i=0;i<k;i++) {
int a, b;
cin >> a >> b;
--a;
--b;
g1[a].push_back(b);
g1[b].push_back(a);
}
for(int i=0;i<l;i++) {
int a, b;
cin >> a >> b;
--a;
--b;
g2[a].push_back(b);
g2[b].push_back(a);
}
int st=1;
for(int i=0;i<n;i++){
if(col1[i]==0){
dfs1(i,st);
st++;
}
}
st=1;
for(int i=0;i<n;i++){
if(col2[i]==0){
dfs2(i,st);
st++;
}
}
for(int i=0;i<n;i++){
freq[{col1[i],col2[i]}]++;
}
for(int i=0;i<n;i++){
cout<<freq[{col1[i],col2[i]}]<<" ";
}



}

int32_t main() {
nitin;

solve();
}
#include<bits/stdc++.h>
#define pb push_back
#define eb emplace_back
#define SZ(x) ((int)(x).size())
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int N=500005;
int main(){
int n,L;
scanf("%d%d",&n,&L);
int sumv=0;
double sumt=0;
deque<tuple<double,int> >que;
auto at=[&](int x){
if(x>=0)return que[x];
else return que[SZ(que)+x];
};
rep(i,1,n){
double t;
int v;
scanf("%lf%d",&t,&v);
sumv+=v;
while(!que.empty()&&sumv>L){
sumt-=get<0>(que[0])*get<1>(que[0]);
if(get<1>(que[0])<=sumv-L){
sumv-=get<1>(que[0]);
que.pop_front();
}else{
get<1>(que[0])-=sumv-L;
sumv=L;
sumt+=get<0>(que[0])*get<1>(que[0]);
}
}
while(!que.empty()&&t<get<0>(at(-1))){
sumt-=get<0>(at(-1))*get<1>(at(-1));
t=(t*v+get<0>(at(-1))*get<1>(at(-1)))/(v+get<1>(at(-1)));
v+=get<1>(at(-1));
que.pop_back();
}
sumt+=t*v;
que.eb(t,v);
printf("%.20f\n",sumt/L);
}
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, cc = 1e8;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n, C; cin >> n >> C;
vector <int> v(n + 2), p(n + 2);
p[n + 1] = C;
for (int i = 0; i < n; ++i)
cin >> p[i + 1] >> v[i + 1];

int ans = 0;
vector <int> pref(n + 2), suf(n + 2), maxPref(n + 2), maxSuf(n + 2), maxPref2(n + 2), maxSuf2(n + 2);
for (int i = 1; i <= n + 1; ++i) {
pref[i] = pref[i - 1] - p[i] + p[i - 1] + v[i];
maxPref[i] = max(pref[i], maxPref[i - 1]);
maxPref2[i] = max(maxPref2[i - 1], pref[i] - p[i]);
ans = max(ans, pref[i]);
}
for (int i = n; i >= 0; --i) {
suf[i] = suf[i + 1] - p[i + 1] + p[i] + v[i];
maxSuf[i] = max(suf[i], maxSuf[i + 1]);
maxSuf2[i] = max(maxSuf2[i + 1], suf[i] - (C - p[i]));
ans = max(ans, suf[i]);
}

for (int i = 0; i <= n; ++i) {
ans = max({ ans, maxPref2[i] + maxSuf[i + 1], maxPref[i] + maxSuf2[i + 1] });
}
cout << ans << '\n';

return 0;
}
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define dF(i,a,b) for(int i=(a);i>=(b);--i)
#define ms(a,vl) memset(a,vl,sizeof(a))
using namespace std;
long long n,a[170],b[170],sum,ans=-1e18;
int main(){ios::sync_with_stdio(0),cin.tie(0);
cin>>n;
for(int i=1;i<=n;i++) cin>>b[i];
F(_,1,100000){
for(int i=1;i<=n;i++) a[i]=b[i];
for(int i=n;i;i--){
sum=0;
for(int j=1;j<=n/i;j++) sum+=a[j*i];
if((sum<=0)^(rand()%13==0))for(int j=1;j<=n/i;j++)a[j*i]=0;
}
sum=0;
for(int i=1;i<=n;i++) sum+=a[i];
ans=max(ans,sum);
}
cout<<ans;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

int n;
int a[N];

int main() {
qread(n);
ll sum = 0;
rep(i, 1, n) qread(a[i]), sum += a[i];
ll ans = 1e18, nw = 0;
rep(i, 1, n) {
if(i > 1) To_min(ans, abs(sum - nw * 2));
nw += a[i];
}
cout << ans << endl;
return 0;
}
#include<bits/stdc++.h>
using namespace std;

const int MAXN=6005;
bool f[MAXN][MAXN];//总 水
int A,B,C,D,E,F;

double ans=-1;
int main(){
f[0][0]=1;
cin>>A>>B>>C>>D>>E>>F;
for(int i=0;i<=F;i++){
for(int j=0;j<=i;j+=100){
if(f[i][j]){
if(i+A*100<=F)f[i+A*100][j+A*100]=1;
if(i+B*100<=F)f[i+B*100][j+B*100]=1;
int sugar=i-j;
if(j/100*E>=sugar+C){
f[i+C][j]=1;
}
if(j/100*E>=sugar+D){
f[i+D][j]=1;
}
}
}
}
int ansx=100*A,ansy=0;
for(int i=1;i<=F;i++){
for(int j=0;j<=i;j+=100){
if(f[i][j]){
//cout<<i<<" "<<j<<endl;
int sugar=i-j;
if(sugar*ansx>ansy*i){
ans=1.0*sugar/i;
ansx=i;ansy=sugar;
}
}
}
}
cout<<ansx<<" "<<ansy<<endl;
return 0;
}
#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#if __cplusplus >= 201103L
#include <type_traits>
#endif
#include <iostream>
#include <limits>
#define INTM_FAST_32 int
#define INTM_FAST_64 unsigned long long
#define _7 __attribute__((always_inline)) inline
#if __cplusplus >= 201103L
#define _6 constexpr
#define CXX11_EXPLICIT explicit
#else
#define _6
#define CXX11_EXPLICIT
#endif
#if __cplusplus >= 201402L
#define _5 constexpr
#else
#define _5
#endif
namespace cm{template<INTM_FAST_32 _2=998244353>class intm{
#if __cplusplus >= 201103L
static_assert(_2*2<std::numeric_limits<INTM_FAST_32>::max(),"");
#endif
public:static constexpr int MOD=_2;protected:INTM_FAST_32 a=0;_7 _6 explicit intm(INTM_FAST_32 a,int):a(a){}static _7 _6 INTM_FAST_32 _4(INTM_FAST_32 a){return a<0?a+MOD:a;}static _7 _6 INTM_FAST_32 _1(INTM_FAST_32 a){return a>=MOD?a-MOD:a;}template<class IntType>static _7 _5 INTM_FAST_32 _3(INTM_FAST_32 a,IntType b){INTM_FAST_32 res=1;for(;b;b>>=1){if(b&1){res=(INTM_FAST_32)((INTM_FAST_64)(res)*(INTM_FAST_64)(a)%MOD);}a=(INTM_FAST_32)((INTM_FAST_64)(a)*(INTM_FAST_64)(a)%MOD);}return res;}static int pretty(int x){if(x>=MOD-1000)return x-MOD;return x;}public:
#if __cplusplus >= 201103L
intm()=default;
#else
intm(){}
#endif
static _6 intm raw(INTM_FAST_32 x){return intm(x,0);}_7 _6 intm(int a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(long a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(long long a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(unsigned int a):a(static_cast<INTM_FAST_32>(a%MOD)){}_7 _6 intm(unsigned long a):a(static_cast<INTM_FAST_32>(a%MOD)){}_7 _6 intm(unsigned long long a):a(static_cast<INTM_FAST_32>(a%MOD)){}template<class _8>_7 _6 CXX11_EXPLICIT operator _8()const{return a;}_7 friend std::ostream&operator<<(std::ostream&out,const intm rhs){
out<<rhs.a;return out;
}_7 friend std::istream&operator>>(std::istream&in,intm&rhs){long long a;in>>a;rhs=intm(a);return in;}template<class _8>_7 _5 intm pow(_8 k)const{return raw(_3(a,k));}_7 _5 intm inv()const{
cm_assert(a!=0,"warning:0 do not have inv");
return raw(_3(a,MOD-2));}_7 _6 friend bool operator<(const intm a,const intm b){return a.a<b.a;}_7 _6 friend bool operator<=(const intm a,const intm b){return a.a<=b.a;}_7 _6 friend bool operator>(const intm a,const intm b){return a.a>b.a;}_7 _6 friend bool operator>=(const intm a,const intm b){return a.a>=b.a;}_7 _6 friend bool operator==(const intm a,const intm b){return a.a==b.a;}_7 _6 friend bool operator!=(const intm a,const intm b){return a.a!=b.a;}template<class _8>_7 _6 friend bool operator<(const _8 a,const intm b){return a<b.a;}template<class _8>_7 _6 friend bool operator<(const intm a,const _8 b){return a.a<b;}template<class _8>_7 _6 friend bool operator<=(const _8 a,const intm b){return a<=b.a;}template<class _8>_7 _6 friend bool operator<=(const intm a,const _8 b){return a.a<=b;}template<class _8>_7 _6 friend bool operator>(const _8 a,const intm b){return a>b.a;}template<class _8>_7 _6 friend bool operator>(const intm a,const _8 b){return a.a>b;}template<class _8>_7 _6 friend bool operator>=(const _8 a,const intm b){return a>=b.a;}template<class _8>_7 _6 friend bool operator>=(const intm a,const _8 b){return a.a>=b;}template<class _8>_7 _6 friend bool operator==(const _8 a,const intm b){return a==b.a;}template<class _8>_7 _6 friend bool operator==(const intm a,const _8 b){return a.a==b;}template<class _8>_7 _6 friend bool operator!=(const _8 a,const intm b){return a!=b.a;}template<class _8>_7 _6 friend bool operator!=(const intm a,const _8 b){return a.a!=b;}_7 _6 friend intm operator+(const intm a,const intm b){return raw(_1(a.a+b.a));}_7 _6 friend intm operator-(const intm a,const intm b){return raw(_4(a.a-b.a));}_7 _6 friend intm operator*(const intm a,const intm b){return raw(static_cast<INTM_FAST_32>((INTM_FAST_64)(a.a)*(INTM_FAST_64)(b.a)%MOD));}_7 _5 friend intm operator/(const intm a,const intm b){return a*b.inv();}_7 _6 friend intm&operator+=(intm&a,const intm b){return a=a+b;}_7 _6 friend intm&operator-=(intm&a,const intm b){return a=a-b;}_7 _6 friend intm&operator*=(intm&a,const intm b){return a=a*b;}_7 _5 friend intm&operator/=(intm&a,const intm b){return a=a/b;}template<class _8>_7 _6 friend intm operator+(const intm a,const _8 b){return a+intm(b);}template<class _8>_7 _6 friend intm operator-(const intm a,const _8 b){return a-intm(b);}template<class _8>_7 _6 friend intm operator*(const intm a,const _8 b){return a*intm(b);}template<class _8>_7 _5 friend intm operator/(const intm a,const _8 b){return a/intm(b);}template<class _8>_7 _6 friend intm&operator+=(intm&a,const _8 b){return a+=intm(b);}template<class _8>_7 _6 friend intm&operator-=(intm&a,const _8 b){return a-=intm(b);}template<class _8>_7 _6 friend intm&operator*=(intm&a,const _8 b){return a*=intm(b);}template<class _8>_7 _5 friend intm&operator/=(intm&a,const _8 b){return a/=intm(b);}template<class _8>_7 _6 friend intm operator+(const _8 a,const intm b){return intm(a)+b;}template<class _8>_7 _6 friend intm operator-(const _8 a,const intm b){return intm(a)-b;}template<class _8>_7 _6 friend intm operator*(const _8 a,const intm b){return intm(a)*b;}template<class _8>_7 _5 friend intm operator/(const _8 a,const intm b){return intm(a)/b;}template<class _8>_7 _6 friend _8&operator+=(_8&a,const intm b){return a+=_8(b);}template<class _8>_7 _6 friend _8&operator-=(_8&a,const intm b){return a-=_8(b);}template<class _8>_7 _6 friend _8&operator*=(_8&a,const intm b){return a*=_8(b);}template<class _8>_7 _5 friend _8&operator/=(_8&a,const intm b){return a/=_8(b);}};}
#undef _7
#undef _6
#undef _5
#undef INTM_FAST_32
#undef INTM_FAST_64
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

constexpr int MOD = 1'000'000'007;
constexpr int N   = 5005;
using int_t       = cm::intm<MOD>;

std::vector<int> e[N];

int n;

int_t cnt[N];

std::vector<int_t> dfs(int u, int f)
{
std::vector<int_t> pos{0, 1};
for (int v : e[u])
if (v != f)
{
auto dpv = dfs(v, u);

std::vector<int_t> cur(pos.size() + dpv.size() - 1);
for (size_t i = 0; i < pos.size(); i++)
for (size_t j = 0; j < dpv.size(); j++)
{
cur[i + j] += pos[i] * dpv[j];
cur[i] -= pos[i] * dpv[j] * cnt[j];
}

pos = std::move(cur);
}
return pos;
}

int main()
{
n = sc.next_int();
for (int i = 1; i < n; i++)
{
int u = sc.next_int();
int v = sc.next_int();
e[u].push_back(v);
e[v].push_back(u);
}

cnt[0] = 1;
for (int i = 2; i <= n; i++)
cnt[i] = cnt[i - 2] * (i - 1);

auto  res = dfs(1, 0);
int_t ans = 0;
for (size_t i = 0; i < res.size(); i++)
ans += res[i] * cnt[i];

std::cout << ans << std::endl;

return 0;
}

#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)
using namespace std;

typedef long long ll;

int main(){
int N;
cin >> N;
vector<ll> A(N), B(N), C(N);
rep(i, N) cin >> A[i];
rep(i, N) cin >> B[i];
rep(i, N) cin >> C[i];

sort(A.begin(), A.end());
sort(B.begin(), B.end());
sort(C.begin(), C.end());

vector<int> B_num(N, 0);
int head = N;
for(int i = N-1; i>=0; i--){
while(head > 0 && C[head - 1] > B[i]) head--;
B_num[i] = N - head;
}

ll ans = 0, accum = 0;
head = N;
for(int i = N-1; i>=0; i--){
while(head > 0 && B[head - 1] > A[i]){
head--;
accum += B_num[head];
}
ans += accum;
}

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
#define ll long long
#define fi first
#define se second
const ll MOD=1e9+7;
using namespace std;
ll N,a[200005];
int main(){
cin>>N;
for(int i=1;i<=N;i++){
cin>>a[i];
}
ll ans=1;
ll l=1;
ll r=1;
ll sum=a[1];
ll xorr=a[1];
a[N+1]=0;
while(l<N&&r<=N){
while(r+1<=N&&sum+a[r+1]==(xorr^a[r+1])){
sum+=a[r+1];
xorr^=a[r+1];
r++;
}
ans+=(r-l+1);
sum-=a[l];
xorr^=a[l];
l++;
}
cout<<ans<<endl;
}
#include <bits/stdc++.h>
const int N = 1e6;
using namespace std;
int sum[N];
int main()
{
int x;
sum[0] = 0;
for (int i = 1; i <= N; i++)
{
sum[i] = sum[i - 1] + i;
}
cin >> x;
for (int i = 1; i <= N; i++)
{
if (sum[i] >= x)
{
cout << i << endl;
return 0;
}
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
int w, h, n, ans;
pair<int,int> a[N];
#define ls p << 1
#define rs p << 1 | 1
struct node{int l, r, val, lz;} t[N << 2];
void pushup(int p) {t[p].val = max(t[ls].val, t[rs].val);}
void pushdown(int p) {
if(t[p].lz) {
t[ls].val += t[p].lz; t[ls].lz += t[p].lz;
t[rs].val += t[p].lz, t[rs].lz += t[p].lz;
t[p].lz = 0;
}
}
void build(int p, int l, int r) {
t[p] = {l , r, 0, 0};
if(l == r) return;
int mid = l + r >> 1;
build(ls, l, mid); build(rs, mid + 1, r);
}
void change(int p, int l, int r, int c) {
if(t[p].l >= l && t[p].r <= r) {t[p].val += c, t[p].lz += c; return;}
int mid = t[p].l + t[p].r >> 1;
pushdown(p);
if(mid >= l) change(ls, l, r, c);
if(mid < r) change(rs, l, r, c);
pushup(p);
}
int query(int p, int l, int r) {
if(t[p].l >= l && t[p].r <= r) return t[p].val;
int mid = t[p].l + t[p].r >> 1;
pushdown(p);
int ans = 0;
if(mid >= l) ans = max(ans, query(ls, l, r));
if(mid < r) ans = max(ans, query(rs, l, r));
return ans;
}
stack<pair<int,int>>minn, maxn;
void changemin(int x, int y) {
while(minn.size() > 1 && minn.top().second < y) {
pair<int,int> w = minn.top(); minn.pop();
change(1, minn.top().first, w.first - 1, w.second);
}
change(1, minn.top().first, x - 1, -y);
minn.push({x, y});
}
void changemax(int x, int y) {
while(maxn.size() > 1 && maxn.top().second > y) {
pair<int,int> w = maxn.top(); maxn.pop();
change(1, maxn.top().first, w.first - 1, -w.second);
}
change(1, maxn.top().first, x - 1, y);
maxn.push({x, y});
}
int getlength() {
int ans = 0;
sort(a + 1, a + n + 1);
while(!minn.empty()) minn.pop();
while(!maxn.empty()) maxn.pop();
build(1, 0, n + 1);
minn.push({0, 0}), maxn.push({0, 0});
for(int i = 1; i <= n + 1; i ++) {
if(i >= 2) {
if(a[i - 1].second * 2 < h ) changemin(i - 1, a[i - 1].second), changemax(i - 1, h);
else changemin(i - 1, 0), changemax(i - 1, a[i - 1].second);
change(1, i - 1, i - 1, - a[i - 1].first);
ans = max(ans, query(1, 0, i - 2) + a[i].first);
}
ans = max(ans, a[i].first - a[i - 1].first + h);
}
return ans;
}
signed main() {
cin >> w >> h >> n;
for(int i = 1; i <= n; i ++)
cin >> a[i].first >> a[i].second;
a[n + 1] = {w, h};
ans = getlength();
for(int i = 1; i <= n + 1; i ++) swap(a[i].first, a[i].second);
swap(w, h);
ans = max(ans, getlength());
cout << ans * 2 << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, 
rb_tree_tag, tree_order_statistics_node_update>;
*/

#define MOD 1000000007
typedef long long ll;
//#define int ll 

typedef pair<int, int> ii;
typedef vector<ll> vi;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define ff first
#define ss second
#define pb push_back
#define all(s) s.begin(), s.end()
#define tc int t; cin>>t; while(t--)
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
#define file_read(x,y) freopen(x, "r", stdin); \
freopen(y, "w", stdout);
#define fightFight cin.tie(0) -> sync_with_stdio(0)
#define show_vi(a)        \
cout << #a << "-->";  \
for (auto &x : a) cout << x << " "; \
cout << endl;

int main(){
fightFight;
ll n, k;	
cin >> n >> k;
ll q = n / k;
ll ans = q * q * q;
if (k % 2 == 0) {
q = n / (k / 2) - q;
ans += q * q * q;
}
cout << ans << "\n";
}

/**
*    author:  shu8Cream
*    created: 19.01.2022 23:08:28
**/

#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for (int i=0; i<(n); i++)
#define rrep(i,n) for (int i=(n-1); i>=0; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) int((x).size())
using ll = long long;
using P = pair<ll,ll>;
using vi = vector<ll>;
using vvi = vector<vi>;
const ll INF = 8e18;

template<class T> inline bool chmax(T& a, T b) {
if (a < b) { a = b; return true; }
return false;
}
template<class T> inline bool chmin(T& a, T b) {
if (a > b) { a = b; return true; }
return false;
}

template <class T> string to_string(T s);
template <class S, class T> string to_string(pair<S, T> p);
string to_string(char c) { return string(1, c); }
string to_string(string s) { return s; }
string to_string(const char s[]) { return string(s); }

template <class T>
string to_string(T v) {
if (v.empty()) return "{}";
string ret = "{";
for (auto x : v) ret += to_string(x) + ",";
ret.back() = '}';
return ret;
}
template <class S, class T>
string to_string(pair<S, T> p) {
return "{" + to_string(p.first) + ":" + to_string(p.second) + "}";
}

void debug_out() { cout << endl; }

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
cout << to_string(H) << " ";
debug_out(T...);
}

#ifdef _DEBUG
#define debug(...) debug_out(__VA_ARGS__)
#else
#define debug(...)
#endif

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
double a,b,c,d,e,f;
cin >> a >> b >> c >> d >> e >> f;
double mx = 0;
ll water = 0, sugar = 0;
rep(i,f/100/a+1){
rep(j,f/100/b+1){
rep(k,f/c+1){
rep(l,f/d+1){
if(100.0*e/(100.0+e)<100.0*(k*c+l*d)/(i*a*100+j*b*100+k*c+l*d)) continue;
if(i*a*100+j*b*100+k*c+l*d>f) continue;
chmax(mx,100.0*(k*c+l*d)/(i*a*100+j*b*100+k*c+l*d));
debug(mx);
if(mx==100.0*(k*c+l*d)/(i*a*100+j*b*100+k*c+l*d)){
water = i*a*100+j*b*100;
sugar = k*c+l*d;
}
}
}
}
}
cout << water+sugar << " " << sugar << endl;
}
#include <bits/stdc++.h>
using namespace std;
#define INF 1000000000
#define rep(i, a, b) for (int i = a; i < b; i++)
#define all(x) (x).begin(), (x).end()
const double PI = acos(-1);
template <class T>
inline bool chmax(T &a, T b)
{
if (a < b)
{
a = b;
return 1;
}
return 0;
}

int main()
{
long long x, y;
cin >> x >> y;
int count = 0;
while (true)
{

if (x > y)
break;
x *= 2;
count++;
//cout << x << endl;
}
cout << count << endl;
}
#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <vector>
#include <math.h>
#include <climits>
#include <algorithm>
#include <vector>
#include <string>
#include <algorithm>
#include <set>
#include <map>
#include <unordered_map>
using namespace std;
typedef long long ll;

#define rep(i,n) for (long long i = 0; i < (n); ++i)
//using P = pair<int,int>;
//#include<bits/stdc++.h>

int main()
{
int n;
cin >> n;
ll a;
vector<ll>A;
rep(i,n){
cin >> a;
A.push_back(a);
}
sort(A.rbegin(),A.rend());
ll x=0,y;
rep(i,n)
{
if(A[i] == A[i+1] && x != 0)
{
y = A[i];
break;
}
if(A[i] == A[i+1]){
x = A[i];
i++;
}
}
cout << x*y << endl;
return 0;
}
#include <cstdio>

#define rep( i, a, b ) for( int i = (a) ; i <= (b) ; i ++ )
#define per( i, a, b ) for( int i = (a) ; i >= (b) ; i -- )

typedef long long LL;

const int MAXN = 1005;

template<typename _T>
void read( _T &x ) {
x = 0; char s = getchar(); bool f = false;
while( s < '0' || '9' < s ) { f = s == '-', s = getchar(); }
while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar(); }
if( f ) x = -x;
}

template<typename _T>
void write( _T x ) {
if( x < 0 ) putchar( '-' ), x = -x;
if( 9 < x ) write( x / 10 );
putchar( x % 10 + '0' );
}

LL x[MAXN], y[MAXN];

int N;

int main() {
//	freopen( ".in", "r", stdin );
//	freopen( ".out", "w", stdout );
read( N );
bool app[2] = {};
rep( i, 1, N ) {
read( x[i] ), read( y[i] );
app[( x[i] + y[i] ) & 1] = true;
}
if( app[0] && app[1] )
return puts( "-1" ), 0;
const int m = 30;
printf( "%d\n", m + 1 + ( app[0] ) );
rep( i, 0, m ) printf( "%d ", 1 << i );
if( app[0] ) printf( "1" );
puts( "" );
rep( i, 1, N ) {
bool alle = false;
if( ( x[i] + y[i] ) % 2 == 0 ) 
alle = true, x[i] --;
LL p = x[i] - y[i], q = x[i] + y[i];
p += ( 1ll << ( m + 1 ) ) - 1; 
q += ( 1ll << ( m + 1 ) ) - 1;
rep( j, 1, m + 1 ) {
bool a = p >> j & 1,
b = q >> j & 1;
if( ! a && ! b ) putchar( 'L' );
if(   a && ! b ) putchar( 'D' );
if( ! a &&   b ) putchar( 'U' );
if(   a &&   b ) putchar( 'R' );
}
if( alle ) putchar( 'R' );
puts( "" );
}
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <math.h>
#include <numeric>
#include <list>
#include <queue>
#include <string>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <string>   


using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<vector<int>> vvi;
typedef vector<vector<int>> vi;
typedef pair<pair<int,int>, int> ppiii;
typedef pair<int, pair<int,int>> pipii;
typedef pair<int,char> pic;
typedef pair<char,int> pci;
typedef pair<string,string> pss;

ll sb(vector<ll>& in) {
//cout << "debug in :" << endl;
ll tot = in[0];
ll res = 0;
for (int i = 1; i < in.size(); i++) {
ll cur = tot + in[i];
if (tot > 0 && cur >= 0) {
res += (cur + 1);
cur = -1;
}
if (tot < 0 && cur <= 0) {
res += 1 - cur;
cur = 1;
}
tot = cur;
}
return res;
}

ll sp(vector<ll> in) {
ll res = 0;
if (in[0] <= 0) {
res += 1 - in[0];
in[0] = 1;
}
return res + sb(in);
}

ll sn(vector<ll> in) {
ll res = 0;
if (in[0] >= 0) {
res += in[0] + 1;
in[0] = -1;
}
return res + sb(in);
}

void solve() {
ll n,x; cin >> n;
vector<ll> in(n);
for(auto& it : in) cin >> it;
ll pos = sp(in);
ll neg = sn(in);
//cout << pos << " " << neg << endl;
cout << min(pos, neg) << endl;

}




int main() {
ios_base::sync_with_stdio(0);
cin.tie(0);
int t = 1;
//cin >> t;
while(t--) {
solve();
}
}





#include<bits/stdc++.h>
#define maxn 200005
#define ll long long
#define put() putchar('\n')
using namespace std;
inline void read(int &x){
int f=1;x=0;char c=getchar();
while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
x*=f;
}
int n,a[maxn];
signed main(void){
int i;ll ans=0;
read(n); 
for (i=1;i<=n;i++) read(a[i]),a[i]-=i;
sort(a+1,a+1+n);
for (i=1;i<=n;i++) ans+=abs(a[i]-a[(n+1)/2]);
printf("%lld",ans);
return 0;
}
#include<bits/stdc++.h>
typedef long long int ll; typedef long double ld; using namespace std; const ll mod = 1e9 + 7, inf = 9e18; const ld pi = 2 * acos (0.0), eps = 1e-12;

ll n, s, ans = -1, L;
vector<ll> factor;

ll f(ll b) {
ll curr = n, ans = 0;
for (; curr >= b;) {
ans += (curr % b);
curr /= b;
}
ans += curr;
return ans;
}

int main() {
ios::sync_with_stdio(0); cin.tie(nullptr); cout.tie(0);
cin >> n >> s;
L = n - s;
if (L < 0)
return puts("-1"), 0;
if (L == 0)
return cout << n + 1 << "\n", 0;
for (ll l = 1; l <= sqrt(n) + 5; ++l)
if (L % l == 0)
factor.push_back(l + 1), factor.push_back(L / l + 1);
sort(factor.begin(), factor.end());
for (auto x : factor) {
if (x == 1)
continue;
if (f(x) == s) {
ans = x;
break;
}
}
cout << ans << "\n";
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main () {
unsigned long long n;
string n_str;
cin >> n_str;
n = n_str.size();
unsigned long long sum = 0;
unsigned long long num = 0;
for (unsigned long long tmp = 0; tmp < (1 << n - 1); tmp++) {
bitset<9> s(tmp);  // 最大n個なのでnビットのビット列として扱う

unsigned long long start = 0;
for (unsigned long long i = 0; i < n - 1; i++){
if (s.test(i)) {
num = stoull(n_str.substr(start, i - start + 1));
sum += num;
start = i + 1;
}
}
num = stoull(n_str.substr(start, n - start));
sum += num;
}
cout << sum << endl;
}


#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
vector <string> a(2);
for (auto& x : a) cin >> x;
int ans = 3, st = 1;
bool lst = 0;
if (a[0][0] != a[1][0]) {
ans = 6, st = 2;
lst = 1;
}
for (int i = st; i < n; ++i) {
if (!lst) ans = ans * 2 % mod;
if (a[0][i] != a[1][i]) {
if (lst) ans = ans * 3 % mod;
i++;
}
lst = (a[0][i] != a[1][i]);
}
cout << ans << '\n';
return 0;
}

#include <iostream>
using namespace std;

int main()
{
int a, b, c, x, y;
cin >> a >> b >> c >> x >> y;
long long ans = 10000*100000;
long long cost = 0;
for (int i = 0; i <= 100000; ++i)
{
cost = i * 2 * c + max(0, x - i) * a + max(0, y - i) * b;
if (ans > cost)
ans = cost;
}

cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std; 

typedef long long ll; 
typedef pair <int, int> ii; 

const ll LINF = (ll) 1e18; 
const int INF = (int) 1e9;

ll ans(ll l, ll r) {
if (l > r) return 0; 
return r - l + 1; 
}

ll sum(ll n) {
return n * (n + 1) / 2; 
}

int main() {
ios::sync_with_stdio(0); 
cin.tie(0); 
int n, k; 
cin >> n >> k; 

// x * a -> (x + 1) * a - 1
ll res = 0; 

for (int a = 1; a <= n; a++) {
for (int x = 1; x * a <= n; x++) {
int l = max(k, l % a), r = min(n, (x + 1) * a - 1) % a; 
res += ans(l, r);
}
}

res += sum(n - max(1, k)); 
cout << res << '\n'; 
}
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
int a, b, c, x, y;
cin >> a >> b >> c >> x >> y;
long long cost = 0;

int min_xy=min(x,y);
int max_xy=max(x,y);
long long ans1,ans2,ans3;
ans1=2*c*max_xy;//only AB
ans2=a*x+b*y;// only A,B
ans3=2*c*min_xy+a*(x-min_xy)+b*(y-min_xy);//A,B,AB

long long ans=min({ans1,ans2,ans3});   

cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
// #include<atcoder/all>

using namespace std;
// using namespace atcoder;

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ll, int> pli;

const double EPS = 1e-10;
const int INF = 1001001001;
const ll LINF = 1e15;
const double PI = acos(-1);
const ll mod = 1e9+7;

#define equals(a, b) (fabs((a) - (b)) < EPS)
#define rep(i,n) for (int i = 0; i < (n); ++i)
#define dup(x,y) (((x)+(y)-1)/(y))
#define ALL(x) (x).begin(), (x).end()

int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};

template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

int labo(){
// 全探索
return 0;
}

ll factrial(int n){
ll res = 1;
for (int i=1; i<=n; i++) res*=i;
return res;
}

ll chose(int n, int m){
return factrial(n) / factrial(m) / factrial(n-m);
}

void printVect(vector<int> A){
rep(i, A.size()){
cout << A[i] << " ";
}
cout << endl;
}

using G = vector<vector<int>>;

int solve(){
int n, k;
cin >> n >> k;

ll ans = 0;
for (int i=k+1; i<=n; i++){
int p = n / i;
int m = (n % i);

ans += max(0, i-k) * p + max(0, m-k+1);

// cout << i << " " << max(0, i-k) * p + max(0, m) << " " << p << " " << m << endl;
// cout << p << " " << m << endl;
// break;
}
if (k == 0){
ans -= n;
}
cout << ans << endl;
return 0;
}


int main(){
// labo()
solve();
}           

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
map <int, int> cnt;
int ans = 0;
vector <int> mx;
for (int i = 0, x; i < n; ++i) {
cin >> x;
cnt[x]++;
if (cnt[x] == 2) mx.push_back(x);
if (cnt[x] == 4) ans = max(ans, x * x);
}

sort(mx.begin(), mx.end());
if (mx.size() > 1)
ans = max(ans, mx.back() * mx[mx.size() - 2]);
cout << ans << '\n';
return 0;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i,a) for(int i=0;i<(a);++i)


int main(){
int n; cin>>n;
vector<int> a(n);
rep(i,n)cin>>a[i];
int L, Q; cin>>L>>Q;
int K = 1;
while((1<<K)<=n) K++;
vector<vector<int>> doubling(K, vector<int>(n, -1));
rep(i, n-1){
int ok = i+1;
int ng = n;
while(ng-ok>1){
int mid = (ok+ng)/2;
if(a[mid] - a[i] <= L) ok = mid;
else ng = mid;
}
doubling[0][i] = ok;
}
rep(i, K-1)rep(j,n){
if(doubling[i][j]<0){
doubling[i+1][j] = -1;
} else {
doubling[i+1][j] = doubling[i][doubling[i][j]];
}
}
rep(i, Q){
int u, v; cin>>u>>v;
u--; v--;
if (u > v) swap(u, v);
int res = 0;
for(int k = K-1; k>=0;k--){
if(doubling[k][u] < v && doubling[k][u] != -1){
u = doubling[k][u];
res += 1 << k;
}
}
cout << res + 1 << endl;
}
return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 5;
ll n, a[maxn], dp1[maxn], dp2[maxn], ans = 0;
int main()
{
cin >> n;
for (int i = 0; i < 1 << n; i++)
{
cin >> dp1[i];
}
for (int j = 0; j < n; j++)
{
for (int i = 0; i < 1 << n; i++)
{
if (i & (1 << j))
{
ll pre = i ^ (1 << j);
ll ans1, ans2;
ans1 = max(dp1[pre], dp1[i]);
if (dp1[pre] > dp1[i]) ans2 = max(dp2[pre], dp1[i]);
else ans2 = max(dp2[i], dp1[pre]);
dp1[i] = ans1, dp2[i] = ans2;
}
}
}
for (int i = 1; i < 1 << n; i++)
{
ans = max(ans, dp1[i] + dp2[i]);
cout << ans << endl;
}
return 0;
}
#include <iostream> 
#include <string> 
#include <utility>
#include <vector> 
#include <algorithm> 
#include <map>
#include <queue> 
#include <set>
#include <stack>
#include <iomanip>
#include <cmath>
#include <limits>
#include <complex>
using namespace std;
typedef long long ll;
#define rep(i,n) for (int i = 0; i < (n); i++)
#define all(v) v.begin(), v.end()
const ll INF = 1001001001001001001;
const ll MOD = 1000000007;
const ll mod = 998244353;
const int inf = 1 << 29;




int main() {
string s,t;
cin >> s;
ll sum = 0,n = s.size();
rep(i, (1 << (n-1))) {
rep(j, n) {
t += s[j];
if (j == n-1 || i & (1 << j)) {
sum += stoll(t);
t = "";
}
}
}
cout << sum << endl;


return 0;
}
# include <bits/stdc++.h>

using namespace std;

#define _USE_MATH_DEFINES_
#define ll long long
#define ld long double
#define Accepted 0
#define pb push_back
#define mp make_pair
#define sz(x) (int)(x.size())
#define every(x) x.begin(),x.end()
#define F first
#define S second
#define lb lower_bound
#define ub upper_bound
#define For(i,x,y)  for (ll i = x; i <= y; i ++)
#define FOr(i,x,y)  for (ll i = x; i >= y; i --)
#define debug(x) cerr << #x << " = " << x << endl
#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)
// ROAD to...                                                                                                                                                                                                                Red

void setIn(string s) { freopen(s.c_str(),"r",stdin); }
void setOut(string s) { freopen(s.c_str(),"w",stdout); }
void setIO(string s = "") {
// cin.exceptions(cin.failbit);
// throws exception when do smth illegal
// ex. try to read letter into int
if (sz(s)) { setIn(s+".in"), setOut(s+".out"); } // for USACO
}

const int dx[] = {-1, 0, 1, 0};
const int dy[] = {0, -1, 0, 1};
mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());

int rnd (int l, int r) {
return uniform_int_distribution<int> (l, r)(gen);
}

int sgn(ll x) {
return (x > 0 ? 1 : -1);
}

ll solve(vector<int> &a) {
if(a.empty() || a[0] == 0) return 1e18;
ll cur = 0;
ll last = a[0];
for (int i = 1; i < sz(a); ++i) {
ll pref = a[i] + last;
if(sgn(last) != sgn(pref)) {
last = pref;
} else {
ll target = sgn(-last);
last = target;
cur += abs(pref - target);
}
}
return cur;
}

void solve() {
int n;
cin >> n;
vector < int > a(n);
for (int i = 0; i < n; ++i) cin >> a[i];
ll ans = solve(a);
int was = a[0];
a[0] = 1;
ans = min(ans, solve(a) + abs(was - 1));
a[0] = -1;
ans = min(ans, solve(a) + abs(was + 1));
cout << ans << '\n';
}


int32_t main () {
SpeedForce;

int TestCases = 1;
//cin >> TestCases;

for (int TestCase = 1; TestCase <= TestCases; ++TestCase) {
//cout << "Case #" << TestCase << ": ";

solve();
}

return Accepted;
}

// B...a

// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline int read(){
int x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

const int N=100005;

char a[N];
int n;

int main(){
scanf("%s",a+1);
n=strlen(a+1);
if(a[1]=='0'||a[n]=='1'){
puts("-1");
return 0;
}
rep(i,1,n-1){
if(a[i]!=a[n-i]){
puts("-1");
return 0; 
}
}
int j=1;
rep(i,1,n){
if(a[i]=='1'){
while(j<i)printf("%d %d\n",j,i),j++;
}
}
printf("%d %d\n",n-1,n);
return 0;
} 
#include<bits/stdc++.h>
using namespace std;
#define N 200020
typedef long long ll;
int nxt[N][26],n,las[26],dp[N],jb[N];
char s[N];
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>(s+1);
n=strlen(s+1);
memset(las,-1,sizeof(las));
for(int i=n;i>=0;--i){
memcpy(nxt[i],las,sizeof(las));
if(i>0)las[s[i]-'a']=i;
}
for(int i=n;i>=0;--i){
dp[i]=1e9;
for(int c=0;c<26;++c){
if(!~nxt[i][c]){
dp[i]=1;jb[i]=c;break;
}
if(dp[nxt[i][c]]+1<dp[i]){
dp[i]=dp[nxt[i][c]]+1;jb[i]=c;
}
}
}
for(int u=0;~u;u=nxt[u][jb[u]]){
cout<<(char)(jb[u]+'a');
}
return 0;
}



#include <bits/stdc++.h>
using namespace std;
#define ll long long int
#define endl '\n'

int main() {
ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
string s;
cin >> s;

ll left = (s.length() / 2) - 1, right = s.length() / 2, k=0;
if(s.length() % 2 == 1) left++;
ll middle = s[left];

while(left >= 0 && right < s.length()) {
if((s[left] == s[right]) && (int(s[left]) == middle)) {
k++;
left--;
right++;
} else break;
}
ll finalans = k + (s.length() / 2);
cout << finalans << endl;
}
// Exported by Exporter.exe

// Included from C.cpp
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define F first
#define S second
#define MP make_pair
#define MTP make_tuple
#define R Read
#define RD Read_Digit
#define RP Read_P
#define RS Read_String
#define RL Read_Loop
#define RLD Read_Loop_Digit
#define RLP Read_Loop_P
#define RLS Read_Loop_String
#ifdef ONLINE_JUDGE
#define Debug(...) ;
#define Debug_Array(n,x) ;
#define Debugln_Array(n,x) ;
#define NL ;
#else
#define Debug(...) {printf("(%s) = ",(#__VA_ARGS__)),_print(__VA_ARGS__),printf("\n");}
#define Debug_Array(n,x) {printf("%s :",(#x));for(int i=1;i<=n;i++)printf(" "),_print(x[i]);printf("\n");}
#define Debugln_Array(n,x) {for(int i=1;i<=n;i++){printf("%s",(#x));printf("[%d] = ", i);_print(x[i]);printf("\n");}}
#define NL {printf("\n");}
#endif
typedef long long int ll;
typedef unsigned long long int ull;

constexpr int kN = int(3E3 + 10);
// constexpr int kMod = 998244353;
// constexpr int kMod = int(1E9 + 7);
// constexpr int kInf = 0x3f3f3f3f;
// constexpr ll kInf = 0x3f3f3f3f3f3f3f3f;
// constexpr double kPi = acos(-1);
// constexpr double kEps = 1E-9;
// constexpr int dx[4] = {0, 0, 1, -1};
// constexpr int dy[4] = {1, -1, 0, 0};
// constexpr int dx[8] = {0, 0, 1, -1, 1, -1, 1, -1};
// constexpr int dy[8] = {1, -1, 1, -1, -1, 1, 0, 0};


// Included from C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp
bool Fast_IO_activated = false;
bool IOS_activated = false;
// --- Get ---
static inline char Get_Raw_Char() {
static bool pre = Fast_IO_activated = true;
static char buf[1 << 16], *p = buf, *end = buf;
if (p == end) {
if ((end = buf + fread(buf, 1, 1 << 16, stdin)) == buf) return '\0';
p = buf;
}
return *p++;
}

// --- Read ---
template <typename T> static inline void Read_P(T &n) {
static_assert(is_integral<T>::value, "Read_P requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
return ;
}

template <typename T> static inline void Read(T &n) {
static_assert(is_integral<T>::value, "Read requires an integral type");
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
if (neg) n = -n;
return ;
}

template <typename T> static inline void Read_Digit(T &n) {
static_assert(is_integral<T>::value, "Read_Digit requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
return ;
}

static inline void Read_String(string &s) {
s.clear();
char c = Get_Raw_Char();
while (c == ' ' or c == '\n') c = Get_Raw_Char();
while (c != ' ' and c != '\n') {
s += c;
c = Get_Raw_Char();
}
return ;
}

// --- Read multiple ---
template <typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read(n); return Read(Fargs...);}
template <typename T, typename... Targs> static inline void Read_Digit(T &n, Targs&... Fargs) {Read_Digit(n); return Read_Digit(Fargs...);}
template <typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P(n); return Read_P(Fargs...);}
template <typename... Targs> static inline void Read_String(string &s, Targs&... Fargs) {Read_String(s); return Read_String(Fargs...);}

// --- Read Loop ---
template <typename T> static inline void Read_Loop_i(int i, T *a) {return Read(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_i(int i, T *a, Targs*... Fargs) {Read(a[i]); return Read_Loop_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_Digit_i(int i, T *a) {return Read_Digit(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_Digit_i(int i, T *a, Targs*... Fargs) {Read_Digit(a[i]); return Read_Loop_Digit_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_Digit(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_Digit_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_P_i(int i, T *a) {return Read_P(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_P_i(int i, T *a, Targs*... Fargs) {Read_P(a[i]); return Read_Loop_P_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_P(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_P_i(i, Fargs...);}

static inline void Read_Loop_String_i(int i, string *a) {return Read_String(a[i]);}
template <typename... Targs> static inline void Read_Loop_String_i(int i, string *a, Targs*... Fargs) {Read_String(a[i]); return Read_Loop_String_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_String(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_String_i(i, Fargs...);}

// --- Float ---
template <int mul, typename T> static inline void Read(T &n) {
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;

if (neg) n = -n;
return ;
}

template <int mul, typename T> static inline void Read_P(T &n) {
char c;
while (!isdigit(c = Get_Raw_Char())) ;

n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;
return ;
}

template <int mul, typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read<mul>(n); return Read<mul>(Fargs...);}
template <int mul, typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P<mul>(n); return Read_P<mul>(Fargs...);}

// --- init ---
inline void IOS() {
IOS_activated = true;
ios::sync_with_stdio(false); cin.tie(0);
}
inline void Freopen(const char *in, const char *out) {freopen(in, "r", stdin); freopen(out, "w", stdout); return ;}

// --- Output ---
#if defined(__SIZEOF_INT128__)
void Print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
} 
#endif
// End of C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp
template <typename T, typename T1> void make_vector_inner(vector<T>& vec, T1 c) {return vec.push_back(T(c));}
template <typename T, typename T1, typename... Targs> void make_vector_inner(vector<T> &vec, T1 c, Targs... targs) {
vec.push_back(T(c));
return make_vector_inner(vec, targs...);
}
template <typename T, typename... Targs> vector<T> make_vector(Targs... targs) {
vector<T> vec;
make_vector_inner(vec, targs...);
return vec;
}

template <typename T> inline void sort(vector<T> &v) {return sort(v.begin(), v.end());}
template <typename T> inline void sort_r(vector<T> &v) {return sort(v.begin(), v.end(), greater<T>());}
inline void sort(string &s) {return sort(s.begin(), s.end());}
inline void sort_r(string &s) {return sort(s.begin(), s.end(), greater<char>());}

template <typename T> inline void reverse(vector<T> &v) {return reverse(v.begin(), v.end());}
inline void reverse(string &s) {return reverse(s.begin(), s.end());}

template <typename T> inline void Merge(vector<T> &a, vector<T> &b, vector<T> &c) {
if (c.size() < a.size() + b.size()) c.resize(a.size() + b.size());
merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());
return ;
}
template <typename T> inline void Concatanate(vector<T> &a, vector<T> &b, vector<T> &c) {
int a_size = int(a.size()), b_size = int(b.size());
c.resize(a_size + b_size);
for (int i = 0; i < a_size; i++) c[i] = a[i];
for (int i = 0; i < b_size; i++) c[i + a_size] = b[i];
return ;
}
template <typename T> inline void Append(vector<T> &lhs, vector<T> rhs) {
int lsz = int(lhs.size()), rsz = int(rhs.size());
lhs.reserve(lsz + rsz);
for (int i = 0; i < rsz; i++) lhs.push_back(rhs[i]);
return ;
}

template <typename T> inline void Erase(vector<T> &vec, T x) {
int sz = int(vec.size());
for (int i = 0; i < sz; i++) if (vec[i] == x) {
swap(vec[i], vec.back());
vec.pop_back();
break;
}
return ;
}

template <typename T> inline void Discrete(vector<T> &v) {sort(v); v.resize(unique(v.begin(), v.end()) - v.begin()); return ;}
template <typename T> inline int Discrete_Id(vector<T> &v, T x) {return lower_bound(v.begin(), v.end(), x) - v.begin();}

template <typename T> using PQ = priority_queue<T>;
template <typename T> using PQ_R = priority_queue<T, vector<T>, greater<T>>;

template <typename T> inline T ABS(T n) {return n >= 0 ? n : -n;}
template <typename T> __attribute__((target("bmi"))) inline T gcd(T a, T b) {
if (a < 0) a = -a;
if (b < 0) b = -b;
if (a == 0 || b == 0) return a + b;
int n = __builtin_ctzll(a);
int m = __builtin_ctzll(b);
a >>= n;
b >>= m;
while (a != b) {
int m = __builtin_ctzll(a - b);
bool f = a > b;
T c = f ? a : b;
b = f ? b : a;
a = (c - b) >> m;
}
return a << min(n, m);
}
template <typename T> inline T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <typename T, typename... Targs> inline T gcd(T a, T b, T c, Targs... args) {return gcd(a, gcd(b, c, args...));}
template <typename T, typename... Targs> inline T lcm(T a, T b, T c, Targs... args) {return lcm(a, lcm(b, c, args...));}
template <typename T, typename... Targs> inline T min(T a, T b, T c, Targs... args) {return min(a, min(b, c, args...));}
template <typename T, typename... Targs> inline T max(T a, T b, T c, Targs... args) {return max(a, max(b, c, args...));}
template <typename T, typename... Targs> inline void chmin(T &a, T b, Targs... args) {a = min(a, b, args...); return ;}
template <typename T, typename... Targs> inline void chmax(T &a, T b, Targs... args) {a = max(a, b, args...); return ;}

vector<int> Primes(int n) {
if (n == 1) return {};
// 2 ~ n
vector<int> primes;
vector<bool> isPrime(n + 1, true);

primes.reserve(n / __lg(n));

for (int i = 2; i <= n; i++) {
if (isPrime[i]) primes.push_back(i);
for (int j : primes) {
if (i * j > n) break;
isPrime[i * j] = false;
if (i % j == 0) break;
}
}
return primes;
}

template <typename T> vector<T> factors(T x) {
// maybe use factorize would be faster?
vector<T> ans;
for (T i = 1; i * i <= x; i++) if (x % i == 0) ans.push_back(i);

int id = int(ans.size()) - 1;
if (ans[id] * ans[id] == x) id--;
for (int i = id; i >= 0; i--) ans.push_back(x / ans[i]);

return ans;
}

int mex(vector<int> vec) {
int n = int(vec.size());
vector<bool> have(n, false);
for (int i : vec) if (i < n) have[i] = true;
for (int i = 0; i < n; i++) if (!have[i]) return i;
return n;
}

template <typename T> T SQ(T x) {return x * x;}

// Euclidean distance
template <typename T> T Dist2(pair<T, T> lhs, pair<T, T> rhs) {return SQ(lhs.F - rhs.F) + SQ(lhs.S - rhs.S);}
template <typename T> T Dist2(T x1, T y1, T x2, T y2) {return SQ(x1 - x2) + SQ(y1 - y2);}

// Manhattan distance
template <typename T> T Mdist(pair<T, T> lhs, pair<T, T> rhs) {return ABS(lhs.first - rhs.first) + ABS(lhs.second - rhs.second);}
template <typename T> T Mdist(T x1, T y1, T x2, T y2) {return ABS(x1 - x2) + ABS(y1 - y2);}

template <typename T> bool Adj(pair<T, T> lhs, pair<T, T> rhs) {return Mdist(lhs, rhs) == 1;}

template <typename T> T LUBound(T LB, T val, T UB) {return min(max(LB, val), UB);}

template <typename T, typename Comp> T Binary_Search(T L, T R, Comp f) {
// L good R bad
static_assert(is_integral<T>::value, "Binary_Search requires an integral type");
while (R - L > 1) {
T mid = (L + R) >> 1;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename Comp> double Binary_Search(double L, double R, Comp f, int loop = 30) {
for (int i = 1; i <= loop; i++) {
double mid = (L + R) / 2;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename T> T nearest_dist(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin() - val;
else if (val >= *prev(se.end())) return val - *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);
return min(*u - val, val - *v);
}
}

template <typename T> T nearest_elem(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin();
else if (val >= *prev(se.end())) return *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);

if (*u - val > val - *v) return *v;
else return *u;
}
}

namespace MR32 {
using ull = unsigned long long int;
using uint = unsigned int;
ull PowMod(ull a, ull b, ull kMod) {
ull ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(uint x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 3, a[3] = {2, 7, 61};
if (x < 8) return low[x];

uint t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
ull tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}

#ifdef __SIZEOF_INT128__
namespace MR64 {
using uint128 = unsigned __int128;
using ull = unsigned long long int;
using uint = unsigned int;
uint128 PowMod(uint128 a, uint128 b, uint128 kMod) {
uint128 ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(ull x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 7, a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
if (x < 8) return low[x];
ull t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
uint128 tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}
#endif

bool IsPrime(unsigned long long int x) {
#ifdef __SIZEOF_INT128__
if ((x >> 32) == 0) return MR32::IsPrime(x);
else return MR64::IsPrime(x);
#endif
return MR32::IsPrime(x);
}

#ifdef __SIZEOF_INT128__
uint64_t PollardRho(uint64_t x) {
static mt19937 rng;
if (!(x & 1)) return 2;
if (IsPrime(x)) return x;
int64_t a = rng() % (x - 2) + 2, b = a;
uint64_t c = rng() % (x - 1) + 1, d = 1;
while (d == 1) {
a = (__int128(a) * a + c) % x;
b = (__int128(b) * b + c) % x;
b = (__int128(b) * b + c) % x;
d = gcd(uint64_t(abs(a - b)), x);
if (d == x) return PollardRho(x);
}
return d;
}

template <typename T> vector<T> factorize(T x) {
if (x <= 1) return vector<T>();
T p = PollardRho(x);
if (p == x) return vector<T>(1, x);
vector<T> ans, lhs = factorize(p), rhs = factorize(x / p);
Merge(lhs, rhs, ans);
return ans;
}
#endif

// vec must be sorted
template <typename T> vector<pair<T, int>> Compress(vector<T> vec) {
if (vec.empty()) return {};

vector<pair<T, int>> ans;
int cnt = 1, sz = int(vec.size());
T lst = vec[0];
for (int i = 1; i < sz; i++) {
if (lst != vec[i]) {
ans.push_back(make_pair(lst, cnt));
lst = vec[i];
cnt = 1;
}
else cnt++;
}
ans.push_back(make_pair(lst, cnt));
return ans;
}

template <typename T> int Divisors(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

int ans = 1;
for (pair<T, int> i : fac) ans *= i.second + 1;

return ans;
}

template <typename T> T phi(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

T ans = 1;
for (pair<T, int> i : fac) {
ans *= i.first - 1;
for (int j = 1; j < i.second; j++) ans *= i.first;
}

return ans;
}
// End of C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp
template <typename T> void _print(vector<T> v) ;
void _print(bool x) {printf("%s", x ? "True" : "False");}
void _print(char x) {printf("%c", x);}
void _print(short x) {printf("%hd", x);}
void _print(unsigned short x) {printf("%hu", x);}
void _print(int x) {printf("%d", x);}
void _print(unsigned int x) {printf("%u", x);}
void _print(long int x) {printf("%ld", x);}
void _print(unsigned long int x) {printf("%lu", x);}
void _print(long long int x) {printf("%lld", x);}
void _print(unsigned long long int x) {printf("%llu", x);}
void _print(float x) {printf("%f", x);}
void _print(double x) {printf("%lf", x);}
void _print(long double x) {printf("%Lf", x);}
void _print(const char* c) {int n = strlen(c); for (int i = 0; i < n; i++) printf("%c", c[i]);}
void _print(string s) {for (char c : s) printf("%c", c);}
template <size_t _size> void _print(bitset<_size> bs) {for (int i = 0; i < _size; i++) printf("%d", bs[i] ? 1 : 0);}
#ifdef __SIZEOF_INT128__
void _print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
void _print(unsigned __int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
#endif
template <typename T1, typename T2> void _print(pair<T1, T2> x) {printf("("); _print(x.first); printf(", "); _print(x.second); printf(")");}
template <typename T1, typename T2, typename T3> void _print(tuple<T1, T2, T3> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(")");}
template <typename T1, typename T2, typename T3, typename T4> void _print(tuple<T1, T2, T3, T4> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(", "); _print(get<3>(x)); printf(")");}
template <typename T> void _print(vector<T> v) {
if (v.empty()) printf(" empty");
else {
bool first = true;
for (T i : v) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(set<T> s) {
if (s.empty()) printf(" empty");
else {
bool first = true;
for (T i : s) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(stack<T> s) {
if (s.empty()) printf(" empty");
else {
_print(s.top()); s.pop();
while (!s.empty()) {printf(", "); _print(s.top()); s.pop();}
}
}
template <typename T> void _print(queue<T> q) {
if (q.empty()) printf(" empty");
else {
_print(q.front()); q.pop();
while (!q.empty()) {printf(", "); _print(q.front()); q.pop();}
}
}
template <typename T> void _print(deque<T> dq) {
if (dq.empty()) printf(" empty");
else {
_print(dq.front()); dq.pop_front();
while (!dq.empty()) {printf(", "); _print(dq.front()); dq.pop_front();}
}
}
template <typename T1, typename T2, typename T3> void _print(priority_queue<T1, T2, T3> pq) {
if (pq.empty()) printf(" empty");
else {
_print(pq.top()); pq.pop();
while (!pq.empty()) {printf(", "); _print(pq.top()); pq.pop();}
}
}
template <typename T1, typename T2> void _print(map<T1, T2> m) {
if (m.empty()) printf(" empty");
else {
bool first = true;
for (pair<T1, T2> i : m) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}

template <typename T> void _print(T& x) {return x.out();}
template <typename T, typename... Targs> void _print(T x, Targs... Fargs) {_print(x); printf(", "); _print(Fargs...);}
// End of C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp

bitset<kN> dp[kN];

int main() {
int a, b, c, d, e, f; RP(a, b, c, d, e, f);
a *= 100;
b *= 100;

dp[0][0] = true;
for (int i = 1; i <= f; i++) for (int j = 0; j <= i; j++) {
if (i >= a and dp[i - a][j]) dp[i][j] = true;
if (i >= b and dp[i - b][j]) dp[i][j] = true;
if (i >= c and j >= c and dp[i - c][j - c]) dp[i][j] = true;
if (i >= d and j >= d and dp[i - d][j - d]) dp[i][j] = true;
}

int tot = 0, sug = 0;

for (int i = 1; i <= f; i++) for (int j = 0; j <= i; j++) if (dp[i][j]) {
int water = i - j;
int sugar = j;

if (water / 100 * e >= sugar) {
int ap = 100 * sug;
int aq = tot;

int bp = 100 * sugar;
int bq = water + sugar;

if (tot == 0 or bp * aq > ap * bq) {
tot = water + sugar;
sug = sugar;
}
}
}


printf("%d %d\n", tot, sug);
}
// End of C.cpp

#include <bits/stdc++.h>
#define int long long
#define x first
#define y second
#define Mid ((l + r) / 2)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
const int N = 3e5 + 1009;
int n, w, h, ans;
pair<int, int> p[N], a[N * 4], b[N * 4];
int tree[N * 4], lzt[N * 4];
void pushdown(int l, int r, int rt) {
if(lzt[rt] == 0) return ;
lzt[lson] += lzt[rt]; lzt[rson] += lzt[rt];
tree[lson] += lzt[rt]; tree[rson] += lzt[rt];
lzt[rt] = 0;
}
void update(int rt) {
tree[rt] = max(tree[lson], tree[rson]);
}
void modify(int l, int r, int L, int R, int v, int rt) {
if(L <= l && r <= R) {
tree[rt] += v;
lzt[rt] += v;
return ;
}
pushdown(l, r, rt);
if(L <= Mid) modify(l, Mid, L, R, v, lson);
if(Mid <  R) modify(Mid + 1, r, L, R, v, rson);
update(rt);
}
void work() {
memset(tree, 0, sizeof(tree));
memset(lzt, 0, sizeof(lzt));
int l = 0, r = 0;
sort(p + 1, p + 1 + n);
for(int i = 1; i < n; i++) {
if(p[i].y >= h / 2) {
int nxt = i - 1;
while(l && a[l].y > p[i].y) {
modify(1, n, a[l].x, nxt, p[i].y - a[l].y, 1);
nxt = a[l].x - 1;
l--;
}
if(nxt != i - 1) a[++l] = {nxt + 1, p[i].y};
} else {
int nxt = i - 1;
while(r && b[r].y < p[i].y) {
modify(1, n, b[r].x, nxt, b[r].y - p[i].y, 1);
nxt = b[r].x - 1;
r--;
}
if(nxt != i - 1) b[++r] = {nxt + 1, p[i].y};
}
a[++l] = {i, h}; b[++r] = {i, 0};
modify(1, n, i, i, h - p[i].x, 1);
ans = max(ans, p[i + 1].x + tree[1]);
//        cout << ans << endl;
}
}

signed main() {
#ifndef ONLINE_JUDGE
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
ios::sync_with_stdio(0);
cin.tie(0);
cin >> w >> h >> n;
for(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y;
p[++n] = {0, 0}; p[++n] = {w, h};
work();
for(int i = 1; i <= n; i++) swap(p[i].x, p[i].y);
swap(w, h);
work();
cout << ans * 2 << endl;
return 0;
}
#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <algorithm>
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

template <class RandomAcessIterator>
size_t calc_inverse(RandomAcessIterator begin, RandomAcessIterator end)
{
if (begin + 1 == end)
return 0;

RandomAcessIterator mid = std::next(begin, std::distance(begin, end) / 2);

size_t res = 0;
res += calc_inverse(begin, mid);
res += calc_inverse(mid, end);

RandomAcessIterator mr    = mid;
size_t              r_cnt = 0;
for (RandomAcessIterator i = begin; i != mid; i++)
{
while (mr != end && *mr < *i)
{
mr++;
r_cnt++;
}
res += r_cnt;
}

std::inplace_merge(begin, mid, end);

return res;
}

int main()
{
int              n = sc.next_int();
std::vector<int> a(n);
for (int i = 0; i < n; i++)
a[i] = sc.next_int() - 1;

for (int i = 0; i < n; i++)
if (i % 2 != a[i] % 2)
{
puts("No");
return 0;
}

std::vector<int> odd;
std::vector<int> even;
for (int i = 0; i < n; i++)
(i % 2 == 1 ? odd : even).push_back(a[i]);

size_t odd_inv  = calc_inverse(odd.begin(), odd.end());
size_t even_inv = calc_inverse(even.begin(), even.end());
size_t all_inv  = calc_inverse(a.begin(), a.end());
// see(odd_inv, even_inv, all_inv);

if ((odd_inv + even_inv) * 3 != all_inv)
puts("No");
else
puts("Yes");

return 0;
}

#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int a[N];
int main()
{
int n,k=0,i=0;
cin>>n;
while(n>k)
{
i++;
k+=i;
}
cout<<i<<endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define re register
#define ll long long
#define get getchar()
#define in inline
in int read()
{
int t=0, x=1; char ch=get;
while(ch!='-' && (ch<'0' || ch>'9')) ch=get;
if(ch=='-') ch=get, x=-1;
while(ch<='9' && ch>='0') t=t*10+ch-'0', ch=get;
return t*x;
}
const int _=2e5+23;
const int inf=0x3f3f3f3f;
int n, tot, h[_], c[_], fa[_], A[_],B[_],m,w[_],cnt;
struct edge{
int to,ne;
}e[_<<1];
in void add(int x,int y) {	e[++tot].ne=h[x], e[tot].to=y, h[x]=tot; }
in int cmp(int a,int b) { return c[a]<c[b];}
in int find(int x){return x==fa[x] ? x : fa[x]=find(fa[x]);}
ll rt, f[_], sum[_];
in void dfs(int u,int fa)
{
//	cout<<u<<' '<<fa<<endl;
int flag=0;  sum[u]=B[u];
for(re int i=h[u];i;i=e[i].ne)
{
int v=e[i].to;
if(v==fa) continue;
dfs(v,u); sum[u]+=sum[v];
flag=1;
}
if(!flag) {f[u]=c[u]+B[u]; return;}
for(re int i=h[u];i;i=e[i].ne)
{
int v=e[i].to;
if(v==fa) continue;
f[u]=min(f[u], sum[u]-sum[v]+max(1ll*c[u],f[v]));
}
}
int id[_],vis[_];
vector<int > vc[_];
#define pb push_back
int main()
{
cnt=n=read(), m=read();
memset(f,0x3f,sizeof(f));
for(re int i=1;i<=n;++i)
{
A[i]=read(), B[i]=read();
c[i]=max(A[i]-B[i],0); id[i]=fa[i]=i;
}
for(re int i=1;i<=m;++i)
{
int x=read(), y=read();
vc[x].pb(y), vc[y].pb(x);
}
sort(id+1,id+n+1,cmp);
for(re int i=1;i<=n;++i)
{
int u=id[i];// cout<<u<<":: \n";
for(re int j=0;j<vc[u].size();++j)
{
if(!vis[vc[u][j]]) continue;
int x=find(u), y=find(vc[u][j]);
if(x==y) continue;
fa[y]=x; add(u,y);
//			cout<<u<<' '<<y<<endl;
}
vis[u]=1;
}
rt=id[n]; dfs(rt,0);
cout<<f[rt]<<endl;
return 0;
}

#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#if __cplusplus >= 201103L
#include <type_traits>
#endif
#include <iostream>
#include <limits>
#define INTM_FAST_32 int
#define INTM_FAST_64 unsigned long long
#define _7 __attribute__((always_inline)) inline
#if __cplusplus >= 201103L
#define _6 constexpr
#define CXX11_EXPLICIT explicit
#else
#define _6
#define CXX11_EXPLICIT
#endif
#if __cplusplus >= 201402L
#define _5 constexpr
#else
#define _5
#endif
namespace cm{template<INTM_FAST_32 _2=998244353>class intm{
#if __cplusplus >= 201103L
static_assert(_2*2<std::numeric_limits<INTM_FAST_32>::max(),"");
#endif
public:static constexpr int MOD=_2;protected:INTM_FAST_32 a=0;_7 _6 explicit intm(INTM_FAST_32 a,int):a(a){}static _7 _6 INTM_FAST_32 _4(INTM_FAST_32 a){return a<0?a+MOD:a;}static _7 _6 INTM_FAST_32 _1(INTM_FAST_32 a){return a>=MOD?a-MOD:a;}template<class IntType>static _7 _5 INTM_FAST_32 _3(INTM_FAST_32 a,IntType b){INTM_FAST_32 res=1;for(;b;b>>=1){if(b&1){res=(INTM_FAST_32)((INTM_FAST_64)(res)*(INTM_FAST_64)(a)%MOD);}a=(INTM_FAST_32)((INTM_FAST_64)(a)*(INTM_FAST_64)(a)%MOD);}return res;}static int pretty(int x){if(x>=MOD-1000)return x-MOD;return x;}public:
#if __cplusplus >= 201103L
intm()=default;
#else
intm(){}
#endif
static _6 intm raw(INTM_FAST_32 x){return intm(x,0);}_7 _6 intm(int a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(long a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(long long a):a(static_cast<INTM_FAST_32>(_4(a%MOD))){}_7 _6 intm(unsigned int a):a(static_cast<INTM_FAST_32>(a%MOD)){}_7 _6 intm(unsigned long a):a(static_cast<INTM_FAST_32>(a%MOD)){}_7 _6 intm(unsigned long long a):a(static_cast<INTM_FAST_32>(a%MOD)){}template<class _8>_7 _6 CXX11_EXPLICIT operator _8()const{return a;}_7 friend std::ostream&operator<<(std::ostream&out,const intm rhs){
out<<rhs.a;return out;
}_7 friend std::istream&operator>>(std::istream&in,intm&rhs){long long a;in>>a;rhs=intm(a);return in;}template<class _8>_7 _5 intm pow(_8 k)const{return raw(_3(a,k));}_7 _5 intm inv()const{
cm_assert(a!=0,"warning:0 do not have inv");
return raw(_3(a,MOD-2));}_7 _6 friend bool operator<(const intm a,const intm b){return a.a<b.a;}_7 _6 friend bool operator<=(const intm a,const intm b){return a.a<=b.a;}_7 _6 friend bool operator>(const intm a,const intm b){return a.a>b.a;}_7 _6 friend bool operator>=(const intm a,const intm b){return a.a>=b.a;}_7 _6 friend bool operator==(const intm a,const intm b){return a.a==b.a;}_7 _6 friend bool operator!=(const intm a,const intm b){return a.a!=b.a;}template<class _8>_7 _6 friend bool operator<(const _8 a,const intm b){return a<b.a;}template<class _8>_7 _6 friend bool operator<(const intm a,const _8 b){return a.a<b;}template<class _8>_7 _6 friend bool operator<=(const _8 a,const intm b){return a<=b.a;}template<class _8>_7 _6 friend bool operator<=(const intm a,const _8 b){return a.a<=b;}template<class _8>_7 _6 friend bool operator>(const _8 a,const intm b){return a>b.a;}template<class _8>_7 _6 friend bool operator>(const intm a,const _8 b){return a.a>b;}template<class _8>_7 _6 friend bool operator>=(const _8 a,const intm b){return a>=b.a;}template<class _8>_7 _6 friend bool operator>=(const intm a,const _8 b){return a.a>=b;}template<class _8>_7 _6 friend bool operator==(const _8 a,const intm b){return a==b.a;}template<class _8>_7 _6 friend bool operator==(const intm a,const _8 b){return a.a==b;}template<class _8>_7 _6 friend bool operator!=(const _8 a,const intm b){return a!=b.a;}template<class _8>_7 _6 friend bool operator!=(const intm a,const _8 b){return a.a!=b;}_7 _6 friend intm operator+(const intm a,const intm b){return raw(_1(a.a+b.a));}_7 _6 friend intm operator-(const intm a,const intm b){return raw(_4(a.a-b.a));}_7 _6 friend intm operator*(const intm a,const intm b){return raw(static_cast<INTM_FAST_32>((INTM_FAST_64)(a.a)*(INTM_FAST_64)(b.a)%MOD));}_7 _5 friend intm operator/(const intm a,const intm b){return a*b.inv();}_7 _6 friend intm&operator+=(intm&a,const intm b){return a=a+b;}_7 _6 friend intm&operator-=(intm&a,const intm b){return a=a-b;}_7 _6 friend intm&operator*=(intm&a,const intm b){return a=a*b;}_7 _5 friend intm&operator/=(intm&a,const intm b){return a=a/b;}template<class _8>_7 _6 friend intm operator+(const intm a,const _8 b){return a+intm(b);}template<class _8>_7 _6 friend intm operator-(const intm a,const _8 b){return a-intm(b);}template<class _8>_7 _6 friend intm operator*(const intm a,const _8 b){return a*intm(b);}template<class _8>_7 _5 friend intm operator/(const intm a,const _8 b){return a/intm(b);}template<class _8>_7 _6 friend intm&operator+=(intm&a,const _8 b){return a+=intm(b);}template<class _8>_7 _6 friend intm&operator-=(intm&a,const _8 b){return a-=intm(b);}template<class _8>_7 _6 friend intm&operator*=(intm&a,const _8 b){return a*=intm(b);}template<class _8>_7 _5 friend intm&operator/=(intm&a,const _8 b){return a/=intm(b);}template<class _8>_7 _6 friend intm operator+(const _8 a,const intm b){return intm(a)+b;}template<class _8>_7 _6 friend intm operator-(const _8 a,const intm b){return intm(a)-b;}template<class _8>_7 _6 friend intm operator*(const _8 a,const intm b){return intm(a)*b;}template<class _8>_7 _5 friend intm operator/(const _8 a,const intm b){return intm(a)/b;}template<class _8>_7 _6 friend _8&operator+=(_8&a,const intm b){return a+=_8(b);}template<class _8>_7 _6 friend _8&operator-=(_8&a,const intm b){return a-=_8(b);}template<class _8>_7 _6 friend _8&operator*=(_8&a,const intm b){return a*=_8(b);}template<class _8>_7 _5 friend _8&operator/=(_8&a,const intm b){return a/=_8(b);}};}
#undef _7
#undef _6
#undef _5
#undef INTM_FAST_32
#undef INTM_FAST_64
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <algorithm>
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

constexpr int MOD = 1'000'000'007;
constexpr int N   = 200050;
using int_t       = cm::intm<MOD>;

int n, m;
int a[N], b[N];

int_t dp[N];

void modify(int p, int_t d)
{
p += 5;
for (; p < N; p += p & (-p))
dp[p] += d;
}

int_t query(int p)
{
p += 5;
int_t res = 0;
for (; p; p -= p & (-p))
res += dp[p];
return res;
}

int main()
{
n = sc.next_int();
m = sc.next_int();
for (int i = 0; i < n; i++)
a[i] = sc.next_int();
for (int i = 0; i < m; i++)
b[i] = sc.next_int();

std::vector<std::pair<int, int>> poss;
for (int i = 0; i < n; i++)
if (a[i] > b[0] && a[i] < b[m - 1])
{
auto pr = std::lower_bound(b, b + m, a[i]);
auto pl = pr - 1;
poss.emplace_back(a[i] - *pl, *pr - a[i]);
}

std::vector<int> values{0};
for (const auto &[x, y] : poss)
{
values.push_back(x);
values.push_back(y);
}
std::sort(values.begin(), values.end());
values.erase(std::unique(values.begin(), values.end()), values.end());
for (auto &[x, y] : poss)
{
x = static_cast<int>(std::distance(
values.begin(), std::lower_bound(values.begin(), values.end(), x)));
y = static_cast<int>(std::distance(
values.begin(), std::lower_bound(values.begin(), values.end(), y)));
}

std::sort(poss.begin(), poss.end(), [](auto x, auto y) {
return x.first != y.first ? x.first < y.first : x.second > y.second;
});
poss.erase(std::unique(poss.begin(), poss.end()), poss.end());

modify(0, 1);
for (const auto &[x, y] : poss)
modify(y, query(y - 1));

std::cout << query(N - 10) << std::endl;

return 0;
}

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
int n;
const int MAXN=5e5+5;
const int MOD=1e9+7;

ll qpow(ll a,ll b){
ll ans=1,base=a;
while(b){
if(b&1)(ans*=base)%=MOD;
(base*=base)%=MOD;
b>>=1;
}
return ans;
}
struct node{
int x,y,_ID;
}nd[MAXN];
vector<int>posx[MAXN],posy[MAXN];
vector<pair<int,int> >par;

struct fenpei{
node x;int point;
}fp[MAXN];
//nd 点 fenpei分配关系

struct edge{
int to,next,w;
}e[MAXN<<1];

int head[MAXN],cnt=0;
inline void add(int u,int v,int w){
assert(u!=v);
e[++cnt]=(edge){v,head[u],w},head[u]=cnt;
e[++cnt]=(edge){u,head[v],w},head[v]=cnt;
}

void init(){
scanf("%d",&n);
for(int i=1;i<=2*n;i++){
scanf("%d%d",&nd[i].x,&nd[i].y);
nd[i]._ID=i;
add(nd[i].x,nd[i].y+n,i);
posx[nd[i].x].push_back(i);
posy[nd[i].y].push_back(i);
}
}
//
int fa[MAXN],dfn[MAXN],loop[MAXN],top=0,_ID=0,is_a_looptree=1;
void dfs(int u,int father){//找基环树
dfn[u]=++_ID;
fa[u]=father;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if(dfn[v]){//在环上
if(dfn[v]<dfn[u])continue;//非最小
for(;v!=u;v=fa[v]){
loop[++top]=v;
}
loop[++top]=u;
return;
}
else{
dfs(v,u);
}
}
}

bool vis[MAXN];
int tedge=0,tpoint=0;
void givecolor(int u,int father){
vis[u]=1;tpoint++;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
tedge++;
if(vis[v])continue;
givecolor(v,u);
}
}

bool islooppoint[MAXN];
int fenpeicnt=0;
int dis[MAXN];//到环的距离

int getedge(int u,int father){
dis[u]=MOD;
fa[u]=father;
dfn[u]=++_ID;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if(dfn[v])continue;
dis[u]=min(dis[u],1+getedge(v,u));
}
if(islooppoint[u])return dis[u]=0;
return dis[u];
}

void getedge2(int u,int father){
dfn[u]=++_ID;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
dis[v]=min(dis[v],dis[u]+1);
if(v==father)continue;
if(dfn[v])continue;
getedge2(v,u);
}

for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if((!islooppoint[v])||(!islooppoint[u])){
int now=dis[u]>dis[v]?u:v;
fp[++fenpeicnt]=(fenpei){nd[e[i].w],now};
}
}
}

int Size[MAXN],tree[MAXN],in[MAXN];
inline void add2(int u,int v){
tree[u]=v;in[v]++;
}

void build(){
for(int i=1;i<=fenpeicnt;i++)in[fp[i].x._ID]=0,Size[fp[i].x._ID]=1,tree[fp[i].x._ID]=0;
for(int i=1;i<=fenpeicnt;i++){//枚举哪个球分配给了机器人
//cout<<fp[i].point<<" -> "<<fp[i].x.x<<" "<<fp[i].x.y<<endl;
if(fp[i].point>n){//y相等的 且x较小的 全都连向node
for(auto t:posy[fp[i].point-n]){
if(nd[t].x<fp[i].x.x){
add2(t,fp[i].x._ID);
}
}
}
else{//x
for(auto t:posx[fp[i].point]){
if(nd[t].y<fp[i].x.y){
add2(t,fp[i].x._ID);
}
}
}
}
}
queue<int>q;
long long calc(int tot){//算内向树森林的答案 共连通块（tot）个点
long long ans=1;
for(int i=1;i<=tot;i++){
(ans*=i)%=MOD;
}
while(q.size())q.pop();
for(int i=1;i<=tot;i++)if(in[fp[i].x._ID]==0)q.push(fp[i].x._ID);
//cout<<q.Size()<<"inSize"<<endl;
while(q.size()){
int u=q.front();q.pop();
if(!tree[u])continue;
Size[tree[u]]+=Size[u];
in[tree[u]]--;
if(in[tree[u]]==0)q.push(tree[u]);
}
for(int i=1;i<=tot;i++){
ans*=qpow(Size[fp[i].x._ID],MOD-2);
ans%=MOD;
}
return ans;
}

void solve(){
/*由于每条边都要被选择，共有2n个点2n个边。且一个点只能对应一条边 
所连成的图只有是基环树森林的时候才合法 否则不合法
*/
for(int i=1;i<=2*n;i++){//遍历每个连通块 对基环树计算答案
if(!vis[i]){
memset(Size,0,sizeof(Size));
memset(tree,0,sizeof(tree));
memset(in,0,sizeof(in));
memset(dis,0,sizeof(dis));
memset(islooppoint,0,sizeof(islooppoint));
memset(fa,0,sizeof(fa));
memset(loop,0,sizeof(loop));
fenpeicnt=0;
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;top=0;
is_a_looptree=1;tpoint=0;tedge=0;
givecolor(i,0);
if(2*tpoint!=tedge)is_a_looptree=0;
if(is_a_looptree==0){
puts("0");exit(0);
}
dfs(i,0);

for(int i=1;i<=top;i++)islooppoint[loop[i]]=1;
//找到基环树后 对每条点分配一条边 从叶子节点开始选到自己father的边 非树边
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;//本来这里初始化错了i<=_id 懒得开vector记录了于是就直接暴力 数据水
getedge(i,0);//分配树边
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;
getedge2(i,0);
int tmpcnt=fenpeicnt;
//枚举环上的边 直接暴力好了 数据水
for(int j=1;j<=top;j++){
if(j!=top){
bool fx=0;
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[j+1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],loop[j]};
fx=1;
break;
}
}
assert(fx);
}
else{
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],loop[j]};
break;
}
}
}
}

//建内向树
build();
long long ans1=calc(fenpeicnt);//计算答案1
fenpeicnt=tmpcnt;
for(int j=1;j<=top;j++){
if(j!=top){
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[j+1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],v};
break;
}
}
}
else{
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],v};
break;
}
}                   
}
}
build();
ll ans2=calc(fenpeicnt);
//cout<<ans2<<" "<<endl;
par.push_back(make_pair((ans1+ans2)%MOD,fenpeicnt));
for(int j=1;j<=fenpeicnt;j++)islooppoint[fp[j].point]=0;
}
}
}

ll fac[MAXN],inv[MAXN];
ll C(int n,int m){
return fac[n]*inv[n-m]%MOD*inv[m]%MOD;
}
void calc(){
ll ans=1;
fac[0]=inv[0]=1;
for(int i=1;i<=2*n;i++)fac[i]=fac[i-1]*i%MOD;
inv[2*n]=qpow(fac[2*n],MOD-2);
for(int i=2*n-1;i>=1;i--)inv[i]=inv[i+1]*(i+1)%MOD;
for(auto i:par){
ans*=i.first;ans%=MOD;
}
ll calced=0;
for(auto i:par){
ans*=C(calced+i.second,i.second);
ans%=MOD;
calced+=i.second;
}
cout<<ans<<endl;//("%lld\n",ans);
}

int main(){
init();
solve();
calc();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int K, dis[100005];
deque <int> Q;
int main() {
#ifndef ONLINE_JUDGE
freopen("prob.in", "r", stdin);
freopen("prob.out", "w", stdout);
#endif
cin >> K;
memset(dis, 0x3f, sizeof dis);
Q.push_back(1);
dis[1] = 1;
while (!Q.empty()) {
int tp = Q.front();
Q.pop_front();
if (dis[tp * 10 % K] > dis[tp]) {
dis[tp * 10 % K] = dis[tp];
Q.push_front(tp * 10 % K);
}
if (dis[(tp + 1) % K] > dis[tp] + 1) {
dis[(tp + 1) % K] = dis[tp] + 1;
Q.push_back((tp + 1) % K);
}
}
printf("%d\n", dis[0]);
return 0;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
graph g;
int vis[100100], ksum[100100];
vector<int> path, dc;
void dfs(int nn, int pp, int dest){
path.eb(nn);
if(nn == dest){
dc = path;
for(auto x: path)
vis[x] = 1;
}
for(auto x: g[nn])
if(x != pp)
dfs(x, nn, dest);
path.pop_back();
}
int dfs2(int nn, int pp){
int sz = 1;
for(auto x: g[nn])
if(x != pp && !vis[x])
sz += dfs2(x, nn);
return sz;
}
void solve(){ 
int n; cin>>n;
g.resize(n+1);
for(int i=0; i<n-1; i++){
int a,b; cin>>a>>b; g[a].eb(b); g[b].eb(a);
}
dfs(1, 0, n);
int half = (sz(dc) + 1)/2;
int s = 0;
for(int i=0; i<half; i++){
s += dfs2(dc[i], 0);
}
for(int i=half; i<sz(dc); i++){
s -= dfs2(dc[i], 0);
}
if(s > 0)
cout<<"Fennec\n";
else cout<<"Snuke\n";
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair <int, int> pii;
#define ci const int
inline void swap(int &x, int &y) { x ^= y ^= x ^= y; }
inline void chmax(ll &x, ll y) { if(x < y) x = y; }
inline void chmin(ll &x, ll y) { if(x > y) x = y; }
#define mp make_pair
#define fi first
#define se second
#define pc putchar
#define rep(i, l, r) for(int i = l, i##end = r; i <= i##end; ++ i)
#define per(i, r, l) for(int i = r, i##end = l; i >= i##end; -- i)
char inputbuf[1 << 23], *p1 = inputbuf, *p2 = inputbuf;
#define getchar() (p1 == p2 && (p2 = (p1 = inputbuf) + fread(inputbuf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {
int res = 0; char ch = getchar(); bool f = true;
for(; ch < '0' || ch > '9'; ch = getchar())
f &= ch != '-';
for(; ch >= '0' && ch <= '9'; ch = getchar())
res = res * 10 + (ch ^ 48);
return f ? res : -res;
}
const int N = 2e5 + 15, M = 105;
const ll INF = 1e18;
int to[N], nxt[N], head[N], ecnt = 1;
int dep[N], now[N], a[N];
int s, t, n;
ll fl[N], ans, sum;
queue <int> Q;

inline void add(int x, int y, ll c) {
to[++ ecnt] = y; fl[ecnt] = c; nxt[ecnt] = head[x]; head[x] = ecnt;
to[++ ecnt] = x; fl[ecnt] = 0; nxt[ecnt] = head[y]; head[y] = ecnt;
}

bool bfs() {
int u, v;
while(!Q.empty()) Q.pop();
memset(dep, 0, 4 * (t + 3));
memcpy(now, head, 4 * (t + 3));
dep[s] = 1;
Q.push(s);
while(!Q.empty()) {
u = Q.front();
Q.pop();
for(int i = head[u]; i; i = nxt[i]) {
v = to[i];
if(fl[i] && !dep[v]) {
dep[v] = dep[u] + 1;
if(v == t) return 1;
Q.push(v);
}
}
}
return 0;
}

ll dfs(int u, ll flow) {
if(u == t) return flow;
ll rest = flow, used;
for(int &i = now[u], v; i && rest; i = nxt[i]) {
v = to[i];
if(!fl[i] || dep[v] != dep[u] + 1) continue;
used = dfs(v, min(rest, fl[i]));
if(!used) dep[v] = 0;
fl[i] -= used;
fl[i ^ 1] += used;
rest -= used;
}
return flow - rest;
}

signed main() {
n = read();
rep(i, 1, n) {
ans += a[i] = read();
a[i] = -a[i];
}
s = n + 1; t = s + 1;
rep(i, 1, n) {
if(a[i] > 0) add(s, i, a[i]), ans += a[i];
if(a[i] < 0) add(i, t, -a[i]);
}
rep(i, 1, n) for(int j = i * 2; j <= n; j += i)
add(i, j, INF);
while(bfs()) ans -= dfs(s, INF);
printf("%lld\n", ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ll,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

/* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
update(i,x): i 番目の要素を x に更新。O(log(n))
query(a,b): [a,b) での最小の要素を取得。O(log(n))
*/
template <typename T>
struct RMQ {
const T INF = numeric_limits<T>::min();
ll n;         // 葉の数
vector<T> dat; // 完全二分木の配列
RMQ(ll n_) : n(), dat(n_ * 4, INF) { // 葉の数は 2^x の形
ll x = 1;
while (n_ > x) {
x *= 2;
}
n = x;
}

void update(ll i, T x) {
i += n - 1;
dat[i] = x;
while (i > 0) {
i = (i - 1) / 2;  // parent
dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);
}
}

// the maximum element of [a,b)
T query(ll a, ll b) { return query_sub(a, b, 0, 0, n); }
T query_sub(ll a, ll b, ll k, ll l, ll r) {
if (r <= a || b <= l) {
return INF;
} else if (a <= l && r <= b) {
return dat[k];
} else {
T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
return max(vl, vr);
}
}
};

int main(){
ll n,c;
cin>>n>>c;
vi x(n+1),v(n+1);
RMQ<ll> seg(n+1),seg2(n+1);
seg.update(0,0);
seg2.update(0,0);
ll d=0,d2=0;
rep(i,n){
cin>>x[i]>>v[i];
d+=v[i]-x[i];
d2+=v[i]-2*x[i];
seg.update(i+1,d);
seg2.update(i+1,d2);
d+=x[i];
d2+=2*x[i];
}
x[n]=c;
ll xl=0,vl=0,ans=0;
for(ll i=n;i>=0;i--){
xl=c-x[i];
vl+=v[i];
ans=max(ans,seg.query(0,i+1)+vl-2*xl);
ans=max(ans,seg2.query(0,i+1)+vl-xl);
// cout<<seg.query(0,i+1)<<" "<<seg2.query(0,i+1)<<endl;
seg.update(i,-1e18);
seg2.update(i,-1e18);
}
// cout<<numeric_limits<ll>::min()<<endl;
cout<<ans<<endl;
}
#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif

int n,m;
string s;
int one[3001];
int to[3001];
int dp[3001][3001];
int solve(int i,int c){
if(i==n) return 1;
if(dp[i][c]!=-1) return dp[i][c];
int len=to[i]-i+1;
int tot=0;
if(c>=1){
tot+=solve(i+1,c-1+one[to[i+1]]-one[to[i]]);
tot%=mod;
}
if(c!=len){
tot+=solve(i+1,c+one[to[i+1]]-one[to[i]]);
tot%=mod;
}
return dp[i][c]=tot;
}

void solve() {
cin>>n>>m;
memset(dp,-1,sizeof dp);
cin>>s;
for(int i=0;i<n;i++){
one[i]=(s[i]=='1');
}
for(int i=1;i<n;i++) one[i]+=one[i-1], to[i]=i;
while(m--) {
int l, r;
cin >> l >> r;
--l;
--r;
to[l] = max(to[l], r);
}
for(int i=1;i<n;i++){
to[i]=max(to[i],to[i-1]);
}
cout<<solve(0,one[to[0]])<<endl;

}

int32_t main() {
nitin;

solve();
}
// #pragma GCC optimize ("O3")
// #pragma GCC target ("sse4")
#include <bits/stdc++.h>
using namespace std;

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;

#define int long long int

#define vi vector<int>

#define ff first
#define ss second

#define pb push_back
#define MOD 1000000007
//const int nax = 1e6+5;
#define inf 4e18
#define Graph vector<vi>
#define Graphw vector<vector<pair<int,int>>> 
#define sz(x) (int)x.size()
#define pr pair<int,int>

#define display(v) for(int i =0;i<(int)v.size();++i)cout << v[i] << " "
#define all(v) v.begin(),v.end()
#define read(a) for(int i = 0;i<(int)a.size();++i)cin>>a[i]
#define show(x) cout << #x << " is " << x << "\n";
// typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>   ind_si;
// typedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>   ind_msi;
#define show_arr(a) cout << #a << "\n"; display(a) ; cout << "\n";
inline int add(int a, int b){ int c = (a%MOD) + (b%MOD); if(c >= MOD) c -= MOD; return c; }
inline int mul(int a, int b){ return ((a%MOD) * 1ll * (b%MOD)) % MOD; }
inline int sub(int a, int b){ int c = (a%MOD) - (b%MOD); if(c < 0) c += MOD; return c; }
inline int sum_till(int n) { return mul(mul(n, n + 1), (MOD + 1) / 2); }
const int nax = 300*1000 + 10;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

//#define ook order_of_key
//#define fbo find_by_order
//   order_of_key(x) -> number of elements less than x.
// * find_by_order(x) -> gives the element at index x (0 - indexing)

void test_case();
int32_t main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
int t = 1; //cin>>t;
while(t--){
test_case();
}
return 0;
}

void test_case(){
int n; cin>>n;
vi a(n); read(a);
int cost1 = 0, cost2 = 0;
int sign = 1, pre = 0;
for(int i = 0; i < n; ++i){
pre += a[i];
if(sign){
if(pre <= 0){
cost1 += abs(pre) + 1;
pre = 1;
}
}
else{
if(pre >= 0){
cost1 += (pre + 1);
pre = -1;
}
}
sign = 1 - sign;
}
sign = 0, pre = 0;
for(int i = 0; i < n; ++i){
pre += a[i];
if(sign){
if(pre <= 0){
cost2 += abs(pre) + 1;
pre = 1;
}
}
else{
if(pre >= 0){
cost2 += (pre + 1);
pre = -1;
}
}
sign = 1 - sign;
}
cout << min(cost1, cost2) << '\n';

}    



// Химаншу
// check overflow
// special case n == 1
// 🍪🍪🍪

#include<bits/stdc++.h>
using namespace std;
#define FOR(i,j,k) for(int i=(j);i<=(k);++i)
#define ROF(i,j,k) for(int i=(j);i>=(k);--i)
#define FOE(i,pos) for(int i=h[pos];i;i=nxt[i])
#define rd read()
#define pc(x) putchar(x)
#define gc getchar()
#define maxn 20
#define maxt 70000
#define int long long
int rd{
int x=0,f=1;char c=gc;
while(c<'0'||c>'9'){if(c=='-') f=-1;c=gc;}
while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c-'0');c=gc;}
return x*f;
}
void write(int x){
if(x<0) pc('-'),x=-x;
if(x>9) write(x/10);
pc(x%10+'0');
}

int n,m,t;
int a[maxn];
int f[maxn][maxt];
int fac[maxt],inv_fac[maxt],inv[maxt];
int g[maxt];
const int mod=1e9+7;
int ans;

int ksm(int x,int y){
int z=1;
while(y){
if(y&1) z=z*x%mod;
x=x*x%mod;
y>>=1;
}
return z;
}

int INV(int x){
return ksm(x,mod-2);
}

bool cmp(int x,int y){return x>y;}

void ad(int &x,int y){x=(x+y)%mod;}

int C(int x,int y){return fac[x]*inv_fac[y]%mod*inv_fac[x-y]%mod;}

signed main(){
n=rd;t=(1<<n)-1;m=rd;
FOR(i,1,m) a[i]=rd;
sort(a+1,a+1+m,cmp);
fac[0]=1;
FOR(i,1,t+1) fac[i]=fac[i-1]*i%mod;
inv_fac[t+1]=INV(fac[t+1]);
ROF(i,t,0) inv_fac[i]=inv_fac[i+1]*(i+1)%mod;
inv[0]=inv[1]=1;
FOR(i,2,t+1) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
f[0][0]=1;
FOR(i,0,m-1) FOR(j,0,t){
ad(f[i+1][j],f[i][j]);
FOR(k,0,n-1){
if(j&(1<<k)) continue;
if(t+1-a[i+1]-j<(1<<k)-1) continue;
ad(f[i+1][j+(1<<k)],f[i][j]*C(t+1-a[i+1]-j,(1<<k)-1)%mod);
}
}
FOR(i,0,t){
g[i]=f[m][i]*fac[t-i]%mod;
FOR(j,0,n-1) if(i&(1<<j)) g[i]=g[i]*fac[1<<j]%mod;
g[i]=g[i]*(1<<n)%mod;
}
ans=g[0];
FOR(i,1,t){
int cnt=0;
FOR(j,0,n-1) if(i&(1<<j)) cnt++;
if(cnt&1) ad(ans,mod-g[i]);
else ad(ans,g[i]);
}
printf("%lld",ans%mod);
return 0;
}
#include<bits/stdc++.h>
using namespace std;

typedef long long int ll;
#define IOS ios_base::sync_with_stdio(0);  cin.tie(0); cout.tie(0);

#define MAXN 1000010
#define pb push_back
int cnt [ MAXN+1];
const int mod = 1e9+7;
vector <ll> v;
bool prime[MAXN];
/*void sieve()
{
v.pb(2);
for(ll i=3;i*i<=MAXN;i+=2)
{
if(prime[i] == false)
{
for(ll j=i*i;j<=MAXN;j+=(2*i))
prime[j] = true;
}
}
for(ll i=3;i<=MAXN;i+=2) if(prime[i] == false) v.pb(i);

}
ll lm(ll a,ll b)
{
return (a/__gcd(a,b))*b;
}
ll lcm(vector<ll> v)
{
ll lc = 1;
for(int i=0;i<v.size();i++)
{
lc = lm(lc,v[i]);
}
return lc;
}
ll sum(ll n,ll a,ll b)
{
if(a % n == 0) return (b/n)-(a/n)+1;
return (b/n)-(a/n);
}
void solve()
{
ll c,d,m;
cin >> c >> d >> m;
ll a = max(c,d);
ll b = min (c,d);
if(a==b) {
cout<<0<<endl;
return;
}

ll ans = 0;
ans = m+1;
b  = a-b;
int mn = -1;
vector<ll>str;
ll tmp  = b;

for(int i=0;i<v.size() && v[i]*v[i] <= b;i++)
{
if(b%v[i] == 0)
{
while(b%v[i] == 0)
{
b /= v[i];
}
str.pb(v[i]);
}
}
if(b > 1) str.pb(b);
b = tmp;

int total = 1<<str.size();
for(int i=1;i<total;i++)
{
vector<ll>res;
for(int j=0;j<str.size();j++)
{
if(i & (1 << j))
{
res.push_back(str[j]);
}
}

if(res.size() % 2 != 0)
{
ll lc = lcm(res);
if(lc <= a)
{
ll es = sum(lc,a,a+m);
ans -= es;
}
}
else{
ll lc = lcm(res);

if(lc <= a)
{
ll es = sum(lc,a,a+m);

ans += es;
}
}
}
cout<<ans<<endl;

}


//stringstream 

vector<int>parseInts(string s){
stringstream ss(s);

int a;
char c;
vector<int>ans;
while(ss>>a){
ans.push_back(a);
ss>>c;
}
return ans;
}

*/

void solve(){

}

int gcd(int a, int b){
if(a>b){
swap(a,b);
}

if(a==0) return b;

return gcd(a, b%a);
}

int main()
{   

// IOS;
// double memoizedArray[1000001];//Array for Memoization
// memoizedArray[0] = 0; //Don't do manual log for 0, it will throw an error

// //Memoizing the array
// for(int i=1;i<=1000000;i++){
//   memoizedArray[i] = memoizedArray[i-1] + log(i);
// }

// int testCase, base;
// long digits,n;

// cin >> testCase;

// for(int i = 1; i<= testCase; i++){
//     cin >> n >> base;
//     //The formula
//     digits = memoizedArray[n]/log(base) + 1;
//     cout << "Case " << i << ": " << digits << "\n";
// }


#ifndef ONLINE_JUDGE 
freopen("input.txt", "r", stdin); 
freopen("output.txt", "w", stdout);
#endif



int n;
cin>>n;
map<int, int>mp;
vector<int>v(n);

for(int i=0; i<n; i++){
cin>>v[i];
mp[v[i]]++;
}

int ans=0;
for(auto p : mp){
int x=p.first;
int n=p.second;

if(n<x){
ans+=n;
}else{
ans+=n-x;
}
}
cout<<ans<<endl;
return 0;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

inline void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
n = read();
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
c[i][j] = read();
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
printf("%lld\n", ans / 6);
return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e6 + 10;
const ll MOD = 1e9 + 7;
int tot;
bool not_prime[maxn];
ll prime[maxn];
void Prime_sieve(ll n)
{
not_prime[1] = 1;
for(ll i = 1; i <= n; i++)
{
if(!not_prime[i])prime[tot++] = i;
for(ll j = 0; j < tot && 1LL * prime[j] * i <= n; j++)
{
not_prime[prime[j] * i] = 1;//每个合数x由它最小素因子prime[j]筛掉
if(i % prime[j] == 0)break;//如果i % prime[j] == 0,不停止循环
//那么接下来将用prime[j+1]筛去i*prime[j+1]，但实际上应该用prime[i]筛去,因为i%prime[j]==0
}
}
///cout<<tot<<endl;
}
ll f(ll n, ll x)
{
ll ans = 0;
while(n)
{
ans += n / x;
n /= x;
}
return ans;
}
int main()
{
ll n;
cin >> n;
Prime_sieve(n);
ll ans = 1;
for(int i = 0; i < tot; i++)
ans = ans * (f(n, prime[i]) + 1) % MOD;
cout<<ans<<endl;
return 0;
}

#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

inline int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll maxn = 2e5 + 5;
const ll maxm = 1e3 + 5;
namespace IO{
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc(){
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread(){}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls){
T1 __ = 0, ___ = 1;
char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do{
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
inline void flush(){
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x){
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite(){}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls){
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
struct Flusher_{~Flusher_(){flush();}}io_flusher;
}
namespace rndom{
mt19937 mtrnd(std::chrono::system_clock::now().time_since_epoch().count());
ll rnd(ll x){return mtrnd() % x;}
ll rndrg(ll l, ll r){return l + rnd(r - l + 1);}
template<class T>
void rndshfl(T *pt, T *ed){
ll len = ed - pt;
for(int i = 0;i < len;i++) swap(pt[i], pt[rnd(len)]);
return ;
}
}
using namespace IO; using namespace rndom;
const int mod = 1e9 + 7;
int n, k;
char s[maxn];
int a[maxn];
int p0[maxn], p1[maxn];
int pl[maxn], pr[maxn];
int l[maxn], r[maxn];
int pos[maxn], tot = 0;
void upd(int &x, int y){
return x = x + y >= mod ? x + y - mod : x + y, void();
}
int f[3005][3005];
int sum[3005][3005];
int main(){
ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
cin >> n >> k >> (s + 1);
for(int i = 1;i <= n;i++){
a[i] = s[i] - '0'; p0[i] = p1[i] = a[i]; l[i] = r[i] = i;
}
for(int i = 1;i <= k;i++){
cin >> pl[i] >> pr[i]; int cnt = 0;
for(int j = pl[i];j <= pr[i];j++) cnt += p0[j];
for(int j = pl[i];j < pl[i] + cnt;j++) p0[j] = 1; 
for(int j = pl[i] + cnt;j <= pr[i];j++) p0[j] = 0;
cnt = 0;
for(int j = pl[i];j <= pr[i];j++) cnt += p1[j];
for(int j = pr[i] - cnt + 1;j <= pr[i];j++) p1[j] = 1;
for(int j = pl[i];j <= pr[i] - cnt;j++) p1[j] = 0; 
}
for(int i = 1;i <= n;i++){
if(p0[i] == 1) l[++tot] = i;
}
tot = 0;
for(int i = 1;i <= n;i++){
if(p1[i] == 1) r[++tot] = i;
}
f[0][0] = 1; for(int i = 0;i <= n;i++) sum[0][i] = 1;
for(int i = 1;i <= tot;i++){
for(int j = l[i];j <= r[i];j++){
upd(f[i][j], sum[i - 1][j - 1]);
}
for(int j = 1;j <= n;j++){
sum[i][j] = sum[i][j - 1]; upd(sum[i][j], f[i][j]);
}
}
int ans = 0;
for(int i = 1;i <= n;i++) upd(ans, f[tot][i]);
cout << ans << endl; return 0;
}

/// Zengy MANGA
#pragma GCC optimize("O3")
#pragma GCC optimize ("unroll-loops")
#pragma GCC target("avx,avx2,fma")

#include "bits/stdc++.h"

using namespace std;

#define pb push_back
#define F first
#define S second
#define f(i, a, b)  for(int i = a; i < b; i++)
#define all(a)  a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define sz(x) (int)(x).size()
#define mp(x,y) make_pair(x,y)
#define popCnt(x) (__builtin_popcountll(x))
#define int ll
using ll = long long;
using ii = pair<int,int>;
using ull = unsigned long long;
using db = long double;

const int N = 3e5+5, LG = 18, MOD = 998244353;
const long double PI = acos(-1);

int dp[1005][1005];
int memo[1005][1005];
int A, B, C, D;
int Ch[1005][1005];
int F[1005];
int iF[1005];
int fast(int b, int e) {
int res = 1;
for(;e;e>>=1,b=1ll*b*b%1000000007)
if(e & 1)
res = 1ll * res * b % 1000000007;
return res;
}
int solve2(int cnt, int div) {
///permutation with repetetion
return 1ll * F[cnt] * fast(iF[div], cnt/div) % 1000000007 * iF[cnt/div] % 1000000007;
}
int solve(int index, int left) {
if(index > B) {
return left == 0;
}

int &ret = dp[index][left];
if(~ret)
return ret;
ret = solve(index+1,left);
for(int j = C; j <= D && j * index <= left; j++) {
//        if(solve(index + 1, left - (j * index))) {
//            cout << "HERE " << left << " " << index << ' ' << index * j << ' ' << solve2(index * j, index) * Ch[left][index*j] << endl;
//        }
ret = (ret + solve(index + 1, left - (j * index)) * 1ll * solve2(index * j, index) % 1000000007 * Ch[left][index*j])%1000000007;
}
return ret;
}
void doWork() {

F[0] = iF[0] = 1;

for(int i = 1; i < 1005; i++) {
F[i] = 1ll * i * F[i-1] % 1000000007;
iF[i] = fast(F[i], 1000000005);
}

f(i,0,1005)
f(j,0,i+1)if(j==0||i==j)Ch[i][j] = 1;
else Ch[i][j] = (Ch[i-1][j] + Ch[i-1][j-1]) % 1000000007;
int n;
cin >> n >> A >> B >> C >> D;
memset(dp,-1,sizeof dp);
memset(memo,-1,sizeof memo);
cout << solve(A,n) << '\n';
}

int32_t main() {
#ifdef ONLINE_JUDGE
ios_base::sync_with_stdio(0);
cin.tie(0);
#endif

int t = 1;
//    cin >> t;
while(t--) {
doWork();
}

return 0;
}

///Bishmillahir Rahmanir Raheem
//sajeedreefy
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
typedef long long int ll;
#define pb push_back
#define pf push_front
#define ull unsigned long long
#define fr0(i,n) for (ll i=0;i<n;i++)
#define fr1(i,n) for (ll i=1;i<=n;i++)
#define ff first
#define ss second
#define sp " "
#define debug cout<<"dhukse ekhane "<<endl;
inline ll MOD(ll a){return (a%mod + mod) %mod ;}
inline ll modAdd(ll a,ll b){return MOD( MOD(a) + MOD(b) ) ;}
inline ll modSub(ll a,ll b){return MOD( MOD(a) - MOD(b) ) ;}
inline ll modMul(ll a,ll b){return MOD( MOD(a) * MOD(b) ) ;}
void fastIO(){ios_base::sync_with_stdio(false); cin.tie(NULL);}
ll dx[]={-1,1,0,0};
ll dy[]={0,0,-1,1};
//ll dx[8]={-1,1,0,0,-1,-1,1,1};
//ll dy[8]={0,0,-1,1,-1,1,-1,1};
/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds ;
template <typename PB>
using ordered_set = tree<PB,null_type,less<PB>,rb_tree_tag,tree_order_statistics_node_update> ;
*x.find_by_order(pos) ----> returns the value at "pos" index in the set 0-based
x.order_of_key(value)     ----> returns the position of "value" in the set 0-based
*/
bool isprime(ll x)
{
if(x<2) return false;
if(x<4) return true;
if(!(x&1)) return false;
for(int i=3; i*i<=x; i+=2) if(x%i==0) return false;
return true;
}

string toBinary(ll n)
{
string r;
while(n!=0)
{
r=(n%2==0 ?"0":"1")+r;
n/=2;
}
return r;
}
ll bi_ex(ll x,ll n)
{
ll pro=1;
while(n>0)
{
if(n%2==1) pro=((pro%mod)*(x%mod))%mod;
x=((x%mod)*(x%mod))%mod;
n>>=1;
}
return pro%mod;
}
ll powr(ll n,ll x)
{
if(x==0) return 1;
if(!(x&1)) return powr(n*n,x>>1);
else return n*powr(n*n,(x-1)>>1);
}

signed main()
{
fastIO();
//    freopen("input.txt", "r", stdin);
//    freopen("output.txt", "w", stdout);
ll t=1,mn,q,p,c,i,j,m,ans,a,b,d,x,y,k,n,mx;
//scanf("%lld",&t);
c=0;
//cin >> t;
while(t--)
{
cin >> n;
map <ll,ll> mp;
fr0(i,n)
{
cin >> x;
mp[x]++;
}
ans=0;
for(auto it: mp)
{
if(it.ff>it.ss) ans+=it.ss;
else ans+=it.ss-it.ff;
}
cout << ans << endl;
}
return 0;
}


#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
void solve() {
int a[3];
cin>>a[0]>>a[1]>>a[2];
sort(a,a+3);
int val=a[2]-a[1];
a[0]+=val;
a[1]+=val;

if((a[1]-a[0])%2==0){
cout<<val+(a[1]-a[0])/2<<endl;
}else{
val++;
a[1]++;
cout<<val+(a[1]-a[0])/2<<endl;
}

}

int32_t main() {
nitin;

solve();
}
#include<iostream>
#include<algorithm>
#include<vector>
#include<cmath>
#include<iomanip>
#include<map>
#include<atcoder/modint>
using namespace std;
using namespace atcoder;
#define rep(i,n) for(int i=0;i<(n);i++)
typedef long long ll;
using mint = modint1000000007;
typedef pair<int,int> P;
template<class T> void chmin(T &a, T b){if(a>b){a=b;}}
template<class T> void chmax(T &a, T b){if(a<b){a=b;}}
int main()
{
int n;
ll a;
cin >> n;
map<ll,P> m;
vector<ll> res(n);
m[0]=P(-1,0);
rep(i,n){
cin >> a;
m[-a].second++;
if(m[-a].second==1) m[-a].first=i;
}
auto it=m.begin();
a=it->first;
auto [i,c]=it->second;
it++;
for(;it!=m.end();it++){
auto aa=it->first;
auto [ii,cc]=it->second;
res[i]+=(aa-a)*c;
chmin(i,ii);
c+=cc;
a=aa;
}
rep(i,n) printf("%ld\n",res[i]);
return 0;
}
// 解き直し.
// https://img.atcoder.jp/arc093/editorial.pdf
// C++(GCC 9.2.1)
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using P = pair<int, int>;
using vi = vector<int>;
using vs = vector<set<int>>;
using T3 = tuple<LL, int, int>;
#define repex(i, a, b, c) for(int i = a; i < b; i += c)
#define repx(i, a, b) repex(i, a, b, 1)
#define rep(i, n) repx(i, 0, n)
#define repr(i, a, b) for(int i = a; i >= b; i--)
#define all(x) x.begin(), x.end()
const LL MOD = 1e9 + 7;
LL w[2020], mPow2[2020];
int u[2020], v[2020];

// https://github.com/atcoder/live_library/blob/master/uf.cpp
// UnionFind
// coding: https://youtu.be/TdR816rqc3s?t=726
// comment: https://youtu.be/TdR816rqc3s?t=6822
// -> 一部改変.
struct UnionFind{
vi d;
UnionFind(int n = 0): d(n, -1) {}
int find(int x){
return (d[x] < 0) ? x : (d[x] = find(d[x]));
}
bool unite(int x, int y){
x = find(x);
y = find(y);
if(x == y) return false;
if(d[x] > d[y]) swap(x, y);
d[x] += d[y];
d[y] = x;
return true;
}
bool same(int x, int y){
return find(x) == find(y);
}
int size(int x){
return -d[find(x)];
}
};

int main(){

// 1. 入力情報.
int N, M;
LL X;
scanf("%d %d %lld", &N, &M, &X);
map<P, LL> m;
rep(i, M){
scanf("%d %d %lld", &u[i], &v[i], &w[i]);
u[i]--;
v[i]--;
m[{u[i], v[i]}] = w[i];
m[{v[i], u[i]}] = w[i];
}

// 2. sort.
vector<T3> t;
rep(i, M) t.emplace_back(w[i], u[i], v[i]);
sort(all(t));

// 3. 最小全域木(Kruskal's Algorithm).
// 競プロ典型 90 問 (049 - Flip Digits 2)
// https://github.com/E869120/kyopro_educational_90/blob/main/sol/049.cpp
LL S = 0;
vs T(N);
UnionFind uf(N + 2);
rep(i, t.size()){
int a = get<1>(t[i]);
int b = get<2>(t[i]);
LL c = get<0>(t[i]);
if(!uf.same(a, b)){
uf.unite(a, b);
T[a].insert(b);
T[b].insert(a);
S += c;
}
}

// 4. D.
LL D = X - S;

// 5. bfs.
// https://ja.wikipedia.org/wiki/幅優先探索
auto bfs = [&](vs &G, int s, int* d){
// 空のキュー.
queue<int> q;

// 探索地点 s をキュー q に追加.
q.push(s);
while(!q.empty()){
// キューから取り出す.
int u = q.front();
q.pop();

// 隣接頂点をチェック.
for(auto &e : G[u]) if(!d[e] && e != s) d[e] = d[u] + 1, q.push(e);
}
};

// 6. 最短経路上 の 辺の重み の 最大値.
auto f = [&](vs &G, int g, int* d) -> LL{
// 返却用.
LL ret = 0;

// 空のキュー.
queue<int> q;

// 探索地点 g をキュー q に追加.
q.push(g);
while(!q.empty()){
// キューから取り出す.
int u = q.front();
q.pop();

// 隣接頂点をチェック.
for(auto &e : G[u]){
if(d[e] == d[u] - 1){
// 距離が 1 小さい頂点を追加.
q.push(e);

// 最短経路を構成する辺とみて, 辺の重みの最大値 を 更新.
ret = max(ret, m[{u, e}]);
}
}
}

// 返却.
return ret;
};

// 7. D との 比較.
// -> グラフ G に含まれるが, グラフ T に 含まれない 辺 のみ 計算.
int eLower = 0, eEqual = 0, eUpper = 0;
rep(i, M){
// グラフ T に 含まれる辺か？
if(T[u[i]].count(v[i])) continue;

// 最短距離.
int d[1010];
rep(j, 1010) d[j] = 0;
bfs(T, u[i], d);

// グラフ T 上で, pathMax 計算.
LL pathMax = f(T, v[i], d);

// diff の 値 に応じて, カウント.
LL diff = w[i] - pathMax;
if(diff < D)  eLower++;
if(diff == D) eEqual++;
if(diff > D)  eUpper++;
}

// 8. 2 の 冪乗.
mPow2[0] = 1;
repx(i, 1, 2020){
mPow2[i] = mPow2[i - 1] << 1;
mPow2[i] %= MOD;
}

// 9. 塗り方の個数.
LL ans = 1;

// 9-1. D < 0.
if(D < 0) ans = 0;

// 9-2. D == 0.
if(D == 0){
// T の 辺 に 2種類の色 を 両方用いる場合.
LL t1 = 1;
t1 *= (mPow2[N - 1] - 2);
t1 %= MOD;
t1 *= mPow2[M - N + 1];
t1 %= MOD;

// それ以外.
LL t2 = 1;
t2 *= 2;
t2 %= MOD;
t2 *= (mPow2[eEqual] - 1);
t2 %= MOD;
t2 *= mPow2[eUpper];
t2 %= MOD;

// 合計.
ans = t1 + t2;
ans %= MOD;
}

// 9-3. D > 0.
if(D > 0){
ans *= 2;
ans %= MOD;
ans *= (mPow2[eEqual] - 1);
ans %= MOD;
ans *= mPow2[eUpper];
ans %= MOD;
}

// 10. 出力.
printf("%lld\n", ans);
return 0;

}
#include <algorithm>
#include <cassert>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>
/*
#include <atcoder/all>
template <int m, std::enable_if_t<(1 <= m)> * = nullptr>
ostream &operator<<(ostream &os, const atcoder::static_modint<m> &v) {
os << v.val();
return os;
}
*/

/*
cd $dir && g++ -std=c++17 -Wall -Wextra -O2 -DATCODERDEBUG
-I/home/moritanian/projects/atcoder/lib/ac-library $fileName && \
echo 'compilation ok!'
&&  ./a.out
*/
using namespace std;
#define REP(i, n) for (ll i = 0; i < ll(n); i++)
#define FOR(i, a, b) for (ll i = a; i <= ll(b); i++)
#define ALL(x) x.begin(), x.end()
#define dame(a)        \
{                    \
cout << a << endl; \
return 0;          \
}
typedef long long ll;

ll __per__(ll a, ll b) {
if (a >= 0) return a % b;
return (((-a - 1LL) / b) + 1LL) * b + a;
}

class dstream : public ostream {
public:
dstream &operator<<(__attribute__((unused))
ostream &(*endl)(std::ostream &out)) {
#ifdef ATCODERDEBUG
cout << endl;
#endif
return *this;
}
};

dstream dout;

template <typename T>
dstream &operator<<(dstream &os, const T &v) {
#ifdef ATCODERDEBUG
cout << "\033[1;31m" << v << "\033[0m";
#endif
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<T> &v) {
os << "[ ";
for (auto const &x : v) {
os << x;
if (&x != &v.back()) {
os << " , ";
}
}
os << " ]";
return os;
}

ostream &operator<<(ostream &os, const vector<bool> &v) {
os << "[ ";
for (size_t i = 0; i < v.size(); i++) {
os << v[i];
if (i != v.size() - 1) {
os << " : ";
}
}
os << " ]";
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<vector<T>> &v) {
os << "[" << endl;
for (auto const &x : v) {
os << " ";
os << x;
os << endl;
}
os << "]";
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const map<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const unordered_map<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const multimap<T, U> &v) {
os << "{" << endl;
for (auto const &x : v) {
os << " ";
os << x;
}
os << "}" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const set<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const unordered_set<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T>
ostream &operator<<(ostream &os, const multiset<T> &v) {
os << "{";
for (auto const &x : v) {
os << " ";
os << x;
}
os << " }" << endl;
return os;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const pair<T, U> &v) {
os << "< " << v.first << " : " << v.second << " >";
return os;
}

template <class tTuple, std::size_t... indices>
void _print_tuple(ostream &os, tTuple const &iTuple,
std::index_sequence<indices...>) {
using swallow = int[];
os << "[ ";
(void)swallow{(os << std::get<indices>(iTuple) << " , ", 0)...};
os << " ]" << endl;
}

template <class... ARGS>
ostream &operator<<(ostream &os, const tuple<ARGS...> &v) {
constexpr size_t N = tuple_size<tuple<ARGS...>>::value;
_print_tuple(os, v, std::make_index_sequence<N>{});
return os;
}

template <typename T, typename U, typename Comp = less<>>
bool chmax(T &xmax, const U &x, Comp comp = {}) {
if (comp(xmax, x)) {
xmax = x;
return true;
}
return false;
}

template <typename T, typename U, typename Comp = less<>>
bool chmin(T &xmin, const U &x, Comp comp = {}) {
if (comp(x, xmin)) {
xmin = x;
return true;
}
return false;
}

ll log10ll(ll n) {
ll res = 0;
while (n >= 10) {
n /= 10LL;
res++;
}
return res;
}

ll powll(ll a, ll b) {
ll res = 1LL;
while (b) {
if (b & 1) res *= a;
a *= a;
b >>= 1;
}
return res;
}

bool recur(ll X, ll Y, vector<vector<ll>> &dp) {
if (dp[X][Y] != -1) return dp[X][Y];

bool b = false;
for (ll x = X - 2LL; x >= 0LL; x -= 2LL) {
if (!recur(x, Y + (X - x) / 2LL, dp)) {
b = true;
break;
}
}

for (ll y = Y - 2LL; y >= 0LL; y -= 2LL) {
if (!recur(X + (Y - y) / 2LL, y, dp)) {
b = true;
break;
}
}

dp[X][Y] = b;
return b;
}

bool solve(ll X, ll Y) {
vector<vector<ll>> dp(X + Y + 2LL, vector<ll>(Y + X + 2LL, -1));
dp[0][0] = 0;
dp[0][1] = 0;
dp[1][0] = 0;
dp[1][1] = 0;
auto ans = recur(X, Y, dp);
// dout << dp << endl;
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

ll X, Y;
cin >> X >> Y;

if (abs(X - Y) < 2LL) {
cout << "Brown" << endl;
} else {
cout << "Alice" << endl;
}
// cout << solve(X, Y) << endl;
//  cout << std::fixed << std::setprecision(15) << sqrt(ans) << endl;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, k, n) for(int i = k; i < n; i++)
#define MAX_N 110000
typedef long long ll;
typedef pair<ll, ll> P;
const ll INF = 100000000000;
using Graph = vector<vector<ll>>;
using Field = vector<vector<char>>;

int main(void) {
ll a, b;
cin >> a >> b;
string ans = to_string(a);
if(b % 2 == 0) {
ans += to_string(b/2);
} else {
ans += to_string(b/2);
ans += '5';
}
cout << ans << endl;

return 0;
}
#include<bits/stdc++.h>
using namespace std;
int fa1[200009];
int fa2[200009];
int findset1(int u)
{
return fa1[u]==u?u:fa1[u]=findset1(fa1[u]);
}
int findset2(int u)
{
return fa2[u]==u?u:fa2[u]=findset2(fa2[u]);
}
int main()
{
int n,k,r;
cin>>n>>k>>r;
for(int i=1;i<=n;i++)
{
fa1[i]=i;
fa2[i]=i;
}
int u,v;
for(int i=1;i<=k;i++)
{
cin>>u>>v;
int fu=findset1(u);
int fv=findset1(v);
if(fu!=fv)
{
fa1[fu]=fv;
}
}
for(int i=1;i<=r;i++)
{
cin>>u>>v;
int fu=findset2(u);
int fv=findset2(v);
if(fu!=fv)
{
fa2[fu]=fv;
}
}
map<pair<int,int>,int>mp;
for(int i=1;i<=n;i++)  //让fa1[i],fa2[i]表示i的祖先。
{
findset1(i);
findset2(i);
}
for(int i=1;i<=n;i++)
{
mp[make_pair(fa1[i],fa2[i])]++;//自身也包括至少一个。
}
for(int i=1;i<=n;i++)
{
cout<<mp[make_pair(fa1[i],fa2[i])]<<" ";
}

}
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define dF(i,a,b) for(int i=(a);i>=(b);--i)
#define ms(a,vl) memset(a,vl,sizeof(a))
using namespace std;
long long n,a[170],b[170],sum,ans=-1e18;
int main(){ios::sync_with_stdio(0),cin.tie(0);
cin>>n;
F(i,1,n)cin>>b[i];
F(_,1,100000){
F(i,1,n)a[i]=b[i];
dF(i,n,1){
sum=0;
for(int j=1;j<=n/i;j++)sum+=a[j*i];
if((sum<=0)^(rand()%13==0))for(int j=1;j<=n/i;j++)a[j*i]=0;
}
sum=0;
F(i,1,n)sum+=a[i];
ans=max(ans,sum);
}
cout<<ans;
}
/*Author: Chiimo*/
#include<stdio.h>

#define int long long
int s[200010], n;
int abs(int a) {
return a > 0 ? a : -a;
}
int min(int i, int j) {
return i < j ? i : j;
}
signed main() {
scanf("%lld", &n);
for(int i = 1; i <= n; ++i) {
int a;
scanf("%lld", &a);
s[i] = s[i - 1] + a;
}
int ans = (int)1e15;
for(int i = 1; i < n; ++i) {
int S = s[i], R = s[n] - s[i];
ans = min(ans, abs(S - R));
}
printf("%lld", ans);
return 0;
}
#include <iostream>
using namespace std;
typedef long long ll;

ll curXor, curSum, ans, n, l, r;

int main(){
cin >> n;

ll a[n];

for(ll i = 0; i < n; i++) cin >> a[i];
l = 0; r = -1;

while(l < n) {
while(r < n - 1 && (curXor ^ a[r + 1]) == curSum + a[r + 1]) {
curXor ^= a[++r];
curSum += a[r];
}
ans += r - l + 1;
curXor ^= a[l++];
curSum -= a[l-1];
}

cout << ans << endl;
}

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<int, int>;

struct frac {
ll a, b;  // a / b
frac(ll a_ = 0, ll b_ = 1) {
a = a_;
b = b_;
if (b == 0) {
a = 1;
return;
}
if (b < 0) {
a = -a;
b = -b;
}
ll g = gcd(a, b);
a /= g;
b /= g;
}
bool operator<(const frac& other) const {
return a * other.b < b * other.a;
}
bool operator<=(const frac& other) const {
return a * other.b <= b * other.a;
}
bool operator>(const frac& other) const {
return a * other.b > b * other.a;
}
bool operator>=(const frac& other) const {
return a * other.b >= b * other.a;
}
bool operator==(const frac& other) const {
return a * other.b == b * other.a;
}
};

int main() {
int a, b, c, d, e, f;
cin >> a >> b >> c >> d >> e >> f;
a *= 100;
b *= 100;
frac now(0, 1);
int x = a, y = 0;  // x := weight of solution, y := weight of sugar
for (int i = 0; i <= 30; i++) {
for (int j = 0; j <= 30; j++) {
int w = i * a + j * b;
if (!w || w > f) continue;
int v = min(f - w, w * e / 100);
for (int k = 0; k <= v / c; k++) {
for (int l = 0; l <= v / d; l++) {
int s = k * c + l * d;
if (v < s) continue;
if (now < frac(s, s + w)) {
now = frac(s, s + w);
x = s + w;
y = s;
}
}
}
}
}
cout << x << " " << y << endl;
}
// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline ll read(){
ll x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

const int N=5005;
const int mod=1e9+7;

inline void add(int &x,int y){
if((x+=y)>=mod)x-=mod;
}
inline void sub(int &x,int y){
if((x-=y)<0)x+=mod;
}

vector<int>adj[N];
int f[N][N],tmp[N];
int n;

int sz[N],coef[N];
void dfs(int u,int fa){
sz[u]=1;
f[u][1]=1;
for(auto v:adj[u]){
if(v==fa)continue;
dfs(v,u);
for(int j=0;j<=sz[u]+sz[v];j++)tmp[j]=0;
for(int j=0;j<=sz[u];j++){
for(int k=0;k<=sz[v];k++){
add(tmp[j+k],1ll*f[u][j]*f[v][k]%mod);
}
}
for(int j=0;j<=sz[u]+sz[v];j++)f[u][j]=tmp[j];
sz[u]+=sz[v];
}
{
for(int i=0;i<=sz[u];i++)tmp[i]=0;
for(int i=0;i<=sz[u];i++)add(tmp[i],f[u][i]);
for(int i=0;i<=sz[u];i+=2)sub(tmp[0],1ll*f[u][i]*coef[i]%mod);
for(int i=0;i<=sz[u];i++)f[u][i]=tmp[i];
}
//    printf("Info (u=%d)\n",u);
//    for(int i=0;i<=sz[u];i++)printf("f[%d][%d]=%d\n",u,i,f[u][i]);
}

int main(){
n=read();
for(int i=0;i<=n;i+=2){
coef[i]=1;
for(int j=i-1;j>=1;j-=2)
coef[i]=1ll*coef[i]*j%mod;
//        printf("coef[%d]=%d\n",i,coef[i]);
}
rep(i,1,n-1){
int u=read(),v=read();
adj[u].pb(v),adj[v].pb(u);
}
dfs(1,0);
print((mod-f[1][0])%mod,'\n');// 根没有父边，所以多乘了 -1 
return 0;
}
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}

const int inf = 1001001001;
const ll INF = 1001001001001001001;

const double PI = acos(-1);

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

using mint = modint998244353;
const int MOD = 998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;

signed main(){
cout << fixed << setprecision(15);

int N, K;
cin >> N >> K;
map<int, ll> mp;
rep2(i, 1, N) mp[i%K]++;
ll ans = 0;
if(K%2 == 1){
ll y = mp[0];
ans += y + y*(y-1)*3 + y*(y-1)*(y-2);
}
else{
ll y = mp[0];
ans += y + y*(y-1)*3 + y*(y-1)*(y-2);
y = mp[K/2];
ans += y + y*(y-1)*3 + y*(y-1)*(y-2);
}

cout << ans << endl;
return 0;
}
#include<bits/stdc++.h>
#define ll long long 
#define maxn 110000
#define inf 1000000007
using namespace std;
int n,k,flag;
int head[maxn],cnt;
struct Edge{
int nex,to;
}edge[maxn*2];
int a,b,v,p;
struct Node{
int val,odd,l,r,pd;
}node[maxn];
inline void add(int from,int to){
edge[++cnt].nex=head[from];
head[from]=cnt;
edge[cnt].to=to;
}
inline void dfs(int x,int fa){
if(flag)return;
for(int i=head[x];i;i=edge[i].nex){
int v=edge[i].to;
if(v==fa)continue;
dfs(v,x);
if(node[v].r==inf)continue;
if(node[x].r==inf){
node[x].l=node[v].l-1;
node[x].r=node[v].r+1;
node[x].odd=node[v].odd^1;
continue;
}
node[x].l=max(node[x].l,node[v].l-1);
node[x].r=min(node[x].r,node[v].r+1);
if(node[x].odd==node[v].odd)flag=1;
if(node[v].l>node[v].r)flag=1;
if(node[v].l==node[v].r&&(node[v].l&1)!=node[v].odd)flag=1;
}
if(node[x].l>node[x].r)flag=1;
if(node[x].l==node[x].r&&(node[x].l&1)!=node[x].odd)flag=1;
return ;
}
inline void dfs1(int x,int fa){
for(int i=head[x];i;i=edge[i].nex){
int v=edge[i].to;
if(v==fa)continue;
//if(node[v].pd)continue;
if(!node[v].pd&&node[v].r==inf){
//if(v==4)cout<<1<<endl;
node[v].val=node[x].val-1;
node[v].odd=node[v].val&1;
//node[v].pd=1;
//continue;
}
else if(!node[v].pd)
{
node[v].pd=1;
for(int j=node[v].l;j<=node[v].r;j++){
if((j==node[x].val-1||j==node[x].val+1)&&(j&1)==node[v].odd){
node[v].val=j;
//node[v].pd=1;
break;
}
}
}
dfs1(v,x);
}
return;
}
int main()
{
cin>>n;
for(int i=1;i<n;i++){
cin>>a>>b;
add(a,b);add(b,a);
}
for(int i=1;i<=n;i++)node[i].pd=0,node[i].l=-inf,node[i].r=inf,node[i].odd=-1;
cin>>k;
for(int i=1;i<=k;i++){
cin>>p>>v;
node[p].pd=1;
node[p].val=v;node[p].odd=v&1;
node[p].l=node[p].r=v;
}
int s;
for(int i=1;i<=n;i++){
if(node[i].pd){
s=i;
break;
}
}
dfs(s,0);
if(flag){
cout<<"No"<<endl;
return 0;
}
//	for(int i=1;i<=n;i++){
//		if(node[i].pd)
//		dfs1(i,0);
//	}
dfs1(s,0);
cout<<"Yes"<<endl;
for(int i=1;i<=n;i++){
cout<<node[i].val<<endl;
}
}
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<functional>
#include<string>
using namespace std;
const int N=1e5+10;
int a[N];
int main()
{
int n;
cin>>n;
int k=0;
for(int i=1;i<=N;i++){
a[i]=a[i-1]+i;
}
for(int i=1;i<=N;i++){
if(a[i]>=n){
k=i;
break;
}
}
cout<<k<<endl;
return 0;
}
#include <bits/stdc++.h>

#define For(i, a, b) for (int i = a; i <= b; ++i)
#define rFor(i, b, a) for (int i = b; i >= a; --i)
#define eFor(i, u, v) for (int i = head[u], v = e[i].to; i; i = e[i].next, v = e[i].to)

typedef long long ll;

using std::cin;
using std::cout;
using std::endl;

typedef std::pair<int, int> pii;
#define fi first
#define se second

std::mt19937 rnd(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename T> T myrand(T l, T r) {
return std::uniform_int_distribution<T>(l, r)(rnd);
}

void close_stdio() {
std::ios::sync_with_stdio(false);
std::cerr << "DO NOT use scanf/printf!\n";
}

const int kN = 2e5 + 5;

int n, nxt[kN], cnt[kN][26];
ll l, r, ans[26];
char s[kN];

ll solve(int c, ll rb) {
if (rb <= n) return cnt[rb][c];
ll sum = cnt[n][c], x = n, y = n - nxt[n], cx = cnt[n][c], cy = cnt[n - nxt[n]][c], t1, t2;
while (x + y <= rb) {
sum += cy;
t1 = x, t2 = cx;
x += y, cx += cy;
y = t1, cy = t2;
}
return sum + solve(c, rb - x);
}

int main() {
scanf("%s%lld%lld", s + 1, &l, &r);
n = strlen(s + 1) / 2;
for (int i = 2, j = 0; i <= n; ++i) {
while (j && s[i] != s[j + 1]) j = nxt[j];
if (s[i] == s[j + 1]) ++j;
nxt[i] = j;
}
if (n % (n - nxt[n]) == 0) {
For(i, 1, n - nxt[n]) {
ans[s[i] - 'a'] += r / (n - nxt[n]) - (l - 1) / (n - nxt[n]);
if (i <= r % (n - nxt[n])) ++ans[s[i] - 'a'];
if (i <= (l - 1) % (n - nxt[n])) --ans[s[i] - 'a'];
}
For(i, 0, 25) printf("%lld ", ans[i]);
return 0;
}
For(i, 1, n) {
For(j, 0, 25) {
cnt[i][j] = cnt[i - 1][j];
}
++cnt[i][s[i] - 'a'];
}
For(i, 0, 25) printf("%lld ", solve(i, r) - solve(i, l - 1));
return 0;
}
/* PAY ATTENTION TO: */
/* 1. Memory Limit, Array Size */
/* 2. Integer Overflow */
/* 3. Multi-test */
/* 4. Potential Constant-speedup */
/* Stay organized and write things down. */

#include<iostream>
using namespace std;
typedef  long long ll;
int main()
{
ll x;
scanf("%lld",&x);
ll sum=0;
int i=1;
while(2333)
{
sum+=i;
if(sum>=x)
{
printf("%d\n",i);
return 0;
}
i++;
}
}
#include<bits/stdc++.h>
using namespace std;

const int MAXN=6005;

struct edge{
int to,next;
}e[MAXN<<1];
int head[MAXN],n,cnt=0;
inline void add(int u,int v){
e[++cnt]=(edge){v,head[u]},head[u]=cnt;
}
int fa[MAXN],val[MAXN];
pair<int,int>f[MAXN];
#define mp make_pair

int F[MAXN];

void dfs(int u){
bool isleave=1;
for(int i=head[u];i;i=e[i].next){
isleave=0;
int v=e[i].to;
dfs(v);
}
if(isleave){
f[u]=mp(val[u],0);
}
else{
memset(F,0,sizeof(F));
F[0]=1;
int tot=0,minn=0;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
tot+=f[v].first+f[v].second;
minn+=f[v].second;
for(int j=val[u];j>=0;j--){
if(!F[j])continue;
if(j+f[v].first<=val[u]){
F[j+f[v].first]=1;
}
if(j+f[v].second<=val[u]){
F[j+f[v].second]=1;
}
}
}
if(minn>val[u]){
puts("IMPOSSIBLE");
exit(0);
}
for(int i=val[u];i>=0;i--){
if(F[i]){
int remain=tot-i;
f[u]=mp(remain,val[u]);
if(f[u].first<f[u].second)swap(f[u].first,f[u].second);
break;
}
}
}
}
int main(){
scanf("%d",&n);
for(int i=2;i<=n;i++){
scanf("%d",&fa[i]);
add(fa[i],i);
}
for(int i=1;i<=n;i++){
scanf("%d",&val[i]);
}
dfs(1);
puts("POSSIBLE");
return 0;
}
#include <bits/stdc++.h>
using namespace std; 

typedef long long ll; 
typedef pair <int, int> ii; 

const ll LINF = (ll) 1e18; 
const int INF = (int) 1e9;
const int mod = (int) 1e9 + 7; 

int main() {
ios::sync_with_stdio(0); 
cin.tie(0); 
int n; 
vector<string> s(2); 
cin >> n >> s[0] >> s[1]; 

vector<int> a;
for (int i = 0; i < n;) {
if (s[0][i] == s[1][i]) {
a.push_back(1);
i++;
}
else {
a.push_back(2);
i += 2; 
}
}

vector<ll> dp(a.size()); 
if (a[0] == 1) dp[0] = 3; else dp[0] = 6;  

for (int i = 1; i < (int)a.size(); i++) {
if (a[i - 1] == 2 && a[i] == 2) dp[i] = dp[i - 1] * 3 % mod; 
if (a[i - 1] == 2 && a[i] == 1) dp[i] = dp[i - 1]; 
if (a[i - 1] == 1 && a[i] == 2) dp[i] = dp[i - 1] * 2 % mod; 
if (a[i - 1] == 1 && a[i] == 1) dp[i] = dp[i - 1] * 2 % mod; 
}

cout << dp[a.size() - 1] << '\n';  
}
#include <map>
#include <set>
#include <queue>
#include <cmath>
#include <bitset>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define pii pair <int , int>
#define mp make_pair
#define fs first
#define sc second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

//const int Mxdt=100000; 
//static char buf[Mxdt],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;

template <typename T>
void read(T &x) {
T f=1;x=0;char s=getchar();
while(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}
while(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s-'0');s=getchar();}
x *= f;
}

template <typename T>
void write(T x , char s='\n') {
if(!x) {putchar('0');putchar(s);return;}
if(x<0) {putchar('-');x=-x;}
T tmp[25]={},t=0;
while(x) tmp[t++]=x%10,x/=10;
while(t-->0) putchar(tmp[t]+'0');
putchar(s); 
}

LL x[1005] , y[1005] , n , tot[1005] , fx[1005] , fy[1005];
LL cur[40] , ans[40];

int main() {
read(n);

for (int i = 1; i <= n; ++i) {
read(x[i]),read(y[i]);
fx[i] = fy[i] = 1;
if(x[i] < 0) x[i] = -x[i] , fx[i] = -1;
if(y[i] < 0) y[i] = -y[i] , fy[i] = -1;

if((x[i] + y[i]) % 2 != (x[1] + y[1]) % 2) {
puts("-1");
return 0;
} 

tot[i] = x[i] + y[i];

}

int m;

if(tot[1] % 2 == 0) write(m = 33);
else write(m = 32);

for (int i = 0; i < 32; ++i) write(1ll << i , ' ');
if(m == 33) write(1 , ' '); 
puts("");

for (int i = 1; i <= n; ++i) {
LL num = 0;
cur[31] = 1;num += (1ll << 31);ans[31] = 1;
if(m == 33) cur[32] = -1;

for (int j = 30; j >= 0; --j) {
if((tot[i] >> (j + 1)) & 1) cur[j] = 1 , ans[j] = 1 , num += (1ll << j);
else cur[j] = -1;
}

LL now = num - x[i] , tmp = 0;

for (int j = 31; j >= 0; --j) if(now & (1 << j)){
if(cur[j] == 1) ans[j] = 0;
else ans[j] = 1;
}

for (int j = 0; j <= 31; ++j) if(ans[j]) tmp += cur[j] * (1ll << j);

if(m == 33 && tmp != x[i]) ans[32] = 1;

LL tmpx = 0 , tmpy = 0;
for (int j = 0; j < m; ++j) {
if(ans[j]) putchar(cur[j] * fx[i] == 1 ? 'R' : 'L') , tmpx += cur[j] * fx[i] * (j < 32 ? (1ll << j) : 1);
else putchar(cur[j] * fy[i] == 1 ? 'U' : 'D') , tmpy += cur[j] * fy[i] * (j < 32 ? (1ll << j) : 1);
} 

puts("");

for (int j = 0; j < m; ++j) ans[j] = cur[j] = 0;
}



return 0;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
int dr[9] = {0, 0, 0, -1, -1, -1, 1, 1, 1}, dc[9] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};
void solve(){ 
int n, m; cin>>n>>m;
int c; cin>>c;
map<pi, int> mp;
for(int i=0; i<c; i++){
int a,b; cin>>a>>b;
for(int j=0; j<9; j++){
int rr = a + dr[j];
int cc = b + dc[j];
mp[{rr, cc}]++;
}
}
vector<int> ans(10, 0);
ans[0] = (n-2)*(m-2);
for(auto x: mp){
int ok = 0;
for(int j=0; j<9; j++){
int rr = x.fr.fr + dr[j];
int cc = x.fr.sc + dc[j];
if(rr >= 1 && rr <= n && cc >= 1 && cc <= m)
ok++;
}
if(ok == 9)
ans[x.sc]++;
}
for(int j=1; j<10; j++)
ans[0] -= ans[j];
for(int j=0; j<10; j++)
cout<<ans[j]<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<bits/stdc++.h>
#define maxn 1000005
#define int long long
#define put() putchar('\n')
using namespace std;
inline void read(int &x){
int f=1;x=0;char c=getchar();
while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
x*=f;
}
int n;
struct node{
int x,y;
node(int a=0,int b=0) {x=a;y=b;}
node operator +(const node &tmp) const {
int rt[5];
rt[1]=x;rt[2]=tmp.x;rt[3]=y;rt[4]=tmp.y;
sort(rt+1,rt+5);
return node(rt[4],rt[3]);
}
}dp[maxn];
int a[maxn];
signed main(void){
int i,j;
read(n);
for (i=0;i<(1<<n);i++) read(a[i]),dp[i]=node(a[i],-1);
for (j=0;j<n;j++)
for (i=1;i<(1<<n);i++)
if ((i>>j)%2==1) dp[i]=dp[i]+dp[i^(1<<j)];
int ans=0;
for (i=1;i<(1<<n);i++) {
ans=max(ans,dp[i].x+dp[i].y);
printf("%lld\n",ans);
}
return 0;
}

#include<bits/stdc++.h>
#define int long long
using namespace std;
#define fi first
#define se second
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<pii> vp;

long long read() {
long long res=0, w=1; char c=getchar();
while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
while(isdigit(c)) {res=res*10+c-48, c=getchar();}
return res*w;
}

const int N=1e6+9;
int n,pre[N],nxt[N];
char s[N];

signed main() {
scanf("%s",s+1); int n=strlen(s+1);
pre[1]=0; int j=0;
rep(i,1,n-1) {
while(j&&s[j+1]!=s[i+1]) j=pre[j];
if(s[j+1]==s[i+1]) j++;
pre[i+1]=j;
}
nxt[n]=n+1; j=n+1;
per(i,n,2) {
while(j<=n&&s[j-1]!=s[i-1]) j=nxt[j];
if(s[j-1]==s[i-1]) j--;
nxt[i-1]=j;
}
int len=n-pre[n];
if(pre[n]==0||n%len) return puts("1\n1"), 0;
else if(len==1) return printf("%lld\n%lld\n",n,1), 0;
else {
int ans=0;
rep(i,2,n) {
if((pre[i-1]==0||(i-1)%(i-1-pre[i-1]))&&(nxt[i]==n+1||(n-i+1)%(nxt[i]-i))) ans++;
}
printf("%lld\n%lld\n",2,ans);
}
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

vector <vector <pair <int, int>>> g;
vector <int> bfs(int S) {
int n = g.size();
vector <int> dist(n, -1);
dist[S] = 0;
queue <int> q;
q.push(S);
while (!q.empty()) {
int v = q.front();
q.pop();
for (auto u : g[v]) {
if (dist[u.first] == -1) {
dist[u.first] = dist[v] + 1;
q.push(u.first);
}
}
}
return dist;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

string s; cin >> s;
int n = s.size();
g.resize(n + 2);
vector <int> last(26, n + 1);
for (int i = n - 1; i >= -1; --i) {
for (int j = 0; j < 26; ++j) {
g[i + 1].push_back({ last[j], j });
g[last[j]].push_back({ i + 1, j });
}
if (i != -1) last[s[i] - 'a'] = i + 1;
}

vector <int> d1 = bfs(0), d2 = bfs(n + 1);
int len = d1[n + 1], curV = 0;
string ans = "";

while (curV != n + 1) {
int curMin = mod, goV = -1;
for (auto& u : g[curV]) {
if (d1[curV] + d2[u.first] + 1 == len and curMin > u.second) {
curMin = u.second, goV = u.first;
}
}
ans += (char)('a' + curMin);
curV = goV;
}
cout << ans << '\n';


return 0;
}

#include<cstdio>
#include<vector>
#include<stack>
#include<algorithm>
typedef long long ll;
using std::vector; using std::stack; using std::min;
vector<int> e[2000006], SCC[2000006], req; stack<int> sta;
int f[2000006], cnt, dfn[2000006], tot, low[2000006], bel[2000006], ans[1000006];
void tarjan(int u) {
dfn[u] = low[u] = ++cnt, sta.push(u);
for (int v : e[u]) {
if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
else if (!bel[v]) low[u] = min(low[u], low[v]);
f[u] |= f[v];
}
if (low[u] == dfn[u]) {
tot++; int dt = 0;
while (sta.top() != u) {
bel[sta.top()] = tot, SCC[tot].push_back(sta.top());
sta.pop();
}
bel[u] = tot, SCC[tot].push_back(u), sta.pop();
for (int v : SCC[tot]) dt |= f[v];
if (dt) for (int v : SCC[tot]) f[v] = 1;
else for (int v : SCC[tot]) ans[v / 2] = v % 2, f[v ^ 1] = 1;
}
}
int n, x[10004], y[10004], fix[20004], p[10004], pr[10004], bd, mxf, mp[100005], fl[10004], fr[10004];
void build(int u, int l, int r) {
bd = std::max(bd, u), mxf = std::max(mxf, u);
if (l == r) return void(fix[p[l]] = u);
int mid = (l + r) >> 1;
e[u << 1 | 1].push_back((u << 1) << 1 | 1);
e[(u << 1) << 1].push_back(u << 1);
e[u << 1 | 1].push_back((u << 1 | 1) << 1 | 1);
e[(u << 1 | 1) << 1].push_back(u << 1);
build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}
void buildr(int u, int l, int r) {
if (l == r) return;
int mid = (l + r) >> 1, ru = u + mxf, ls = (u << 1) + mxf, rs = (u << 1 | 1) + mxf;
bd = std::max(bd, ru);
if (r - l == 1) {
mp[fix[pr[l]]] = ls, mp[fix[pr[r]]] = rs;
ls = fix[pr[l]], rs = fix[pr[r]];
}
if (r - l == 2) mp[fix[pr[r]]] = u << 1 | 1, rs = fix[pr[r]];
e[ru << 1].push_back(ls << 1);
e[ls << 1 | 1].push_back(ru << 1 | 1);
e[ru << 1].push_back(rs << 1);
e[rs << 1 | 1].push_back(ru << 1 | 1);
buildr(u << 1, l, mid), buildr(u << 1 | 1, mid + 1, r);
}
void link(int u, int l, int r, ll L, ll R, int k, int d) {
if (R < L) return;
if (x[p[l]] > R || x[p[r]] < L) return;
if (x[p[l]] >= L && x[p[r]] <= R && (fl[k] < l || fl[k] > r)) {
e[fix[k] << 1 | d].push_back(u << 1 | 1);
e[u << 1].push_back(fix[k] << 1 | (d ^ 1));
return;
}
if (l == r) return;
int mid = (l + r) >> 1;
if (x[p[mid]] >= L) link(u << 1, l, mid, L, R, k, d);
if (x[p[mid + 1]] <= R) link(u << 1 | 1, mid + 1, r, L, R, k, d);
}
void linkr(int u, int l, int r, ll L, ll R, int k, int d) {
if (R < L) return;
if (y[pr[l]] > R || y[pr[r]] < L) return;
int ru = (l == r ? u : u + mxf);
if (y[pr[l]] >= L && y[pr[r]] <= R && (fr[k] < l || fr[k] > r)) {
e[fix[k] << 1 | d].push_back(ru << 1);
e[ru << 1 | 1].push_back(fix[k] << 1 | (d ^ 1));
return;
}
if (l == r) return;
int mid = (l + r) >> 1, ls = (u << 1), rs = (u << 1 | 1);
if (r - l == 1) ls = fix[pr[l]], rs = fix[pr[r]];
if (r - l == 2) rs = fix[pr[r]];
if (y[pr[mid]] >= L) linkr(ls, l, mid, L, R, k, d);
if (y[pr[mid + 1]] <= R) linkr(rs, mid + 1, r, L, R, k, d);
}

int check(ll d) {
for (int i = 1; i <= bd * 2 + 1; i++) {
dfn[i] = low[i] = bel[i] = 0;
e[i].clear(), ans[i] = 0, f[i] = 0;
}
for (int i = 1; i <= tot; i++) SCC[i].clear();
tot = cnt = 0; while (!sta.empty()) sta.pop();
build(1, 1, n), buildr(1, 1, n);
for (int i = 1; i <= n; i++) {
link(1, 1, n, x[i] - d + 1, x[i] + d - 1, i, 0);
link(1, 1, n, y[i] - d + 1, y[i] + d - 1, i, 1);
linkr(1, 1, n, x[i] - d + 1, x[i] + d - 1, i, 0);
linkr(1, 1, n, y[i] - d + 1, y[i] + d - 1, i, 1);
}
for (int i = 2; i <= bd * 2 + 1; i++) if (!dfn[i]) tarjan(i);
for (int i = 1; i <= bd; i++) if (bel[i << 1] == bel[i << 1 | 1]) return 0;
return 1;
}
bool cmpl(int _, int __) { return x[_] < x[__]; }
bool cmpr(int _, int __) { return y[_] < y[__]; }
int main() {
scanf("%d", &n);
for (int i = 1; i <= n; i++) scanf("%d%d", x + i, y + i), p[i] = pr[i] = i;
std::sort(p + 1, p + n + 1, cmpl), std::sort(pr + 1, pr + n + 1, cmpr);
for (int i = 1; i <= n; i++) fl[p[i]] = i, fr[pr[i]] = i;
ll l = 1, r = 1e15, ans = 0;
while (l <= r) {
ll mid = (l + r) >> 1;
if (check(mid)) ans = mid, l = mid + 1;
else r = mid - 1;
}
printf("%lld\n", ans);
}

#include <bits/stdc++.h>

using namespace std;
using ll = long long;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

vector<int> dx = {1,0,-1,0};
vector<int> dy = {0,1,0,-1};
vector<char> Alph = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};

long long INF = 1LL << 60;
long long MINF = -INF; 
int inf = 1 << 30;
int minf = -inf;
long long MOD = 1000000007;
long double pi = 3.1415926535897932384;

int main() {
long long N,M; cin >> N >> M;
if(N > 2 && M > 2) {
cout << (N-2) * (M-2) << endl;
return 0;
}
else{
if(N == 2 || M == 2){
cout << 0 << endl;
return 0;
}
else{
cout << max(max(N,M) - 2,1LL) << endl;
return 0;
}
}
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, n) for(int i = a; i < n; i++)
#define ll long long

int main(){
ll n, k; cin >> n >> k;
ll ans = 0;
if(k == 0) cout << n*n << endl;
else{
rep(i, 1, n+1){
if(i <= k) continue;
ans += (n/i)*(i-k);
ans += max((n%i)-k+1, 0LL);
// cout << ans << endl;
}
cout << ans << endl;
}
}
#include <bits/stdc++.h>

#include <atcoder/fenwicktree>
#include <atcoder/modint>
using namespace atcoder;
using namespace std;
#define REP(i, m, n) for (int64_t i = (int64_t)(m); i < (int64_t)(n); i++)
#define rep(i, n) REP(i, 0, n)
#define rep1(i, n) for (int64_t i = 1; i <= (int)(n); i++)
#define rrep(i, n) for (int64_t i = (n - 1); i >= 0; i--)
#define rrep1(i, n) for (int64_t i = (n); i > 0; i--)
#define all(v) v.begin(), v.end()
using vi = vector<int64_t>;
using vvi = vector<vi>;
using vb = vector<bool>;
using vvb = vector<vb>;
using vc = vector<char>;
using vvc = vector<vc>;
using vs = vector<string>;
using vvs = vector<vs>;
using vd = vector<long double>;
using vvd = vector<vd>;
using pii = pair<int64_t, int64_t>;
using vp = vector<pii>;
using vvp = vector<vp>;
using mint = modint1000000007;
using vm = vector<mint>;
using vvm = vector<vm>;
using mii = map<int64_t, int64_t>;
using pdi = pair<long double, int64_t>;
const int64_t INF = 3e18;
const vi dx = {0, 1}, dy = {1, 0};

template <typename T>
bool chmax(T &a, const T &b) {
if (a < b) {
a = b;
return true;
}
return false;
}

template <typename T>
bool chmin(T &a, const T &b) {
if (a > b) {
a = b;
return true;
}
return false;
}

int64_t to_int(char c) { return c - '0'; }

int main() {
int64_t n;
cin >> n;
vi a(n);
rep(i, n) cin >> a[i];

mii comp_a;
comp_a[0] = -1;
rep(i, n) comp_a[a[i]] = -1;

int64_t idx = 0;
for (auto [k, v] : comp_a) {
comp_a[k] = idx;
idx++;
}

vi ans(n, -1), before_maximum(n, 0);
int64_t maximum = 0;
rep(i, n) {
before_maximum[i] = maximum;
if (!chmax(maximum, a[i])) ans[i] = 0;
}

fenwick_tree<int64_t> fw_count(n + 1), fw_sum(n + 1);
rrep(i, n) {
fw_count.add(comp_a[a[i]], 1);
fw_sum.add(comp_a[a[i]], a[i]);

if (ans[i] == 0) continue;

ans[i] = (a[i] - before_maximum[i]) * fw_count.sum(comp_a[a[i]], n + 1) +
fw_sum.sum(comp_a[before_maximum[i]] + 1, comp_a[a[i]]) -
before_maximum[i] *
fw_count.sum(comp_a[before_maximum[i]] + 1, comp_a[a[i]]);
}

for (auto x : ans) cout << x << endl;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, n) for(int i = a; i < n; i++)
#define ll long long
#define pii pair<int, int>
#define MOD 1000000007

int main(){
int n; cin >> n;
string s1; cin >> s1;
s1 += "1";
bool f = true;
ll ans = 0, j = 0;
if(s1[0] == s1[1]){
ans = 6;
j = 2;
f = false;
}else{
ans = 3;
j = 1;
}
rep(i, j, n){
if(f){
ans = (ans*2)%MOD;
if(s1[i] == s1[i+1]){
i++;
f = false;
}
}else{
if(s1[i] == s1[i+1]){
ans = (ans*3)%MOD;
i++;
}else f = true;
}
}
cout << ans << endl;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

string s;
ll n;
ll ans;

void solve(ll idx, ll cur, ll sum) {
if(idx == n) {
ans += (sum) + cur;
return;
}

solve(idx + 1, cur * 10 + s[idx] - '0', sum);
solve(idx + 1, s[idx] - '0', sum + cur);
return;
}

int main() {
cin >> s;
n = s.size();
solve(1, s[0] - '0', 0);
cout << ans << '\n';
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ll,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
ll n,s;
cin>>n>>s;
ll l=1;
if(n==1) cout<<(n==s ? n+1 : -1)<<endl;
else if(n==2){
if(s==n) cout<<n+1<<endl;
else if(s==1) cout<<n<<endl;
else cout<<-1<<endl;
}
else if(n==3){
if(s==n) cout<<n+1<<endl;
else if(s==1) cout<<n<<endl;
else if(s==2) cout<<2<<endl;
else cout<<-1<<endl;
}
if(n<=3) return 0;
for(ll i=2;i*i<=n;i++){
l=i+1;
ll tmp=0,m=n;
while(m>0){
tmp+=m%i;
m/=i;
}
if(tmp==s){
cout<<i<<endl;
return 0;
}
}
for(ll i=n/l;i>=1;i--){
ll d=n/(i+1)+1,u=n/i;
if(n%u<=s-i&&s-i<=n%d&&(n-(s-i))%i==0){
cout<<(n-(s-i))/i<<endl;
return 0;
}
}
cout<<(n==s ? n+1 : -1)<<endl;
}
#include<bits/stdc++.h>
#define maxn 200005
#define int long long
#define put() putchar('\n')
using namespace std;
inline void read(int &x){
int f=1;x=0;char c=getchar();
while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
x*=f;
}
int n,a[maxn],sum[maxn];
inline int query(int L,int R){
int l=L,r=R,lmid,rmid;
while (l+2<r) {
lmid=(r-l)/3+l;rmid=(r-l)*2/3+l;
if (abs(sum[R]+sum[L-1]-2*sum[lmid])>abs(sum[R]+sum[L-1]-2*sum[rmid])) l=lmid;
else r=rmid;
}
int tmp1=abs(sum[R]+sum[L-1]-2*sum[l]),tmp2=abs(sum[R]+sum[L-1]-2*sum[l+1]),tmp3=abs(sum[R]+sum[L-1]-2*sum[r]);
if (tmp1<tmp2&&tmp1<tmp3) return l;
else if (tmp2<tmp1&&tmp2<tmp3) return l+1;
else return r;
}
signed main(void){
int i,ans=1e18;
read(n);
for (i=1;i<=n;i++) read(a[i]),sum[i]=sum[i-1]+a[i];
for (i=2;i<n;i++) {
int j=query(1,i);int k=query(i+1,n);
//		printf("[ %lld %lld %lld ] [ %lld %lld %lld ]\n",1ll,j,i,i+1,k,n);
int tmp1=sum[j],tmp2=sum[i]-sum[j],tmp3=sum[k]-sum[i],tmp4=sum[n]-sum[k];
ans=min(ans,max(tmp1,max(tmp2,max(tmp3,tmp4)))-min(tmp1,min(tmp2,min(tmp3,tmp4))));
//		printf("%lld %lld %lld\n",i,n,ans);
}
printf("%lld",ans);
return 0;
}
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define sz(a) (ll)a.size()
#define all(a) a.begin(),a.end()
#define rep(i,n) for(ll i=0;i<n;i++)
#define crep(i,x,n) for(ll i=x;i<n;i++)
#define drep(i,n) for(ll i=n-1;i>=0;i--)
#define vec(...) vector<__VA_ARGS__>
#define _34raRxL ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
typedef long long ll;
typedef long double ld;

void prll(){
cout<<"\n";
}

template<class te,class ...ti>
void prll(const te&v, const ti&...nv) { 
cout<<v;
if(sizeof...(nv)){
cout<<" ";
prll(nv...);
}
}

#define yare {cout<<"YES\n"; exit(0);}
#define nare {cout<<"-1\n"; exit(0);}

using pii=pair<ll,ll>;
using vi=vector<ll>;
using vll=vector<long long>;

signed main(){
_34raRxL;
ll n;
cin>>n;
vec(pii) a(n);
rep(i,n){
cin>>a[i].fi>>a[i].se;
}
ll ox=-1;
rep(i,n){
ll x=(abs(a[i].fi)%2)^(abs(a[i].se)%2);
if(ox!=-1 and ox!=x){
nare;
}
ox=x;
}
rep(i,n){
a[i]={a[i].fi-a[i].se,a[i].fi+a[i].se};
}
vi d;
drep(i,31){
d.pb((1ll<<i));
}
rep(i,(ox^1)){
d.pb(1);
}
vec(vi) pans;

auto getdir=[&](ll t0,ll t1)->ll{
if(t0==0 and t1==0){
// x ++ 
return 0;
}
if(t0==1 and t1==1){
// x --
return 1;
}
if(t0==1 and t1==0){
// y ++
return 2;
}
if(t0==0 and t1==1){
// y --
return 3;
}
return -1;
};

auto dirtochar=[&](ll dir)->char{
if(dir==0){
return 'R';
}else if(dir==1){
return 'L';
}else if(dir==2){
return 'U';
}else if(dir==3){
return 'D';
}
return -1;
};

auto f=[&](ll u,ll v){
ll rev0=0,rev1=0;
if(u<0){
rev0=1;
u=abs(u);
}
if(v<0){
rev1=1;
v=abs(v);
}
vi carry(2,0);
drep(i,31){
ll t0=0,t1=0;
if(carry[0]){
t0=1;
}
if(carry[1]){
t1=1;
}
t0^=rev0;
t1^=rev1;
carry[0]=((u>>i)&1)^1;
carry[1]=((v>>i)&1)^1;
pans.back().pb(getdir(t0,t1));
}
if(carry[0] and carry[1]){
ll dir=0;
if(rev0==0){
if(rev1==0) dir=1;
else dir=2;
}else{
if(rev1==1) dir=0;
else dir=3;
}
pans.back().pb(dir);
}
};

rep(i,n){
ll u=a[i].fi,v=a[i].se;
pans.pb({});
f(u,v);
}
prll(sz(d),"\n");
for(auto x : d){
prll(x,"");
}
prll();
for(auto vc : pans){
for(auto x : vc){
prll(dirtochar(x));
}
prll();
}
//	
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*

*/

int main(){
cincout();

ll N;
cin >> N;
map<ll, ll> M;
vector<ll> V;
rep(i, N){
ll a;
cin >> a;
++M[a];
if (M[a] == 2){
V.push_back(a);
M[a] -= 2;
}
}
sort(all(V), greater<ll>());
ll ans = 0;
if ((ll)V.size() > 1){
ans = V[0] * V[1];
}
cout << ans << endl;
}
// Exported by Exporter.exe

// Included from D.cpp
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define F first
#define S second
#define MP make_pair
#define MTP make_tuple
#define R Read
#define RD Read_Digit
#define RP Read_P
#define RS Read_String
#define RL Read_Loop
#define RLD Read_Loop_Digit
#define RLP Read_Loop_P
#define RLS Read_Loop_String
#ifdef ONLINE_JUDGE
#define Debug(...) ;
#define Debug_Array(n,x) ;
#define Debugln_Array(n,x) ;
#define NL ;
#else
#define Debug(...) {printf("(%s) = ",(#__VA_ARGS__)),_print(__VA_ARGS__),printf("\n");}
#define Debug_Array(n,x) {printf("%s :",(#x));for(int i=1;i<=n;i++)printf(" "),_print(x[i]);printf("\n");}
#define Debugln_Array(n,x) {for(int i=1;i<=n;i++){printf("%s",(#x));printf("[%d] = ", i);_print(x[i]);printf("\n");}}
#define NL {printf("\n");}
#endif
typedef long long int ll;
typedef unsigned long long int ull;

constexpr int kN = int(3E2 + 10);
// constexpr int kMod = 998244353;
// constexpr int kMod = int(1E9 + 7);
// constexpr int kInf = 0x3f3f3f3f;
// constexpr ll kInf = 0x3f3f3f3f3f3f3f3f;
// constexpr double kPi = acos(-1);
// constexpr double kEps = 1E-9;
// constexpr int dx[4] = {0, 0, 1, -1};
// constexpr int dy[4] = {1, -1, 0, 0};
// constexpr int dx[8] = {0, 0, 1, -1, 1, -1, 1, -1};
// constexpr int dy[8] = {1, -1, 1, -1, -1, 1, 0, 0};


// Included from C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp
bool Fast_IO_activated = false;
bool IOS_activated = false;
// --- Get ---
static inline char Get_Raw_Char() {
static bool pre = Fast_IO_activated = true;
static char buf[1 << 16], *p = buf, *end = buf;
if (p == end) {
if ((end = buf + fread(buf, 1, 1 << 16, stdin)) == buf) return '\0';
p = buf;
}
return *p++;
}

// --- Read ---
template <typename T> static inline void Read_P(T &n) {
static_assert(is_integral<T>::value, "Read_P requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
return ;
}

template <typename T> static inline void Read(T &n) {
static_assert(is_integral<T>::value, "Read requires an integral type");
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
if (neg) n = -n;
return ;
}

template <typename T> static inline void Read_Digit(T &n) {
static_assert(is_integral<T>::value, "Read_Digit requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
return ;
}

static inline void Read_String(string &s) {
s.clear();
char c = Get_Raw_Char();
while (c == ' ' or c == '\n') c = Get_Raw_Char();
while (c != ' ' and c != '\n') {
s += c;
c = Get_Raw_Char();
}
return ;
}

// --- Read multiple ---
template <typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read(n); return Read(Fargs...);}
template <typename T, typename... Targs> static inline void Read_Digit(T &n, Targs&... Fargs) {Read_Digit(n); return Read_Digit(Fargs...);}
template <typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P(n); return Read_P(Fargs...);}
template <typename... Targs> static inline void Read_String(string &s, Targs&... Fargs) {Read_String(s); return Read_String(Fargs...);}

// --- Read Loop ---
template <typename T> static inline void Read_Loop_i(int i, T *a) {return Read(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_i(int i, T *a, Targs*... Fargs) {Read(a[i]); return Read_Loop_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_Digit_i(int i, T *a) {return Read_Digit(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_Digit_i(int i, T *a, Targs*... Fargs) {Read_Digit(a[i]); return Read_Loop_Digit_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_Digit(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_Digit_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_P_i(int i, T *a) {return Read_P(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_P_i(int i, T *a, Targs*... Fargs) {Read_P(a[i]); return Read_Loop_P_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_P(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_P_i(i, Fargs...);}

static inline void Read_Loop_String_i(int i, string *a) {return Read_String(a[i]);}
template <typename... Targs> static inline void Read_Loop_String_i(int i, string *a, Targs*... Fargs) {Read_String(a[i]); return Read_Loop_String_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_String(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_String_i(i, Fargs...);}

// --- Float ---
template <int mul, typename T> static inline void Read(T &n) {
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;

if (neg) n = -n;
return ;
}

template <int mul, typename T> static inline void Read_P(T &n) {
char c;
while (!isdigit(c = Get_Raw_Char())) ;

n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;
return ;
}

template <int mul, typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read<mul>(n); return Read<mul>(Fargs...);}
template <int mul, typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P<mul>(n); return Read_P<mul>(Fargs...);}

// --- init ---
inline void IOS() {
IOS_activated = true;
ios::sync_with_stdio(false); cin.tie(0);
}
inline void Freopen(const char *in, const char *out) {freopen(in, "r", stdin); freopen(out, "w", stdout); return ;}

// --- Output ---
#if defined(__SIZEOF_INT128__)
void Print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
} 
#endif
// End of C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp
template <typename T, typename T1> void make_vector_inner(vector<T>& vec, T1 c) {return vec.push_back(T(c));}
template <typename T, typename T1, typename... Targs> void make_vector_inner(vector<T> &vec, T1 c, Targs... targs) {
vec.push_back(T(c));
return make_vector_inner(vec, targs...);
}
template <typename T, typename... Targs> vector<T> make_vector(Targs... targs) {
vector<T> vec;
make_vector_inner(vec, targs...);
return vec;
}

template <typename T> inline void sort(vector<T> &v) {return sort(v.begin(), v.end());}
template <typename T> inline void sort_r(vector<T> &v) {return sort(v.begin(), v.end(), greater<T>());}
inline void sort(string &s) {return sort(s.begin(), s.end());}
inline void sort_r(string &s) {return sort(s.begin(), s.end(), greater<char>());}

template <typename T> inline void reverse(vector<T> &v) {return reverse(v.begin(), v.end());}
inline void reverse(string &s) {return reverse(s.begin(), s.end());}

template <typename T> inline void Merge(vector<T> &a, vector<T> &b, vector<T> &c) {
if (c.size() < a.size() + b.size()) c.resize(a.size() + b.size());
merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());
return ;
}
template <typename T> inline void Concatanate(vector<T> &a, vector<T> &b, vector<T> &c) {
int a_size = int(a.size()), b_size = int(b.size());
c.resize(a_size + b_size);
for (int i = 0; i < a_size; i++) c[i] = a[i];
for (int i = 0; i < b_size; i++) c[i + a_size] = b[i];
return ;
}
template <typename T> inline void Append(vector<T> &lhs, vector<T> rhs) {
int lsz = int(lhs.size()), rsz = int(rhs.size());
lhs.reserve(lsz + rsz);
for (int i = 0; i < rsz; i++) lhs.push_back(rhs[i]);
return ;
}

template <typename T> inline void Erase(vector<T> &vec, T x) {
int sz = int(vec.size());
for (int i = 0; i < sz; i++) if (vec[i] == x) {
swap(vec[i], vec.back());
vec.pop_back();
break;
}
return ;
}

template <typename T> inline void Discrete(vector<T> &v) {sort(v); v.resize(unique(v.begin(), v.end()) - v.begin()); return ;}
template <typename T> inline int Discrete_Id(vector<T> &v, T x) {return lower_bound(v.begin(), v.end(), x) - v.begin();}

template <typename T> using PQ = priority_queue<T>;
template <typename T> using PQ_R = priority_queue<T, vector<T>, greater<T>>;

template <typename T> inline T ABS(T n) {return n >= 0 ? n : -n;}
template <typename T> __attribute__((target("bmi"))) inline T gcd(T a, T b) {
if (a < 0) a = -a;
if (b < 0) b = -b;
if (a == 0 || b == 0) return a + b;
int n = __builtin_ctzll(a);
int m = __builtin_ctzll(b);
a >>= n;
b >>= m;
while (a != b) {
int m = __builtin_ctzll(a - b);
bool f = a > b;
T c = f ? a : b;
b = f ? b : a;
a = (c - b) >> m;
}
return a << min(n, m);
}
template <typename T> inline T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <typename T, typename... Targs> inline T gcd(T a, T b, T c, Targs... args) {return gcd(a, gcd(b, c, args...));}
template <typename T, typename... Targs> inline T lcm(T a, T b, T c, Targs... args) {return lcm(a, lcm(b, c, args...));}
template <typename T, typename... Targs> inline T min(T a, T b, T c, Targs... args) {return min(a, min(b, c, args...));}
template <typename T, typename... Targs> inline T max(T a, T b, T c, Targs... args) {return max(a, max(b, c, args...));}
template <typename T, typename... Targs> inline void chmin(T &a, T b, Targs... args) {a = min(a, b, args...); return ;}
template <typename T, typename... Targs> inline void chmax(T &a, T b, Targs... args) {a = max(a, b, args...); return ;}

vector<int> Primes(int n) {
if (n == 1) return {};
// 2 ~ n
vector<int> primes;
vector<bool> isPrime(n + 1, true);

primes.reserve(n / __lg(n));

for (int i = 2; i <= n; i++) {
if (isPrime[i]) primes.push_back(i);
for (int j : primes) {
if (i * j > n) break;
isPrime[i * j] = false;
if (i % j == 0) break;
}
}
return primes;
}

template <typename T> vector<T> factors(T x) {
// maybe use factorize would be faster?
vector<T> ans;
for (T i = 1; i * i <= x; i++) if (x % i == 0) ans.push_back(i);

int id = int(ans.size()) - 1;
if (ans[id] * ans[id] == x) id--;
for (int i = id; i >= 0; i--) ans.push_back(x / ans[i]);

return ans;
}

int mex(vector<int> vec) {
int n = int(vec.size());
vector<bool> have(n, false);
for (int i : vec) if (i < n) have[i] = true;
for (int i = 0; i < n; i++) if (!have[i]) return i;
return n;
}

template <typename T> T SQ(T x) {return x * x;}

// Euclidean distance
template <typename T> T Dist2(pair<T, T> lhs, pair<T, T> rhs) {return SQ(lhs.F - rhs.F) + SQ(lhs.S - rhs.S);}
template <typename T> T Dist2(T x1, T y1, T x2, T y2) {return SQ(x1 - x2) + SQ(y1 - y2);}

// Manhattan distance
template <typename T> T Mdist(pair<T, T> lhs, pair<T, T> rhs) {return ABS(lhs.first - rhs.first) + ABS(lhs.second - rhs.second);}
template <typename T> T Mdist(T x1, T y1, T x2, T y2) {return ABS(x1 - x2) + ABS(y1 - y2);}

template <typename T> bool Adj(pair<T, T> lhs, pair<T, T> rhs) {return Mdist(lhs, rhs) == 1;}

template <typename T> T LUBound(T LB, T val, T UB) {return min(max(LB, val), UB);}

template <typename T, typename Comp> T Binary_Search(T L, T R, Comp f) {
// L good R bad
static_assert(is_integral<T>::value, "Binary_Search requires an integral type");
while (R - L > 1) {
T mid = (L + R) >> 1;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename Comp> double Binary_Search(double L, double R, Comp f, int loop = 30) {
for (int i = 1; i <= loop; i++) {
double mid = (L + R) / 2;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename T> T nearest_dist(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin() - val;
else if (val >= *prev(se.end())) return val - *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);
return min(*u - val, val - *v);
}
}

template <typename T> T nearest_elem(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin();
else if (val >= *prev(se.end())) return *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);

if (*u - val > val - *v) return *v;
else return *u;
}
}

namespace MR32 {
using ull = unsigned long long int;
using uint = unsigned int;
ull PowMod(ull a, ull b, ull kMod) {
ull ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(uint x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 3, a[3] = {2, 7, 61};
if (x < 8) return low[x];

uint t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
ull tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}

#ifdef __SIZEOF_INT128__
namespace MR64 {
using uint128 = unsigned __int128;
using ull = unsigned long long int;
using uint = unsigned int;
uint128 PowMod(uint128 a, uint128 b, uint128 kMod) {
uint128 ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(ull x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 7, a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
if (x < 8) return low[x];
ull t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
uint128 tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}
#endif

bool IsPrime(unsigned long long int x) {
#ifdef __SIZEOF_INT128__
if ((x >> 32) == 0) return MR32::IsPrime(x);
else return MR64::IsPrime(x);
#endif
return MR32::IsPrime(x);
}

#ifdef __SIZEOF_INT128__
uint64_t PollardRho(uint64_t x) {
static mt19937 rng;
if (!(x & 1)) return 2;
if (IsPrime(x)) return x;
int64_t a = rng() % (x - 2) + 2, b = a;
uint64_t c = rng() % (x - 1) + 1, d = 1;
while (d == 1) {
a = (__int128(a) * a + c) % x;
b = (__int128(b) * b + c) % x;
b = (__int128(b) * b + c) % x;
d = gcd(uint64_t(abs(a - b)), x);
if (d == x) return PollardRho(x);
}
return d;
}

template <typename T> vector<T> factorize(T x) {
if (x <= 1) return vector<T>();
T p = PollardRho(x);
if (p == x) return vector<T>(1, x);
vector<T> ans, lhs = factorize(p), rhs = factorize(x / p);
Merge(lhs, rhs, ans);
return ans;
}
#endif

// vec must be sorted
template <typename T> vector<pair<T, int>> Compress(vector<T> vec) {
if (vec.empty()) return {};

vector<pair<T, int>> ans;
int cnt = 1, sz = int(vec.size());
T lst = vec[0];
for (int i = 1; i < sz; i++) {
if (lst != vec[i]) {
ans.push_back(make_pair(lst, cnt));
lst = vec[i];
cnt = 1;
}
else cnt++;
}
ans.push_back(make_pair(lst, cnt));
return ans;
}

template <typename T> int Divisors(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

int ans = 1;
for (pair<T, int> i : fac) ans *= i.second + 1;

return ans;
}

template <typename T> T phi(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

T ans = 1;
for (pair<T, int> i : fac) {
ans *= i.first - 1;
for (int j = 1; j < i.second; j++) ans *= i.first;
}

return ans;
}
// End of C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp
template <typename T> void _print(vector<T> v) ;
void _print(bool x) {printf("%s", x ? "True" : "False");}
void _print(char x) {printf("%c", x);}
void _print(short x) {printf("%hd", x);}
void _print(unsigned short x) {printf("%hu", x);}
void _print(int x) {printf("%d", x);}
void _print(unsigned int x) {printf("%u", x);}
void _print(long int x) {printf("%ld", x);}
void _print(unsigned long int x) {printf("%lu", x);}
void _print(long long int x) {printf("%lld", x);}
void _print(unsigned long long int x) {printf("%llu", x);}
void _print(float x) {printf("%f", x);}
void _print(double x) {printf("%lf", x);}
void _print(long double x) {printf("%Lf", x);}
void _print(const char* c) {int n = strlen(c); for (int i = 0; i < n; i++) printf("%c", c[i]);}
void _print(string s) {for (char c : s) printf("%c", c);}
template <size_t _size> void _print(bitset<_size> bs) {for (int i = 0; i < _size; i++) printf("%d", bs[i] ? 1 : 0);}
#ifdef __SIZEOF_INT128__
void _print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
void _print(unsigned __int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
#endif
template <typename T1, typename T2> void _print(pair<T1, T2> x) {printf("("); _print(x.first); printf(", "); _print(x.second); printf(")");}
template <typename T1, typename T2, typename T3> void _print(tuple<T1, T2, T3> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(")");}
template <typename T1, typename T2, typename T3, typename T4> void _print(tuple<T1, T2, T3, T4> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(", "); _print(get<3>(x)); printf(")");}
template <typename T> void _print(vector<T> v) {
if (v.empty()) printf(" empty");
else {
bool first = true;
for (T i : v) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(set<T> s) {
if (s.empty()) printf(" empty");
else {
bool first = true;
for (T i : s) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(stack<T> s) {
if (s.empty()) printf(" empty");
else {
_print(s.top()); s.pop();
while (!s.empty()) {printf(", "); _print(s.top()); s.pop();}
}
}
template <typename T> void _print(queue<T> q) {
if (q.empty()) printf(" empty");
else {
_print(q.front()); q.pop();
while (!q.empty()) {printf(", "); _print(q.front()); q.pop();}
}
}
template <typename T> void _print(deque<T> dq) {
if (dq.empty()) printf(" empty");
else {
_print(dq.front()); dq.pop_front();
while (!dq.empty()) {printf(", "); _print(dq.front()); dq.pop_front();}
}
}
template <typename T1, typename T2, typename T3> void _print(priority_queue<T1, T2, T3> pq) {
if (pq.empty()) printf(" empty");
else {
_print(pq.top()); pq.pop();
while (!pq.empty()) {printf(", "); _print(pq.top()); pq.pop();}
}
}
template <typename T1, typename T2> void _print(map<T1, T2> m) {
if (m.empty()) printf(" empty");
else {
bool first = true;
for (pair<T1, T2> i : m) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}

template <typename T> void _print(T& x) {return x.out();}
template <typename T, typename... Targs> void _print(T x, Targs... Fargs) {_print(x); printf(", "); _print(Fargs...);}
// End of C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp

int a[kN][kN];

int main() {
int n; RP(n);
for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) RP(a[i][j]);

for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) for (int k = 1; k <= n; k++) if (a[i][j] + a[j][k] < a[i][k]) {
printf("-1\n");
return 0;
}

ll ans = 0;
for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {
bool can = false;
for (int k = 1; k <= n; k++) if (k != i and k != j and a[i][k] + a[k][j] == a[i][j]) can = true;
if (!can) ans += a[i][j];
}

printf("%lld\n", ans >> 1);


}
// End of D.cpp

/*       code by the cute PixelCat owo       */
/*   as cute as nacho neko (aka. my wife)!   */
//#pragma GCC optimize("O4,unroll-loops,no-stack-protector")
#include <bits/stdc++.h>
#define int LL  //__int128
#define double long double
using namespace std;
using LL = long long;
using uLL = unsigned long long;
using pii = pair<LL, LL>;

#define For(i, a, b) for (int i = a; i <= b; i++)
#define Fors(i, a, b, s) for (int i = a; i <= b; i += s)
#define Forr(i, a, b) for (int i = a; i >= b; i--)
#define F first
#define S second
#define L(id) (id * 2 + 1)
#define R(id) (id * 2 + 2)
#define LO(x) (x & (-x))

#define eb emplace_back
#define all(x) x.begin(), x.end()
#define sz(x) ((int)x.size())
#define mkp make_pair

#define MOD (LL)(998244353)
#define INF (LL)(9000'000'000'000'000'000)  // 9e18
#define EPS (1e-6)

#ifdef NYAOWO
#include "debug.hpp"
inline void USACO(const string &s) {
cerr << "USACO: " << s << "\n";
}
#else
#define debug(...)
inline void timer() {}
inline void USACO(const string &s) {
freopen((s + ".in").c_str(), "r", stdin);
freopen((s + ".out").c_str(), "w", stdout);
}
#endif

inline void NYA() {
ios::sync_with_stdio(false);
cin.tie(0);
}
inline int gcd(int a, int b) {
return __gcd(a, b);
}
inline int lcm(int a, int b) {
return a / gcd(a, b) * b;
}
int fpow(int b, int p, const int &mod) {
int ans = 1;
while (p) {
if (p & 1) ans = ans * b % mod;
p /= 2;
b = b * b % mod;
}
return ans;
}
int fpow(int b, int p) {
return fpow(b, p, MOD);
}
template <typename T>
inline void chmin(T &_a, const T &_b) {
if (_b < _a) _a = _b;
}
template <typename T>
inline void chmax(T &_a, const T &_b) {
if (_b > _a) _a = _b;
}
// mt19937_64 rng(
//     chrono::steady_clock::now().time_since_epoch().count());

int s1[100010];
int s2[100010];

void add(int l, int r, int vl) {
s2[l + 1]++;
s2[r + 1]--;
s1[l] += vl;
s1[r + 1] -= vl + r - l;
}

int32_t main() {
NYA();
// nyaacho >/////<
// miku sama bless me >/////<
int n, m;
cin >> n >> m;
int k;
cin >> k;
int tot = 0;
For(i, 2, n) {
int a;
cin >> a;
if (a >= k) {
add(k + 1, a, 0);
tot += a - k;
} else {
add(k + 1, m, 0);
add(1, a, m - k);
tot += m - k + a;
}
k = a;
}
For(i, 1, m) {
s2[i] += s2[i - 1];
s1[i] += s2[i];
}
int mx = 0;
For(i, 1, m) {
s1[i] += s1[i - 1];
chmax(mx, s1[i]);
}
cout << tot - mx << "\n";
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
int main()
{
long long n;
cin>>n;
long long sum=0;
for(int i=1;;i++)
{
sum+=i;
if(sum>=n)
{
cout<<i<<endl;
break;
}
}
return 0;
}
#include<iostream>
using namespace std;
typedef  long long ll;
int main()
{
ll x;
scanf("%lld",&x);
ll sum=0;
int i=1;
while(1)
{
sum+=i;
if(sum>=x)
{
printf("%d\n",i);
return 0;
}
i++;
}
}
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244353;
const int maxn = 2010;
int n, m, ans;
int c[maxn * 2][maxn];
int jie[maxn * 2];
signed main()
{
cin >> m >> n;
for (int i = 0; i <= n + m; i++)
c[i][i] = 1, c[i][0] = 1, c[i][1] = i;
for (int i = 1; i <= n + m; i++)
for (int j = 1; j <= m + n - 1; j++)
c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
jie[1] = 1;
for (int i = 2; i <= n + m; i++)
jie[i] = (jie[i - 1] * (i % mod)) % mod;
for (int i = 2; i <= m * 2; i++)
{
ans = 0;
int num;
if (i & 1)
num = min(i / 2, m - i / 2);//m-i/2是因为我当前的m凑不够那么多的点对了
else
num = min(i / 2, m - i / 2 + 1);//奇偶数不一样。。。
for (int k = 0; k <= num; k++)
{
ans = (ans + mod + c[num][k] * c[n - 2 * k + m - 1][m - 1] * (int)pow(-1, k % 2) % mod) % mod;
}
cout << ans << endl;
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;


const int INF = 0x3f3f3f3f;

const int maxn = 1e5 + 20;
const int maxm = 2e5 + 20;
int h[maxn], e[maxm], ne[maxm], pw[maxn], top; int d[maxn];
int ll[maxn], rr[maxn];
void add(int a, int b){
e[top] = b, ne[top] = h[a], h[a] = top++;
}

void dfs1(int u, int pa){

if(~pa) d[u] = d[pa] + 1;

for(int i = h[u]; ~i; i = ne[i]){
int v = e[i];
if(v == pa) continue;
dfs1(v, u);
}

}

void dfs2(int u, int pa){

if(~pw[u]) ll[u] = rr[u] = pw[u];
else ll[u] = -INF, rr[u] = INF;

for(int i = h[u]; ~i; i = ne[i]){
int v = e[i];
if(v == pa) continue;
dfs2(v, u);
ll[u] = max(ll[u], ll[v]-1);
rr[u] = min(rr[u], rr[v]+1);
}

}

void dfs3(int u, int pa){

if(pa!=-1 && pw[u]==-1){
int ret = ll[pa] + 1;
if(ret >= ll[u] && ret <= rr[u]) ll[u] = ret;
else ll[u] = ret-2;
}

for(int i = h[u]; ~i; i = ne[i]){
int v = e[i];
if(v == pa) continue;
dfs3(v, u);
}
}


signed main() {
ios::sync_with_stdio(false);
cin.tie(0);

memset(h, -1, sizeof h);
memset(pw, -1, sizeof pw);

int n; cin >> n;
for(int i = 1; i<=n-1; i++){
int a, b; cin >> a >> b;
add(a, b); add(b, a);
}


int k; cin >> k;
for(int i = 1; i<=k; i++){
int v, p; cin >> v >> p;
pw[v] = p;
}

d[1] = 0;
dfs1(1, -1);

int t = -1;
bool flag = true;
for(int i = 1; i<=n; i++){
if(pw[i] == -1) continue;
if(t == -1 || t == ((pw[i] ^ d[i])&1)){
t = (pw[i] ^ d[i])&1;
} else{
flag = false;
break;
}
}

dfs2(1, -1);


// for(int i = 1; i<=n; i++) cout << ll[i] << " " << rr[i] << endl;

for(int i = 1; i<=n; i++) {
if(ll[i] > rr[i]) flag = false;
}

dfs3(1, -1);

if(flag) {
cout << "Yes" << endl;
for(int i = 1; i<=n; i++){
cout << ll[i] << endl;
}
} else{
cout << "No" << endl;
}


return 0;
}
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define N 5003
using namespace std;
inline ll read(){
ll x=0,f=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
return x*f;
}
ll n,dp[N][N],f[N],g[N],Mod=1e9+7,sz[N],ans;
vector<ll>to[N];
void dfs(ll u,ll fa){
sz[u]=1;
dp[u][1]=1;
for(ll v:to[u]){
if(v==fa)continue;
dfs(v,u);
rep(i,1,sz[u]+sz[v])f[i]=0;
rep(i,1,sz[u]){
rep(j,1,sz[v]){
f[i]=(f[i]+Mod-dp[u][i]*dp[v][j]%Mod*g[j]%Mod)%Mod;
f[i+j]=(f[i+j]+dp[u][i]*dp[v][j]%Mod)%Mod;
}
}
sz[u]+=sz[v];
rep(i,1,sz[u])dp[u][i]=f[i];
}
}
int main(){
n=read();
rep(i,2,n){
ll x=read(),y=read();
to[x].push_back(y);
to[y].push_back(x);
}
g[0]=1;
rep(i,2,n)g[i]=g[i-2]*(i-1)%Mod;
dfs(1,0);
rep(i,1,n)ans=(ans+g[i]*dp[1][i]%Mod)%Mod;
cout<<ans;
return 0;
}
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
int n;
const int MAXN=5e5+5;
const int MOD=1e9+7;

ll qpow(ll a,ll b){
ll ans=1,base=a;
while(b){
if(b&1)(ans*=base)%=MOD;
(base*=base)%=MOD;
b>>=1;
}
return ans;
}
struct node{
int x,y,_ID;
}nd[MAXN];
vector<int>posx[MAXN],posy[MAXN];
vector<pair<int,int> >par;

struct fenpei{
node x;int point;
}fp[MAXN];
//nd 点 fenpei分配关系

struct edge{
int to,next,w;
}e[MAXN<<1];

int head[MAXN],cnt=0;
inline void add(int u,int v,int w){
assert(u!=v);
e[++cnt]=(edge){v,head[u],w},head[u]=cnt;
e[++cnt]=(edge){u,head[v],w},head[v]=cnt;
}

void init(){
scanf("%d",&n);
for(int i=1;i<=2*n;i++){
scanf("%d%d",&nd[i].x,&nd[i].y);
nd[i]._ID=i;
add(nd[i].x,nd[i].y+n,i);
posx[nd[i].x].push_back(i);
posy[nd[i].y].push_back(i);
}
}
//
int fa[MAXN],dfn[MAXN],loop[MAXN],top=0,_ID=0,is_a_looptree=1;
void dfs(int u,int father){//找基环树
dfn[u]=++_ID;
fa[u]=father;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if(dfn[v]){//在环上
if(dfn[v]<dfn[u])continue;//非最小
for(;v!=u;v=fa[v]){
loop[++top]=v;
}
loop[++top]=u;
return;
}
else{
dfs(v,u);
}
}
}

bool vis[MAXN];
int tedge=0,tpoint=0;
void givecolor(int u,int father){
vis[u]=1;tpoint++;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
tedge++;
if(vis[v])continue;
givecolor(v,u);
}
}

bool islooppoint[MAXN];
int fenpeicnt=0;
int dis[MAXN];//到环的距离

int getedge(int u,int father){
dis[u]=MOD;
fa[u]=father;
dfn[u]=++_ID;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if(dfn[v])continue;
dis[u]=min(dis[u],1+getedge(v,u));
}
if(islooppoint[u])return dis[u]=0;
return dis[u];
}

void getedge2(int u,int father){
dfn[u]=++_ID;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
dis[v]=min(dis[v],dis[u]+1);
if(v==father)continue;
if(dfn[v])continue;
getedge2(v,u);
}

for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
if(v==father)continue;
if((!islooppoint[v])||(!islooppoint[u])){
int now=dis[u]>dis[v]?u:v;
fp[++fenpeicnt]=(fenpei){nd[e[i].w],now};
}
}
}

int Size[MAXN],tree[MAXN],in[MAXN];
inline void add2(int u,int v){
tree[u]=v;in[v]++;
}

void build(){
for(int i=1;i<=fenpeicnt;i++)in[fp[i].x._ID]=0,Size[fp[i].x._ID]=1,tree[fp[i].x._ID]=0;
for(int i=1;i<=fenpeicnt;i++){//枚举哪个球分配给了机器人
//cout<<fp[i].point<<" -> "<<fp[i].x.x<<" "<<fp[i].x.y<<endl;
if(fp[i].point>n){//y相等的 且x较小的 全都连向node
for(auto t:posy[fp[i].point-n]){
if(nd[t].x<fp[i].x.x){
add2(t,fp[i].x._ID);
}
}
}
else{//x
for(auto t:posx[fp[i].point]){
if(nd[t].y<fp[i].x.y){
add2(t,fp[i].x._ID);
}
}
}
}
}
queue<int>q;
long long calc(int tot){//算内向树森林的答案 共连通块（tot）个点
long long ans=1;
for(int i=1;i<=tot;i++){
(ans*=i)%=MOD;
}
while(q.size())q.pop();
for(int i=1;i<=tot;i++)if(in[fp[i].x._ID]==0)q.push(fp[i].x._ID);
//cout<<q.Size()<<"inSize"<<endl;
while(q.size()){
int u=q.front();q.pop();
if(!tree[u])continue;
Size[tree[u]]+=Size[u];
in[tree[u]]--;
if(in[tree[u]]==0)q.push(tree[u]);
}
for(int i=1;i<=tot;i++){
ans*=qpow(Size[fp[i].x._ID],MOD-2);
ans%=MOD;
}
return ans;
}

void solve(){
/*由于每条边都要被选择，共有2n个点2n个边。且一个点只能对应一条边 
所连成的图只有是基环树森林的时候才合法 否则不合法
*/
for(int i=1;i<=2*n;i++){//遍历每个连通块 对基环树计算答案
if(!vis[i]){
memset(Size,0,sizeof(Size));
memset(tree,0,sizeof(tree));
memset(in,0,sizeof(in));
memset(dis,0,sizeof(dis));
memset(islooppoint,0,sizeof(islooppoint));
memset(fa,0,sizeof(fa));
memset(loop,0,sizeof(loop));
fenpeicnt=0;
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;top=0;
is_a_looptree=1;tpoint=0;tedge=0;
givecolor(i,0);
if(2*tpoint!=tedge)is_a_looptree=0;
if(is_a_looptree==0){
puts("0");exit(0);
}
dfs(i,0);

for(int i=1;i<=top;i++)islooppoint[loop[i]]=1;
//找到基环树后 对每条点分配一条边 从叶子节点开始选到自己father的边 非树边
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;
getedge(i,0);//分配树边
for(int i=1;i<=2*n;i++)dfn[i]=0;_ID=0;
getedge2(i,0);
int tmpcnt=fenpeicnt;
//cout<<tmpcnt<<" sas"<<endl;
//枚举环上的边 直接暴力好了
//for(int j=1;j<=top;j++){
//  cout<<loop[j]<<" huan "<<j<<endl;
//}
for(int j=1;j<=top;j++){
if(j!=top){
bool fx=0;
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[j+1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],loop[j]};
fx=1;
break;
}
}
assert(fx);
}
else{
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],loop[j]};
break;
}
}
}
}

//建内向树
build();
long long ans1=calc(fenpeicnt);//计算答案1
fenpeicnt=tmpcnt;
for(int j=1;j<=top;j++){
if(j!=top){
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[j+1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],v};
break;
}
}
}
else{
for(int ti=head[loop[j]];ti;ti=e[ti].next){
int v=e[ti].to;
if(v==loop[1]){
fp[++fenpeicnt]=(fenpei){nd[e[ti].w],v};
break;
}
}                   
}
}
build();
ll ans2=calc(fenpeicnt);
//cout<<ans2<<" "<<endl;
par.push_back(make_pair((ans1+ans2)%MOD,fenpeicnt));
for(int j=1;j<=fenpeicnt;j++)islooppoint[fp[j].point]=0;
}
}
}

ll fac[MAXN],inv[MAXN];
ll C(int n,int m){
return fac[n]*inv[n-m]%MOD*inv[m]%MOD;
}
void calc(){
ll ans=1;
fac[0]=inv[0]=1;
for(int i=1;i<=3*n;i++)fac[i]=fac[i-1]*i%MOD;
inv[3*n]=qpow(fac[3*n],MOD-2);
for(int i=3*n-1;i>=1;i--)inv[i]=inv[i+1]*(i+1)%MOD;
for(auto i:par){
ans*=i.first;ans%=MOD;
}
ll calced=0;
for(auto i:par){
//if(calced+i.second>2*n){puts("WA");exit(0);}
ans*=C(calced+i.second,i.second);
ans%=MOD;
calced+=i.second;
}
cout<<ans<<endl;//("%lld\n",ans);
}

int main(){
init();
solve();
calc();
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define re register
#define ll long long
#define get getchar()
#define in inline
in int read()
{
int t=0, x=1; char ch=get;
while(ch!='-' && (ch<'0' || ch>'9')) ch=get;
if(ch=='-') ch=get, x=-1;
while(ch<='9' && ch>='0') t=t*10+ch-'0', ch=get;
return t*x;
}
const int _=2e5+23;
const int inf=0x3f3f3f3f;
int n, tot, h[_], c[_], fa[_], A[_],B[_],m,w[_],cnt;
struct edge{
int to,ne;
}e[_<<1];
in void add(int x,int y) {	e[++tot].ne=h[x], e[tot].to=y, h[x]=tot; }
in int cmp(int a,int b) { return c[a]<c[b];}
in int find(int x){return x==fa[x] ? x : fa[x]=find(fa[x]);}
ll rt, f[_], sum[_];
in void dfs(int u,int fa)
{
//	cout<<u<<' '<<fa<<endl;
int flag=0;  sum[u]=B[u];
for(re int i=h[u];i;i=e[i].ne)
{
int v=e[i].to;
if(v==fa) continue;
dfs(v,u); sum[u]+=sum[v];
flag=1;
}
if(!flag) {f[u]=c[u]+B[u]; return;}
for(re int i=h[u];i;i=e[i].ne)
{
int v=e[i].to;
if(v==fa) continue;
f[u]=min(f[u], sum[u]-sum[v]+max(1ll*c[u],f[v]));
}
}
int id[_],vis[_];
vector<int > vc[_];
#define pb push_back
int main()
{
cnt=n=read(), m=read();
memset(f,0x3f,sizeof(f));
for(re int i=1;i<=n;++i)
{
A[i]=read(), B[i]=read();
c[i]=max(A[i]-B[i],0); id[i]=fa[i]=i;
}
for(re int i=1;i<=m;++i)
{
int x=read(), y=read();
vc[x].pb(y), vc[y].pb(x);
}
sort(id+1,id+n+1,cmp);
for(re int i=1;i<=n;++i)
{
int u=id[i];// cout<<u<<":: \n";
for(re int j=0;j<vc[u].size();++j)
{
if(!vis[vc[u][j]]) continue;
int x=find(u), y=find(vc[u][j]);
if(x==y) continue;
fa[y]=x; add(u,y);
//			cout<<u<<' '<<y<<endl;
}
vis[u]=1;
}
rt=id[n]; dfs(rt,0);
cout<<f[rt]<<endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;

const int N=16;
const int S=1<<N;

int n,m,g[N][N],f[N][S],dp[N][S],sum;

int main(){
memset(g,-1,sizeof(g));
scanf("%d%d",&n,&m);
int lim=(1<<n)-1;
for(int i=1;i<=m;i++){
int u,v,w;
scanf("%d%d%d",&u,&v,&w);
g[u][v]=g[v][u]=w;
sum+=w;
}
for(int s=0;s<=lim;s++){
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
int x=(1<<j-1);
if(!(s&x)||g[i][j]<0)continue;
f[i][s]+=g[i][j];
}
}
}
for(int s=0;s<=lim;s++){
int res=0;
for(int i=1;i<=n;i++){
for(int j=i+1;j<=n;j++){
int x=(1<<i-1),y=(1<<j-1);
if(!(s&x)||!(s&y)||g[i][j]<0)continue;
res+=g[i][j];
}
}
for(int i=1;i<=n;i++)f[i][s]+=res;
}
memset(dp,-1,sizeof(dp));
dp[1][1]=0;
for(int s=0;s<=lim;s++){
for(int i=1;i<=n;i++){
if(dp[i][s]<0)continue;
for(int j=1;j<=n;j++){
int x=(1<<j-1);
if(s&x||g[i][j]<0)continue;
dp[j][s|x]=max(dp[j][s|x],dp[i][s]+g[i][j]);
}
for(int t=(lim^s);t;t=((t-1)&(lim^s)))dp[i][s|t]=max(dp[i][s|t],dp[i][s]+f[i][t]);
}
}
printf("%d",sum-dp[n][lim]);
return 0;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
int dp[2020][2020][2], a[2020], n;
int go(int pos, int lst, int tk){
if(pos == n){
return abs(a[pos] - a[lst]);
}
int &e = dp[pos][lst][tk];
if(e == -1){
if(tk){
e = go(pos + 1, pos, 1-tk);
e = min(e, go(pos + 1, lst, tk));
}	
else{
e = go(pos + 1, pos, 1-tk);
e = max(e, go(pos + 1, lst, tk));
}
}
return e;
}
void solve(){ 
int z, w; cin>>n>>z>>w;
a[0] = w;
mem(dp, -1);
for(int i=1; i<=n; i++)
cin>>a[i];
cout<<go(1, 0, 0)<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>
using namespace std;
const long long MOD1 = 1000000007;
const long long MOD2 = 998244353;
typedef long long ll;
//typedef int ll;
typedef pair<ll, ll> P;
const long long INF = 1e9;
template <typename T>
void input_arr(vector<T>& A, ll N) {
for (ll i = 0; i < N; i++) {
cin >> A[i];
}
}
template <typename T, typename Q>
void input_arr(vector<pair<T, Q>>& A, ll N) {
for (ll i = 0; i < N; i++) {
cin >> A[i].first >> A[i].second;
}
}
template <typename T>
void input_arr(vector<vector<T>>& A, ll H, ll W) {
for (ll i = 0; i < H; i++) {
for (ll j = 0; j < W; j++) {
cin >> A[i][j];
}
}
}
int main() {
ll N; cin >> N;
vector<ll>A(N); input_arr(A, N);
ll ans = 0, ans2 = 0;
ll sum = 0;
for (ll i = 0; i < N; i++) {
sum += A[i];
if (i % 2 == 0) {
if (sum > 0) continue;
ans += 1 - sum;
sum = 1;
}
else {
if (sum < 0) continue;
ans += sum + 1;
sum = -1;
}
}
sum = 0;
for (ll i = 0; i < N; i++) {
sum += A[i];
if (i % 2 == 0) {
if (sum < 0) continue;
ans2 += sum + 1;
sum = -1;
}
else {
if (sum > 0) continue;
ans2 += 1 - sum;
sum = 1;
}
}
cout << min(ans, ans2) << endl;
}
#include<bits/stdc++.h>
using namespace std;

#define all(x) x.begin(),x.end()
#define debug(x) cerr<<#x<<' '<<x<<endl
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
/* --------------- fast io --------------- */ // begin
namespace Fread{
const int SIZE= 1 << 16;
char buf[SIZE],*S,*T;
inline char getchar(){if(S==T){T=(S=buf)+
fread(buf,1,SIZE,stdin);if(S==T)return'\n';}return *S++;}
} // namespace Fread
namespace Fwrite {
const int SIZE= 1 << 16;
char buf[SIZE],*S=buf,*T=buf+SIZE;
inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
inline void putchar(char c){*S++=c;if(S==T)flush();}
struct NTR{~NTR(){flush();}}ztr;
} // namespace Fwrite
#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif
namespace Fastio{
struct Reader{
template<typename T>Reader&operator>>(T&x){
char c=getchar();short f=1;
while(c<'0'||c>'9'){if(c=='-')f*=-1;c=getchar();}
x=0;while(c>='0'&&c<='9'){
x=(x<<1)+(x<<3)+(c^48);
c=getchar();
}x*=f;return *this;
}
Reader&operator>>(double&x){
char c=getchar();short f=1,s=0;x=0;double t=0;
while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}
while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();
if(c=='.')c=getchar();else return x*=f,*this;
while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();
while(s--)t/=10.0;x=(x+t)*f;return*this;
}
Reader&operator>>(long double&x){
char c=getchar();short f=1,s=0;x=0;long double t=0;
while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}
while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();
if(c=='.')c=getchar();else return x*=f,*this;
while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();
while(s--)t/=10.0;x=(x+t)*f;return*this;
}
Reader&operator>>(__float128&x){
char c=getchar();short f=1,s=0;x=0;__float128 t=0;
while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}
while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();
if(c=='.')c=getchar();else return x*=f,*this;
while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();
while(s--)t/=10.0;x=(x+t)*f;return*this;
}
Reader&operator>>(char&c){
c=getchar();while(c=='\n'||c==' '||c=='\r')c=getchar();
return *this;
}
Reader&operator>>(char*str){
int len=0;char c=getchar();
while(c=='\n'||c==' '||c=='\r')c=getchar();
while(c!='\n'&&c!=' '&&c!='\r')str[len++]=c,c=getchar();
str[len]='\0';return*this;
}
Reader&operator>>(string&str){
char c=getchar();str.clear();
while(c=='\n'||c==' '||c=='\r')c=getchar();
while(c!='\n'&&c!=' '&&c!='\r')str.push_back(c),c=getchar();
return*this;
}
Reader(){}
}cin;
const char endl='\n';
struct Writer{
const int Setprecision=6;
typedef int mxdouble;
template<typename T>Writer&operator<<(T x){
if(x==0)return putchar('0'),*this;
if(x<0)putchar('-'),x=-x;
static int sta[45];int top=0;
while(x)sta[++top]=x%10,x/=10;
while(top)putchar(sta[top]+'0'),--top;
return*this;
}
Writer&operator<<(double x){
if(x<0)putchar('-'),x=-x;
mxdouble _=x;x-=(double)_;static int sta[45];int top=0;
while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');
while(top)putchar(sta[top]+'0'),--top;putchar('.');
for(int i=0;i<Setprecision;i++)x*=10;
_=x;while(_)sta[++top]=_%10,_/=10;
for(int i=0;i<Setprecision-top;i++)putchar('0');
while(top)putchar(sta[top]+'0'),--top;
return*this;
}
Writer&operator<<(long double x){
if(x<0)putchar('-'),x=-x;
mxdouble _=x;x-=(long double)_;static int sta[45];int top=0;
while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');
while(top)putchar(sta[top]+'0'),--top;putchar('.');
for(int i=0;i<Setprecision;i++)x*=10;
_=x;while(_)sta[++top]=_%10,_/=10;
for(int i=0;i<Setprecision-top;i++)putchar('0');
while(top)putchar(sta[top]+'0'),--top;
return*this;
}
Writer&operator<<(__float128 x){
if(x<0)putchar('-'),x=-x;
mxdouble _=x;x-=(__float128)_;static int sta[45];int top=0;
while(_)sta[++top]=_%10,_/=10;if(!top)putchar('0');
while(top)putchar(sta[top]+'0'),--top;putchar('.');
for(int i=0;i<Setprecision;i++)x*=10;
_=x;while(_)sta[++top]=_%10,_/=10;
for(int i=0;i<Setprecision-top;i++)putchar('0');
while(top)putchar(sta[top]+'0'),--top;
return*this;
}
Writer&operator<<(char c){putchar(c);return*this;}
Writer& operator<<(char*str){
int cur=0;while(str[cur])putchar(str[cur++]);
return *this;
}
Writer&operator<<(const char*str){
int cur=0;while(str[cur])putchar(str[cur++]);
return*this;
}
Writer&operator<<(string str){
int st=0,ed=str.size();
while(st<ed)putchar(str[st++]);
return*this;
}
Writer(){}
}cout;
} // namespace Fastio
#define cin Fastio :: cin
#define cout Fastio :: cout
#define endl Fastio :: endl
/* --------------- fast io --------------- */ // end

#define maxn 100010
int n;
char s[maxn];
signed main(){
cin>>s+1;
n=strlen(s+1);
int i=1;
while(i<=n){
if(s[i]=='d'){
if(!(s[i+1]=='r'&&s[i+2]=='e'&&s[i+3]=='a'&&s[i+4]=='m')){
cout<<"NO"<<endl;
return 0;
}else{
if(s[i+5]=='e'&&s[i+6]=='r'){
if(s[i+7]=='a')i+=5;
else i+=7;
}else i+=5;
}
}else if(s[i]=='e'){
if(!(s[i+1]=='r'&&s[i+2]=='a'&&s[i+3]=='s'&&s[i+4]=='e')){
cout<<"NO"<<endl;
return 0;
}else{
if(s[i+5]=='r')i+=6;
else i+=5;
}
}else{
cout<<"NO"<<endl;
return 0;
}
}
cout<<"YES"<<endl;
}

#include <bits/stdc++.h>

using namespace std;

template<typename T> inline void cmin(T &x, T y) {x = (x < y ? x : y);}
template<typename T> inline void cmax(T &x, T y) {x = (x > y ? x : y);}

#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;i--)

#define dbg(x) cerr << #x " = " << x << '\n'

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
int x = 0, f = 1;
char ch = gc;
while(!isdigit(ch)) {
if(ch == '-') f = 0;
ch = gc;
}
while(isdigit(ch)) {
x = (x << 1) + (x << 3) + (ch ^ 48);
ch = gc;
}
return f ? x : -x;
}

using ll = long long;

const int N = 18;
const int mod = 1e9 + 7;

inline void chk(int &x) {x -= mod, x += x >> 31 & mod;}
inline int mll(int x, int y) {return (ll) x * y % mod;}
inline int add(int x, int y) {return chk(x += y), x ;}
inline int del(int x, int y) {return add(x, mod - y);}

inline int ksm(int x, int y) {
int ret = 1;
for(; y; y >>= 1, x = mll(x, x))
if(y & 1) ret = mll(ret, x);
return ret;
}

int fc[1 << N], fv[1 << N], inv[1 << N];
inline void pref(const int lim) {
fc[0] = 1;
FOR(i, 1, lim) fc[i] = mll(fc[i - 1], i);
fv[lim] = ksm(fc[lim], mod - 2);
ROF(i, lim, 1) fv[i - 1] = mll(fv[i], i);
FOR(i, 1, lim) inv[i] = mll(fv[i], fc[i - 1]);
return ;
}

inline int C(int n, int m) {
if(n < m) return 0;
return mll(fc[n], mll(fv[m], fv[n - m]));
}

int n, m;
int a[N], dp[1 << N];

inline void input() {
n = rd, m = rd;
FOR(i, 1, m) a[i] = rd;
//    sort(a + 1, a + 1 + m);
return ;
}


inline void work() {
dp[0] = 1;
int len = (1 << n);
pref(len);
//    dbg(fc[len]);
ROF(i, m, 1) ROF(j, len - 1, 0) FOR(k, 0, n - 1) {
if(j & (1 << k)) continue;
int tem = mll(dp[j], C(len - j - a[i], (1 << k) - 1));
tem = mll(tem, fc[1 << k]);
chk(dp[j | (1 << k)] += tem);
}
int ans = 0;
FOR(i, 0, len - 1) {
int num = 0;
FOR(k, 0, n - 1) if(i & (1 << k)) num++;
int tem = mll((num & 1 ? mod - 1 : 1), dp[i]);
tem = mll(tem, fc[len - i - 1]);
chk(ans += tem);
}
cout << mll(ans, len) << '\n';
return ;
}

inline void solve() {
input();
work();
return ;
}

#define local freopen("in.txt","r",stdin);freopen("out.txt","w",stdout)

int main() {
#ifdef LOCAL
local;
#endif
solve();
#ifdef LOCAL
fprintf(stderr, "%lf\n", (double) clock() / CLOCKS_PER_SEC);
#endif
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define rep(i, n) for(int i=0; i<(n); i++)

int main(){
ll n, m;
cin >> n >> m;
ll a = m/2;
ll ans;
if(a < n){
ans = a;
}else{
m -= 2*n;
m /= 4;
ans = n+m;  
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif

int fir,sec;
int f,s;
int val(int n,int a,int b) {
if(n%2!=0){
fir=sec=(n+1)/2;
if(fir>=a) fir++;
if(sec>=b) sec++;
return fir*sec;
}else {
fir = sec = n / 2;
sec++;
f = fir, s = sec;
if (f >= a) f++;
if (s >= b) s++;
return f * s;
}
}


void solve() {
w(q) {
int a, b;
cin >> a >> b;
if (a > b) swap(a, b);
int l = 0, r = 1;
while ((r / 2) * (r / 2) < a * b) {
r *= 2;
}
while (l + 1 < r) {
int m = (l + r) / 2;
if (val(m, a, b) < a * b) {
l = m;
} else {
r = m;
}
}
cout << l << endl;
}
}

int32_t main() {
nitin;

solve();
}
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
using namespace std;
vector<int> v;
map<int, int> m;
int main()
{
int n;
scanf("%d", &n);
for (int i = 0; i < n; i++) {
int t;
scanf("%d", &t);
m[t]++;
v.push_back(t);
}
long long sum = 0;
sort(v.begin(), v.end());
if (v[0] > m[v[0]]) sum += m[v[0]];
else sum += m[v[0]] - v[0];
for (int i = 1; i < n; i++) {
//cout << m[v[i]] <<"  " << sum << endl;
if (v[i] != v[i - 1]) {
if (v[i] > m[v[i]]) sum += m[v[i]];
else sum += m[v[i]] - v[i];
}
}
printf("%lld\n", sum);
return 0;
}
#include<bits/stdc++.h>
#include <iterator>
#include <iostream>
#include <numeric>
#include <math.h>
#define ll long long
#define ull long
#define mpa make_pair
#define pb push_back
#define ff first
#define pii pair<ll,ll>
#define dd long double
#define trace(x) cerr << #x << " : " << x << endl
#define ss second
#define boost ios_base::sync_with_stdio(0)
#define forp(i,a,b) for(ll i=a;i<=b;i++)
#define rep(i,n)    for(ll i=0;i<n;++i)
#define ren(i,n)    for(ll i=n-1;i>=0;i--)
#define forn(i,a,b) for(ll i=a;i>=b;i--)
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end();
#define sc(x) scanf("%lld",&x)
#define clr(x,val) memset(x,val,sizeof(x))
#define pr(x) printf("%lld\n",x) 
#define gc getchar
#define pdd pair<dd,dd>
#define prec(x) cout<<fixed<<setprecision(x)
#define fre freopen("input.txt","r",stdin),freopen("output.txt","w",stdout)
#define arr array 
using namespace std;
ll mod=1e9+7;

void solve(ll tc){
ll n;
map<ll,ll> help;
cin>>n;


for(ll i=1;i<=n;i++){
ll v=i;
for(ll j=2;j*j<=v;j++){
if(v%j==0){
while(v%j==0){
help[j]++;
v/=j;
}
}
}
if(v>1)help[v]++;
}    

ll ans=1;
for(auto it:help){
ans=ans*(it.ss+1);
ans%=mod;
}
cout<<ans<<endl;


}
int main(){
boost;

//pre_cum();
//prec(20);
//fre;






ll t=1;
ll tc=1;
//cin>>t;

while(t--){
solve(tc);
tc++;
}

return 0;


}

#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
int p[5], tol;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (int i = 0; i < tol; i ++) {
add(p[i]);
}
tol = 0;
}

LL solve(int x, int y, int id) {
LL res = 1, k;
k = c[x][1] * b[0] + c[x][4] * b[1] + c[y][id + 3] * b[2] + c[y][id + 2] * b[3];
res = res * cnt[k];
if (res == 0) return 0;
p[tol ++] = (mp[k].begin()->first);
del(p[0]);
k = c[x][4] * b[0] + c[x][3] * b[1] + c[y][id + 4] * b[2] + c[y][id + 3] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[1]);
k = c[x][3] * b[0] + c[x][2] * b[1] + c[y][id + 1] * b[2] + c[y][id + 4] * b[3];
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p[tol ++] = (mp[k].begin()->first);
del(p[2]);
k = c[x][2] * b[0] + c[x][1] * b[1] + c[y][id + 2] * b[2] + c[y][id + 1] * b[3];
res = res * cnt[k];
restore();
return res;
}

inline int read() {
char c = getchar();
int num = 0, f = 1;
for (; c < '0' || c > '9'; c = getchar()) if (c == '-') f = -f;
for (; c >= '0' && c <= '9'; c = getchar()) num = num * 10 - '0' + c;
return num * f;
}

int main() {
n = read();
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
c[i][j] = read();
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, k);
}
add(j);
}
add(i);
}
printf("%lld\n", ans / 6);
return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const ll maxn = 2e5 + 5;
const ll maxm = 1e3 + 5;
namespace IO{
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE],*oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc(){
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread(){}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls){
T1 __ = 0, ___ = 1;
char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do{
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
inline void flush(){
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x){
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite(){}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls){
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
struct Flusher_{~Flusher_(){flush();}}io_flusher;
}
namespace rndom{
mt19937 mtrnd(std::chrono::system_clock::now().time_since_epoch().count());
ll rnd(ll x){return mtrnd() % x;}
ll rndrg(ll l, ll r){return l + rnd(r - l + 1);}
template<class T>
void rndshfl(T *pt, T *ed){
ll len = ed - pt;
for(int i = 0;i < len;i++) swap(pt[i], pt[rnd(len)]);
return ;
}
}
using namespace IO; using namespace rndom;
const int mod = 1e9 + 7;
int n, k;
char s[maxn];
int a[maxn];
int p0[maxn], p1[maxn];
int pl[maxn], pr[maxn];
int l[maxn], r[maxn];
int pos[maxn], tot = 0;
void upd(int &x, int y){
return x = x + y >= mod ? x + y - mod : x + y, void();
}
int f[3005][3005];
int sum[3005][3005];
int main(){
ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
cin >> n >> k >> (s + 1);
for(int i = 1;i <= n;i++){
a[i] = s[i] - '0'; p0[i] = p1[i] = a[i]; l[i] = r[i] = i;
}
for(int i = 1;i <= k;i++){
cin >> pl[i] >> pr[i]; int cnt = 0;
for(int j = pl[i];j <= pr[i];j++) cnt += p0[j];
for(int j = pl[i];j < pl[i] + cnt;j++) p0[j] = 1; 
for(int j = pl[i] + cnt;j <= pr[i];j++) p0[j] = 0;
cnt = 0;
for(int j = pl[i];j <= pr[i];j++) cnt += p1[j];
for(int j = pr[i] - cnt + 1;j <= pr[i];j++) p1[j] = 1;
for(int j = pl[i];j <= pr[i] - cnt;j++) p1[j] = 0; 
}
for(int i = 1;i <= n;i++){
if(p0[i] == 1) l[++tot] = i;
}
tot = 0;
for(int i = 1;i <= n;i++){
if(p1[i] == 1) r[++tot] = i;
}
f[0][0] = 1; for(int i = 0;i <= n;i++) sum[0][i] = 1;
for(int i = 1;i <= tot;i++){
for(int j = l[i];j <= r[i];j++){
upd(f[i][j], sum[i - 1][j - 1]);
}
for(int j = 1;j <= n;j++){
sum[i][j] = sum[i][j - 1]; upd(sum[i][j], f[i][j]);
}
}
int ans = 0;
for(int i = 1;i <= n;i++) upd(ans, f[tot][i]);
cout << ans << endl; return 0;
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

struct Node {
int x, y, id;

bool operator < (const Node &oth) const {
return x < oth.x;
}
} a[N], b[N];

int n, ida, idb, dis;
int idcnt;
bool vis[N];
map<int, int> id;
set<Node> ss[N << 1], sd[N << 1];
queue<int> q;
map<int, int> cnt1, cnt2;
map<pii, bool> has;

void Push(int x) {
if(vis[x]) return ;
vis[x] = 1;
q.push(x);
ss[id[a[x].x + a[x].y]].erase(a[x]);
sd[id[a[x].x - a[x].y]].erase(a[x]);
}

ll calc() {
ll ret = 0;
int cnt = 0;
rep(i, 1, n) if(vis[i]) b[++cnt] = a[i];
sort(b + 1, b + cnt + 1);
int nw = 1;
rep(i, 1, cnt) {
while(b[nw].x < b[i].x - dis) --cnt1[b[nw].x + b[nw].y], --cnt2[b[nw].x - b[nw].y], ++nw;
ret += cnt1[b[i].x + b[i].y - dis] + cnt2[b[i].x - b[i].y - dis];
++cnt1[b[i].x + b[i].y]; ++cnt2[b[i].x - b[i].y];
if(has[mp(b[i].x - dis, b[i].y)]) --ret;
has[mp(b[i].x, b[i].y)] = 1;
}
return ret;
}

int main() {
qread(n, ida, idb);
rep(i, 1, n) {
qread(a[i].x, a[i].y);
a[i].id = i;
if(!id[a[i].x + a[i].y]) {
id[a[i].x + a[i].y] = ++idcnt;
ss[idcnt].insert(a[i]);
}
else ss[id[a[i].x + a[i].y]].insert(a[i]);

if(!id[a[i].x - a[i].y]) {
id[a[i].x - a[i].y] = ++idcnt;
sd[idcnt].insert(a[i]);
} 
else sd[id[a[i].x - a[i].y]].insert(a[i]);
}
dis = abs(a[ida].x - a[idb].x) + abs(a[ida].y - a[idb].y);
Push(ida), Push(idb);
set<Node> It it; int nw;
while(!q.empty()) {
int u = q.front();
q.pop();
// cout << "now : " << u << endl;

// 1
nw = id[a[u].x + a[u].y + dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].end()) {
// cout << "1 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 3
nw = id[a[u].x + a[u].y - dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].begin()) {
--it;
// cout << "3 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 2
nw = id[a[u].x - a[u].y - dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].begin()) {
--it;
// cout << "2 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// 4
nw = id[a[u].x - a[u].y + dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].end()) {
// cout << "4 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// cout << endl;
}
// rep(i, 1, n) cout << vis[i] << " \n"[i == n];
cout << calc() << endl;
return 0;
}
/// TcThang
#include  <bits/stdc++.h>
#define taskname  "choco"
#define fto(i,a,b) for (int i=a; i<=b; ++i)
#define fdo(i,a,b) for (int i=a; i>=b; --i)
#define X first
#define Y second
#define pb push_back
#define mp make_pair
#define ep emplace_back
#define EL cout<<"\n"
#define sz(A) (int) A.size()
#define fillchar(a,x) memset(a, x, sizeof (a))
using   namespace   std;
typedef long long ll;
typedef pair<int,int> ii;
typedef unsigned long long ull;
const   int maxN=1e5+5;
const   int oo=INT_MAX;
int     h,w,rem;
ll      A1,A2,A3,a2,a3,ans;
//-------------------------
void    input()
{
#ifndef ONLINE_JUDGE
freopen(taskname".inp","r",stdin);
freopen(taskname".out","w",stdout);
#endif // ONLINE_JUDGE
ios::sync_with_stdio(0);
cin.tie(0); cout.tie(0);
cin>>h>>w;
}
//-------------------------
void    solve()
{
ans=oo;
fto(i,1,h-1)
{
A1 = 1ll*i*w;
rem = max(i, h-i);
if (rem >= 2)
{
a2 = 1ll*w*(rem/2);
a3 = 1ll*w*(rem - rem/2);
ans = min(ans, max({A1, a2, a3}) - min({A1, a2, a3}));
}
A2 = 1ll*(w/2)*rem;
A3 = 1ll*w*rem - A2;
ans = min(ans, max({A1, A2, A3}) - min({A1, A2, A3}));
}
fto(i,1,w-1)
{
A1 = 1ll*i*h;
rem = max(i, w-i);
if (rem >= 2)
{
a2 = 1ll*h*(rem/2);
a3 = 1ll*h*(rem - rem/2);
ans = min(ans, max({A1, a2, a3}) - min({A1, a2, a3}));
}
A2 = 1ll*(h/2)*rem;
A3 = 1ll*h*rem - A2;
ans = min(ans, max({A1, A2, A3}) - min({A1, A2, A3}));
}
cout<<ans;
}
//-------------------------
int     main()
{
input();
solve();
}

#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <cstdlib>
#include <queue>
#include <deque>
#include <tuple>
#include <cassert>
#include <cstring>
#include <unordered_set>
#include <unordered_map>
#include <bitset>
#include <stack>
#include <complex>
#include <random>
#include <chrono>
#include <list>

using namespace std;

#define fi first
#define se second
#define int long long
#define double long double
#define fastio cout.tie(nullptr); cin.tie(nullptr); ios_base::sync_with_stdio(false)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define gcd __gcd
#define precision(x) cout << setprecision((x))
#define umap unordered_map
#define uset unordered_set
// #pragma GCC optimize("Ofast,unroll-loops")
// #pragma GCC target("avx,avx2,fma,sse4")
// #pragma comment(linker,"/STACK:128777216")

const double pi = 3.14159265358979323846264338327950288419716939937510;
const double eps = 1e-8;
const int inf = 1e12;
const int MOD = 1e9 + 7;  // 998244353
const int maxN = 2e5 + 9;

template<typename T, typename S>
istream &operator>>(istream &in, pair<T, S> &m) {
in >> m.fi >> m.se;
return in;
}

template<typename T>
istream &operator>>(istream &in, vector<T> &m) {
for (int i = 0, l = m.size(); i < l; ++i)in >> m[i];
return in;
}

template<typename T, typename S>
ostream &operator<<(ostream &out, pair<T, S> &m) {
out << m.fi << ' ' << m.se;
return out;
}

template<typename T>
ostream &operator<<(ostream &out, vector<T> &m) {
for (int i = 0, l = m.size(); i < l; ++i)cout << m[i] << ' ';
return out;
}

template<typename T>
inline int len(T a) { return a.size(); }

inline int lcm(int a, int b) { return a / gcd(a, b) * b; }

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count() + 239 + 'm' + 'a' + 'n' + 'u' + 'l' + 777);



void solution() {
int n;
cin >> n;
vector<int> a(n), b(n);
for (int i = 0; i < n; ++i) {
cin >> a[i] >> b[i];
}
if (a == b) {
cout << 0;
return;
}
int sum = 0;
for (int i : a) {
sum += i;
}
int ans = 0;
for (int i = 0; i < n; ++i) {
if (a[i] > b[i]) {
ans = max(ans, (sum - a[i]) + (a[i] - b[i]));
}
}
cout << ans;
}

int32_t main() {
//fastio;
int t = 1;
//cin >> t;
while (t--) solution();
}





// This Code was made by Chinese_zjc_.
#include <bits/stdc++.h>
// #define debug
int n, x[10005], y[10005], cnt, root, F[20005];
std::vector<std::pair<int, int>> app;
std::vector<int> to[40005];
int lson[40005], rson[40005];
#define mid ((l + r) >> 1)
void build(int &now = root, int l = 0, int r = app.size())
{
if (r - l == 1)
{
now = app[l].second;
return;
}
now = cnt++;
build(lson[now], l, mid);
build(rson[now], mid, r);
}
void visit(int now = root, int l = 0, int r = app.size())
{
if (r - l == 1)
return;
visit(lson[now], l, mid);
visit(rson[now], mid, r);
to[now].push_back(lson[now]);
to[now].push_back(rson[now]);
}
void add(int L, int R, int from, int now = root, int l = 0, int r = app.size())
{
if (R <= l || r <= L)
return;
if (L <= l && r <= R)
return to[from].push_back(now);
add(L, R, from, lson[now], l, mid);
add(L, R, from, rson[now], mid, r);
}
#undef mid
int dfn[40005], low[40005], in[40005], tim, tot;
bool ins[40005];
std::stack<int> sta;
void Tarjan(int now)
{
sta.push(now);
ins[now] = true;
low[now] = dfn[now] = ++tim;
for (auto i : to[now])
if (!dfn[i])
{
Tarjan(i);
low[now] = std::min(low[now], low[i]);
}
else if (ins[i])
low[now] = std::min(low[now], low[i]);
if (dfn[now] == low[now])
{
while (sta.top() != now)
{
in[sta.top()] = tot;
ins[sta.top()] = false;
sta.pop();
}
in[now] = tot++;
ins[now] = false;
sta.pop();
}
}
bool check(int lim)
{
std::for_each(to, to + cnt, [&](std::vector<int> &x)
{ x.clear(); });
for (int i = 0; i != n; ++i)
{
add(std::upper_bound(app.begin(), app.end(), std::make_pair(x[i] - lim, INT_MAX)) - app.begin(),
F[i << 1 | 1],
i << 1);
add(F[i << 1 | 1] + 1,
std::lower_bound(app.begin(), app.end(), std::make_pair(x[i] + lim, INT_MIN)) - app.begin(),
i << 1);
add(std::upper_bound(app.begin(), app.end(), std::make_pair(y[i] - lim, INT_MAX)) - app.begin(),
F[i << 1],
i << 1 | 1);
add(F[i << 1] + 1,
std::lower_bound(app.begin(), app.end(), std::make_pair(y[i] + lim, INT_MIN)) - app.begin(),
i << 1 | 1);
}
visit();
std::fill(dfn, dfn + cnt, 0);
for (int i = 0; i != cnt; ++i)
if (!dfn[i])
Tarjan(i);
for (int i = 0; i != n; ++i)
if (in[i << 1] == in[i << 1 | 1])
return false;
return true;
}
signed main()
{
std::ios::sync_with_stdio(false);
std::cin >> n;
for (int i = 0; i != n; ++i)
std::cin >> x[i] >> y[i], app.push_back({x[i], i << 1 | 1}), app.push_back({y[i], i << 1});
cnt = n << 1;
std::sort(app.begin(), app.end());
for (std::size_t i = 0; i != app.size(); ++i)
F[app[i].second] = i;
build();
int l = 0, r = 1000000000;
while (l < r)
{
int mid = (l + r + 1) >> 1;
// std::cout << l << ' ' << r << std::endl;
if (check(mid))
l = mid;
else
r = mid - 1;
}
std::cout << l << std::endl;
return 0;
}
#include<map>
#include<ctime>
#include<cmath>
#include<queue>
#include<bitset>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
#define I inline ll
#define her 20090115
#define IV inline void
#define cht 998244353
#define ld long double
#define Aestas16 392699
#define ull unsigned long long
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=e[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register ll i=j;i>=n;i--)
#define EL(i,now)for(register ll i=first[now];i;i=e[i].nxt)
#define FL(i,j,n)for(register ll i=j;i<=n;i++)
//#define D(i,j,n)for(int i=j;i>=n;i--)
//#define E(i,now)for(int i=first[now];i;i=e[i].nxt)
//#define F(i,j,n)for(int i=j;i<=n;i++)
//#define DL(i,j,n)for(ll i=j;i>=n;i--)
//#define EL(i,now)for(ll i=first[now];i;i=e[i].nxt)
//#define FL(i,j,n)for(ll i=j;i<=n;i++)
ll read(){
ll ans=0,f=1;
char c=getchar();
while(c<'0'||c>'9'){
if(c=='-')f=-1;
c=getchar();
}
while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
return ans*f;
}
const int maxn = 1e3+5;
ll n,m,f[maxn][maxn],d[maxn][maxn],now;
struct edge{ll u,v,w;}e[2*maxn];
int main(){
n=read();m=read();F(i,1,n)F(j,1,m)d[i][j]=read();
F(i,0,100)F(j,0,100)F(x,1,n)F(y,1,m)f[i][j]=max(f[i][j],d[x][y]-i*x-j*y);
ll now;F(x,1,n)F(y,1,m){
now=1e18;F(i,0,100)F(j,0,100)now=min(now,f[i][j]+i*x+j*y);
if(now^d[x][y])return puts("Impossible"),0;
}
puts("Possible");puts("202 10401");
F(i,1,100)printf("%d %d X\n",i,i+1);
F(i,102,201)printf("%d %d Y\n",i,i+1);
F(i,0,100)F(j,0,100)printf("%d %d %lld\n",i+1,202-j,f[i][j]);puts("1 202");
return 0;
}
#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <algorithm>
#include <utility>
#include <tuple>
#include <map>
#include <queue>
#include <deque>
#include <set>
#include <stack>
#include <numeric>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <cassert>

#include <atcoder/all>

using namespace std;
using namespace atcoder;

#define DEBUG(var) cerr << #var << ": " << var << " "
#define DEBUG_EN(var) cerr << #var << ": " << var << endl

using ll = long long;
using ld = long double;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using Graph = vector<vector<int>>;
template<class T> void print_with_space(T p) { for(auto e : p) cerr << e << " "; cerr << endl; }

const ll MOD = 1e9 + 7;
const ll INF = 1LL << 60;
const int inf = 1 << 29;
const ld PI = acos(-1);
template<class T>
struct heap {
priority_queue<T, vector<T>, greater<T>> pq;
heap() : pq() {}
heap(priority_queue<T, vector<T>, greater<T>> pq) : pq(pq) {}
void push(T c) { pq.push(c); }
T top() { return pq.top(); }
void pop() { pq.pop(); }
bool empty() { return pq.empty(); }
int size() { return pq.size(); }
};
int main(int argc, char* argv[]){
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
int n;
cin >> n;
vector<pll> p;
bool f = true;
ll sum = 0;
for(int i=0;i<n;i++) {
ll a, b;
cin >> a >> b;
sum += a;
if(a != b) f = false;
if(a > b) p.push_back({b, a});
}
if(f) {
cout << 0 << endl;
return 0;
} else {
sort(p.begin(), p.end());
cout << sum - p[0].first << endl;
}
return 0;
}

#include <iostream> // cout, endl, cin
#include <string> // string, to_string, stoi
#include <vector> // vector
#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound
#include <utility> // pair, make_pair
#include <tuple> // tuple, make_tuple
#include <cstdint> // int64_t, int*_t
#include <cstdio> // printf
#include <map> // map
#include <queue> // queue, priority_queue
#include <set> // set
#include <stack> // stack
#include <deque> // deque
#include <unordered_map> // unordered_map
#include <unordered_set> // unordered_set
#include <bitset> // bitset
#include <cctype> // isupper, islower, isdigit, toupper, tolower
#include<math.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)
using namespace std;
typedef long long ll;
const ll inf=1e18;




using ll=long long;
using P= pair<ll, ll>;

const int MAX = 1000005;
// 今回採用する大きい素数
const ll MOD = 1e9+7;

// メモを保管する場所
ll fact[MAX], inv_fact[MAX], inv[MAX];

// メモを計算する
void init() {
// 初期値設定と1はじまりインデックスに直す
fact[0] = 1;
fact[1] = 1;
inv[0] = 1;
inv[1] = 1;
inv_fact[0] = 1;
inv_fact[1] = 1;
// メモの計算
repi(i, 2, MAX){
// 階乗
fact[i] = fact[i - 1] * i % MOD;
// 逆元
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
// 逆元の階乗
inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD;
}
}

// 二項係数の実体
ll nCk(int n, int k) {
ll x = fact[n]; // n!の計算
ll y = inv_fact[n-k]; // (n-k)!の計算
ll z = inv_fact[k]; // k!の計算
if (n < k) return 0; // 例外処理
if (n < 0 || k < 0) return 0; // 例外処理
return x * ((y * z) % MOD) % MOD; //二項係数の計算
}


ll pow_pow(ll x,ll n,ll mod){
if(n==0) return 1;
x%=mod;

ll res=pow_pow(x*x%mod,n/2,mod);
if(n&1)res=res*x%mod;
return res;
}



int extgcd(int a,int b,int &x,int &y){
int d=a;
if(b!=0){
d=extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else{
x=1;y=0;
}
return d;
}
int mod_inverse(int a,int m){
int x,y;
extgcd(a,m,x,y);
return (m+x%m)%m;
}

struct UnionFind {
vector<int> par, siz;

UnionFind(int n) : par(n, -1) , siz(n, 1) { }

// 根を求める
int root(int x) {
if (par[x] == -1) return x;
else return par[x] = root(par[x]);
}

// x と y が同じグループに属するかどうか (根が一致するかどうか)
bool issame(int x, int y) {
return root(x) == root(y);
}

// x を含むグループと y を含むグループとを併合する
bool unite(int x, int y) {
x = root(x), y = root(y);
if (x == y) return false; 
if (siz[x] < siz[y]) swap(x, y);
par[y] = x;
siz[x] += siz[y];
return true;
}

// x を含むグループのサイズ
int size(int x) {
return siz[root(x)];
}
};

//min(x,y)が0以下の場合はmax(x,y)が返される
//ユークリッドの互除法を元に実装
ll gcd(ll x,ll y){
if(y==0)return x;
return gcd(y,x%y);
}

//オーバフローしないようにかける順番を気を付ける
ll lcm(ll x,ll y){
return ll(x/gcd(x,y))*y;
}




template<class T> bool chmin(T& a, T b) {
if (a > b) {
a = b;
return true;
}
else return false;
}

//using Graph1=vector<vector<Edge> >;
//using Graph=vector<vector<int> >;

// auto mod int
// https://youtu.be/L8grWxBlIZ4?t=9858
// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize
// https://youtu.be/8uowVvQ_-Mo?t=1329 : division
const int mod =  1e9+7;
struct mint {
ll x; // typedef long long ll;
mint(ll x=0):x((x%mod+mod)%mod){}
mint operator-() const { return mint(-x);}
mint& operator+=(const mint a) {
if ((x += a.x) >= mod) x -= mod;
return *this;
}
mint& operator-=(const mint a) {
if ((x += mod-a.x) >= mod) x -= mod;
return *this;
}
mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}
mint operator+(const mint a) const { return mint(*this) += a;}
mint operator-(const mint a) const { return mint(*this) -= a;}
mint operator*(const mint a) const { return mint(*this) *= a;}
mint pow(ll t) const {
if (!t) return 1;
mint a = pow(t>>1);
a *= a;
if (t&1) a *= *this;
return a;
}

// for prime mod
mint inv() const { return pow(mod-2);}
mint& operator/=(const mint a) { return *this *= a.inv();}
mint operator/(const mint a) const { return mint(*this) /= a;}
};
istream& operator>>(istream& is, const mint& a) { return is >> a.x;}
ostream& operator<<(ostream& os, const mint& a) { return os << a.x;}
// combination mod prime
// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619
struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
//assert(n < mod);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
mint p(int n, int k) {
return fact[n]*ifact[n-k];
}
} c(1000005);




//const ll INF=1e18;


class segment_tree {
private:
int sz;
std::vector<int> seg;
std::vector<int> lazy;
void push(int k) {
if (k < sz) {
lazy[k * 2] = max(lazy[k * 2], lazy[k]);
lazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);
}
seg[k] = max(seg[k], lazy[k]);
lazy[k] = 0;
}
void update(int a, int b, int x, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return;
if (a <= l && r <= b) {
lazy[k] = x;
push(k);
return;
}
update(a, b, x, k * 2, l, (l + r) >> 1);
update(a, b, x, k * 2 + 1, (l + r) >> 1, r);
seg[k] = max(seg[k * 2], seg[k * 2 + 1]);
}
int range_max(int a, int b, int k, int l, int r) {
push(k);
if (r <= a || b <= l) return 0;
if (a <= l && r <= b) return seg[k];
int lc = range_max(a, b, k * 2, l, (l + r) >> 1);
int rc = range_max(a, b, k * 2 + 1, (l + r) >> 1, r);
return max(lc, rc);
}
public:
segment_tree() : sz(0), seg(), lazy() {};
segment_tree(int N) {
sz = 1;
while (sz < N) {
sz *= 2;
}
seg = std::vector<int>(sz * 2, 0);
lazy = std::vector<int>(sz * 2, 0);
}
void update(int l, int r, int x) {
update(l, r, x, 1, 0, sz);
}
int range_max(int l, int r) {
return range_max(l, r, 1, 0, sz);
}
//cin.tie(0);
//ios_base::sync_with_stdio(false); これらをmain関数の先頭に
};

const int seg_size=200005;
ll seg[seg_size*2];

ll seg_take(int l,int r){
ll tot=0;
l+=seg_size;
r+=seg_size;
while(l<r){
if(l%2==1){
tot+=seg[l];
l++;
}
l/=2;
if(r%2==1){
tot+=seg[r-1];
r--;
}
r/=2;

}
return tot;
}

void seg_up(int ind,int val){
ind+=seg_size;
seg[ind]+=val;
while(true){
ind/=2;
if(ind==0)break;
seg[ind]=seg[ind*2]+seg[ind*2+1];
}
}
struct  Edge{
int to;ll w;
Edge() {}
Edge(int to,ll w):to(to),w(w) {}
};

using graph= vector<vector<int > >;

void comp(vector<int>&a){
set<int>s(a.begin(),a.end());
map<int,int>d;
int cnt=0;
for(auto x:s)d[x]=cnt++;
for(auto&x:a)x=d[x];
}


int main(){
int n; cin >> n;
vector<ll> a(n+1),sum(n+1);
repi(i,1,n+1){
cin >> a[i];
sum[i]=sum[i-1]+a[i];
}
ll tot=0;
ll ans=0;
repi(i,1,n+1){
if(i%2){//plus
if(sum[i]+tot<=0){
ans+=(1-(sum[i]+tot));
tot+=(1-(sum[i]+tot));
}
}
else{
if(sum[i]+tot>=0){
ans+=abs(-1-(tot+sum[i]));
tot+=-1-(tot+sum[i]);
}
}
}
tot=0;
ll ans2=0;
repi(i,1,n+1){
if(i%2==0){
if(sum[i]+tot<=0){
ans2+=(1-(sum[i]+tot));
tot+=(1-(sum[i]+tot));
}
}
else{
if(sum[i]+tot>=0){
ans2+=abs(-1-(tot+sum[i]));
tot+=-1-(tot+sum[i]);
}
}
}
cout << min(ans,ans2) << endl;



}
#include<iostream>

using namespace std;

int main()
{
long a,b,c=1e9; cin>>a>>b;
printf("%ld\n",c/2*b+a);
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<int, int>;

template <typename T>
struct SegmentTree {
// T : type of node
private:
int size;
int p;
vector<T> node;
function<T(T, T)> op1, op2;  // op1 : operation, op2 : update
T id;                        // identity element of op1
public:
SegmentTree(int p_, T id_, function<T(T, T)> op1_, function<T(T, T)> op2_) {
size = p_;
id = id_;
op1 = op1_;
op2 = op2_;
p = 1;
while (p < p_) p *= 2;
node = vector<T>(2 * p, id);
}
void set(int i, const T& v) {
node[i + p] = v;
}
void build() {
for (int i = p - 1; i >= 1; i--) {
node[i] = op1(node[2 * i], node[2 * i + 1]);
}
}
void clear() {
for (T& v : node) {
v = id;
}
}
void update(int x, T val) {
x += p;
node[x] = op2(node[x], val);
while (x > 0) {
x >>= 1;
node[x] = op1(node[2 * x], node[2 * x + 1]);
}
}
T query(int l, int r) {
T vl = id, vr = id;
l += p;
r += p;
while (l < r) {
if (l & 1) vl = op1(vl, node[l++]);
if (r & 1) vr = op1(node[--r], vr);
l >>= 1;
r >>= 1;
}
return op1(vl, vr);
}
friend ostream& operator<<(ostream& os, SegmentTree tree) {
for (int i = 0; i < tree.size; i++) {
os << tree.node[i + tree.p] << " ";
}
return os;
}
};

int main() {
int n;
ll k;
cin >> n >> k;
vector<ll> a(n);
for (int i = 0; i < n; i++) cin >> a[i];
vector<ll> s(n + 1);
for (int i = 0; i < n; i++) s[i + 1] = s[i] + a[i];
for (int i = 0; i <= n; i++) s[i] -= k * i;
vector<ll> vec(n + 1);
auto zip = [](const vector<ll>& u, vector<ll>& v) -> void {
// u -> v
vector<ll> _ = u;
sort(_.begin(), _.end());
_.erase(unique(_.begin(), _.end()), _.end());
for (int i = 0; i < int(u.size()); i++) {
v[i] = lower_bound(_.begin(), _.end(), u[i]) - _.begin();
}
};
zip(s, vec);
auto op = [](int a, int b) {return a + b;};
SegmentTree<int> tree(n + 1, 0, op, op);
ll res = 0;
for (int i = 0; i < n + 1; i++) {
res += tree.query(0, vec[i] + 1);
tree.update(vec[i], 1);
}
cout << res << endl;
}
#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
void solve() {
string s;
cin>>s;
int n=s.length();
bool dp[n+1];
memset(dp,false,sizeof dp);
dp[n]=true;
for(int i=n-1;i>=0;i--){
if(s.substr(i,5)=="dream") dp[i]|=dp[i+5];
if(s.substr(i,5)=="erase") dp[i]|=dp[i+5];
if(s.substr(i,6)=="eraser") dp[i]|=dp[i+6];
if(s.substr(i,7)=="dreamer") dp[i]|=dp[i+7];
}
if(dp[0]) cout<<"YES";
else cout<<"NO";
}

int32_t main() {
nitin;

solve();
}
#include<bits/stdc++.h>
#define ll long long int
using namespace std;
vector<ll>vis(200000,-1);
ll traverse(ll x)
{
if(vis[x]==-1) return x;
return vis[x]=traverse(vis[x]);
}
void solve()
{
ll n,i,k,j;
cin>>n;
vector<pair<ll,pair<ll,ll>>>v1,v2,v;
for(int i=0; i<n; i++){
ll x,y;
cin>>x>>y;
v1.push_back({x,{y,i}});
v2.push_back({y,{x,i}});
}
sort(v1.begin(),v1.end());
sort(v2.begin(),v2.end());
for(int i=0; i<n-1; i++){
ll a=abs(v1[i].first-v1[i+1].first);
ll x=v1[i].second.second;
ll y=v1[i+1].second.second;
v.push_back({a,{x,y}});
}
for(int i=0; i<n-1; i++){
ll a=abs(v2[i].first-v2[i+1].first);
ll x=v2[i].second.second;
ll y=v2[i+1].second.second;
v.push_back({a,{x,y}});
}
ll ans=0;
sort(v.begin(),v.end());
for(auto it:v)
{
ll need=it.first;
ll a=it.second.first;
ll b=it.second.second;
ll z=traverse(a);
ll y=traverse(b);
if(z!=y){
ans+=need;
vis[z]=y;
}
}
cout<<ans<<endl;
}
int main()
{
int t=1;
while(t--){
solve();
}
return 0;
}

#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=3010; 
int n,p;
int C[N][N],S[N][N]; 
int POW(int a,int b,int p)
{
if(!b) return 1;
if(b==1) return a;
int sum=POW(a,b/2,p);
if(b%2) return sum*sum%p*a%p;
return sum*sum%p;
}
signed main()
{
scanf("%lld%lld",&n,&p);
C[0][0]=S[0][0]=1;
for(int i=1;i<N;i++)
{
C[i][0]=1;
for(int j=1;j<=i;j++)
{
C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;
S[i][j]=(S[i-1][j]*j%p+S[i-1][j-1])%p;
}
}
int ans=0;
for(int i=0;i<=n;i++)
{
int sum=0,s=POW(2,POW(2,n-i,p-1),p);
for(int j=0;j<=i;j++)
{
int t=POW(POW(2,n-i,p),j,p);
sum=(sum+S[i+1][j+1]*s%p*t%p)%p;
}
if(i%2) ans=(ans-sum*C[n][i]%p+p)%p;
else ans=(ans+sum*C[n][i]%p)%p;
}
printf("%lld",ans);
return 0;
}
#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;


template<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}
template<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}

typedef long long ll;
typedef pair<int,int> pii;

// mint
using mint = static_modint<1000000007>;
// using mint = static_modint<998244353>;
// ll int
ll INF = numeric_limits<ll>::max() / 2;

int main(){
// set precision (10 digit)
cout << setprecision(10);
int N; cin >> N;
vector<ll> A(N), B(N), C(N);
for(int i = 0; i < N; i++) cin >> A[i];
for(int i = 0; i < N; i++) cin >> B[i];
for(int i = 0; i < N; i++) cin >> C[i];

sort(A.begin(), A.end());
sort(B.begin(), B.end());
sort(C.begin(), C.end());

ll ans = 0;
for(int i = 0; i < N; i++){
ll now = B[i];

ll a_index = lower_bound(A.begin(), A.end(), now) - A.begin();
ll c_index = upper_bound(C.begin(), C.end(), now) - C.begin();

// cerr << a_index << " " << c_index << endl;
ll tmp = a_index * (N-c_index);

ans += tmp;
}

cout << ans << endl;

}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n, k, q; cin >> n >> k >> q;
vector <int> a(n);
for (auto& x : a) cin >> x;

int ans = mod * mod;
vector <int> un = a;
sort(un.begin(), un.end());

un.erase(unique(un.begin(), un.end()), un.end());

for (int i = 0; i < un.size(); ++i) {
int l = i - 1, r = un.size();
while (l + 1 < r) {
int m = (l + r) / 2;
int lx = un[i], rx = un[m];
vector <pair <int, int>> info; // { len, cnt }
int curLen = 0, curCnt = 0;
for (int i = 0; i < n; ++i) {
if (a[i] < lx) {
info.push_back({ curLen, curCnt });
curLen = curCnt = 0;
}
else {
curLen++;
curCnt += (a[i] <= rx);
}
}
info.push_back({ curLen, curCnt });
int maxQ = 0;
for (auto& x : info) {
curLen = x.first, curCnt = x.second;
maxQ += min(max(0ll, curLen - k + 1), curCnt);
}
maxQ >= q ? r = m : l = m;
}
if (r < un.size()) ans = min(ans, un[r] - un[i]);
}
cout << ans << '\n';

return 0;
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
struct segment_tree{
vector<int> val,tag;
int type,L,R;
inline int mid(int l, int r){return l+r>>1;}
segment_tree(int _siz, int _type){val.resize(4*_siz),tag.resize(4*_siz),type=_type,L=0,R=_siz-2;}
inline int oper(int i, int j){
if(type==0) return i+j;
else if(type==1) return min(i,j);
else return max(i,j);
}
inline int def(){
if(type==0) return 0;
else if(type==1) return 4e18;
else return -4e18;
}
void pull(int k){val[k]=oper(val[k<<1],val[(k<<1)+1]);}
void push(int k, int l, int r){
if(l!=r){
if(type){
tag[k<<1]+=tag[k];
tag[(k<<1)+1]+=tag[k];
val[k<<1]+=tag[k];
val[(k<<1)+1]+=tag[k];
}
else{
tag[k<<1]+=tag[k];
tag[(k<<1)+1]+=tag[k];
val[k<<1]+=(mid(l,r)-l+1)*tag[k];
val[(k<<1)+1]+=(r-mid(l,r))*tag[k];
}
}
tag[k]=0;
}
void modify_in(int k, int l, int r, int ql, int qr, int x){
if(l>qr||r<ql) return;
if(ql<=l&&qr>=r){
if(type) val[k]+=x;
else val[k]+=(r-l+1)*x;
tag[k]+=x;
return;
}
push(k,l,r);
modify_in(k<<1,l,mid(l,r),ql,qr,x);
modify_in((k<<1)+1,mid(l,r)+1,r,ql,qr,x);
pull(k);
}
int query_in(int k, int l, int r, int ql, int qr){
if(l>qr||r<ql) return def();
if(ql<=l&&qr>=r) return val[k];
push(k,l,r);
return oper(query_in(k<<1,l,mid(l,r),ql,qr),query_in((k<<1)+1,mid(l,r)+1,r,ql,qr));
}
void modify(int l, int r, int x){modify_in(1,L,R,l,r,x);}
int query(int l, int r){return query_in(1,L,R,l,r);}
};
const int maxn=100005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m,a[maxn],cnt[maxn];
vector<int> vec;
segment_tree tree(maxn,1);

void orzck(){
cin >> m >> n;
rep(m) cin >> a[i];
rep(m-1){
int x=a[i],y=a[i+1];
x--,y--;
int k=y-x;
if(k<0) k+=n;
if(y>=x){
tree.modify(0,0,k);
tree.modify(x+2,y,-1);
tree.modify(y+1,y+1,k-1);
}
else{
tree.modify(0,0,y+1);
tree.modify(1,y,-1);
tree.modify(y+1,y+1,k-1);
tree.modify(x+2,n-1,-1);
}
}
vector<int> vec;
rep(n) vec.pb(tree.query(i,i));
rep2(i,1,n) vec[i]+=vec[i-1];
print(*min_element(all(vec)));
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;

int main()
{
int n; cin >> n;
int sum = 0;
for (int i = 1; i <= n; i++)
{
sum += i;
if (sum >= n)
{
cout << i << endl;
break;
}
}





return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
#define rep(i, begin, end) for (ll i = (ll)begin; i < (ll)(end); i++)
#define drep(i, begin, end) for (ll i = (ll)begin; i >= (ll)(end); i--)
#define rep1toN(i, n) for (int i = 1; i <= (int)(n); i++)
#define presicion cout<<fixed<<setprecision(20);
using ll = long long;
using ld = long double;
using namespace std;
using namespace atcoder;
template<class T> using v = vector<T>;
template<class T> inline bool chmin(T &a, const T b) { if (a > b) { a = b; return true; } return false; }
template<class T> inline bool chmax(T &a, const T b) { if (a < b) { a = b; return true; } return false; }
istream &operator>>(istream &is, modint998244353 &a) { long long v; is >> v; a = v; return is; }
ostream &operator<<(ostream &os, const modint998244353 &a) { return os << a.val(); }
istream &operator>>(istream &is, modint1000000007 &a) { long long v; is >> v; a = v; return is; }
ostream &operator<<(ostream &os, const modint1000000007 &a) { return os << a.val(); }
template<class T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }
template<class T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }
template<class T1, class T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }
template<class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << ", " << p.second << ')'; return os; }
using P = pair<ll,ll>;

bool solve(){
ll n,m; cin>>n>>m;
v<v<P>> ds(n);
rep(i,0,m){
ll l,r,d; cin>>l>>r>>d;
l--;r--;
ds[l].push_back(make_pair(r,d));
ds[r].push_back(make_pair(l,-d));
}

v<ll> pos(n, LLONG_MAX);
rep(i,0,n){
if(pos[i] != LLONG_MAX) continue;
queue<ll> q;
q.push(i);
pos[i] = 0;
while(q.size()){
ll t = q.front(); q.pop();
for(auto e:ds[t]){
ll to = e.first, x = pos[t] + e.second;
if(pos[to] == LLONG_MAX){
q.push(to);
pos[to] = x;
}
else if(pos[to] != x){
return false;
}
}
}
}


return true;
}

int main()
{
cout << (solve()? "Yes" : "No") << endl;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
template<typename T, int maxn, int type>
struct sparse{
vector<T> val[22];
sparse(){rep(__lg(maxn)+1) val[i].resize(max(0ll,maxn-pow2(i)+1));}
inline T oper(T i, T j){return type?max(i,j):min(i,j);}
void init(vector<T>& vec){
rep(sz(vec)) val[0][i]=vec[i];
rep2(i,1,__lg(maxn)+1) rep1(j,sz(vec)-pow2(i)+1) val[i][j]=oper(val[i-1][j],val[i-1][j+pow2(i-1)]);
}
T query(int l, int r){return oper(val[__lg(r-l+1)][l],val[__lg(r-l+1)][r-pow2(__lg(r-l+1))+1]);}
};
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],out[maxn],res[maxn];
vector<vector<int>> vals;
bool vis[maxn];

int mex(vector<int> vec){
bool vis[sz(vec)+1];
memset(vis,0,sizeof vis);
for(auto i: vec) if(i<=sz(vec)) vis[i]=1;
rep(sz(vec)+1) if(!vis[i]) return i;
return 777771449;
}

void orzck(){
vals.resize(maxn);
cin >> n;
rep(n) cin >> a[i];
rep(n){
a[i]--;
out[a[i]]++;
}
queue<int> q;
rep(n) if(!out[i]) q.push(i);
while(!q.empty()){
int u=q.front();q.pop();
res[u]=mex(vals[u]);
vals[a[u]].pb(res[u]);
vis[u]=1;
out[a[u]]--;
if(!out[a[u]]) q.push(a[u]);
}
int u=-1;
rep(n) if(!vis[i]){
u=i;
break;
}
vector<int> vec;
vec.pb(u),vec.pb(a[u]);
while(vec.back()!=u) vec.pb(a[vec.back()]);
int x=mex(vals[a[u]]);
//Case 1
vector<vector<int>> vals2=vals;
res[u]=x;
int cur=u;
for(int i=a[u]; i!=u; i=a[i]){
vals2[i].pb(res[cur]);
res[i]=mex(vals2[i]);
cur=i;
}
vals2[u].pb(res[cur]);
if(res[u]==mex(vals2[u])){
print("POSSIBLE");
return;
}
//Case 2
vals2=vals;
int v=a[u];
res[v]=x;
cur=v;
for(int i=a[v]; i!=v; i=a[i]){
vals2[i].pb(res[cur]);
res[i]=mex(vals2[i]);
cur=i;
}
vals2[v].pb(res[cur]);
if(res[v]==mex(vals2[v])){
print("POSSIBLE");
return;
}
print("IMPOSSIBLE");
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main()
{

cin.tie(0) -> ios_base::sync_with_stdio(0);

string s;
cin >> s;
int n = s.size();
int ans = n;
for(int i=0;i<n;i++)
{
if(s[i] != s[i+1])
ans = min(ans, max(i + 1, n - i - 1));
}
cout << ans << '\n';

}	 
//And in that light,I find deliverance.
#include<algorithm>
#include<iostream>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<iomanip>
#include<bitset>
#include<cstdio>
#include<string>
#include<cmath>
#include<ctime>
#include<queue>
#include<stack>
#include<map>
#include<set>
using namespace std;
#define file(s) freopen(#s".in","r",stdin),freopen(#s".out","w",stdout)
#define clr(x) memset((x),0,sizeof(x))
#define neinf 0xc0c0c0c0c0c0c0c0ll
#define inf 0x3f3f3f3f3f3f3f3fll
#define uint unsigned int
#define ull unsigned ll
#define HgS 1000000007
#define pr pair<ll,ll>
#define prpr make_pair
#define ll long long
#define opr operator
#define pb push_back
#define gc getchar
#define pc putchar
#define ret return
#define sec second
#define fir first
#define cst const
#define db double
#define il inline
il ll rd()
{
ll res=0,lab=1;
char ch=gc();
while((ch<'0'||ch>'9')&&ch!=EOF){if(ch=='-')lab=-lab;ch=gc();}
while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch&15),ch=gc();
ret res*lab;
}
il db rdf()
{
db res=0,g=1;int lab=1;char ch=gc();
while((ch<'0'||ch>'9')&&ch!=EOF)lab=lab^(ch=='-'),ch=gc();
while(ch>='0'&&ch<='9')res=res*10+(ch&15),ch=gc();
if(ch=='.')
{
ch=gc();
while(ch>='0'&&ch<='9')g*=0.1,res+=g*(ch&15),ch=gc();
}
ret lab?res:-res;
}
il void prt(ll x,char t='\n')
{
static char ch[70];int tp=0;
if(!x){fputs("0",stdout);if(t)pc(t);ret;}
if(x<0)pc('-'),x=-x;
while(x)ch[++tp]=(x%10)^48,x/=10;
while(tp)pc(ch[tp--]);
if(t)pc(t);
}
il db deg(cst db&x,cst db&y){return (!x&&!y)?0:atan2(y,x);}
template<class T>il void pls(T &x,cst T&y){x+=y;if(x>=HgS)x-=HgS;}
template<class T>il void sub(T &x,cst T&y){x-=y;if(x<0)x+=HgS;}
template<class T>T gcd(cst T&a,cst T&b){ret b?gcd(b,a%b):a;}
template<class T>il T tomax(T&a,cst T&b){ret a>b?a:(a=b);}
template<class T>il T tomin(T&a,cst T&b){ret a<b?a:(a=b);}
template<class T>il T umax(T a){ret a;}
template<class T>il T umin(T a){ret a;}
template<class T>il T umax(T a,T b){ret a>b?a:b;}
template<class T>il T umin(T a,T b){ret a<b?a:b;}
template<class T,class... A>T umin(T a,A... ar){ret umin(a,umin(ar...));}
template<class T,class... A>T umax(T a,A... ar){ret umax(a,umax(ar...));}
template<class T>il T uabs(cst T&x){ret x>0?x:-x;}
template<class T>il T sqr(cst T&x){ret x*x;}
il ll qpow(ll n,ll e=HgS-2,cst ll&p=HgS)
{n%=p;ll res=1;while(e){if(e&1)res=res*n%p;n=n*n%p;e>>=1;}ret res;}
cst ll ir=HgS-1;
struct cpx
{
int r,i;
cpx(ll a=0,ll b=0):r(a%HgS),i(b%HgS){}
cpx opr+(cst cpx&_)cst{ret cpx(r+_.r,i+_.i);}
cpx opr-(cst cpx&_)cst{ret cpx(r-_.r+HgS,i-_.i+HgS);}
il cpx opr*(cst cpx&_)cst
{ret cpx(1ll*r*_.r+ir*i*_.i,1ll*r*_.i+1ll*i*_.r);}
};
il cpx qpow(cpx n,ll e)
{cpx res(1);while(e){if(e&1)res=res*n;n=n*n;e>>=1;}ret res;}
struct mat
{
#define siz 2
int n,m,d[siz+1][siz+1];
il mat(int n=siz,int m=siz,int x=0):n(n),m(m)
{clr(d);for(int i=1;i<=umin(n,m);++i)d[i][i]=x;}
il int* opr[](uint x){ret d[x];}
il mat opr*(mat _)
{
mat res(n,_.m);int p=umin(m,_.n);
for(int i=1,*pta;pta=d[i],i<=n;++i)
for(int k=1,*ptb;ptb=_[k],++pta,k<=p;++k)
for(int j=1;j<=_.m;++j)
pls(res[i][j],(int)(1ll*(*pta)*(*++ptb)%HgS));
ret res;
}
#undef siz
};
il mat qpow(mat n,ll e)
{mat res(n.n,n.m,1);while(e){if(e&1)res=res*n;n=n*n;e>>=1;}ret res;}
ll n,fa[100005],siz[100005],dis[100005];pr d[100005];
il bool calc()
{
ll cnt=0;
for(int i=n;i>=2;--i)
{
ll id=d[i].sec,v=d[i].fir-n+2*siz[id];
if(v>=d[i].fir){++cnt;continue;}
int pos=lower_bound(d+1,d+1+n,prpr(v,0ll))-d;
if(d[pos].fir==v)fa[id]=d[pos].sec,siz[fa[id]]+=siz[id];
else ++cnt;
}
ret !cnt;
}
il bool j()
{
ll t=0;for(int i=1,id;i<=n;++i)
if(fa[id=d[i].sec])t+=dis[id]=dis[fa[id]]+1;
ret t==d[1].fir;
}
int main()
{
n=rd();for(int i=1;i<=n;++i)d[i]=prpr(rd(),i),siz[i]=1;
sort(d+1,d+1+n);if(!calc()||!j())ret prt(-1),0;
//for(int i=1;i<=n;++i)cerr<<d[i].fir<<" \n"[i==n];
//for(int i=1;i<=n;++i)cerr<<d[i].sec<<" \n"[i==n];
for(int i=1;i<=n;++i)if(fa[i])prt(fa[i],' '),prt(i);
ret 0;
}

#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; --i)

int main() {
int n, k;
cin >> n >> k;
vi c(n);
rep(i, n) {
int a;
cin >> a, --a;
c[a]++;
}
sort(c.begin(), c.end(), greater<int>());

int r = 0, cc = 0;
rep(i, n) {
if (c[i] > 0) {
r += c[i];
cc++;
}
if (cc == k) break;
}
cout << n - r << endl;
return 0;
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

ll x, y;
ll f[2];

bool check() {
int fl = 0;
while(f[fl] > 1) {
f[fl ^ 1] += f[fl] / 2;
f[fl] %= 2;
fl ^= 1;
}
return (fl != 0);
}

int main() {
qread(x, y);
if(abs(x - y) <= 1) puts("Brown");
else puts("Alice");
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
int main(){
int n;
ll a,b;
cin>>n>>a>>b;
vector<int>p(n);
sort(p.begin(),p.end());
for(int i=0;i<n;i++) cin>>p[i];
ll ans=0;
for(int i=1;i<n;i++){
ll dist=p[i]-p[i-1];
ans+=min((ll)a*dist,b);
}
cout<<ans<<endl;
return 0;
}

#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
void solve() {
int n;
cin>>n;
int a[n];
for(int i=0;i<n;i++){
cin>>a[i];
}
int l;
cin>>l;
int tab[n+1][22];
for(int i=0;i<n-1;i++){
int left=i,right=n;
while(left+1<right){
int mid=(left+right)/2;
if(a[mid]-a[i]<=l){
left=mid;
}else{
right=mid;
}
}
tab[i][0]=left;
}
tab[n-1][0]=n;
tab[n][0]=n;
for(int j=1;j<22;j++){
for(int i=0;i<=n;i++){
tab[i][j]=tab[tab[i][j-1]][j-1];
}
}
int q;
cin>>q;
while(q--){
int a,b;
cin>>a>>b;
--a;--b;
if(a>b) swap(a,b);
int ans=0;
for(int j=21;j>=0;j--) {
if (tab[a][j] < b) {
ans |= (1 << j);
a = tab[a][j];
}
}
ans++;
cout<<ans<<endl;
}
}

int32_t main() {
nitin;

solve();
}
#include<bits/stdc++.h>
#define int long long
#define inf 1e15
#define INF 0x3f3f3f3f
#define N 25005
#define K 405
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define pii pair<int,int>
#define il inline
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
il int read(){
int w=0,h=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')h=-h;ch=getchar();}
while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
return w*h;
}
const int mod=1e9+7;
int n,m,k,a[N],cnt[N];
int f[N][K],g[N][K];
int c[N],d[N];
int Fac[N],IFac[N];
int qpow(int b,int k){
int s=1;
while(k){
if(k&1)s=s*b%mod;
b=b*b%mod;
k>>=1;
}
return s;
}
int check(){
int cur=0,flg=0;
for(int i=1,j=1;i<=m;i++){
if(!cnt[a[i]])cur++;
cnt[a[i]]++;
while(cnt[a[j]]>1)cnt[a[j++]]--;
if(i-j+1==k&&cur==k)return 0;
}
memset(cnt,0,sizeof(cnt));
for(int i=1;i<=m;i++)
if((cnt[a[i]]++)>0)return 2;
return 1;
}
int calc(){
int ans=0;
f[0][0]=1;
for(int i=0;i<n;i++){
for(int j=0;j<k;j++){
if(j<k-1){
(f[i+1][j+1]+=f[i][j]*(k-j+mod)%mod)%=mod;
(f[i+1][j+2]+=mod-f[i][j]*(k-j+mod)%mod)%=mod;
(g[i+1][j+1]+=g[i][j]*(k-j+mod)%mod)%=mod;
(g[i+1][j+2]+=mod-g[i][j]*(k-j+mod)%mod)%=mod;
}
(f[i+1][1]+=f[i][j])%=mod;
(f[i+1][j+1]+=mod-f[i][j])%=mod;
(g[i+1][1]+=g[i][j])%=mod;
(g[i+1][j+1]+=mod-g[i][j])%=mod;
}
for(int j=1;j<k;j++){
(f[i+1][j]+=f[i+1][j-1])%=mod;
(g[i+1][j]+=g[i+1][j-1])%=mod;
}
for(int j=m;j<k;j++)(g[i+1][j]+=f[i+1][j])%=mod;
}
for(int i=1;i<k;i++)(ans+=g[n][i])%=mod;
return ans;
}
void dp(int ans[N],int dp[N][K]){
ans[0]=1;
for(int i=0;i<n-m;i++){
for(int j=1;j<k;j++){
if(j<k-1){
(dp[i+1][j+1]+=dp[i][j]*(k-j)%mod)%=mod;
(dp[i+1][j+2]+=mod-dp[i][j]*(k-j)%mod)%=mod;
}
(dp[i+1][1]+=dp[i][j])%=mod;
(dp[i+1][j+1]+=mod-dp[i][j])%=mod;
}
for(int j=1;j<k;j++){
(dp[i+1][j]+=dp[i+1][j-1])%=mod;
(ans[i+1]+=dp[i+1][j])%=mod;
}
}
}
signed main(){
n=read();k=read();m=read();
if(k>n)return puts("0"),0;
for(int i=1;i<=m;i++)a[i]=read();
int all=(n-m+1)*qpow(k,n-m)%mod;
Fac[0]=IFac[0]=1;
for(int i=1;i<=25000;i++)Fac[i]=Fac[i-1]*i%mod;
IFac[25000]=qpow(Fac[25000],mod-2);
for(int i=24999;i;i--)IFac[i]=IFac[i+1]*(i+1)%mod;
switch(check()){
case 0:return printf("%lld\n",all),0;
case 1:return printf("%lld\n",(all-calc()*Fac[k-m]%mod*IFac[k]%mod+mod)%mod),0;
case 2:{
memset(cnt,0,sizeof(cnt));
for(int i=1;i<=m;i++){
cnt[a[i]]++;
if(cnt[a[i]]>1){
f[0][i-1]=1;
break;
}
}
dp(c,f);
memset(cnt,0,sizeof(cnt));
for(int i=m;i>=1;i--){
cnt[a[i]]++;
if(cnt[a[i]]>1){
g[0][m-i]=1;
break;
}
}
dp(d,g);
for(int i=0;i<=n-m;i++)
(all+=mod-c[i]*d[n-m-i]%mod)%=mod;
printf("%lld\n",all);
return 0;
}
}
return 0;
}

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 210000
using namespace std;
char s[N];
int n,nxt[N][26],f[N];
int main(){

scanf("%s",s+1);n=strlen(s+1);
memset(nxt,-1,sizeof(nxt));
for(int i=n;i;i--)
for(int j=0;j<26;j++){
nxt[i][j]=('a'+j==s[i]?i:nxt[i+1][j]);
}
memset(f,0x3f,sizeof(f));
for(int i=n;i;i--){
for(int j=0;j<26;j++){
if(nxt[i][j]==-1) {f[i]=1;break;}
f[i]=min(f[i],f[nxt[i][j]+1]+1);
}
}
int len=f[1],pos=1;
while(len--){
if(!len) for(int i=0;i<26;i++){
if(nxt[pos][i]==-1) {putchar(i+'a');return 0;}
}
for(int i=0;i<26;i++){
if(f[pos]==f[nxt[pos][i]+1]+1) {putchar(i+'a');pos=nxt[pos][i]+1;break;}
} 
}
return 0;
}
#include <stack>
#include <vector>
#include <iostream>
#include <cstring>
#include <algorithm>
namespace Qiaoqia { 
constexpr int N = 20005;
int n, low[N*5], dfn[N*5], inst[N*5], scc[N*5], id[4*N], cnt, col, tim;
std::stack<int> st;
std::vector<int> g[N*5];
struct kk { 
int p, id;
kk(int x = 0, int y = 0) { p = x, id = y; }
bool operator < (const kk& b) const {
if (p != b.p) return p < b.p;
return id < b.id;
}
} a[N];
int op(int x) { return x > n/2 ? x-n/2 : x+n/2; }
void dfs(int u) {
dfn[u] = low[u] = ++tim;
st.push(u), inst[u] = 1;
for (int v : g[u]) 
if (!dfn[v]) dfs(v), low[u] = std::min(low[u], low[v]);
else if (inst[v]) low[u] = std::min(low[u], dfn[v]);
if (low[u] == dfn[u]) {
int c;
scc[u] = ++col;
while ("guang_gao_wei_zhao_zu"[0]) {
c = st.top(), st.pop();
inst[c] = 0;
scc[c] = scc[u];
if (c == u) break;
}
}
}
void add(int p, int l, int r, int x, int y, int z) {
// if (p == 1) std::cout << z << ' ' << x << ' ' << y << '\n';
if (l == x && r == y) {
g[z].push_back(id[p]);
return;
}
int mid = l + (r-l) / 2;
if (y <= mid) add(p+p, l, mid, x, y, z);
else if (x > mid) add(p+p+1, mid+1, r, x, y, z);
else add(p+p, l, mid, x, mid, z), add(p+p+1, mid+1, r, mid+1, y, z);
}
void build(int p, int l, int r) {
id[p] = ++cnt;
if (l == r) {
g[id[p]].push_back(op(a[l].id));
return;
}
int mid = l + (r-l) / 2;
build(p+p, l, mid), g[id[p]].push_back(id[p+p]);
build(p+p+1, mid+1, r), g[id[p]].push_back(id[p+p+1]);
}
bool check(int d) {
memset(dfn, 0, sizeof dfn);
memset(low, 0, sizeof low);
for (int i = 1; i <= cnt; i++) g[i].clear();
cnt = n;
build(1, 1, n);
for (int i = 1; i <= n; i++) {
int l = std::upper_bound(a+1, a+i, kk(a[i].p-d, n+1)) - a,
r = std::lower_bound(a+i+1, a+n+1, kk(a[i].p+d, -1)) - a - 1;
if (l < i) add(1, 1, n, l, i-1, a[i].id);
if (r > i) add(1, 1, n, i+1, r, a[i].id);        
}       
tim = 0, col = 0;
for (int i = 1; i <= n; i++)
if (!dfn[i]) dfs(i);
for (int i = 1; i <= n/2; i++)
if (scc[i] == scc[i+n/2]) return false;
return true;
}
void main() {
std::cin >> n;
for (int i = 1; i <= n; i++) {
std::cin >> a[i].p >> a[i+n].p;;
a[i].id = i, a[i+n].id = i+n;
}
n = n * 2;
std::sort(a+1, a+1+n);
int l = 0, r = a[n].p - a[1].p, ans = -1;
while (l <= r) {
int mid = l + (r - l) / 2;
if (check(mid)) ans = mid, l = mid + 1;
else r = mid - 1;
}
std::cout << ans;
}
}
void _() { if (0) std::ios::sync_with_stdio(false), std::cin.tie(nullptr); }
int main() { _(); Qiaoqia::main(); }
/*
Here's to the crazy ones, the misfits, the rebels, the troublemakers, 
the round pegs in the square holes ... the ones who see things differently . 
They're not fond of rules, and they have no respect for the status quo. ... 
You can quote them, disagree with them, glorify or vilify them, 
but the only thing you can't do is ignore them because they change things. ... 
They push the human race forward, and while some may see them as the crazy ones, 
we see genius, because the people who are crazy enough to think that they can change the world, are the ones who do.
*/
/*
I watched a snail crawl along the edge of a straight razor. 
That's my dream; that's my nightmare. 
Crawling, slithering, along the edge of a straight razor.d.. and surviving..
*/
// Templates
// 1. tempgeo.cpp
// 2. tempunion.cpp
// 3. mysegtree.cpp
// 4. tempnt.cpp
#pragma GCC target ("avx2")
#pragma GCC optimization ("O3")
#pragma GCC optimization ("unroll-loops")
#include <bits/stdc++.h>
using namespace std;
#define ll int64_t
#define pb push_back
// #define int ll
#define pii pair <int, int>
#define pll pair <long long, long long>
#define endl '\n'
#include <random>
#define PI (2.0 * acos(0.0))
#define testcase int T; cin >> T; for (int tc = 1; tc <= T; tc++)
//#define info pair<int, pair < int, string > >

#define mkp make_pair
#define info pair < int, pii > 
// template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
struct custom_hash {
static uint64_t splitmix64(uint64_t x) {
// http://xorshift.di.unimi.it/splitmix64.c
x += 0x9e3779b97f4a7c15;
x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
return x ^ (x >> 31);
}

size_t operator()(uint64_t x) const {
static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
return splitmix64(x + FIXED_RANDOM);
}
};
int fx[10] = {0, 1, 0, -1, 1, -1, 1, -1};
int fy[10] = {1, 0, -1, 0, 1 , -1, -1, 1};
const long long M = 2e5 + 10, M2 = 2e6 + 10, oo = 1e9 + 7, mod = 998244353;
const long long MC = (1 << 20) + 5;
int ceil(int a, int b) {
return (a + b - 1) / b;
}
// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
// ceil is a bad function
// think about reverse process
// read statement carefully
// think about corner cases before *implementing*
// don't forget to comment/uncomment define endl in interractive/non-interractive problems
// don't forget to return value in a return type function
// check if you are returning from solve before resetting array values
// try not to use continue statement
// try to write custom functions if stl one deals with floating point values
void madd (int& a, int b) {
a = (a + b) % mod;
}
void precomp() {
}
void solve () {
int n, d;
cin >> n >> d;
int dp[n + 2][(1LL << (2 * d + 1)) + 5];
int ara[n + 2];
for (int i = 0; i < n + 2; i++) {
for (int j = 0; j < (1LL << (2 * d + 1)) + 5; j++) {
dp[i][j] = 0;
}
ara[i] = 0;
}

for (int i = 1; i <= n; i++) {
cin >> ara[i];
}
dp[1][0] = 1;
for (int i = 1; i <= n; i++) {
for (int mask = 0; mask < (1LL << (2 * d + 1)); mask++) {
//cout << dp[i][mask] << endl;
int nmask = (mask / 2);
//if (dp[i][mask]) cout << mask << " " << i << " " << nmask << " " << dp[i][mask] <<  endl;
if (ara[i] != -1) {
int curd = ara[i];
int dig = curd + d - i;
if ((nmask >> dig)&1) continue;
else madd(dp[i + 1][nmask | (1LL << dig)], dp[i][mask]);
continue;
}
for (int dig = 0; dig < (2 * d + 1); dig++) {
int curd = i + dig - d;
if (curd <= 0 || curd > n) continue;
if (!((nmask >> dig)&1)) madd(dp[i + 1][nmask | (1LL << dig)], dp[i][mask]);
}
}
}
int pre = 1;
pre = max(pre, n - d);
int post = n;
post = min(post, n + d);
int tot = post - pre + 1;
//cout << tot << endl;
cout << dp[n + 1][(1LL << tot) - 1] << endl;
}
int32_t main () {
//freopen("E:/newts/in.txt", "r", stdin);
//freopen("E:/newts/out.txt", "w", stdout);
ios_base::sync_with_stdio(false);
cin.tie(NULL);
precomp();
// int T;
//scanf("%d", &T);
//while (T--) {
// testcase {
// cout << "Case #" << tc << ": "; 
solve (); 
// }
return 0;
}
//include
//------------------------------------------
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include<queue>
using namespace std;
//conversion
//------------------------------------------
inline long long toint(string s) {long long v; istringstream sin(s);sin>>v;return v;}
template<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}
//math
//-------------------------------------------
template<class T> inline T sqr(T x) {return x*x;}
//typedef
//------------------------------------------
typedef long long ll;
typedef long long LL;
typedef vector<int > vi;
typedef vector<long long > VLL;
typedef vector<long long > vll;
typedef vector<string > ves;
typedef vector<char > vech;

typedef pair<long long , long long> pll;
typedef pair<long long , long long> PLL;
typedef map<ll , ll >mll;
typedef map<int , int >mii;
typedef map<char , int >mci;
typedef map<char , ll >mcl;
typedef vector<pair<ll , ll> > vpll;

//container util
//------------------------------------------
#define ALL(a)  (a).begin(),(a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define VECMAX(x) *max_element(ALL(x))
#define VECMIN(x) *min_element(ALL(x))
#define PB push_back
#define MP make_pair
#define SZ(a) int((a).size())
#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)
#define EXIST(s,e) ((s).find(e)!=(s).end())
#define SORT(c) sort((c).begin(),(c).end())
//repetition
//------------------------------------------
#define FOR(i,a,b) for(long long i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
//#define MULTIPLE(i,n,k) for(int i = (k) ; i<(n) ; i+=k+1)//倍数ループ
//constant
//------------------------------------------
const double EPS = 1e-10;
const double PI  = acos(-1.0);
//clear memory
#define CLR(a) memset((a), 0 ,sizeof(a))
//debug
#define dump(x)  cerr << #x << " = " << (x) << endl;
#define debug(x) cerr << #x << " = " << (x) << " (L" << __LINE__ << ")" << " " << __FILE__ << endl;
#define SIZEOF(x) sizeof(x)/sizeof(x[0])


const long long INF = 4e18;
const long long NINF = 1 - INF;

#define ENDL cout << endl;
#define CIN(a) REP(i,a.size())cin >> a[i];

//二次元座標の点を表す構造体。xとyをメンバに持つ
struct POINT{
double x;
double y;

};







/*

木のプロトタイプ

SubTreeSize:=部分木のサイズ
add_edgeで辺を追加、buildで構築
rev[d]:=rootからの距離がdであるような頂点の集合,
dが大きい方から見ていく->木の下の方から上の方へ登っていく道のりでDPできる
center := 木の重心(未実装)

dist[i]:=頂点iまでの重み無しの距離
cost[i]:=頂点iまでの重み付き距離
LCAもできる


*/      
template<class T>
class Tree{
public:
//隣接グラフ　, secondはcost
vector<vector<pair< long long , T > > > G;
long long size;//木のサイズ
long long root;//木の根
//親を求める
vector<vector<long long>> parent;  // parent[k][u]:= u の 2^k 先の親


long long center;//木の重心(未実装)

vector<long long> SubTreeSize;//部分木のサイズ

vector<vector<long long> >rev; // rev[d] := 根からの距離がdであるような頂点の集合
//根からの距離が遠い方から上の方へ上がっていく道でDPする

vector<long long > dist;//根から各頂点への距離()
vector<T> cost;

Tree(long long size_){
size = size_;
vector<vector<pair<long long , T> > >(size).swap(G);
}


~Tree(){}

//u-vに有向辺を追加,costはデフォルトなら1
void add_edge(long long u , long long v , T cost = 1){
G[u].push_back(make_pair(v,cost));
}   


//rootを初期化し、構築する
void build(long long root_){

//------宣言パート--------
root = root_;

vector<long long>(size , -1).swap(dist);//重み無しの距離
vector<long long>(size , NINF).swap(cost);//重み有りの距離(こっちは負になる可能性あり)
vector<long long>(size , 1).swap(SubTreeSize);
int K = 1;
while ((1 << K) < size) K++;
vector<vector<long long> >(K, vector<long long>(size, -1)).swap(parent);
//-----------------------


stack<long long> st;
st.push(root);
dist[root] = 0;
cost[root] = 0;

//dist、parentの構築
while(!st.empty()){
long long now = st.top();
st.pop();
for(pair<long long , T > nx:G[now]){
if(dist[nx.first]==-1){
st.push(nx.first);
dist[nx.first] = dist[now] + 1;
parent[0][nx.first] = now;//親を決める
}

if(cost[nx.first] == NINF){
cost[nx.first] = cost[now] + nx.second;
}

}
}

//parentでダブリング
for (int k = 0; k + 1 < K; k++) {
for (int v = 0; v < size; v++) {
if (parent[k][v] < 0) {
parent[k + 1][v] = -1;
} else {
parent[k + 1][v] = parent[k][parent[k][v]];
}
}
}

//revの構築
long long mx = *max_element(ALL(dist));
vector<vector<long long> >(mx+1).swap(rev);
for(long long i = 0 ; i < dist.size() ; i++){
if(dist[i]!=-1)rev[dist[i]].push_back(i);
}

//部分木の計算
for(long long d = rev.size()-1;d>=0;d--){
for(long long now : rev[d]){
for(pair<long long , T> nx : G[now]){
if(dist[now]>dist[nx.first]){
SubTreeSize[nx.first]+=SubTreeSize[now];//DP演算
}
}
}
}


}


//LCAを求める
int query(int u, int v) {
if (dist[u] < dist[v]) swap(u, v);  // u の方が深いとする
int K = parent.size();
// LCA までの距離を同じにする
for (int k = 0; k < K; k++) {
if ((dist[u] - dist[v]) >> k & 1) {
u = parent[k][u];
}
}
// 二分探索で LCA を求める
if (u == v) return u;
for (int k = K - 1; k >= 0; k--) {
if (parent[k][u] != parent[k][v]) {
u = parent[k][u];
v = parent[k][v];
}
}
return parent[0][u];
}




};












ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }
ll lcm(ll a, ll b) { return (a / gcd(a, b)) * b; }

/*
nCr , 値が大きいとオーバーフローする
n<=kなら1 (0C1や1C5= 1)
*/
ll nCr(ll n,  ll r){
if ( r * 2 > n ) r = n - r;
ll dividend = 1;
ll divisor  = 1;
for ( unsigned int i = 1; i <= r; ++i ) {
dividend *= (n-i+1);
divisor  *= i;
}
return dividend / divisor;
}



//firstが最大値（最小値） , second が index
template<class T>
pair<T , ll> maxP(vector<T> a , ll size){
pair <T , ll> p;
ll ind = 0;
T mx = NINF;
REP(i,size){
if(mx<a[i]){
mx = a[i];
ind = i;
}
}
p.first = mx;
p.second = ind;
return p;
}


template<class T>
pair<T , ll> minP(vector<T> a , ll size){
pair <T , ll> p;
T mn = INF;
ll ind = 0;
REP(i,size){
if(mn > a[i]){
mn = a[i];
ind = i;
}
}
p.first = mn;
p.second = ind;
return p;
}

template<class T>
T sumL(vector<T> a , ll size){
T sum = 0;
REP(i,size){
sum += a[i];

}
return sum;
}


//sort済みのvll ; a のleft ~ rightにtがいくつあるか
ll counT(VLL a ,ll left , ll right ,  ll t ){
//sort(a.begin(),a.end());
return upper_bound(a.begin() + left , a.begin() + right,t)-lower_bound(a.begin() + left , a.begin() + right, t);
}

//切り上げ
ll kiriage(ll a , ll b){
return a/b + (a%b!=0);
}

#define COUNT(a,b) counT((a),0,a.size(),(b))

#define MAX(x) maxP(x,x.size())
#define MIN(x) minP(x,x.size())
#define SUM(x) sumL(x,x.size())




//-------要素を見つける-----------
ll search(vll &a , ll n ){//a内のnのindexを返す
std::vector<ll>::iterator iter = std::find(a.begin(), a.end(), n);
size_t index = distance(a.begin(), iter);
return index;
}


//桁数
int getdigit(ll n){
return log10(n)+1;
}



// toBinary[i]は,binaを二進数で表したときの下からi桁目のbitが入ってる
vll toBinary(ll bina){
vll ans;
for (ll i = 0; bina>0 ; i++)
{
ans.push_back(bina%2);
bina = bina/2;
}
return ans;
}



//-----------MAIN:困った時メモ------------//
//    
//    Sqrは２乗 sqrtはルート , 二次元座標の点は struct POINT でも表せる(メンバはx , y)
//    小さい順ならpriority_queue<ll, vll, greater<ll> > と書く
//    ゲーム:grundy数 , グラフ:LCA,eulerTour,　
//    最大流がScalingMaxFlow , 最小費用流がPrimalDual<flow_t , cost_t>
//    めぐる式二分探索 , 半分前列挙
//    bitDP , 最小全域木でコストやグラフを求める , オイラーツアー , 0-1BFS 
//    オイラーツアーはDFS , 全域木はDFS , 三分探索
//    区間スケジューリング問題(右端が小さい順にソート)
//    定数倍(log)を落とすことで通ることもたまにある(setやmapに注意)
//    度数　＝ ラジアン × 180 ÷ 円周率
//    競技プログラミングでは「数が少ない方を考えると考察が進む場合がある」という典型テクニックがあります。
//    std::mapをループするときは、for(pair<type,type> x(要素): MAP)
//    期待値の線形性, 平均値は期待値の特殊な場合 

//    二次元累積和の計算 : s[i+1][j+1] = s[i][j+1] + s[i+1][j] - s[i][j] + a[i][j];
//    (a,b) -> (c,d)の二次元累積和 : s[c][d] - s[a][d] - s[b][c] + s[a][b]

//    multisetは便利 , 値の重複、upperbound、追加削除がlogN , *rbeginで最大値,*beginで最小値

#define ENDL cout << endl;







// グラフを受け取り、そのトポロジカルソートを記録した配列を返す関数
vector<ll> topological_sort(vector<vector<ll> > &G) {

ll V = G.size();

vector<ll> indegree(V,0);


REP(i,V){
for(ll x:G[i]){
indegree[x]++;
}
}

// トポロジカルソートを記録する配列
vector<ll> sorted_vertices;

// 入次数が0の頂点を発見したら、処理待ち頂点としてキューに追加する
queue<ll> que;
for (ll i = 0; i < V; i++) {
if (indegree[i] == 0) {
que.push(i);
}
}


// キューが空になるまで、操作1~3を繰り返す
while (que.empty() == false) {
// キューの先頭の頂点を取り出す
ll v = que.front();
que.pop();

// その頂点と隣接している頂点の入次数を減らし、0になればキューに追加
for (ll i = 0; i < G[v].size(); i++) {
ll u = G[v][i];
indegree[u] -= 1;
if (indegree[u] == 0) que.push(u);
}
// 頂点vを配列の末尾に追加する 
sorted_vertices.push_back(v);
}

// トポロジカルソートを返す

return sorted_vertices;
}





//MODの計算
//MODの計算
//MODの計算
//MODの計算

//modpow : O(logN) 
long long modpow(long long a, long long n, long long mod) {
long long res = 1;
while (n > 0) {
if (n & 1) res = res * a % mod;
a = a * a % mod;
n >>= 1;
}
return res;
}


//逆元(mod)
long long modinv(long long a, long long m) {
long long b = m, u = 1, v = 0;
while (b) {
long long t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
u %= m;
if (u < 0) u += m;
return u;
}

//modの割り算
ll moddiv(ll a , ll b , ll m){
a%=m;
return a*modinv(b,m)%m;
}


// a^x ≡ b (mod. m) となる最小の正の整数 x を求める
long long modlog(long long a, long long b, long long m) {
a %= m, b %= m;

// calc sqrt(M)
long long lo = -1, hi = m;
while (hi - lo > 1) {
long long mid = (lo + hi) / 2;
if (mid * mid >= m) hi = mid;
else lo = mid;
}
long long sqrtM = hi;

// {a^0, a^1, a^2, ..., a^sqrt(m)} 
map<long long, long long> apow;
long long amari = a;
for (long long r = 1; r < sqrtM; ++r) {
if (!apow.count(amari)) apow[amari] = r;
(amari *= a) %= m;
}

// check each A^p
long long A = modpow(modinv(a, m), sqrtM, m);
amari = b;
for (long long q = 0; q < sqrtM; ++q) {
if (amari == 1 && q > 0) return q * sqrtM;
else if (apow.count(amari)) return q * sqrtM + apow[amari];
(amari *= A) %= m;
}

// no solutions
return -1;
}




/*
//nが大きい場合用のmodcomb
//nが大きい場合用のmodcomb
//Modが素数の場合が安全
//Modが素数の場合が安全
//計算量はO(r)
計算量はO(r)
*/
ll modcomb(ll n , ll r , ll Mod){
ll N = 1;
ll K = 1;
REP(i,r){
N*=(n-i)%Mod;
K*=(i+1)%Mod;
N%= Mod;
K%= Mod;
}
return (N*modinv(K,Mod))%Mod;
//modinvはKの逆元を求めている

//modinvの別解:
//Modが素数の時、Y^(Mod-1) = Y*(Y^Mod-2) = 1 (mod Mod)
//よってY^(Mod-2) = Y^(-1) = 1/Y (mod Mod)

//よって nCk = {n*(n-1)* ... *(n-k+1)} / (k!)
//は nPk * (k!)^(-1) = nPk * modpow(k! , Mod-2 , Mod)である

}





ll n , m , k , h , w;
string s;
mll p;

bool isin(ll y , ll x){
return y>=0 && y < h && x >= 0 && x<w;
}



//-----------MODつきCombination------------//
/*
これは何度も計算で使う場合用、MAXが小さい時(10000000とか)じゃないとダメ(引数:max ,mod)
先にCOMinit()で初期化
*/
class ModComb{

//これは何度も計算で使う場合用、MAXが小さい時(10000000とか)じゃないとダメ
//これは何度も計算で使う場合用、MAXが小さい時(10000000とか)じゃないとダメ
public:
vll fac ;
vll finv ;
vll inv ;
ModComb(ll MAX_ , ll MOD_):fac(MAX_),finv(MAX_),inv(MAX_){
MAX = MAX_;
MOD = MOD_;
}
~ModComb(){
std::vector<ll>().swap(fac);
std::vector<ll>().swap(finv);
std::vector<ll>().swap(inv);
}
int MAX;
int MOD;


// テーブルを作る前処理
void COMinit() {
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++){
fac[i] = fac[i - 1] * i % MOD;
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
finv[i] = finv[i - 1] * inv[i] % MOD;
}
}

// 二項係数計算
long long COM(int n, int k){
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
}

};





/*  
game探索のプロトタイプ(後退解析,Grundy数)
0-indexedの方が良さそう

add_edgeで有向辺を加えて、buikdで構築

後退解析 : state[x]:= -1(引き分け) , 0(負け、終了状態)　, 1(勝利)
Nは現実的なサイズならOK

Grundy数 : Grundy[x] グラフをトポロジカルソートし、後ろから前にGrundy数(のMex)を伝搬させる

*/
class Game{
//少し不安です
private:


//ここら辺の値は不変
vector<long long> degree;//頂点iから出てる辺の個数(何も出てない場合は負け(終了状態))
vector<long long> indegree;//頂点iに入る辺の個数
vector<vector<long long > >G;//状態遷移のグラフ
vector<vector<long long > >G_inv;//後退解析したいので辺の向きを逆に



long long mex(vector<long long> v){//mexの計算
if(v.size()==0)return 0;
vector<int> M(v.size()+1,0);
for(long long x: v)if(x>=0&&x<=v.size())M[x]=1;

for(int res = 0 ; res < M.size();res++)if(M[res] == 0) return res;
return 0;
}




// グラフ、頂点の入次数、頂点数を受け取り、そのトポロジカルソートを記録した配列を返す関数
vector<long long> topological_sort(vector<vector<long long> > G, vector<long long> indegree, int V) {
// トポロジカルソートを記録する配列
vector<long long> sorted_vertices;

// 入次数が0の頂点を発見したら、処理待ち頂点としてキューに追加する
queue<long long> que;
for (int i = 0; i < V; i++) if (indegree[i] == 0) que.push(i);

// キューが空になるまで、操作1~3を繰り返す
while (que.empty() == false) {
// キューの先頭の頂点を取り出す
long long v = que.front() ;  que.pop();

// その頂点と隣接している頂点の入次数を減らし、0になればキューに追加
for (int i = 0; i < G[v].size(); i++) {
int u = G[v][i];
indegree[u] -= 1;
if (indegree[u] == 0) que.push(u);
}
sorted_vertices.push_back(v);// 頂点vを配列の末尾に追加する 
}

return sorted_vertices;
}





public:
long long N;
vector<long long> Grundy;//grundy数を格納
vector<long long> state;//-1なら引き分け,0なら負け(終了),1なら勝ち

Game(){}
Game(long long size){
init(size);
}



void init(long long size){
N=size;

vector<vector<long long > >(N).swap(G);
vector<vector<long long > >(N).swap(G_inv);

//入次数と出次数
vector<long long>(N , 0).swap(degree);
vector<long long>(N , 0).swap(indegree);


}



//u->vの有向辺
void add_edge(long long u , long long v){
if(max(u,v)>=N){
cerr<<"out of index"<<endl;
return;
}else if(min(u,v)<0){
cerr<<"out of index"<<endl;
return;
}
G[u].push_back(v);
G_inv[v].push_back(u);
}

void build(){
REP(u,N){
degree[u]=G[u].size();
for(long long v : G[u]){
indegree[v]++;
}

}
}

void Backward(){
vector<long long>(N,-1).swap(state);
//stateを初期化、辺が出てない頂点が終了状態
vector<long long> Deg = degree;
REP(x,N){
if(Deg[x]==0){
state[x] = 0;
}
}   


queue<long long> Q;

REP(x,N){
//終了状態を持った状態でスタート
if(state[x] == 0){Q.push(x);}
}
while(!Q.empty()){
long long v = Q.front();
Q.pop();
//逆辺を辿っていける頂点
for(long long pre : G_inv[v]){
if(state[pre]!=-1){
continue;
}
Deg[pre]--;//preにつながる辺を切ります。
if(state[v]==0){    
state[pre] = 1;
Q.push(pre);
}else if(state[v]==1 && Deg[pre]==0){
//vが終了状態でなく、辺(pre,v)以外が全て探索済み(切られている)場合
state[pre] = 0;
Q.push(pre);
}
}
}


}


void GrundyCalc(){
vector<long long>(N , -1).swap(Grundy);
//Gをトポロジーソートしたやつ
vector<long long> G_tp = topological_sort(G,indegree,N);

//MexVector[v]:= 頂点vから行ける頂点たちのGrundy数を保管
vector<vector<long long> > MexVector(N);

//トポロジカル順で後ろの方から前の方へ逆辺を辿って.
//頂点ごとのGrundy数を伝搬していく.  
for(long long i = G_tp.size()-1;i>=0;i--){   

long long nw = G_tp[i]; 

//自分から行ける頂点のGrundy数のMexを計算
Grundy[nw] = mex(MexVector[nw]);

//pre:G_inv ... preはnwからの逆辺を辿っていける頂点
for(long long pre : G_inv[nw]){
//自分よりも前の頂点のMex配列に渡す。
MexVector[pre].push_back(Grundy[nw]);
}
}

}



};
























/*
Yu_ki.Iさんのをコピペしました。

最初は全て０で初期化(各要素はaddで構築していく)
コンストラクタにはsizeと mode(0か0以外)
modeが0 -> RangeMinQuery
modeが0以外　-> RangeMaxQuery

add -> 区間[a , b)に加算
*/
struct RangeAddMinMax{
private:
int siz;
vector<long long> node,lazy;
long long seg_inf;
int mode;

long long ope(long long a , long long b){
long long res;
if(mode == 0){
res = min(a,b);
}else{
res = max(a,b);
}
return res;
}

public:
RangeAddMinMax(long long n , int mode_){
mode = mode_;
if(mode==0){
seg_inf = 4e18;
}else{
seg_inf = 1 - (4e18) ;
}
siz=1;
while(siz<=n) siz*=2;
node.resize(siz*2-1,0);
lazy.resize(siz*2-1,0);

}
void eval(long long k){
node[k]+=lazy[k];
if(k<siz-1){
lazy[2*k+1]+=lazy[k];
lazy[2*k+2]+=lazy[k];
}
lazy[k]=0;
}
void plus(int a,int b,long long x,int k,int l,int r){
eval(k);
if(r<=a||b<=l) return;
if(a<=l&&r<=b){
lazy[k]+=x;
eval(k);
}
else{
plus(a,b,x,2*k+1,l,(l+r)/2);
plus(a,b,x,2*k+2,(l+r)/2,r);
node[k]=ope(node[2*k+1],node[2*k+2]);
}
}

void add(int a,int b,long long x){
plus(a,b,x,0,0,siz);
}
long long query_sub(int a,int b,int k,int l,int r){
eval(k);
if(r<=a||b<=l) return seg_inf;
if(a<=l&&r<=b) return node[k];
else return ope(query_sub(a,b,2*k+1,l,(l+r)/2),query_sub(a,b,2*k+2,(l+r)/2,r));
}
long long query(int s,int t){
return query_sub(s,t,0,0,siz);
}
};







/*

vector<vll> Gで初期化(Scc(G)) ,宣言時に強連結成分分解を構築する(initする必要なし)

component[x] := 頂点xの属する強連結成分の番号(トポロジカル順(入次数順))
なお、component[x]+1の最大値がグラフ内の強連結成分の個数

mll p; for(ll y : component)p[y]++; -> p[x] = トポロジカル順でx番目の強連結成分に属する頂点の個数

vector<vll> rebuild() := 強連結成分を一つの頂点として見たグラフを生成
*/
struct Scc {
ll n;
vector<vector<ll>> G, rG;
vector<ll> order, component;//component[x] := 頂点xの属する強連結成分の番号
vector<bool> used;

void dfs(int v) {
used[v] = 1;
for (auto nv : G[v]) {
if (!used[nv]) dfs(nv);
}
order.push_back(v);
}
void rdfs(int v, int k) {
component[v] = k;
for (auto nv : rG[v]) {
if (component[nv] < 0) rdfs(nv, k);
}
}

Scc(vector<vector<ll> > &_G) {
n = _G.size();
G = _G;
rG.resize(n);
component.assign(n, -1);
used.resize(n);
for (int v = 0; v < n; v++) {
for (auto nv : G[v]) rG[nv].push_back(v);
}
for (int v = 0; v < n; v++) if (!used[v]) dfs(v);
int k = 0;
reverse(order.begin(), order.end());
for (auto v : order) if (component[v] == -1) rdfs(v, k), k++;
}

/// 頂点(u, v)が同じ強連結成分に含まれるか
bool is_same(int u, int v) { return component[u] == component[v]; }

/// 強連結成分を1つのノードに潰したグラフを再構築する
vector<vector<ll>> rebuild() {
int N = *max_element(component.begin(), component.end()) + 1;
vector<vector<ll>> rebuildedG(N);
set<pair<int, int>> connected;
for (int v = 0; v < N; v++) {
for (auto nv : G[v]) {
if (component[v] != component[nv] and !connected.count(MP(v, nv))) {
connected.insert(MP(v, nv));
rebuildedG[component[v]].push_back(component[nv]);
}
}
}
return rebuildedG;
}
};



















/*
コンストラクタにvector<vector<double> >
各方程式において、変数の位置は全て同じにしてください。
a[i]はi番目の方程式
aの大きさはN , a[0]の大きさは定数項を含めてN+1
各変数の値はS.ansに格納 
ans[i] := 左からi番目の変数の値
ex. ax + by + cz = d -> a[i] = {a,b,c,d}とする(注意!!!)
*/
class  SimultaneousEquation{
public:
vector<vector<double > > a;
int N;//変数の個数


vector<double> ans;
// 各種変数
double d;     // ダミー
int i, j, k;  // LOOP インデックス


SimultaneousEquation(vector<vector<double> >a_){
init(a_);
}


void init(vector<vector<double> >a_){
int fl = 1;
for(int i = 0 ; i < (int)a_.size()-1 ; i++){
if(a_[i].size()!=a_[i+1].size()){
fl = 0;
}
}
if(fl && a_.size() >0 && a_.size()+1==a_[0].size()){
a = a_;
N=a.size();
vector<double>(N,-1).swap(ans);
}else{
cerr<<"inValid Size"<<endl;
}
}


// 連立方程式を解く（ガウスの消去法）
void calcGaussElimination(){

// 前進消去
for (k = 0; k < N -1; k++) {
for (i = k + 1; i < N; i++) {
d = a[i][k] / a[k][k];

for (j = k + 1; j <= N; j++)
a[i][j] -= a[k][j] * d;
}
}

// 後退代入
for (i = N - 1; i >= 0; i--) {
d = a[i][N];
for (j = i + 1; j < N; j++)
d -= a[i][j] * a[j][N];
a[i][N] = d / a[i][i];
}

// 結果
for (k = 0; k < N; k++)ans[k]=a[k][N];

}

};









// 行列ライブラリ

// size(): 行数を返す (列数は mat[0].size() で)
// 演算子: 複合代入 (+=, *=, -=), 単項 (-), 二項 (+, -, *, ==)
// eigen(N): N*N 単位行列を返す
// pow(mat, k): mat の k 乗を返す

template <typename T>
struct Matrix {
vector< vector<T> > mat;
Matrix() {}
Matrix(int h, int w, T val = T(0)) : mat(h, vector<T>(w, val)) {}
size_t size() const { return mat.size(); }
const vector<T>& operator[](int i) const { return mat[i]; }
vector<T>& operator[](int i) { return mat[i]; }

Matrix<T> &operator+=(const Matrix<T>& rhs) {
assert(mat.size() == rhs.size());
assert(mat[0].size() == rhs[0].size());
for(size_t i=0; i<mat.size(); i++) {
for(size_t j=0; j<mat[0].size(); j++) {
mat[i][j] += rhs[i][j];
}
}
return *this;
}

Matrix<T> operator-() const {
Matrix<T> res(*this);
for(size_t i=0; i<res.size(); i++) {
for(size_t j=0; j<res[0].size(); j++) {
res[i][j] *= T(-1);
}
}
return res;
}

Matrix<T>& operator-=(const Matrix<T>& rhs) {
return (Matrix<T>(*this) += -rhs);
}

Matrix<T>& operator*=(const Matrix<T>& rhs) {
assert(mat[0].size() == rhs.size());
size_t H = mat.size(), W = rhs[0].size(), C = rhs.size();
Matrix<T> res(H, W);
for(size_t i=0; i<H; i++) {
for(size_t j=0; j<W; j++) {
for(size_t k=0; k<C; k++) {
res[i][j] += mat[i][k] * rhs[k][j];
}
}
}
this->mat = res.mat;
return *this;
}

Matrix<T> operator+(const Matrix<T>& rhs) {
return (Matrix<T>(*this) += rhs);
}

Matrix<T> operator*(const Matrix<T>& rhs) {
return (Matrix<T>(*this) *= rhs);
}

Matrix<T> operator-(const Matrix<T> &rhs) {
return (Matrix<T>(*this) -= rhs);
}

bool operator==(const Matrix<T> &rhs) const {
return this->mat == rhs.mat;
}
bool operator!=(const Matrix<T> &rhs) const {
return !(*this == rhs);
}
};

template <typename T>
Matrix<T> eigen(size_t N) {
Matrix<T> res(N, N, 0);
for(size_t i=0; i<N; i++) res[i][i] = T(1);
return res;
}

template <typename T>
Matrix<T> pow(Matrix<T> mat, long long int k) {
Matrix<T> res = eigen<T>(mat.size());
for(; k>0; k>>=1) {
if(k & 1) res *= mat;
mat *= mat;
}
return res;
}

template <typename T>
ostream& operator<< (ostream& out, Matrix<T> mat) {
int H = mat.size(), W = mat[0].size();
out << "[" << endl;
for(int i=0; i<H; i++) {
out << "  [ ";
for(int j=0; j<W; j++) out << mat[i][j] << " ";
out << "]" << endl;
}
out << "]" << endl;
return out;
}










int main(){

ll n , m  ,q;
cin >> n;
vector<vll> a(300) , b(300);
REP(i,n){
ll x , y;
cin >> x >> y;
a[x].push_back(y);
}
REP(i,n){
ll x , y;cin >> x >> y;
b[x].push_back(y);
}

ll ans = 0;
set<ll> used , unused;
REP(i,300){

if(a[i].size()!=0){
for(ll y:a[i])unused.insert(y);
}

if(b[i].size()==0){
continue;
}else{
auto it = unused.upper_bound(b[i][0]);
if(it==unused.begin())continue;
it--;            


unused.erase(it);
//debug(*it)
ans++;



}
}
cout << ans << endl;

return 0;       

}


#include<bits/stdc++.h>
#include<atcoder/all>
using namespace std;
using namespace atcoder;

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;

#define ll long long
#define ull unsigned long long
#define rep(i, n) for(int i = 0; i < n; i++)
#define rep2(i, a, b) for(int i = a; i <= b; i++)
#define rrep(i, n) for(int i = n; i >= 0; i--)
#define rrep2(i, a, b) for(int i = a; i >= b; i--)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define eb emplace_back
#define fi first
#define se second
#define sz(x) (int)x.size()
#define pii pair<int, int>
#define pll pair<ll, ll>
#define endl '\n'
template<class T> using pq = priority_queue< T >;
template<class T> using pqg = priority_queue< T , vector< T >, greater< T >>;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }

ll digit(ll x){
string s = to_string(x);
return (ll)s.size();
}
#define debug(arg) print(#arg, arg)

// std::cerr << arg が元々使えるやつはそれを使う
template <class Tp> void out(Tp arg) {
std::cerr << arg;
}
// std::pair の出力
template <class Tp1, class Tp2> void out(std::pair<Tp1, Tp2> arg) {
std::cerr << '(';
out(arg.first);
std::cerr << ", ";
out(arg.second);
std::cerr << ')';
}
// std::tuple の出力
template <class T, std::size_t... Is> void print_tuple(T arg, std::index_sequence<Is...>) {
static_cast<void>(((std::cerr << (Is == 0 ? "" : ", "), out(std::get<Is>(arg))), ...));
}
template <class... Ts> void out(std::tuple<Ts...> arg) {
std::cerr << '(';
print_tuple(arg, std::make_index_sequence<sizeof...(Ts)>());
std::cerr << ')';
}
// std::{vector, deque, forward_list, list, initializer_list, set, multiset, unordered_set, unordered_multiset, map, multimap, unordered_map, unordered_multimap, valarray} の出力
template <template <class...> class Container, class... Ts>
void out(Container<Ts...> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](typename Container<Ts...>::value_type elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}
// std::array の出力
template <class Tp, std::size_t N> void out(std::array<Tp, N> arg) {
std::cerr << "[ ";
std::for_each(std::cbegin(arg), std::cend(arg), [](Tp elem) {
out(elem);
std::cerr << ' ';
});
std::cerr << ']';
}

template <class Tp> void print(std::string_view name, Tp arg) {
std::cerr << name << ": ";
out(arg);  // out 関数を使うように変更
std::cerr << '\n';
}

const int inf = 1001001001;
const ll INF = 1001001001001001001;

const double PI = acos(-1);

bool range(int y, int x, int h, int w){
return (0 <= y && y < h && 0 <= x && x < w);
}
int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};

using mint = modint998244353;
const int MOD = 998244353;
//using mint = modint1000000007;
//const int MOD = 1000000007;

signed main(){
cout << fixed << setprecision(15);

int N;
string S;
cin >> N >> S;
int LE = 0, LW = 0, RE = 0, RW = 0;
rep(i, N){
if(S[i] == 'E') RE++;
else RW++;
}
int ans = N;
rep(i, N){
if(S[i] == 'E') RE--;
else RW--;
chmin(ans, LW + RE);
if(S[i] == 'E') LE++;
else LW++;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
#define For(i,x,y,...) for(int i=x,##__VA_ARGS__;i<=(y);++i)
#define rFor(i,x,y,...) for(int i=x,##__VA_ARGS__;i>=(y);--i)
#define Rep(i,x,y,...) for(int i=x,##__VA_ARGS__;i<(y);++i)
#define mem(a,x,n) memset(a,x,sizeof(*(a+0))*(n+1))
#define pb emplace_back
#define sz(a) int(a.size())
#define all(a) a.begin(),a.end()
#define MT make_tuple
#define MP make_pair
#define fi first
#define se second
#define priority_queue __gnu_pbds::priority_queue
typedef long long LL; typedef unsigned long long ULL;
typedef pair<int,int> PII; typedef vector<int> VI;
char buf[1<<22],*p1=buf,*p2=buf,pbuf[1<<22],*pp=pbuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
#define ocl() fwrite(pbuf,1,pp-pbuf,stdout),pp=pbuf,0
#define putchar(x) pp-pbuf==1<<22&&(ocl()),*pp++=x
template<typename T>void read(T &x){
x=0;bool f=1;char c;
while(!isdigit(c=getchar()))if(c=='-')f=0;
if(f)for(;isdigit(c);c=getchar())x=x*10+c-48;
else for(;isdigit(c);c=getchar())x=x*10-c+48;
if(c=='.')for(T i=f?10:-10;isdigit(c=getchar());i*=10)x+=(c^48)/i;
}
template<typename T,typename ...Args>void read(T &x, Args &...args)
{ read(x),read(args...); }
template<typename T>void write(T x,char y=10) {
if(!x)putchar(48);
else{static int s[44];int l=0;if(x<0)putchar('-'),x=-x;
for(;x;x/=10)s[l++]=x%10;while(l)putchar(s[--l]|48);}
putchar(y);
}
template<typename X,typename Y>void ckmax(X &x,Y y) { if( x < y ) x = y; }
template<typename X,typename Y>void ckmin(X &x,Y y) { if( y < x ) x = y; }
const int mod = 998244353;
template<typename X,typename Y>void ckadd(X &x,Y y) { x = x+y<mod?x+y:x+y-mod; }
template<typename X,typename Y>void ckdel(X &x,Y y) { x = x-y<0?x-y+mod:x-y; }
LL Pow(LL x,LL y=mod-2) {LL z=1;for(;y;y>>=1,x=x*x%mod)if(y&1)z=z*x%mod;return z;}

const int N = 55;
int n,m,d,ans,fa[N],siz[N],cnt[N];
LL s[N],f[N*N*N];
VI id;

void upd(int v,LL w) { rFor(i,n*n*n,v) ckmin(f[i],f[i-v]+w); }

signed main() {
#ifdef JK
freopen("a.in","r",stdin);// freopen("a.out","w",stdout);
#endif
memset(f,0x3f,sizeof f);
read(n,m,d,s[1]); siz[1] = 1, cnt[1] = n;
For(i,2,n) read(s[i],fa[i]), siz[i] = 1;
rFor(i,n,2) siz[fa[i]] += siz[i], s[fa[i]] += s[i], cnt[i] = min(n,d);
f[0] = 0;
For(i,1,n) {
int rest = cnt[i];
for(int j = 1; j <= rest; rest -= j, j <<= 1)
upd(j*siz[i],j*s[i]);
if( rest ) upd(rest*siz[i],rest*s[i]);
}
For(i,1,n) id.pb(i);
sort(all(id),[](const int &x,const int &y){return siz[x]*s[y]>siz[y]*s[x];});
For(i,0,n*n*n) if( f[i] <= m ) {
int res = i, rest = m-f[i];
for(int j : id) {
int k = rest / s[j];
if( j != 1 ) ckmin(k,d-cnt[j]);
res += k*siz[j], rest -= k*s[j];
}
ckmax(ans,res);
}
write(ans);
//	For(i,1,n) cerr<<siz[i]<<" "<<s[i]<<" "<<cnt[i]<<endl;
//	for(int i : id) cerr<<i<<" "; cerr<<endl;
//	For(i,0,n*n*n) cerr<<f[i]<<" "; cerr<<endl;
return ocl();
}

#include <bits/stdc++.h>
using namespace std;

int main() {
int A, B, C, X, Y;
cin >> A >> B >> C >> X >> Y;

int price, C2 = 2*C;
if (X < Y) {
if (C2 < A+B) {
price = C2 * X;
} else {
price = (A + B) * X;
}
if (C2 < B) {
price += C2 * (Y - X);
} else {
price += B * (Y - X);
}
} else {
if (C2 < A+B) {
price = C2 * Y;
} else {
price = (A + B) * Y;
}
if (C2 < A) {
price += C2 * (X - Y);
} else {
price += A * (X - Y);
}
}

cout << price << endl;
}

#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;
using ll = long long;
const int INF = INT_MAX;
const ll LINF = LLONG_MAX;
bool chmin(int& a, int b){ if(a > b){ a = b; return 1; } return 0; }
bool chmax(int& a, int b){ if(a < b){ a = b; return 1; } return 0; }
int mod = 1000000007;
int mod2 = 998244353;

int main() {
int N;
string S;
cin >> N >> S;
vector<int> Emen(N, 0), Wmen(N, 0);
for (int i = 1; i < N; i++) {
if (S[i-1] == 'E') Emen[i] = Emen[i-1] + 1;
else Emen[i] = Emen[i-1];
}
for (int i = N - 2; i >= 0; i--) {
if (S[i+1] == 'W') Wmen[i] = Wmen[i+1] + 1;
else Wmen[i] = Wmen[i+1];
}
int maxv = 0;
for (int i = 0; i < N; i++) {
if (maxv < Emen[i] + Wmen[i]) {
maxv = Emen[i] + Wmen[i];
}
}
cout << N - 1 - maxv << endl;
}
#include <bits/stdc++.h>
#define mp make_pair
#define pb push_back
using namespace std;
using ll = long long int;
template<typename T>
ostream& operator+(ostream& out, const vector<T> &vec){
for(const auto &x : vec){
out<<x<<" ";
}
out<<"\n";
return out;
}
template<typename T>
ostream& operator*(ostream& out, const vector<T> &vec){
for(const auto &x : vec){
out+x;
}
return out;
}
template<typename T>
istream& operator>>(istream& in, vector<T> &vec){
for(auto &x : vec){
in>>x;
}
return in;
}
void solve(){
int n;
cin>>n;
vector<int> a(n);
cin>>a;
ll oddsum = 0, evensum = 0;
for(int i=0;i<n;i++){
if(i % 2) oddsum += max(0, a[i]);
else evensum += max(0, a[i]);
}
vector<int> op;
if(oddsum == 0 && evensum == 0){
int best = max_element(a.begin(), a.end()) - a.begin();
for(int i=0;i<best;i++) op.push_back(1);
for(int i=n-best;i>1;--i) op.push_back(i);
cout<<a[best]<<"\n";
cout<<op.size()<<"\n";
for(auto &o : op) cout<<o<<"\n";
return;
}

bool parity = (oddsum > evensum);
op.reserve(n - 1);
while(a.back() < 0 || a.size() % 2 == parity){
op.push_back(a.size());
a.pop_back();
}

vector<int>::iterator start;
for(int i=0;i<a.size();i++){
if(a[i] >= 0 && i % 2 == parity){
start = a.begin() + i; 
break;
}
else op.push_back(1);
}
a = vector<int>(start, a.end());
n = a.size();
int finsize = n;
assert(n % 2 == 1);
for(int i=n + (n % 2) - 2;i>=0;i -= 2){
if(a[i] < 0){
op.push_back(i + 1);
finsize -= 2;
}
}
while(finsize != 1){ 
op.push_back(2);
finsize -= 2;
}
cout<<max(oddsum, evensum)<<"\n";
cout<<op.size()<<"\n";
for(auto &o : op) cout<<o<<"\n";
}
int main() {
ios_base::sync_with_stdio(false);
cin.tie(NULL);
solve();
}
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
using namespace std;

typedef long long ll;
const int MAXN=5e5+5;

template<typename T> void chkmax(T& x,T y){if(y>x)x=y;}
template<typename T> void chkmin(T& x,T y){if(y<x)x=y;}

int N,M,L;char S[MAXN],T[MAXN];int si[MAXN],sl,ti[MAXN],tl,le[MAXN],ri[MAXN];

int main(){
#ifndef ONLINE_JUDGE
freopen("classic1.in","r",stdin);
freopen("classic1.out","w",stdout);
#endif
scanf("%d%d%s%s",&N,&M,S+1,T+1),L=N+M;
for(int i=1;i<=L;++i)if(S[i]=='0')si[++sl]=i;
for(int i=1;i<=L;++i)if(T[i]=='0')ti[++tl]=i;
if(!sl||sl==L){printf("%d\n",L-1);return 0;}
for(int i=1;i<=sl;++i){
le[i]=si[i],ri[i]=ti[i];
if(le[i]>ri[i])swap(le[i],ri[i]);
//printf("[%d,%d]\n",le[i],ri[i]);
}
int ans=0;

int cur=L-1;
int cnt=0,l,r;
for(int i=1;i<=sl;++i){
if(!cnt)l=le[i],r=ri[i],cnt=1;
else{
if(max(l,le[i]-cnt)>min(r,ri[i]-cnt)){
if(cnt==L)cur-=0;
else if(l==1||r+cnt-1==L)cur-=1;
else cur-=2;
l=le[i],r=ri[i],cnt=1;
}else{
l=max(l,le[i]-cnt),r=min(r,ri[i]-cnt);
++cnt;
}
}
}
if(cnt==L)cur-=0;
else if(l==1||r+cnt-1==L)cur-=1;
else cur-=2;
chkmax(ans,cur);
//printf("ans=%d\n",ans);

if(le[1]==1){
int st=1;
while(le[st]==st)++st;
//printf("st=%d\n",st);
cur=L-1;
cur-=1;
cnt=0;
for(int i=st;i<=sl;++i){
if(!cnt)l=le[i],r=ri[i],cnt=1;
else{
if(max(l,le[i]-cnt)>min(r,ri[i]-cnt)){
//printf("seg[%d,%d],cnt=%d\n",l,r,cnt);
if(cnt==L)cur-=0;
else if(l==1||r+cnt-1==L)cur-=1;
else cur-=2;
l=le[i],r=ri[i],cnt=1;
}else{
l=max(l,le[i]-cnt),r=min(r,ri[i]-cnt);
++cnt;
}
}
}
//printf("seg[%d,%d],cnt=%d\n",l,r,cnt);
if(cnt==L)cur-=0;
else if(l==1||r+cnt-1==L)cur-=1;
else cur-=2;
chkmax(ans,cur);
}

printf("%d\n",ans);
return 0;
}
#include <stack>
#include <vector>
#include <iostream>
#include <cstring>
#include <algorithm>
namespace Qiaoqia { 
constexpr int N = 40005;
int n, low[N*5], dfn[N*5], inst[N*5], scc[N*5], id[4*N], cnt, col, tim;
std::stack<int> st;
std::vector<int> g[N*5];
struct kk { 
int p, id;
kk(int x = 0, int y = 0) { p = x, id = y; }
bool operator < (const kk& b) const {
if (p != b.p) return p < b.p;
return id < b.id;
}
} a[N];
int op(int x) { return x > n/2 ? x-n/2 : x+n/2; }
void dfs(int u) {
dfn[u] = low[u] = ++tim;
st.push(u), inst[u] = 1;
for (int v : g[u]) 
if (!dfn[v]) dfs(v), low[u] = std::min(low[u], low[v]);
else if (inst[v]) low[u] = std::min(low[u], dfn[v]);
if (low[u] == dfn[u]) {
int c;
scc[u] = ++col;
while ("guang_gao_wei_zhao_zu"[0]) {
c = st.top(), st.pop();
inst[c] = 0;
scc[c] = scc[u];
if (c == u) break;
}
}
}
void add(int p, int l, int r, int x, int y, int z) {
// if (p == 1) std::cout << z << ' ' << x << ' ' << y << '\n';
if (l == x && r == y) {
g[z].push_back(id[p]);
return;
}
int mid = l + (r-l) / 2;
if (y <= mid) add(p+p, l, mid, x, y, z);
else if (x > mid) add(p+p+1, mid+1, r, x, y, z);
else add(p+p, l, mid, x, mid, z), add(p+p+1, mid+1, r, mid+1, y, z);
}
void build(int p, int l, int r) {
id[p] = ++cnt;
if (l == r) {
g[id[p]].push_back(op(a[l].id));
return;
}
int mid = l + (r-l) / 2;
build(p+p, l, mid), g[id[p]].push_back(id[p+p]);
build(p+p+1, mid+1, r), g[id[p]].push_back(id[p+p+1]);
}
bool check(int d) {
memset(dfn, 0, sizeof dfn);
memset(low, 0, sizeof low);
for (int i = 1; i <= cnt; i++) g[i].clear();
cnt = n;
build(1, 1, n);
for (int i = 1; i <= n; i++) {
int l = std::upper_bound(a+1, a+i, kk(a[i].p-d, n+1)) - a,
r = std::lower_bound(a+i+1, a+n+1, kk(a[i].p+d, -1)) - a - 1;
if (l < i) add(1, 1, n, l, i-1, a[i].id);
if (r > i) add(1, 1, n, i+1, r, a[i].id);        
}       
tim = 0, col = 0;
for (int i = 1; i <= n; i++)
if (!dfn[i]) dfs(i);
for (int i = 1; i <= n/2; i++)
if (scc[i] == scc[i+n/2]) return false;
return true;
}
void main() {
std::cin >> n;
for (int i = 1; i <= n; i++) {
std::cin >> a[i].p >> a[i+n].p;;
a[i].id = i, a[i+n].id = i+n;
}
n = n * 2;
std::sort(a+1, a+1+n);
int l = 0, r = a[n].p - a[1].p, ans = -1;
while (l <= r) {
int mid = l + (r - l) / 2;
if (check(mid)) ans = mid, l = mid + 1;
else r = mid - 1;
}
std::cout << ans;
}
}
void _() { if (0) std::ios::sync_with_stdio(false), std::cin.tie(nullptr); }
int main() { _(); Qiaoqia::main(); }
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<ll> vi;
typedef vector<long double> vd;
typedef vector<string> vs;
typedef vector<pair<ll, ll>> vp;

#define int ll
#define PB push_back
#define pb pop_back
#define in insert 
#define endl "\n"
#define MP make_pair
#define F first
#define PI 3.141592653589
#define Se second
#define Trav(a,x) for(auto &a: x)
#define sz(A) (int)A.size()
#define all(x) x.begin(),x.end()
#define rall(x) x.rbegin(), x.rend()
#define Out(A) for(auto &a: A)cout<<a<<" "
#define In(A) for(auto &a: A)cin>>a
const int MOD  = 99824435399999999;
const int maxn = (int)1e9+7;

long long a,b,c,d,e,f,m,n,h,q,k,x,y,w,ans,sum; 
// vector<vector<int>>AA(, vector<int>(3));
//Don't get stuck on one approach
//Read the question correctly (is y a vowel?)
//Look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)

int32_t main(){
// freopen("cardgame.in", "r", stdin);
// freopen("cardgame.out", "w", stdout);
cin>>n;
vp A;
map<int,int>M;

for(int i = 0; i < n; i++){
cin>>a;
M[a]++;
}

Trav(a,M){
A.PB({a.F, a.Se});
}

sort(rall(A));
int length = 0, breadth = 0;
if(A[0].Se >= 4){
cout<<A[0].F * A[0].F;
return 0;
}
bool OG = true;
for(int i = 0; i < sz(A); i++){
if(A[i].Se >= 2 and OG){
length = A[i].F;
OG = false;
}
else if(A[i].Se >= 2 and !OG){
breadth = A[i].F;
break;
}
}

cout<<length * breadth;
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
int main(){
int n;
ll a,b;
cin>>n>>a>>b;
vector<int>p(n);
for(int i=0;i<n;i++) cin>>p[i];
ll ans=0;
for(int i=1;i<n;i++){
ll dist=p[i]-p[i-1];
ans+=min((ll)a*dist,b);
}
cout<<ans<<endl;
return 0;
}

#include<bits/stdc++.h>
#define int long long
#define inf 1e15
#define INF 0x3f3f3f3f
#define N 25005
#define K 405
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define pii pair<int,int>
#define il inline
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
il int read(){
int w=0,h=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')h=-h;ch=getchar();}
while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
return w*h;
}
const int mod=1e9+7;
int n,m,k,a[N],cnt[N];
int f[N][K],g[N][K];
int c[N],d[N];
int Fac[N],IFac[N];
int qpow(int b,int k){
int s=1;
while(k){
if(k&1)s=s*b%mod;
b=b*b%mod;
k>>=1;
}
return s;
}
int check(){
int cur=0,flg=0;
for(int i=1,j=1;i<=m;i++){
if(!cnt[a[i]])cur++;
cnt[a[i]]++;
while(cnt[a[j]]>1)cnt[a[j++]]--;
if(i-j+1==k&&cur==k)return 0;
}
memset(cnt,0,sizeof(cnt));
for(int i=1;i<=m;i++)
if((cnt[a[i]]++)>0)return 2;
return 1;
}
int calc(){
int ans=0;
f[0][0]=1;
for(int i=0;i<n;i++){
for(int j=0;j<k;j++){
if(j<k-1){
(f[i+1][j+1]+=f[i][j]*(k-j+mod)%mod)%=mod;
(f[i+1][j+2]+=mod-f[i][j]*(k-j+mod)%mod)%=mod;
(g[i+1][j+1]+=g[i][j]*(k-j+mod)%mod)%=mod;
(g[i+1][j+2]+=mod-g[i][j]*(k-j+mod)%mod)%=mod;
}
(f[i+1][1]+=f[i][j])%=mod;
(f[i+1][j+1]+=mod-f[i][j])%=mod;
(g[i+1][1]+=g[i][j])%=mod;
(g[i+1][j+1]+=mod-g[i][j])%=mod;
}
for(int j=1;j<k;j++){
(f[i+1][j]+=f[i+1][j-1])%=mod;
(g[i+1][j]+=g[i+1][j-1])%=mod;
}
for(int j=m;j<k;j++)(g[i+1][j]+=f[i+1][j])%=mod;
}
for(int i=1;i<k;i++)(ans+=g[n][i])%=mod;
return ans;
}
void dp(int ans[N],int dp[N][K]){
ans[0]=1;
for(int i=0;i<n-m;i++){
for(int j=1;j<k;j++){
if(j<k-1){
(dp[i+1][j+1]+=dp[i][j]*(k-j)%mod)%=mod;
(dp[i+1][j+2]+=mod-dp[i][j]*(k-j)%mod)%=mod;
}
(dp[i+1][1]+=dp[i][j])%=mod;
(dp[i+1][j+1]+=mod-dp[i][j])%=mod;
}
for(int j=1;j<k;j++){
(dp[i+1][j]+=dp[i+1][j-1])%=mod;
(ans[i+1]+=dp[i+1][j])%=mod;
}
}
}
signed main(){
n=read();k=read();m=read();
if(k>n)return puts("0"),0;
for(int i=1;i<=m;i++)a[i]=read();
int all=(n-m+1)*qpow(k,n-m)%mod;
Fac[0]=IFac[0]=1;
for(int i=1;i<=25000;i++)Fac[i]=Fac[i-1]*i%mod;
IFac[25000]=qpow(Fac[25000],mod-2);
for(int i=24999;i;i--)IFac[i]=IFac[i+1]*(i+1)%mod;
switch(check()){
case 0:return printf("%lld\n",all),0;
case 1:return printf("%lld\n",(all-calc()*Fac[k-m]%mod*IFac[k]%mod+mod)%mod),0;
case 2:{
memset(cnt,0,sizeof(cnt));
for(int i=1;i<=m;i++){
cnt[a[i]]++;
if(cnt[a[i]]>1){
f[0][i-1]=1;
break;
}
}
dp(c,f);
memset(cnt,0,sizeof(cnt));
for(int i=m;i>=1;i--){
cnt[a[i]]++;
if(cnt[a[i]]>1){
g[0][m-i]=1;
break;
}
}
dp(d,g);
for(int i=0;i<=n-m;i++)
(all+=mod-c[i]*d[n-m-i]%mod)%=mod;
printf("%lld\n",all);
return 0;
}
}
return 0;
}

#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
void solve() {
int n;
cin>>n;
int a[n];
for(int i=0;i<n;i++){
cin>>a[i];
}
int l;
cin>>l;
int tab[n][22];
for(int i=0;i<n;i++){
int left=i,right=n;
while(left+1<right){
int mid=(left+right)/2;
if(a[mid]-a[i]<=l){
left=mid;
}else{
right=mid;
}
}
tab[i][0]=left;
}
for(int j=1;j<22;j++){
for(int i=0;i<n;i++){
tab[i][j]=tab[tab[i][j-1]][j-1];
}
}
int q;
cin>>q;
while(q--){
int a,b;
cin>>a>>b;
--a;--b;
if(a>b) swap(a,b);
int ans=0;
for(int j=21;j>=0;j--) {
if (tab[a][j] < b) {
ans |= (1 << j);
a = tab[a][j];
}
}
ans++;
cout<<ans<<endl;
}
}

int32_t main() {
nitin;

solve();
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int a[N];
ll pre[N];
int f[N];

int get(ll x) {
if(x > 0) return 1;
else if(!x) return 0;
return -1;
}

ll solve() {
ll ret = 0, sum = 0;
rep(i, 1, n) {
if(get(pre[i] + sum) != f[i]) {
ret += abs(f[i] - pre[i] - sum);
sum += f[i] - pre[i] - sum;
}
}
return ret;
}

int main() {
qread(n);
rep(i, 1, n) qread(a[i]), pre[i] = pre[i - 1] + a[i];
rep(i, 1, n) f[i] = ((i & 1) ? 1 : -1);
ll ans = solve();
rep(i, 1, n) f[i] *= -1;
To_min(ans, solve());
cout << ans << endl;
return 0;
}
#include <algorithm>
#include <cstdio>
using namespace std;

const int N = 1010;

int n, m, x[N], y[N], d[N];
bool tg[N];

int main() {
scanf("%d", &n);
for(int i = 1; i <= n; i ++) {
scanf("%d%d", x + i, y + i);
tg[(x[i] + y[i]) & 1] = 1;
}
if(tg[0] & tg[1]) return puts("-1") & 0;
if(tg[0]) d[++ m] = 1;
for(int i = 30; ~ i; i --) d[++ m] = 1 << i;
printf("%d\n", m);
for(int i = 1; i <= m; i ++) printf("%d%c", d[i], " \n"[i == m]);
for(int i = 1; i <= n; i ++, putchar('\n')) {
for(int j = 1; j <= m; j ++) {
if(abs(x[i]) > abs(y[i])) {
if(x[i] > 0) x[i] -= d[j], putchar('R');
else x[i] += d[j], putchar('L');
} else {
if(y[i] > 0) y[i] -= d[j], putchar('U');
else y[i] += d[j], putchar('D');
}
}
}
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int maxn=520000;
const int mod=1000000007;
int n,fa[maxn];
int tot=0,pre[maxn],now[maxn],son[maxn];
int id[maxn],idn=0,dep[maxn],f[maxn][20];
int st[maxn],top=0,h[maxn],k=0,sum0[maxn],sum1[maxn];
vector<int> S[maxn],G[maxn];
int power(int x,int y)
{
int ans=1;
while(y)
{
if(y&1)
ans=1ll*ans*x%mod;
x=1ll*x*x%mod;
y>>=1;
}
return ans;
}
bool cmp(int x,int y){return id[x]<id[y];}
void put(int x,int y)
{
pre[++tot]=now[x];
now[x]=tot;
son[tot]=y;
}
int LCA(int x,int y)
{
if(dep[x]<dep[y])
swap(x,y);
for(int i=19;i>=0;i--)
if(dep[f[x][i]]>=dep[y])
x=f[x][i];
if(x==y)
return x;
for(int i=19;i>=0;i--)
if(f[x][i]!=f[y][i])
x=f[x][i],y=f[y][i];
return f[x][0];
}
void dfs(int x,int dp)
{
id[x]=++idn;dep[x]=dp;f[x][0]=fa[x];S[dp].push_back(x);
for(int i=1;i<=19;i++)
f[x][i]=f[f[x][i-1]][i-1];
for(int p=now[x];p;p=pre[p])
dfs(son[p],dp+1);
}
void calc(int x)
{
sum0[x]=sum1[x]=0;
if(!G[x].size())
return sum0[x]=sum1[x]=1,void();
int ans=1,sum=1;
for(auto t:G[x])
{
calc(t);
ans=1ll*ans*sum0[t]%mod;
sum=1ll*sum*(sum0[t]+sum1[t])%mod;
}
for(auto t:G[x])
sum1[x]=(sum1[x]+1ll*ans*power(sum0[t],mod-2)%mod*sum1[t]%mod)%mod;
sum0[x]=(0ll+sum-sum1[x]+mod)%mod;
}
void build()
{
sort(h+1,h+k+1,cmp);
st[top=1]=0;G[0].clear();
for(int i=1;i<=k;i++)
if(h[i])
{
int Lca=LCA(h[i],st[top]);
if(Lca!=st[top])
{
while(id[st[top-1]]>id[Lca])
G[st[top-1]].push_back(st[top]),top--;
if(st[top-1]!=Lca)
G[Lca].clear(),G[Lca].push_back(st[top]),st[top]=Lca;
else
G[Lca].push_back(st[top]),top--;
}
st[++top]=h[i];G[h[i]].clear();
}
for(int i=1;i<top;i++)
G[st[i]].push_back(st[i+1]);
}
int main()
{
scanf("%d",&n);
for(int i=1;i<=n;i++)
scanf("%d",&fa[i]),put(fa[i],i);
dfs(0,1);
int ans=0;
for(int i=1;S[i].size();i++)
{
k=0;
for(auto t:S[i])
h[++k]=t;
build();calc(0);
ans=(0ll+ans+1ll*power(2,n+1-S[i].size())*sum1[0]%mod)%mod;
}
printf("%d\n",ans);

return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long int
#define endl '\n'

int main() {
ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
string s;
cin >> s;

ll left = (s.length() / 2) - 1, right = s.length() / 2, k=0;
if(s.length() % 2 == 1) left++;
ll middle = s[left];

while(left >= 0 && right < s.length()) {
if((s[left] == s[right]) && (int(s[left]) == middle)) {
k++;
left--;
right++;
} else break;
}
ll finalans = k + (s.length() / 2);
cout << finalans << endl;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
template<typename T, int maxn, int type>
struct sparse{
vector<T> val[22];
sparse(){rep(__lg(maxn)+1) val[i].resize(max(0ll,maxn-pow2(i)+1));}
inline T oper(T i, T j){return type?max(i,j):min(i,j);}
void init(vector<T>& vec){
rep(sz(vec)) val[0][i]=vec[i];
rep2(i,1,__lg(maxn)+1) rep1(j,sz(vec)-pow2(i)+1) val[i][j]=oper(val[i-1][j],val[i-1][j+pow2(i-1)]);
}
T query(int l, int r){return oper(val[__lg(r-l+1)][l],val[__lg(r-l+1)][r-pow2(__lg(r-l+1))+1]);}
};
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[55],res;

void orzck(){
cin >> n;
rep(n) cin >> a[i];
while(1){
bool flag=0;
rep(n) if(a[i]>=n){
flag=1;
int x=a[i]/n;
rep1(j,n) if(i!=j) a[j]+=x;
a[i]-=x*n;
res+=x;
}
if(!flag) break;
}
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
int N;
cin>>N;
vector<int> A(N);
vector<int> B(N);
int sum = 0;
for(int i=0;i<N;i++){
cin>>A[i];
sum += A[i];
}
for(int i=0;i<N;i++){
cin>>B[i];
if(i == N-1){
sum += B[i];
}
}
int ans = sum;
for(int i=N-1;i>0;i--){
sum -= A[i];
sum += B[i-1];
if(sum > ans){
ans = sum;
}
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;

const int N = 1e5 + 10;

int s[N];

int lower(int x)
{
int l = 1, r = N;
while (l < r)
{
int mid = l + r >> 1;
if (s[mid] >= x) r = mid;
else l = mid + 1;
}
return l;
}



int main()
{

for (int i = 1; i < N; i++) s[i] = s[i - 1] + i;

int n; cin >> n;

cout << lower(n) << endl;


return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef unsigned long long ull;
#define REP(i, n) for(int i=0; i<n; i++)
#define REPi(i, a, b) for(int i=int(a); i<int(b); i++)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define mp make_pair
#define mod(a, m) ((a % m + m) % m)
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
const ll MOD = 1e9+7;

int main(){
int N, M;
cin >> N >> M;
vector<int> A(N);
for(auto& a : A) {
cin >> a;
a--;
}

vector<ll> X(2*M+2);
REP(i,N-1){
int left = A[i];
int right = A[i+1];
if(right < left) right += M;
int range = right - left;
X[left+2] += 1;
X[right+1] -= range;
X[right+2] += range-1;
}

REPi(i,1,2*M+2) X[i] += X[i-1];
REPi(i,1,2*M+2) X[i] += X[i-1];

ll ans = 1e15;
ll tmp = 0;
REP(i,N-1){
tmp += (M + A[i+1] - A[i]) % M;
}

REP(i,M){
//chmin(ans, tmp - X[i]);
chmin(ans, tmp - (X[i] + X[M+i]));
}

cout << ans << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int main() {
int n;
cin >> n;

int num[n+5];
int fre = 1;
int total1 = 0;

for(int i = 1; i<=n; i++) cin >> num[i];

long long total2 = 0;

for(int i = 1; i<=n; i++) {
while(fre <= n) {
if((total1^num[fre]) == (total1+num[fre])) {
total1 ^= num[fre];
fre++;
}
else break;
}
//cout << i << " " << fre << endl;
total2 += fre-i;
total1 ^= num[i];
}

cout << total2 << endl;

} 
#include<bits/stdc++.h>
#define rint register int
using namespace std;
const int N=1e5+5;
int n,d[N],q[N*2];
int main(){
cin>>n; rint l=N,r=N-1; q[++r]=1;
memset(d,63,sizeof(d)),d[1]=0;
while(l<=r){
rint x=q[l++];
if(d[10*x%n]>d[x]) d[10*x%n]=d[x],q[--l]=10*x%n;
if(d[(x+1)%n]>d[x]+1) d[(x+1)%n]=d[x]+1,q[++r]=(x+1)%n;
}
cout<<d[0]+1;
return 0;
} 
#include <bits/stdc++.h>
#define int long long
namespace mystd {
inline int read() {
char c = getchar();
int x = 0, f = 1;
while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
return x * f;
}
inline void write(int x) {
if (x < 0) x = ~(x - 1), putchar('-');
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}
}
using namespace std;
using namespace mystd;

const int maxn = 3e3 + 300;
int n, mod, res, fac[maxn], inv[maxn], ifac[maxn], pw[maxn], s[maxn][maxn];

void init(int lim) {
fac[0] = inv[1] = ifac[0] = s[0][0] = 1;
for (int i = 2; i <= lim; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for (int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = ifac[i - 1] * inv[i] % mod;
for (int i = 1; i <= lim; i++) {
for (int j = 1; j <= i; j++) {
s[i][j] = (s[i - 1][j - 1] + j * s[i - 1][j]) % mod;
}
}
//	pw[0] = 1;
//	for (int i = 1; i <= lim; i++) pw[i] = pw[i - 1] * 2 % mod;
}

int C(int n, int m) { return fac[n] * ifac[m] % mod * ifac[n - m] % mod; }
int ksm(int p, int q, int m) {
int res = 1;
while (q) {
if (q & 1) res = res * p % m;
p = p * p % m;
q >>= 1;
}
return res;
}

signed main() {
n = read(), mod = read();
init(n + 1);
for (int k = 0; k <= n; k++) {
int tp = 0;
for (int i = 0; i <= k; i++) {
tp = (tp + s[k + 1][i + 1] * ksm(2, i * (n - k) % (mod - 1), mod) % mod) % mod;
}
res = ((res + ksm(-1, k, mod) * C(n, k) % mod * ksm(2, ksm(2, n - k, mod - 1), mod) % mod * tp % mod) % mod + mod) % mod;
}
write(res);
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)
def(p, int, 1e9 + 7) 

int n, m;
ll fac[N];

int main() {
qread(n, m);
if(abs(n - m) >= 2) {
puts("0");
return 0;
}
fac[0] = fac[1] = 1;
rep(i, 2, max(n, m)) fac[i] = fac[i - 1] * i % p;
if(n == m) cout << fac[n] * fac[n] * 2 % p << endl;
else cout << fac[n] * fac[m] % p << endl;
return 0;
}
// #pragma GCC optimize ("O3")
// #pragma GCC target ("sse4")
#include <bits/stdc++.h>
using namespace std;

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;

#define int long long int

#define vi vector<int>

#define ff first
#define ss second

#define pb push_back
#define MOD 1000000007
//const int nax = 1e6+5;
#define inf 4e18
#define Graph vector<vi>
#define Graphw vector<vector<pair<int,int>>> 
#define sz(x) (int)x.size()
#define pr pair<int,int>

#define display(v) for(int i =0;i<(int)v.size();++i)cout << v[i] << " "
#define all(v) v.begin(),v.end()
#define read(a) for(int i = 0;i<(int)a.size();++i)cin>>a[i]
#define show(x) cout << #x << " is " << x << "\n";
// typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>   ind_si;
// typedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>   ind_msi;
#define show_arr(a) cout << #a << "\n"; display(a) ; cout << "\n";
inline int add(int a, int b){ int c = (a%MOD) + (b%MOD); if(c >= MOD) c -= MOD; return c; }
inline int mul(int a, int b){ return ((a%MOD) * 1ll * (b%MOD)) % MOD; }
inline int sub(int a, int b){ int c = (a%MOD) - (b%MOD); if(c < 0) c += MOD; return c; }
inline int sum_till(int n) { return mul(mul(n, n + 1), (MOD + 1) / 2); }
const int nax = 300*1000 + 10;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

//#define ook order_of_key
//#define fbo find_by_order
//   order_of_key(x) -> number of elements less than x.
// * find_by_order(x) -> gives the element at index x (0 - indexing)

void test_case();
int32_t main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);
int t = 1; //cin>>t;
while(t--){
test_case();
}
return 0;
}

void test_case(){
int x, y; cin>>x>>y;
if(abs(x-y) <= 1){
cout << "Brown\n";
}
else{
cout << "Alice\n";
}

}    

// Химаншу
// check overflow
// special case n == 1
// 🍪🍪🍪

#include<bits/stdc++.h>
#include<atcoder/all>

#define FOR(i, a, b) for (ll i = a; i < b; i++)
#define REP(i, n) for (ll i = 0; i < n; i++)
#define REPR(i, n) for (ll i = n; i >= 0; i--)
#define FOREACH(x, a) for (auto&& x : a)
#define CIN(...) ll __VA_ARGS__; CINT(__VA_ARGS__)
#define DCIN(...) ld __VA_ARGS__; CINT(__VA_ARGS__)
#define SCIN(...) string __VA_ARGS__; CINT(__VA_ARGS__)
#define VCIN(x) FOREACH(_e, x) std::cin >> _e
#define VVCIN(x) FOREACH(_v, x) FOREACH(_e, _v) std::cin >> _e
#define GCIN(g, n) REP(_i, n) {CIN(_a, _b); g[_a - 1].push_back(_b - 1); g[_b - 1].push_back(_a - 1);}
#define DGCIN(g, n) REP(_i, n) {CIN(_a, _b); g[_a - 1].push_back(_b - 1);}
#define WGCIN(g, n) REP(_i, n) {CIN(_a, _b, _w); g[_a - 1].push_back(Edge(_b - 1, _w)); g[_b - 1].push_back(Edge(_a - 1, _w));}
#define WDGCIN(g, n) REP(_i, n) {CIN(_a, _b, _w); g[_a - 1].push_back(Edge(_b - 1, _w));}
#define COUT(x) std::cout << x << "\n"
#define SCOUT(x) std::cout << x << " "
#define VCOUT(x) FOREACH(_e, x) std::cout << _e << "\n"
#define SVCOUT(x) FOREACH(_e, x) std::cout << _e << " "; std::cout << std::endl
#define VVCOUT(x) FOREACH(_v, x) {SVCOUT(_v);}
#define FCOUT(x) std::cout << fixed << setprecision(x)
#define Yes(n) std::cout << ((n) ? "Yes" : "No") << "\n"
#define ALL(x) x.begin(), x.end()
#define RALL(x) x.rbegin(), x.rend()
#define DUMP(x) std::cout << #x << " = " << x << std::endl
#define SVDUMP(x) std::cout << #x << " = "; SVCOUT(x);
#define VDUMP(x) REP(_i, x.size()) std::cout << #x << "[" << _i << "] = " << x[_i] << std::endl
#define VVDUMP(x) REP(_i, x.size()) {std::cout << #x << "[" << _i << "] = "; SVCOUT(x[_i]);}

using namespace std;
using namespace atcoder;

struct Edge{
int to;
long long w;
Edge(int to, long long w) : to(to), w(w) {}
};

using ll = long long;
using ull = unsigned long long;
using ld = long double;
using cp = complex<ld>;
using Graph = vector<vector<int>>;
using WGraph = vector<vector<Edge>>;
using UnionFind = dsu;

const int INF = 1 << 30;
const ll INFL = 1LL << 60;

template<class T> inline bool chmax(T& a, T b) {if (a < b) { a = b; return (true);} return (false);}
template<class T> inline bool chmin(T& a, T b) {if (a > b) { a = b; return (true);} return (false);}

struct InitCppIo{
InitCppIo() noexcept{
std::cin.tie(nullptr);
std::ios::sync_with_stdio(false);
}
} initCppIo;

void CINT(){}
template <class Head, class... Tail>
void CINT(Head&& head, Tail&&... tail){
std::cin >> head;
CINT(move(tail)...);
}
/*-----------------------------------------------------------------------------------------------------------------------------------*/


bool ans = false;

bool is_dream(string S)
{
return (S.size() >= 5 && S[0] == 'd' && S[1] == 'r' && S[2] == 'e' && S[3] == 'a' && S[4] == 'm');
}

bool is_dreamer(string S)
{
return (S.size() >= 7 && S[0] == 'd' && S[1] == 'r' && S[2] == 'e' && S[3] == 'a' && S[4] == 'm' && S[5] == 'e' && S[6] == 'r');
}

bool is_erase(string S)
{
return (S.size() >= 5 && S[0] == 'e' && S[1] == 'r' && S[2] == 'a' && S[3] == 's' && S[4] == 'e');
}

bool is_eraser(string S)
{
return (S.size() >= 6 && S[0] == 'e' && S[1] == 'r' && S[2] == 'a' && S[3] == 's' && S[4] == 'e' && S[5] == 'r');
}

/* <dfs> *****************************************************************************************************************/
template<typename T>
void dfs(ll depth, T&& p, ll d = 0)
{
if (p[0] == '\0')
{
// depthまで探索後の処理
ans = true;
return ;
}
// 深さdの頂点を回る
// for ()
{
// p = ref[d - 1] から ref[d] を作成
if (is_dream(p))
{
dfs(depth, &p[5], d + 1);
}
if (is_dreamer(p))
{
dfs(depth, &p[7], d + 1);
}
if (is_erase(p))
{
dfs(depth, &p[5], d + 1);
}
if (is_eraser(p))
{
dfs(depth, &p[6], d + 1);
}
}
}
/**************************************************************************************************************************/


int main()
{
SCIN(S);
vector<string> ref;
dfs(S.size(), S);
if (ans)
COUT("YES");
else
COUT("NO");
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
template<typename T, signed N>
struct BIT{
T val[N];
void modify(signed x, T y){for(signed i=++x; i<N; i+=i&-i) val[i]+=y;}
T query(signed x, signed y){
T ret=0;
for(signed i=++y; i; i-=i&-i) ret+=val[i];
for(signed i=x; i; i-=i&-i) ret-=val[i];
return ret;
}
signed first_true(bool(*f)(T,signed)){
if(f(0,0)) return 0;
signed cur=0;
T curval=0;
for(signed i=__lg(N); i>=0; --i) if(cur+(1<<i)<N){
if(!f(curval+val[cur+(1<<i)],cur+(1<<i))) cur+=1<<i,curval+=val[cur];
}
return min(cur,N-2);
}
};
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,k,a[maxn],sum[maxn],res;
vector<int> vec;
BIT<int,maxn> bit;

void orzck(){
cin >> n >> k;
rep(n) cin >> a[i];
rep(n) a[i]-=k;
rep(n) sum[i+1]=sum[i]+a[i];
rep(n+1) vec.pb(sum[i]);
sort(all(vec));
vec.resize(unique(all(vec))-vec.begin());
rep(n+1) sum[i]=lower_bound(all(vec),sum[i])-vec.begin();
rep(n+1){
res+=bit.query(0,sum[i]);
bit.modify(sum[i],1);
}
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef unsigned long long ull;
#define REP(i, n) for(int i=0; i<n; i++)
#define REPi(i, a, b) for(int i=int(a); i<int(b); i++)
#define MEMS(a,b) memset(a,b,sizeof(a))
#define mp make_pair
#define mod(a, m) ((a % m + m) % m)
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
const ll MOD = 1e9+7;

int main(){
int N;
cin >> N;
bool same = true;
vector<ll> A(N), B(N);
REP(i,N){
cin >> A[i] >> B[i];
if(A[i] != B[i]) same = false;
}

ll ans = 0;
if(same){
ans = 0;
} else {
ll sum = accumulate(A.begin(), A.end(), 0LL);
ll m = 1e17;
REP(i,N){
if(A[i] > B[i]) chmin(m, B[i]);
}
ans = sum - m;
}

cout << ans << endl;
return 0;
}

#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define st string
#define pub push_back
#define puf push_front
#define pob pop_back
#define pof pop_front
#define mp make_pair
#define fi first
#define se second
using namespace std;
const ll mill = 1e6;
const ll bill = 1e9;

int n, t[mill], x[mill], y[mill];

int main(){
cin >> n;
for (int i = 1; i <= n; i++){
cin >> t[i] >> x[i] >> y[i];
}
for (int i = 1; i <= n; i++){
int cek = x[i-1]+y[i-1];
int tmp = x[i]+y[i];
if (abs(tmp-cek) > t[i]-t[i-1]){
cout << "No" << endl;
return 0;
}
else if ((abs(tmp-cek))%2 != (t[i]-t[i-1])%2){
cout << "No" << endl;
return 0;
}
}
cout << "Yes" << endl;
}

#include<bits/stdc++.h>
using namespace std;

int main(){
long long N,M;
cin>>N>>M;
if(N*2>=M)
cout<<M/2;
else{
long long a=M/2;
a=a+N;
a=a/2;
cout<<a;
}
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define OD(i) (((i) & 1) == 1)
#define EV(i) (((i) & 1) == 0)
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
int d2i(const char& d) { assert(isdigit(d)); return (d - '0'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
char i2d(const int& i) { assert(0 <= i && i <= 9); return ('0' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VI = vector<int>;
using VVI = vector<VI>;
using VVVI = vector<VVI>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N; input(N);

ll ans = 0;
VLL X;
bool same = true;
REP(i,N) {
ll A, B; input(A, B);
if (A > B) X.push_back(B);
ans += A;
if (A != B) same = false;
}
if (same) { print(0); exit(0); }

if (not X.empty()) {
SORT(X);
ans -= X[0];
}

print(ans);

return 0;
}

#ifdef _DEBUG
#define _GLIBCXX_DEBUG
#endif
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;

#define fs(n) fixed << setprecision(n)
#define mp(a, b) make_pair(a, b)
#define all(x) x.begin(), x.end()
using ll = long long;
using ld = long double;
#define query(t) while(t--)
#define aryin(a, n) for(int i = 0; i < n; i++) cin >> a[i];
#define chmin(a, b) a = min(a, b)
#define chmax(a, b) a = max(a, b)


int main(){
cin.tie(nullptr);
ios_base::sync_with_stdio(false);

int n; cin >> n;
vector<ll> a(3 * n);
aryin(a, 3 * n);

vector<ll> s(n * 2 + 1, 0);
priority_queue<ll, vector<ll>, greater<ll>> lq;
for(int i = 0; i < n; i++){
s[i + 1] = s[i] + a[i];
lq.push(a[i]);
}
for(int i = n; i < n * 2; i++){
ll m = lq.top();
if(a[i] > m) {
s[i + 1] = s[i] - m + a[i];
lq.pop();
lq.push(a[i]);
}else{
s[i + 1] = s[i];
}
}
vector<ll> t(n * 2 + 1, 0);
priority_queue<ll> rq;
for(int i = 0; i < n; i++){
t[i + 1] = t[i] + a[n * 3 - 1 - i];
rq.push(a[n * 3 - 1 - i]);
}
for(int i = n; i < n * 2; i++){
ll m = rq.top();
if(a[n * 3 - 1 - i] < m) {
t[i + 1] = t[i] - m + a[n * 3 - 1 - i];
rq.pop();
rq.push(a[n * 3 - 1 - i]);
}else{
t[i + 1] = t[i];
}
}

ll ans = LLONG_MIN;
for(int i = n; i <= n * 2; i++){
chmax(ans, s[i] - t[n * 3 - i]);
}cout << ans << endl;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

struct Node {
int x, y, id;

bool operator < (const Node &oth) const {
return x < oth.x;
}
} a[N], b[N];

int n, ida, idb, dis;
int idcnt;
bool vis[N];
map<int, int> id;
set<Node> ss[N << 1], sd[N << 1];
queue<int> q;
map<int, int> cnt1, cnt2;
map<pii, bool> has;

void Push(int x) {
if(vis[x]) return ;
vis[x] = 1;
q.push(x);
ss[id[a[x].x + a[x].y]].erase(a[x]);
sd[id[a[x].x - a[x].y]].erase(a[x]);
}

ll calc() {
ll ret = 0;
int cnt = 0;
rep(i, 1, n) if(vis[i]) b[++cnt] = a[i];
sort(b + 1, b + cnt + 1);
int nw = 1;
rep(i, 1, cnt) {
while(b[nw].x < b[i].x - dis) --cnt1[b[nw].x + b[nw].y], --cnt2[b[nw].x - b[nw].y], ++nw;
ret += cnt1[b[i].x + b[i].y - dis] + cnt2[b[i].x - b[i].y - dis];
++cnt1[b[i].x + b[i].y]; ++cnt2[b[i].x - b[i].y];
if(has[mp(b[i].x - dis, b[i].y)]) --ret;
has[mp(b[i].x, b[i].y)] = 1;
}
return ret;
}

int main() {
qread(n, ida, idb);
rep(i, 1, n) {
qread(a[i].x, a[i].y);
a[i].id = i;
if(!id[a[i].x + a[i].y]) {
id[a[i].x + a[i].y] = ++idcnt;
ss[idcnt].insert(a[i]);
}
else ss[id[a[i].x + a[i].y]].insert(a[i]);

if(!id[a[i].x - a[i].y]) {
id[a[i].x - a[i].y] = ++idcnt;
sd[idcnt].insert(a[i]);
} 
else sd[id[a[i].x - a[i].y]].insert(a[i]);
}
dis = abs(a[ida].x - a[idb].x) + abs(a[ida].y - a[idb].y);
Push(ida), Push(idb);
set<Node> It it; int nw;
while(!q.empty()) {
int u = q.front();
q.pop();
// cout << "now : " << u << endl;

// 1
nw = id[a[u].x + a[u].y + dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].end()) {
// cout << "1 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 3
nw = id[a[u].x + a[u].y - dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].begin()) {
--it;
// cout << "3 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 2
nw = id[a[u].x - a[u].y - dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].begin()) {
--it;
// cout << "2 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// 4
nw = id[a[u].x - a[u].y + dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].end()) {
// cout << "4 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// cout << endl;
}
// rep(i, 1, n) cout << vis[i] << " \n"[i == n];
cout << calc() << endl;
return 0;
}
// Problem: C - Daydream
// Contest: AtCoder - AtCoder Regular Contest 065
// URL: https://atcoder.jp/contests/arc065/tasks/arc065_a
// Memory Limit: 256 MB
// Time Limit: 2000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>

using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
string s;
cin >> s;
int i = 0, n = s.size();
// cerr << (s.substr(i, 11) == "dreameraser");
// cerr << s.substr(5784, 100);
// return 0;
while (i < n) {
if (s[i] == 'd') {
if (s.substr(i, 11) == "dreameraser") {
// cerr << "HERE";
i += 11;
} else if (s.substr(i, 13) == "dreamereraser") {
i += 13;
} else if (s.substr(i, 10) == "dreamerase") {
i += 10;
} else if (s.substr(i, 12) == "dreamererase") {
i += 12;
} else if (s.substr(i, 5) == "dream") {
i += 5;
if (s.substr(i, 2) == "er") i += 2;
} else {
cout << "NO";
return 0;
}
} else if (s[i] == 'e') {
if (s.substr(i, 5) == "erase") {
i += 5;
if (s.substr(i, 1) == "r") i += 1;
} else {
cout << "NO";
return 0;
}
} else {
cout << "NO";
return 0;
}
}
cout << "YES";
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
int h, w; cin>>h>>w;
int ans = 1e18;
for(int i=1; i<h; i++){
int A1 = i*w;
int rem = max(i, h-i);
if(rem >= 2){
int a2 = w*((int)rem/2);
int a3 = w*(rem - (int)rem/2);
ans = min(ans, max({A1, a2, a3}) - min({A1, a2, a3}));
}
int A2 = ((int)w/2)*rem;
int A3 = w*rem - A2;
ans = min(ans, max({A1, A2, A3}) - min({A1, A2, A3}));
}
for(int i=1; i<w; i++){
int A1 = i*h;
int rem = max(i, w-i);
if(rem >= 2){
int a2 = h*((int)rem/2);
int a3 = h*(rem - (int)rem/2);
ans = min(ans, max({A1, a2, a3}) - min({A1, a2, a3}));
}
int A2 = ((int)h/2)*rem;
int A3 = h*rem - A2;
ans = min(ans, max({A1, A2, A3}) - min({A1, A2, A3}));
}

cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1005,ha=1e9+7;

inline int add(int x,int y){ x+=y; return x>=ha?x-ha:x;}
inline void ADD(int &x,int y){ x+=y; if(x>=ha) x-=ha;}

inline int ksm(int x,int y){
int an=1;
for(;y;y>>=1,x=x*(ll)x%ha) if(y&1) an=an*(ll)x%ha;
return an;
}

int jc[N],ni[N],f[N],n,a,b,c,d,ans,inv[N];

inline void init(){
jc[0]=1;
for(int i=1;i<=n;i++) jc[i]=jc[i-1]*(ll)i%ha;
ni[n]=ksm(jc[n],ha-2);
for(int i=n;i;i--) ni[i-1]=ni[i]*(ll)i%ha;
}

inline void dp(){
f[0]=1;
for(int i=a;i<=b;i++) // 最外层枚举 队伍的人数 
for(int m=i*c,j=min(i*d,n);j>=m;j--) // 第二层枚举 已经选好的人数
for(int k=c,now=ksm(ni[i],c),M=j-c*i;k<=d&&M>=0;k++,M-=i,now=now*(ll)ni[i]%ha)
/* 第三层枚举 这种人数的队伍选几个*/
ADD(f[j],jc[j]*(ll)now%ha*(ll)ni[M]%ha*(ll)f[M]%ha*(ll)ni[k]%ha);
}

int main(){
scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);
init(),dp(),printf("%d\n",f[n]);
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
vector <int> a(n), b(n);

set <pair <int, int>> ok;
int ans = 0, minB = mod * mod, cnt = 0;

for (int i = 0; i < n; ++i) {
cin >> a[i] >> b[i];
ans += b[i];
if (b[i] < a[i])
minB = min(minB, b[i]);
if (b[i] == a[i]) 
cnt++;
}

cout << (cnt == n ? 0 : ans - minB) << '\n';

return 0;
}

// #include <bits/stdc++.h>
#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream> 
#include <iterator>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>
using namespace std;
// #include <boost/multiprecision/cpp_int.hpp>
// using bint = boost::multiprecision::cpp_int;
using ll = long long;
using vl = vector<ll>;
using vvl = vector<vl>;
using pll = pair<ll, ll>;
#define rep(i, s, n) for (ll i = (ll)(s); i < (ll)(n); i++)
#define repr(i, n, s) for (ll i = (ll)(n); (ll)(s) < i; i--)
#define fore(e, a) for (auto&& e: (a))
#define len(a) (ll)(a).size()
#define all(a) (a).begin(), (a).end()
#define pb push_back
#define eb emplace_back
#define fi first
#define se second
/*********       P R I N T       **********/
template<class T> void print(const T& e);
template<class T> void print(const vector<T>& v);
template<class T> void print(const vector<vector<T>>& vv);
template<class H, class... T> void print(const H& h, const T&... t);  // スペース区切り
/*********       D E B U G       **********/
#ifdef __LOCAL
#define debug(...) if(DEBUG) do{cout << '[' << #__VA_ARGS__ << "] ";debug_(__VA_ARGS__);}while(0)
#else
#define debug(...)
#endif
template<class T> void debug_(const T& e);
template<class T> void debug_(const vector<T>& v);
template<class T> void debug_(const vector<vector<T>>& vv);
template<class T, class U> void debug_(const map<T, U>& mp);
template<class T, class U> void debug_(const vector<map<T, U>>& vm);
template<class T> void debug_(const set<T>& st);
template<class T> void debug_(const multiset<T>& st);
template<class T> void debug_(const vector<set<T>>& vs);
template<class T> void debug_(const vector<multiset<T>>& vs);
template<class H, class... T> void debug_(const H& h, const T&... t);  // 改行区切り
/*********       M  O  D       **********/
// #include <atcoder/modint>  // https://atcoder.github.io/ac-library/production/document_ja/
// using namespace atcoder;
// using mint = modint1000000007;     // modint998244353;
// const long long MOD = 1000000007;  // 998244353;
// using vm = vector<mint>;
// using vvm = vector<vm>;
// void print_(const mint& e){cout << e.val();}
// void dbg_(const mint& e){cout << e.val();}
/*********       O T H E R S       **********/
template<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return true;} return false;}  // bは値渡し!
template<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return true;} return false;}
template<class T> inline T mod(const T& a, const T& m) {return (a % m + m) % m;}
template<class T> inline T div_ceil(const T& x, const T& y) {return (x + y - 1) / y;}
template<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;
const long long INF64 = LONG_LONG_MAX / 2 - 10000LL;  // 4,611,686,018,427,377,903  ~= 4.6e+18, 19桁
const double PI = acos(-1);
const bool DEBUG = true;



int main() {
ll N;
cin >> N;
string S;
cin >> S;
// solve
rep(i0, 0, 2) {      // 0: sheep, 1: wolf
rep(i1, 0, 2) {  // 0: sheep, 1: wolf
vl A(N);
A[0] = i0;
A[1] = i1;
rep(i, 2, N) {
if ((A[i - 1] == 0) && (S[i - 1] == 'o') || (A[i - 1] == 1 && (S[i - 1] == 'x'))) {
A[i] = A[i - 2];
} else {
A[i] = 1 - A[i - 2];
}
}
if ((A[N - 1] == 0) && (S[N - 1] == 'o') || (A[N - 1] == 1 && (S[N - 1] == 'x'))) {
if (A[N - 2] != A[0]) continue;
} else {
if (A[N - 2] == A[0]) continue;
}
if ((A[0] == 0) && (S[0] == 'o') || (A[0] == 1 && (S[0] == 'x'))) {
if (A[N - 1] != A[1]) continue;
} else {
if (A[N - 1] == A[1]) continue;
}
// ここに来たら合格
string ans = "";
string SW = "SW";
fore(a, A) ans += SW[a];
print(ans);
return 0;
}
}    
print(-1);
}




/*********       P R I N T       **********/
// mint, pairの場合と処理を分けるために定義
template<class T> void print_(const T& e){
cout << e;
}

// pairの入れ子やvector<pll>に対応しているが、vector<pll>はpllごとに改行しないので注意
template<class T, class U> void print_(const pair<T, U>& p){
print_(p.first);
cout << ' ';
print_(p.second);
}

template<class T> void print(const T& e){
print_(e);
cout << '\n';
}

template<class T> void print(const vector<T>& v){
if (v.size()) {
auto iter = v.begin();
print_(*iter++);
for(; iter != v.end(); ++iter) {
cout << ' ';
print_(*iter);
}
}
cout << '\n';
}

template<class T> void print(const vector<vector<T>>& vv){
for(auto&& v : vv){
print(v);
}
}

// スペース区切りで出力。引数にpairやvectorは不可。
template<class H, class... T> void print(const H& h, const T&... t) {
cout << h << ' ';
print(t...);
}

/*********       D E B U G       **********/
void dbg_(const long long& e){
if (e >= INF64) cout << "INF";
else if (e <= -INF64) cout << "-INF";
else cout << e;
}

template<class T> void dbg_(const T& e){
cout << e;
}

// 再帰によりpairの入れ子を出力
template<class T, class U> void dbg_(const pair<T, U>& p) {
cout << '(';
dbg_(p.first);
cout << ' ';
dbg_(p.second);
cout << ')';
}

template<class T> void debug_(const T& e) {
dbg_(e);
cout << '\n';
}

template<class T> void debug_(const vector<T>& v){
if (v.size()) {
auto iter = v.begin();
dbg_(*iter++);
for(; iter != v.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const vector<vector<T>>& vv){
cout << '\n';
ll cnt = 0;
for(auto&& v : vv){
cout << cnt++ << ": ";
debug_(v);
}
}

template<class T, class U> void debug_(const map<T, U>& mp){
if (mp.size()) {
auto iter = mp.begin();
dbg_(*iter++);
for(; iter != mp.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T, class U> void debug_(const vector<map<T, U>>& vm){
cout << '\n';
ll cnt = 0;
for(auto&& mp : vm){
cout << cnt++ << ": ";
debug_(mp);
}
}

template<class T> void debug_(const set<T>& st){
if (st.size()) {
auto iter = st.begin();
dbg_(*iter++);
for(; iter != st.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const multiset<T>& st){
if (st.size()) {
auto iter = st.begin();
dbg_(*iter++);
for(; iter != st.end(); ++iter) {
cout << ' ';
dbg_(*iter);
}
}
cout << '\n';
}

template<class T> void debug_(const vector<set<T>>& vs){
cout << '\n';
ll cnt = 0;
for(auto&& st : vs){
cout << cnt++ << ": ";
debug_(st);
}
}

template<class T> void debug_(const vector<multiset<T>>& vs){
cout << '\n';
ll cnt = 0;
for(auto&& st : vs){
cout << cnt++ << ": ";
debug_(st);
}
}

// 改行区切りで出力。引数にpairやvectorもOK。
template<class H, class... T> void debug_(const H& h, const T&... t) {
debug_(h);
debug_(t...);
}

#include<bits/stdc++.h>
#define	Mod 1000000007 
#define gc getchar()
#define ll long long
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,b,a) for(int i=b;i>=a;i--) 
using namespace std;
inline int read(){
int x=0;char s=gc;
while('0'>s||s>'9')s=gc;
while('0'<=s&&s<='9'){x=x*10+s-48;s=gc;}
return x;
}

const int N=(1<<16)+11;
int n,m,a[21];
ll ans,f[21][N],fac[N],ifac[N],inv[N];

ll C(ll x,ll y){if(x<y||x<0||y<0)return 0;return fac[x]*ifac[y]%Mod*ifac[x-y]%Mod;}
int main(){
n=read(),m=read();
FOR(i,1,m)a[i]=read();
fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1;
FOR(i,2,(1<<16))fac[i]=fac[i-1]*i%Mod,inv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod,ifac[i]=ifac[i-1]*inv[i]%Mod; 
sort(a+1,a+m+1);
f[m+1][0]=1;
ROF(i,m,1){
FOR(j,0,(1<<n)-1)f[i][j]=f[i+1][j];
FOR(j,0,(1<<n)-1)
FOR(k,0,n-1)			
if(!(j&(1<<k))&&f[i+1][j])
f[i][j|(1<<k)]=(f[i][j|(1<<k)]+f[i+1][j]*C((1<<n)-a[i]-j,(1<<k)-1)%Mod)%Mod;
}
FOR(i,0,(1<<n)-1){
ll p1=0,p2=1,cnt=n;
FOR(j,0,n-1)if(!(i&(1<<j)))cnt--,p1+=(1<<j),p2=p2*ifac[(1<<j)]%Mod;
f[1][i]=f[1][i]*fac[p1]%Mod*p2%Mod;
if(cnt&1)ans=(ans-f[1][i]+Mod)%Mod;
else ans=(ans+f[1][i])%Mod;
}

FOR(i,0,n-1)ans=ans*fac[(1<<i)]%Mod;
cout<<ans*(1<<n)%Mod;
return 0;	
}
/*
2 1
3
*/

#include <bits/stdc++.h>

using namespace std;
#define rep(i,n) for(long long i=0;i<n;++i)
#define rep1(i,n) for(long long i=1;i<=n;++i)
#define rrep(i,n) for(long long i=n-1;i>=0;--i)
#define debug(output) if(debugFlag)cout<<#output<<"= "<<output<<endl
using lint = long long;
typedef pair<int,int> P;
const bool debugFlag=true;
const lint linf=1.1e18;const lint inf=1.01e9;
constexpr int MOD=1000000007;
template<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }

signed main(){
int n;cin>>n;
vector<lint> a(n),b(n);
rep(i,n)cin>>a[i]>>b[i];
lint res=0;
if(a==b){
cout<<0<<"\n";
return 0;
}
rep(i,n)res+=a[i];
lint mn=linf;
rep(i,n){
if(a[i]>b[i]){
chmin(mn,b[i]);
}
}
res-=mn;
cout<<res<<"\n";
return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define nyahalo ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define otsumiko exit(0);
#define mikodanye priority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > >
#define mikochi priority_queue<long long, vector<long long>, greater<long long> >

int main() {
nyahalo
long long n, cn = 1, t, x, y, pt = 0, px = 0, py = 0;
cin >> n;
while (n--) {
cin >> t >> x >> y;
long long dt = t-pt, dx = x-px, dy = y-py;
pt = t, px = x, py = y;
if ((dt+dx+dy)%2 == 0 && abs(dx)+abs(dy)<=dt) {
continue;
}
cn = 0;
}
if (cn == 1) {
cout << "Yes\n";
} else {
cout << "No\n";
}
otsumiko
}

#include<bits/stdc++.h>
#define ll long long int
using namespace std;
vector<ll>vis(200000,-1);
ll traverse(ll x)
{
if(vis[x]==-1) return x;
return vis[x]=traverse(vis[x]);
}
void solve()
{
ll n,i,k,j;
cin>>n;
vector<pair<ll,pair<ll,ll>>>v1,v2,v;
for(int i=0; i<n; i++){
ll x,y;
cin>>x>>y;
v1.push_back({x,{y,i}});
v2.push_back({y,{x,i}});
}
sort(v1.begin(),v1.end());
sort(v2.begin(),v2.end());
for(int i=0; i<n-1; i++){
ll a=abs(v1[i].first-v1[i+1].first);
ll x=v1[i].second.second;
ll y=v1[i+1].second.second;
v.push_back({a,{x,y}});
}
for(int i=0; i<n-1; i++){
ll a=abs(v2[i].first-v2[i+1].first);
ll x=v2[i].second.second;
ll y=v2[i+1].second.second;
v.push_back({a,{x,y}});
}
ll ans=0;
sort(v.begin(),v.end());
for(auto it:v)
{
ll need=it.first;
ll a=it.second.first;
ll b=it.second.second;
ll z=traverse(a);
ll y=traverse(b);
if(z!=y){
ans+=need;
vis[z]=y;
}
}
cout<<ans<<endl;
}
int main()
{
int t=1;
while(t--){
solve();
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=105,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n;
bitset<maxn*maxn> bs;

void orzck(){
cin >> n;
bs[0]=1;
rep(n){
int x;
cin >> x;
bs|=bs<<x;
}
rep3(i,maxn*maxn-2,0) if(bs[i]&&i%10){
print(i);
return;
}
print(0);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
#define int long long
namespace mystd {
inline int read() {
char c = getchar();
int x = 0, f = 1;
while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
return x * f;
}
inline void write(int x) {
if (x < 0) x = ~(x - 1), putchar('-');
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}
}
using namespace std;
using namespace mystd;

const int maxn = 3e3 + 300;
int n, mod, res, fac[maxn], inv[maxn], ifac[maxn], s[maxn][maxn];

void init(int lim) {
fac[0] = inv[1] = ifac[0] = s[0][0] = 1;
for (int i = 2; i <= lim; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for (int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = ifac[i - 1] * inv[i] % mod;
for (int i = 1; i <= lim; i++) {
for (int j = 1; j <= i; j++) {
s[i][j] = (s[i - 1][j - 1] + j * s[i - 1][j]) % mod;
}
}
}

int C(int n, int m) { return fac[n] * ifac[m] % mod * ifac[n - m] % mod; }
int ksm(int p, int q, int m) {
int res = 1;
while (q) {
if (q & 1) res = res * p % m;
p = p * p % m;
q >>= 1;
}
return res;
}

signed main() {
n = read(), mod = read();
init(n + 1);
for (int x = 0; x <= n; x++) {
int tp = 0, pw = 1, p = ksm(2, n - x, mod);
for (int y = 0; y <= x; y++) {
tp = (tp + s[x + 1][y + 1] * pw % mod) % mod;
pw = pw * p % mod;
}
res = ((res + ksm(-1, x, mod) * C(n, x) % mod * ksm(2, ksm(2, n - x, mod - 1), mod) % mod * tp % mod) % mod + mod) % mod;
}
write(res);
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

int n;
int a[N], b[N], c[N];
ll suf[N];

int main() {
qread(n);
rep(i, 1, n) qread(a[i]); rep(i, 1, n) qread(b[i]); rep(i, 1, n) qread(c[i]);
sort(a + 1, a + n + 1), sort(b + 1, b + n + 1), sort(c + 1, c + n + 1);
per(i, n, 1) suf[i] = suf[i + 1] + n - (upper_bound(c + 1, c + n + 1, b[i]) - c - 1);
ll ans = 0;
rep(i, 1, n) ans += suf[upper_bound(b + 1, b + n + 1, a[i]) - b];
cout << ans << endl;
return 0;
}
#include <algorithm>
#include <iostream>
#include <numeric>
#include <cstring>
#include <iomanip>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <cmath>
#include <set>
#include <map>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int n = 20;

vector<pii> G[n];
int m = 0;

int32_t main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int L; cin >> L;
int diff = 0;
for(int i = 0; i < n-2; i++)
{
if((1 << i) >= L) break;
G[i].push_back({i+1, 0 });
G[i].push_back({i+1, (1 << i) });
m += 2;
}
for(int i = 0; i < n; i++)
{
if((L>>i)&1)
{
if(i == n-1)
{
G[n-2].push_back({n-1, diff});
G[n-2].push_back({n-1, diff+(1<<18)});
m += 2;
}
else
{
G[i].push_back({n-1, diff});
diff += (1<<i);
m++;
}
}
}
cout << n << " " << m << endl;
for(int i = 0; i < n; i++)
for(pii p: G[i])
cout << i+1 << " " << p.first+1 << " " << p.second << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],cnt[maxn];
vector<int> vec;

void orzck(){
init_comb(maxn);
cin >> n;
rep(n+1) cin >> a[i];
rep(n+1) a[i]--;
rep(n+1) cnt[a[i]]++;
rep(n) if(cnt[i]==2){
rep1(j,n+1) if(a[j]==i) vec.pb(j);
break;
}
rep2(i,1,n+2){
print(C(n+1,i)-C(n+1-(vec[1]-vec[0]+1),i-1));
}
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<iostream>
using namespace std;

int main()
{
long long n,m;
int a=1;
cin>>n;
m=0;
while(m<n){

m+=a;
a++;
};
printf("%d\n",a-1);


return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <math.h>
#include <numeric>
#include <list>
#include <queue>
#include <string>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <string>   


using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<vector<int>> vvi;
typedef vector<vector<int>> vi;
typedef pair<pair<int,int>, int> ppiii;
typedef pair<int, pair<int,int>> pipii;
typedef pair<int,char> pic;
typedef pair<char,int> pci;
typedef pair<string,string> pss;


ll MX = 1000*1000*1000;
void solve() {
ll n,m; cin >> n >> m;
map<ll, vector<pll>> lt,rt;
for(int i = 1; i <= m; i++) {
ll l,r,d; cin >> l >> r >> d;
lt[l].push_back({r, d});
rt[r].push_back({l, d});
}

unordered_map<ll,ll> pos;
for (ll i = 1; i <= n; i++) {
if (!rt[i].empty() || pos.count(i)) continue;
queue<ll> track;
track.push(i);
pos[i] = 0;
while(track.size()) {
ll cur =  track.front();
track.pop();
for(auto k : lt[cur]) {
ll expect = k.second + pos[cur];
if (!pos.count(k.first)) {
pos[k.first] = expect;
track.push(k.first);
}
if (pos[k.first] != expect) {
cout << "No" << endl;
return;
}
}
for(auto k : rt[cur]) {
ll expect = pos[cur] - k.second;
if (!pos.count(k.first)) {
pos[k.first] = expect;
track.push(k.first);
}
if (pos[k.first] != expect) {
cout << "No" << endl;
return;
}
}
}
}
ll shift = 0;
for(auto it : pos) {
if (it.second < 0) {
shift = max(-it.second, shift);
}
}
for(auto& it : pos) {
it.second += shift;
if (it.second > MX) {
cout << "No" << endl;
return;
}
}
if (pos.size() != n) {
cout << "No" << endl;
return;
}
cout << "Yes" << endl;

}




int main() {
ios_base::sync_with_stdio(0);
cin.tie(0);
int t = 1;
//cin >> t;
while(t--) {
solve();
}
}







#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
template<typename T, int maxn, int type>
struct sparse{
vector<T> val[22];
sparse(){rep(__lg(maxn)+1) val[i].resize(max(0ll,maxn-pow2(i)+1));}
inline T oper(T i, T j){return type?max(i,j):min(i,j);}
void init(vector<T>& vec){
rep(sz(vec)) val[0][i]=vec[i];
rep2(i,1,__lg(maxn)+1) rep1(j,sz(vec)-pow2(i)+1) val[i][j]=oper(val[i-1][j],val[i-1][j+pow2(i-1)]);
}
T query(int l, int r){return oper(val[__lg(r-l+1)][l],val[__lg(r-l+1)][r-pow2(__lg(r-l+1))+1]);}
};
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m,cnt[maxn];

void orzck(){
cin >> n >> m;
rep(m){
int u,v;
cin >> u >> v;
u--,v--;
if(u>v) swap(u,v);
if(u==0) cnt[v]++;
if(v==n-1) cnt[u]++;
}
rep(n) if(cnt[i]==2){
print("POSSIBLE");
return;
}
print("IMPOSSIBLE");
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
using namespace std;

const int MAXN=6005;

struct edge{
int to,next;
}e[MAXN<<1];
int head[MAXN],n,cnt=0;
inline void add(int u,int v){
e[++cnt]=(edge){v,head[u]},head[u]=cnt;
}
int fa[MAXN],val[MAXN];
pair<int,int>f[MAXN];
#define mp make_pair

int F[MAXN];

void dfs(int u){
bool isleave=1;
for(int i=head[u];i;i=e[i].next){
isleave=0;
int v=e[i].to;
dfs(v);
}
if(isleave){
f[u]=mp(val[u],0);
}
else{
memset(F,0,sizeof(F));
F[0]=1;
int tot=0,minn=0;
for(int i=head[u];i;i=e[i].next){
int v=e[i].to;
tot+=f[v].first+f[v].second;
minn+=f[v].second;
for(int j=val[u];j>=0;j--){
if(!F[j])continue;
if(j+f[v].first<=val[u]){
F[j+f[v].first]=1;
}
if(j+f[v].second<=val[u]){
F[j+f[v].second]=1;
}
}
}
if(minn>val[u]){
puts("IMPOSSIBLE");
exit(0);
}
for(int i=val[u];i>=0;i--){
if(F[i]){
int remain=tot-i;
f[u]=mp(remain,val[u]);
if(f[u].first<f[u].second)swap(f[u].first,f[u].second);
break;
}
}
}
}
int main(){
scanf("%d",&n);
for(int i=2;i<=n;i++){
scanf("%d",&fa[i]);
add(fa[i],i);
}
for(int i=1;i<=n;i++){
scanf("%d",&val[i]);
}
dfs(1);
puts("POSSIBLE");
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main()
{

cin.tie(0) -> ios_base::sync_with_stdio(0);

string s;
cin >> s;
int n = s.size();
int ans = n;
for(int i=0;i<n;i++)
{
if(s[i] != s[i+1])
ans = min(ans, max(i + 1, n - i - 1));
}
cout << ans << '\n';

}   
#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <charconv>
#include <cmath>
using namespace std;

#define rep(i, n) for (long i = 0; i < (long)(n); i++)
using ll = long long;



int main() {
ll n,k;
cin>>n>>k;
vector<ll>a(n);
vector<ll>num(200001,0);
rep(i,n){
cin>>a[i];
num[a[i]]++;
}
vector<ll>b;
ll spe=0;
rep(i,num.size()){
if(num[i]!=0){
b.push_back(num[i]);
spe++;
}
}
sort(b.begin(), b.end());
if(spe<=k){
cout<<0<<endl;
exit(0);
}
ll ans=0;
rep(i,spe-k){
ans+=b[i];
}
cout<<ans<<endl;

}


#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=2e5+10;
int n;
int t[30];
char s[N];
char ans[N];
int fr[N],v[N];
int nxt[N][30];
queue <int> q;
int main()
{
scanf("%s",s+1),n=strlen(s+1);
for(int i=n;i>=1;i--)
{
nxt[i][s[i+1]-'a'+1]=i+1;
for(char j='a';j<='z';j++)
{
if(s[i+1]==j) nxt[i][j-'a'+1]=i+1;
else nxt[i][j-'a'+1]=nxt[i+1][j-'a'+1];
}
}
for(int i=1;i<=n;i++) if(!t[s[i]-'a'+1])
nxt[0][s[i]-'a'+1]=i,t[s[i]-'a'+1]=1;q.push(0);
while(q.size())
{
int x=q.front();q.pop();
for(int i=1;i<=26;i++)
{
int t=nxt[x][i];
if(!t)
{
int cnt=0;
ans[++cnt]=i+'a'-1;
while(x) ans[++cnt]=s[x],x=fr[x];
for(int i=cnt;i>=1;i--) putchar(ans[i]);exit(0);
}
else if(!v[t]) v[t]=1,fr[t]=x,q.push(t);
}
}
return 0;
}
#include "bits/stdc++.h"
using namespace std;

#pragma GCC optimize("Ofast")
#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#pragma GCC optimize("unroll-loops")

#define rep(i,a,b) for (int i=(a); i<(b); i++)
#define repd(i,a,b) for (int i=(a); i>(b); i--)
#define fori(i,a) for (int i=(0); i<(a); i++)
#define ford(i,a) for (int i=(a); i>(-1); i--)
#define trav(i,a) for(auto &i: a)
#define ll long long int
#define mp make_pair
#define pb push_back
#define f first
#define s second
#define pq priority_queue
#define pii pair<int, int>
#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define T(t)  while(t--)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
#define sz(x) (int) x.size()
#define nl '\n'
#define Nl '\n'
#define min3(a1,b1,cost) min(a1,min(b1,cost))
#define min4(a1,b1,cost,d ) min(a1 , min(b1 , min(cost,d)))
#define max3(a1,b1,cost) max(a1 , max(b1,cost))
#define max4(a1,b1,cost,d) max(max(a1,b1) , max(cost,d))
#define fsp(x) fixed<<setprecision(x)
#define mod 1000000007
#define mod1 998244353
#define yes cout<<"Yes";
#define no cout<<"No";
#define inf INT_MAX

pair<int, int> ds[] = {{0, 1} , {0, -1} , { -1, 0} , {1, 0}};

ll _pow(ll x, ll n){
if (n) {
ll u = _pow(x, n / 2);
u *= u;
if (n % 2) u *= x;
return u;
}
return 1;
}

ll mpow(ll x, ll n, ll m) {
if (n) {
ll u = mpow(x, n / 2, m);
u = (u * u) % m;
if (n % 2) u = (u * x) % m;
return u;
}
return 1 % m;
}


int invmod(int a, int m) {
return mpow(a, m - 2, m);
}

ll C(int n, int r) {
if (n < 0) n *= -1;
if (r < 0) r *= -1;
ll ans = 1;
rep(i, 1, r + 1) {
ans *= (n + 1 - i);
ans /= i;
}
return ans;
}


ll mull(ll a, ll b, ll m) {
return (a % m * b % m) % m;
}

void solve() {
int n; cin>>n;
vector<ll>a(n+1);
ll ans =1;
rep(i,2,n+1){
int r = sqrt(n)+1;
int j =i;
rep(k,2,r){
if(j%k==0){
while(j%k==0) j/=k,a[k]++;
}
}
if(j>1)a[j]++;
}	
trav(i,a) ans = ans*(i+1)%mod;
cout<<ans<<nl;
}

int main() {
fastio;
//pre();
int t = 1; //cin >> t;
for (int i = 1; i <= t; i++) {
//cout<<"Case #"<<i<<": ";
solve();
}
return 0;
}
// check if you are correctly updating values
// check if you are missing a cin
// check if t==1?

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 5e5 + 5)

int n, d, q;
int a[N], to[N];
int mn[N];

int main() {
qread(n, d);
rep(i, 1, n) qread(a[i]);
int nw = d;
to[0] = d; mn[n + 1] = 1;
rep(i, 1, n) {
To_min(nw, abs(nw - a[i]));
to[i] = nw;
}
per(i, n, 1) {
if(a[i] >= 2 * mn[i + 1]) mn[i] = mn[i + 1];
else mn[i] = mn[i + 1] + a[i];
}
qread(q);
W(q) {
int x; qread(x);
if(to[x - 1] >= mn[x + 1]) puts("YES");
else puts("NO");
}
return 0;
}
#line 1 "Contests/AtCoder_arc132/arc132_a/main.cpp"
using namespace std;
#line 2 "library/bits/stdc++.h"

// C
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif
#line 3 "Contests/AtCoder_arc132/arc132_a/main.cpp"

// add your library with double quotation #include"" here.
#line 1 "library/atcoder/convolution.hpp"



#line 5 "library/atcoder/convolution.hpp"
#include <array>
#include <cassert>
#include <type_traits>
#line 9 "library/atcoder/convolution.hpp"

#line 1 "library/atcoder/internal_bit.hpp"



#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

// @param n `0 <= n`
// @return minimum non-negative `x` s.t. `n <= 2**x`
int ceil_pow2(int n) {
int x = 0;
while ((1U << x) < (unsigned int)(n)) x++;
return x;
}

// @param n `1 <= n`
// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`
int bsf(unsigned int n) {
#ifdef _MSC_VER
unsigned long index;
_BitScanForward(&index, n);
return index;
#else
return __builtin_ctz(n);
#endif
}

}  // namespace internal

}  // namespace atcoder


#line 1 "library/atcoder/modint.hpp"



#line 7 "library/atcoder/modint.hpp"

#ifdef _MSC_VER
#include <intrin.h>
#endif

#line 1 "library/atcoder/internal_math.hpp"



#line 5 "library/atcoder/internal_math.hpp"

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

// @param m `1 <= m`
// @return x mod m
constexpr long long safe_mod(long long x, long long m) {
x %= m;
if (x < 0) x += m;
return x;
}

// Fast modular multiplication by barrett reduction
// Reference: https://en.wikipedia.org/wiki/Barrett_reduction
// NOTE: reconsider after Ice Lake
struct barrett {
unsigned int _m;
unsigned long long im;

// @param m `1 <= m < 2^31`
explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

// @return m
unsigned int umod() const { return _m; }

// @param a `0 <= a < m`
// @param b `0 <= b < m`
// @return `a * b % m`
unsigned int mul(unsigned int a, unsigned int b) const {
// [1] m = 1
// a = b = im = 0, so okay

// [2] m >= 2
// im = ceil(2^64 / m)
// -> im * m = 2^64 + r (0 <= r < m)
// let z = a*b = c*m + d (0 <= c, d < m)
// a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im
// c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2
// ((ab * im) >> 64) == c or c + 1
unsigned long long z = a;
z *= b;
#ifdef _MSC_VER
unsigned long long x;
_umul128(z, im, &x);
#else
unsigned long long x =
(unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
unsigned int v = (unsigned int)(z - x * _m);
if (_m <= v) v += _m;
return v;
}
};

// @param n `0 <= n`
// @param m `1 <= m`
// @return `(x ** n) % m`
constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
if (m == 1) return 0;
unsigned int _m = (unsigned int)(m);
unsigned long long r = 1;
unsigned long long y = safe_mod(x, m);
while (n) {
if (n & 1) r = (r * y) % _m;
y = (y * y) % _m;
n >>= 1;
}
return r;
}

// Reference:
// M. Forisek and J. Jancina,
// Fast Primality Testing for Integers That Fit into a Machine Word
// @param n `0 <= n`
constexpr bool is_prime_constexpr(int n) {
if (n <= 1) return false;
if (n == 2 || n == 7 || n == 61) return true;
if (n % 2 == 0) return false;
long long d = n - 1;
while (d % 2 == 0) d /= 2;
constexpr long long bases[3] = {2, 7, 61};
for (long long a : bases) {
long long t = d;
long long y = pow_mod_constexpr(a, t, n);
while (t != n - 1 && y != 1 && y != n - 1) {
y = y * y % n;
t <<= 1;
}
if (y != n - 1 && t % 2 == 0) {
return false;
}
}
return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

// @param b `1 <= b`
// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g
constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
a = safe_mod(a, b);
if (a == 0) return {b, 0};

// Contracts:
// [1] s - m0 * a = 0 (mod b)
// [2] t - m1 * a = 0 (mod b)
// [3] s * |m1| + t * |m0| <= b
long long s = b, t = a;
long long m0 = 0, m1 = 1;

while (t) {
long long u = s / t;
s -= t * u;
m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b

// [3]:
// (s - t * u) * |m1| + t * |m0 - m1 * u|
// <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)
// = s * |m1| + t * |m0| <= b

auto tmp = s;
s = t;
t = tmp;
tmp = m0;
m0 = m1;
m1 = tmp;
}
// by [3]: |m0| <= b/g
// by g != b: |m0| < b/g
if (m0 < 0) m0 += b / s;
return {s, m0};
}

// Compile time primitive root
// @param m must be prime
// @return primitive root (and minimum in now)
constexpr int primitive_root_constexpr(int m) {
if (m == 2) return 1;
if (m == 167772161) return 3;
if (m == 469762049) return 3;
if (m == 754974721) return 11;
if (m == 998244353) return 3;
int divs[20] = {};
divs[0] = 2;
int cnt = 1;
int x = (m - 1) / 2;
while (x % 2 == 0) x /= 2;
for (int i = 3; (long long)(i)*i <= x; i += 2) {
if (x % i == 0) {
divs[cnt++] = i;
while (x % i == 0) {
x /= i;
}
}
}
if (x > 1) {
divs[cnt++] = x;
}
for (int g = 2;; g++) {
bool ok = true;
for (int i = 0; i < cnt; i++) {
if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
ok = false;
break;
}
}
if (ok) return g;
}
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

// @param n `n < 2^32`
// @param m `1 <= m < 2^32`
// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)
unsigned long long floor_sum_unsigned(unsigned long long n,
unsigned long long m,
unsigned long long a,
unsigned long long b) {
unsigned long long ans = 0;
while (true) {
if (a >= m) {
ans += n * (n - 1) / 2 * (a / m);
a %= m;
}
if (b >= m) {
ans += n * (b / m);
b %= m;
}

unsigned long long y_max = a * n + b;
if (y_max < m) break;
// y_max < m * (n + 1)
// floor(y_max / m) <= n
n = (unsigned long long)(y_max / m);
b = (unsigned long long)(y_max % m);
std::swap(m, a);
}
return ans;
}

}  // namespace internal

}  // namespace atcoder


#line 1 "library/atcoder/internal_type_traits.hpp"



#line 7 "library/atcoder/internal_type_traits.hpp"

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value ||
std::is_same<T, __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int128 =
typename std::conditional<std::is_same<T, __uint128_t>::value ||
std::is_same<T, unsigned __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using make_unsigned_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value,
__uint128_t,
unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
is_signed_int128<T>::value ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
std::is_signed<T>::value) ||
is_signed_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<(is_integral<T>::value &&
std::is_unsigned<T>::value) ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
is_signed_int128<T>::value,
make_unsigned_int128<T>,
typename std::conditional<std::is_signed<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<is_integral<T>::value &&
std::is_unsigned<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


#line 14 "library/atcoder/modint.hpp"

namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
using mint = static_modint;

public:
static constexpr int mod() { return m; }
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

static_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
static_modint(T v) {
long long x = (long long)(v % (long long)(umod()));
if (x < 0) x += umod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
static_modint(T v) {
_v = (unsigned int)(v % umod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v -= rhs._v;
if (_v >= umod()) _v += umod();
return *this;
}
mint& operator*=(const mint& rhs) {
unsigned long long z = _v;
z *= rhs._v;
_v = (unsigned int)(z % umod());
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
if (prime) {
assert(_v);
return pow(umod() - 2);
} else {
auto eg = internal::inv_gcd(_v, m);
assert(eg.first == 1);
return eg.second;
}
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static constexpr unsigned int umod() { return m; }
static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
using mint = dynamic_modint;

public:
static int mod() { return (int)(bt.umod()); }
static void set_mod(int m) {
assert(1 <= m);
bt = internal::barrett(m);
}
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

dynamic_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
dynamic_modint(T v) {
long long x = (long long)(v % (long long)(mod()));
if (x < 0) x += mod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
dynamic_modint(T v) {
_v = (unsigned int)(v % mod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v += mod() - rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator*=(const mint& rhs) {
_v = bt.mul(_v, rhs._v);
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
auto eg = internal::inv_gcd(_v, mod());
assert(eg.first == 1);
return eg.second;
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static internal::barrett bt;
static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder


#line 12 "library/atcoder/convolution.hpp"

namespace atcoder {

namespace internal {

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
void butterfly(std::vector<mint>& a) {
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);

static bool first = true;
static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]
if (first) {
first = false;
mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--) {
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i <= cnt2 - 2; i++) {
sum_e[i] = es[i] * now;
now *= ies[i];
}
}
for (int ph = 1; ph <= h; ph++) {
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint now = 1;
for (int s = 0; s < w; s++) {
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++) {
auto l = a[i + offset];
auto r = a[i + offset + p] * now;
a[i + offset] = l + r;
a[i + offset + p] = l - r;
}
now *= sum_e[bsf(~(unsigned int)(s))];
}
}
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
void butterfly_inv(std::vector<mint>& a) {
static constexpr int g = internal::primitive_root<mint::mod()>;
int n = int(a.size());
int h = internal::ceil_pow2(n);

static bool first = true;
static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]
if (first) {
first = false;
mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1
int cnt2 = bsf(mint::mod() - 1);
mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();
for (int i = cnt2; i >= 2; i--) {
// e^(2^i) == 1
es[i - 2] = e;
ies[i - 2] = ie;
e *= e;
ie *= ie;
}
mint now = 1;
for (int i = 0; i <= cnt2 - 2; i++) {
sum_ie[i] = ies[i] * now;
now *= es[i];
}
}

for (int ph = h; ph >= 1; ph--) {
int w = 1 << (ph - 1), p = 1 << (h - ph);
mint inow = 1;
for (int s = 0; s < w; s++) {
int offset = s << (h - ph + 1);
for (int i = 0; i < p; i++) {
auto l = a[i + offset];
auto r = a[i + offset + p];
a[i + offset] = l + r;
a[i + offset + p] =
(unsigned long long)(mint::mod() + l.val() - r.val()) *
inow.val();
}
inow *= sum_ie[bsf(~(unsigned int)(s))];
}
}
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution_naive(const std::vector<mint>& a, const std::vector<mint>& b) {
int n = int(a.size()), m = int(b.size());
std::vector<mint> ans(n + m - 1);
if (n < m) {
for (int j = 0; j < m; j++) {
for (int i = 0; i < n; i++) {
ans[i + j] += a[i] * b[j];
}
}
} else {
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
ans[i + j] += a[i] * b[j];
}
}
}
return ans;
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution_fft(std::vector<mint> a, std::vector<mint> b) {
int n = int(a.size()), m = int(b.size());
int z = 1 << internal::ceil_pow2(n + m - 1);
a.resize(z);
internal::butterfly(a);
b.resize(z);
internal::butterfly(b);
for (int i = 0; i < z; i++) {
a[i] *= b[i];
}
internal::butterfly_inv(a);
a.resize(n + m - 1);
mint iz = mint(z).inv();
for (int i = 0; i < n + m - 1; i++) a[i] *= iz;
return a;
}

}  // namespace internal

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution(std::vector<mint>&& a, std::vector<mint>&& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};
if (std::min(n, m) <= 60) return convolution_naive(a, b);
return internal::convolution_fft(a, b);
}

template <class mint, internal::is_static_modint_t<mint>* = nullptr>
std::vector<mint> convolution(const std::vector<mint>& a, const std::vector<mint>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};
if (std::min(n, m) <= 60) return convolution_naive(a, b);
return internal::convolution_fft(a, b);
}

template <unsigned int mod = 998244353,
class T,
std::enable_if_t<internal::is_integral<T>::value>* = nullptr>
std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};

using mint = static_modint<mod>;
std::vector<mint> a2(n), b2(m);
for (int i = 0; i < n; i++) {
a2[i] = mint(a[i]);
}
for (int i = 0; i < m; i++) {
b2[i] = mint(b[i]);
}
auto c2 = convolution(move(a2), move(b2));
std::vector<T> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++) {
c[i] = c2[i].val();
}
return c;
}

std::vector<long long> convolution_ll(const std::vector<long long>& a,
const std::vector<long long>& b) {
int n = int(a.size()), m = int(b.size());
if (!n || !m) return {};

static constexpr unsigned long long MOD1 = 754974721;  // 2^24
static constexpr unsigned long long MOD2 = 167772161;  // 2^25
static constexpr unsigned long long MOD3 = 469762049;  // 2^26
static constexpr unsigned long long M2M3 = MOD2 * MOD3;
static constexpr unsigned long long M1M3 = MOD1 * MOD3;
static constexpr unsigned long long M1M2 = MOD1 * MOD2;
static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;

static constexpr unsigned long long i1 =
internal::inv_gcd(MOD2 * MOD3, MOD1).second;
static constexpr unsigned long long i2 =
internal::inv_gcd(MOD1 * MOD3, MOD2).second;
static constexpr unsigned long long i3 =
internal::inv_gcd(MOD1 * MOD2, MOD3).second;

auto c1 = convolution<MOD1>(a, b);
auto c2 = convolution<MOD2>(a, b);
auto c3 = convolution<MOD3>(a, b);

std::vector<long long> c(n + m - 1);
for (int i = 0; i < n + m - 1; i++) {
unsigned long long x = 0;
x += (c1[i] * i1) % MOD1 * M2M3;
x += (c2[i] * i2) % MOD2 * M1M3;
x += (c3[i] * i3) % MOD3 * M1M2;
// B = 2^63, -B <= x, r(real value) < B
// (x, x - M, x - 2M, or x - 3M) = r (mod 2B)
// r = c1[i] (mod MOD1)
// focus on MOD1
// r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)
// r = x,
//     x - M' + (0 or 2B),
//     x - 2M' + (0, 2B or 4B),
//     x - 3M' + (0, 2B, 4B or 6B) (without mod!)
// (r - x) = 0, (0)
//           - M' + (0 or 2B), (1)
//           -2M' + (0 or 2B or 4B), (2)
//           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)
// we checked that
//   ((1) mod MOD1) mod 5 = 2
//   ((2) mod MOD1) mod 5 = 3
//   ((3) mod MOD1) mod 5 = 4
long long diff =
c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));
if (diff < 0) diff += MOD1;
static constexpr unsigned long long offset[5] = {
0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};
x -= offset[diff % 5];
c[i] = x;
}

return c;
}

}  // namespace atcoder


#line 1 "library/atcoder/dsu.hpp"



#line 7 "library/atcoder/dsu.hpp"

namespace atcoder {

// Implement (union by size) + (path compression)
// Reference:
// Zvi Galil and Giuseppe F. Italiano,
// Data structures and algorithms for disjoint set union problems
struct dsu {
public:
dsu() : _n(0) {}
explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}

int merge(int a, int b) {
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
int x = leader(a), y = leader(b);
if (x == y) return x;
if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
parent_or_size[x] += parent_or_size[y];
parent_or_size[y] = x;
return x;
}

bool same(int a, int b) {
assert(0 <= a && a < _n);
assert(0 <= b && b < _n);
return leader(a) == leader(b);
}

int leader(int a) {
assert(0 <= a && a < _n);
if (parent_or_size[a] < 0) return a;
return parent_or_size[a] = leader(parent_or_size[a]);
}

int size(int a) {
assert(0 <= a && a < _n);
return -parent_or_size[leader(a)];
}

std::vector<std::vector<int>> groups() {
std::vector<int> leader_buf(_n), group_size(_n);
for (int i = 0; i < _n; i++) {
leader_buf[i] = leader(i);
group_size[leader_buf[i]]++;
}
std::vector<std::vector<int>> result(_n);
for (int i = 0; i < _n; i++) {
result[i].reserve(group_size[i]);
}
for (int i = 0; i < _n; i++) {
result[leader_buf[i]].push_back(i);
}
result.erase(
std::remove_if(result.begin(), result.end(),
[&](const std::vector<int>& v) { return v.empty(); }),
result.end());
return result;
}

private:
int _n;
// root node: -1 * component size
// otherwise: parent
std::vector<int> parent_or_size;
};

}  // namespace atcoder


#line 1 "library/atcoder/fenwicktree.hpp"



#line 6 "library/atcoder/fenwicktree.hpp"

#line 8 "library/atcoder/fenwicktree.hpp"

namespace atcoder {

// Reference: https://en.wikipedia.org/wiki/Fenwick_tree
template <class T> struct fenwick_tree {
using U = internal::to_unsigned_t<T>;

public:
fenwick_tree() : _n(0) {}
explicit fenwick_tree(int n) : _n(n), data(n) {}

void add(int p, T x) {
assert(0 <= p && p < _n);
p++;
while (p <= _n) {
data[p - 1] += U(x);
p += p & -p;
}
}

T sum(int l, int r) {
assert(0 <= l && l <= r && r <= _n);
return sum(r) - sum(l);
}

private:
int _n;
std::vector<U> data;

U sum(int r) {
U s = 0;
while (r > 0) {
s += data[r - 1];
r -= r & -r;
}
return s;
}
};

}  // namespace atcoder


#line 1 "library/atcoder/lazysegtree.hpp"



#line 8 "library/atcoder/lazysegtree.hpp"

#line 10 "library/atcoder/lazysegtree.hpp"

namespace atcoder {

template <class S,
S (*op)(S, S),
S (*e)(),
class F,
S (*mapping)(F, S),
F (*composition)(F, F),
F (*id)()>
struct lazy_segtree {
public:
lazy_segtree() : lazy_segtree(0) {}
explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}
explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
lz = std::vector<F>(size, id());
for (int i = 0; i < _n; i++) d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--) {
update(i);
}
}

void set(int p, S x) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
d[p] = x;
for (int i = 1; i <= log; i++) update(p >> i);
}

S get(int p) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
return d[p];
}

S prod(int l, int r) {
assert(0 <= l && l <= r && r <= _n);
if (l == r) return e();

l += size;
r += size;

for (int i = log; i >= 1; i--) {
if (((l >> i) << i) != l) push(l >> i);
if (((r >> i) << i) != r) push((r - 1) >> i);
}

S sml = e(), smr = e();
while (l < r) {
if (l & 1) sml = op(sml, d[l++]);
if (r & 1) smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}

return op(sml, smr);
}

S all_prod() { return d[1]; }

void apply(int p, F f) {
assert(0 <= p && p < _n);
p += size;
for (int i = log; i >= 1; i--) push(p >> i);
d[p] = mapping(f, d[p]);
for (int i = 1; i <= log; i++) update(p >> i);
}
void apply(int l, int r, F f) {
assert(0 <= l && l <= r && r <= _n);
if (l == r) return;

l += size;
r += size;

for (int i = log; i >= 1; i--) {
if (((l >> i) << i) != l) push(l >> i);
if (((r >> i) << i) != r) push((r - 1) >> i);
}

{
int l2 = l, r2 = r;
while (l < r) {
if (l & 1) all_apply(l++, f);
if (r & 1) all_apply(--r, f);
l >>= 1;
r >>= 1;
}
l = l2;
r = r2;
}

for (int i = 1; i <= log; i++) {
if (((l >> i) << i) != l) update(l >> i);
if (((r >> i) << i) != r) update((r - 1) >> i);
}
}

template <bool (*g)(S)> int max_right(int l) {
return max_right(l, [](S x) { return g(x); });
}
template <class G> int max_right(int l, G g) {
assert(0 <= l && l <= _n);
assert(g(e()));
if (l == _n) return _n;
l += size;
for (int i = log; i >= 1; i--) push(l >> i);
S sm = e();
do {
while (l % 2 == 0) l >>= 1;
if (!g(op(sm, d[l]))) {
while (l < size) {
push(l);
l = (2 * l);
if (g(op(sm, d[l]))) {
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}

template <bool (*g)(S)> int min_left(int r) {
return min_left(r, [](S x) { return g(x); });
}
template <class G> int min_left(int r, G g) {
assert(0 <= r && r <= _n);
assert(g(e()));
if (r == 0) return 0;
r += size;
for (int i = log; i >= 1; i--) push((r - 1) >> i);
S sm = e();
do {
r--;
while (r > 1 && (r % 2)) r >>= 1;
if (!g(op(d[r], sm))) {
while (r < size) {
push(r);
r = (2 * r + 1);
if (g(op(d[r], sm))) {
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;
std::vector<F> lz;

void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
void all_apply(int k, F f) {
d[k] = mapping(f, d[k]);
if (k < size) lz[k] = composition(f, lz[k]);
}
void push(int k) {
all_apply(2 * k, lz[k]);
all_apply(2 * k + 1, lz[k]);
lz[k] = id();
}
};

}  // namespace atcoder


#line 1 "library/atcoder/math.hpp"



#line 6 "library/atcoder/math.hpp"
#include <tuple>
#line 8 "library/atcoder/math.hpp"

#line 10 "library/atcoder/math.hpp"

namespace atcoder {

long long pow_mod(long long x, long long n, int m) {
assert(0 <= n && 1 <= m);
if (m == 1) return 0;
internal::barrett bt((unsigned int)(m));
unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));
while (n) {
if (n & 1) r = bt.mul(r, y);
y = bt.mul(y, y);
n >>= 1;
}
return r;
}

long long inv_mod(long long x, long long m) {
assert(1 <= m);
auto z = internal::inv_gcd(x, m);
assert(z.first == 1);
return z.second;
}

// (rem, mod)
std::pair<long long, long long> crt(const std::vector<long long>& r,
const std::vector<long long>& m) {
assert(r.size() == m.size());
int n = int(r.size());
// Contracts: 0 <= r0 < m0
long long r0 = 0, m0 = 1;
for (int i = 0; i < n; i++) {
assert(1 <= m[i]);
long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];
if (m0 < m1) {
std::swap(r0, r1);
std::swap(m0, m1);
}
if (m0 % m1 == 0) {
if (r0 % m1 != r1) return {0, 0};
continue;
}
// assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)

// (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));
// r2 % m0 = r0
// r2 % m1 = r1
// -> (r0 + x*m0) % m1 = r1
// -> x*u0*g = r1-r0 (mod u1*g) (u0*g = m0, u1*g = m1)
// -> x = (r1 - r0) / g * inv(u0) (mod u1)

// im = inv(u0) (mod u1) (0 <= im < u1)
long long g, im;
std::tie(g, im) = internal::inv_gcd(m0, m1);

long long u1 = (m1 / g);
// |r1 - r0| < (m0 + m1) <= lcm(m0, m1)
if ((r1 - r0) % g) return {0, 0};

// u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)
long long x = (r1 - r0) / g % u1 * im % u1;

// |r0| + |m0 * x|
// < m0 + m0 * (u1 - 1)
// = m0 + m0 * m1 / g - m0
// = lcm(m0, m1)
r0 += x * m0;
m0 *= u1;  // -> lcm(m0, m1)
if (r0 < 0) r0 += m0;
}
return {r0, m0};
}

long long floor_sum(long long n, long long m, long long a, long long b) {
assert(0 <= n && n < (1LL << 32));
assert(1 <= m && m < (1LL << 32));
unsigned long long ans = 0;
if (a < 0) {
unsigned long long a2 = internal::safe_mod(a, m);
ans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m);
a = a2;
}
if (b < 0) {
unsigned long long b2 = internal::safe_mod(b, m);
ans -= 1ULL * n * ((b2 - b) / m);
b = b2;
}
return ans + internal::floor_sum_unsigned(n, m, a, b);
}

}  // namespace atcoder


#line 1 "library/atcoder/maxflow.hpp"



#line 9 "library/atcoder/maxflow.hpp"

#line 1 "library/atcoder/internal_queue.hpp"



#line 5 "library/atcoder/internal_queue.hpp"

namespace atcoder {

namespace internal {

template <class T> struct simple_queue {
std::vector<T> payload;
int pos = 0;
void reserve(int n) { payload.reserve(n); }
int size() const { return int(payload.size()) - pos; }
bool empty() const { return pos == int(payload.size()); }
void push(const T& t) { payload.push_back(t); }
T& front() { return payload[pos]; }
void clear() {
payload.clear();
pos = 0;
}
void pop() { pos++; }
};

}  // namespace internal

}  // namespace atcoder


#line 11 "library/atcoder/maxflow.hpp"

namespace atcoder {

template <class Cap> struct mf_graph {
public:
mf_graph() : _n(0) {}
explicit mf_graph(int n) : _n(n), g(n) {}

int add_edge(int from, int to, Cap cap) {
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
int m = int(pos.size());
pos.push_back({from, int(g[from].size())});
int from_id = int(g[from].size());
int to_id = int(g[to].size());
if (from == to) to_id++;
g[from].push_back(_edge{to, to_id, cap});
g[to].push_back(_edge{from, from_id, 0});
return m;
}

struct edge {
int from, to;
Cap cap, flow;
};

edge get_edge(int i) {
int m = int(pos.size());
assert(0 <= i && i < m);
auto _e = g[pos[i].first][pos[i].second];
auto _re = g[_e.to][_e.rev];
return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};
}
std::vector<edge> edges() {
int m = int(pos.size());
std::vector<edge> result;
for (int i = 0; i < m; i++) {
result.push_back(get_edge(i));
}
return result;
}
void change_edge(int i, Cap new_cap, Cap new_flow) {
int m = int(pos.size());
assert(0 <= i && i < m);
assert(0 <= new_flow && new_flow <= new_cap);
auto& _e = g[pos[i].first][pos[i].second];
auto& _re = g[_e.to][_e.rev];
_e.cap = new_cap - new_flow;
_re.cap = new_flow;
}

Cap flow(int s, int t) {
return flow(s, t, std::numeric_limits<Cap>::max());
}
Cap flow(int s, int t, Cap flow_limit) {
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);

std::vector<int> level(_n), iter(_n);
internal::simple_queue<int> que;

auto bfs = [&]() {
std::fill(level.begin(), level.end(), -1);
level[s] = 0;
que.clear();
que.push(s);
while (!que.empty()) {
int v = que.front();
que.pop();
for (auto e : g[v]) {
if (e.cap == 0 || level[e.to] >= 0) continue;
level[e.to] = level[v] + 1;
if (e.to == t) return;
que.push(e.to);
}
}
};
auto dfs = [&](auto self, int v, Cap up) {
if (v == s) return up;
Cap res = 0;
int level_v = level[v];
for (int& i = iter[v]; i < int(g[v].size()); i++) {
_edge& e = g[v][i];
if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;
Cap d =
self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));
if (d <= 0) continue;
g[v][i].cap += d;
g[e.to][e.rev].cap -= d;
res += d;
if (res == up) return res;
}
level[v] = _n;
return res;
};

Cap flow = 0;
while (flow < flow_limit) {
bfs();
if (level[t] == -1) break;
std::fill(iter.begin(), iter.end(), 0);
Cap f = dfs(dfs, t, flow_limit - flow);
if (!f) break;
flow += f;
}
return flow;
}

std::vector<bool> min_cut(int s) {
std::vector<bool> visited(_n);
internal::simple_queue<int> que;
que.push(s);
while (!que.empty()) {
int p = que.front();
que.pop();
visited[p] = true;
for (auto e : g[p]) {
if (e.cap && !visited[e.to]) {
visited[e.to] = true;
que.push(e.to);
}
}
}
return visited;
}

private:
int _n;
struct _edge {
int to, rev;
Cap cap;
};
std::vector<std::pair<int, int>> pos;
std::vector<std::vector<_edge>> g;
};

}  // namespace atcoder


#line 1 "library/atcoder/mincostflow.hpp"



#line 9 "library/atcoder/mincostflow.hpp"

#line 1 "library/atcoder/internal_csr.hpp"



#line 7 "library/atcoder/internal_csr.hpp"

namespace atcoder {
namespace internal {

template <class E> struct csr {
std::vector<int> start;
std::vector<E> elist;
explicit csr(int n, const std::vector<std::pair<int, E>>& edges)
: start(n + 1), elist(edges.size()) {
for (auto e : edges) {
start[e.first + 1]++;
}
for (int i = 1; i <= n; i++) {
start[i] += start[i - 1];
}
auto counter = start;
for (auto e : edges) {
elist[counter[e.first]++] = e.second;
}
}
};

}  // namespace internal

}  // namespace atcoder


#line 12 "library/atcoder/mincostflow.hpp"

namespace atcoder {

template <class Cap, class Cost> struct mcf_graph {
public:
mcf_graph() {}
explicit mcf_graph(int n) : _n(n) {}

int add_edge(int from, int to, Cap cap, Cost cost) {
assert(0 <= from && from < _n);
assert(0 <= to && to < _n);
assert(0 <= cap);
assert(0 <= cost);
int m = int(_edges.size());
_edges.push_back({from, to, cap, 0, cost});
return m;
}

struct edge {
int from, to;
Cap cap, flow;
Cost cost;
};

edge get_edge(int i) {
int m = int(_edges.size());
assert(0 <= i && i < m);
return _edges[i];
}
std::vector<edge> edges() { return _edges; }

std::pair<Cap, Cost> flow(int s, int t) {
return flow(s, t, std::numeric_limits<Cap>::max());
}
std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {
return slope(s, t, flow_limit).back();
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t) {
return slope(s, t, std::numeric_limits<Cap>::max());
}
std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {
assert(0 <= s && s < _n);
assert(0 <= t && t < _n);
assert(s != t);

int m = int(_edges.size());
std::vector<int> edge_idx(m);

auto g = [&]() {
std::vector<int> degree(_n), redge_idx(m);
std::vector<std::pair<int, _edge>> elist;
elist.reserve(2 * m);
for (int i = 0; i < m; i++) {
auto e = _edges[i];
edge_idx[i] = degree[e.from]++;
redge_idx[i] = degree[e.to]++;
elist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});
elist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});
}
auto _g = internal::csr<_edge>(_n, elist);
for (int i = 0; i < m; i++) {
auto e = _edges[i];
edge_idx[i] += _g.start[e.from];
redge_idx[i] += _g.start[e.to];
_g.elist[edge_idx[i]].rev = redge_idx[i];
_g.elist[redge_idx[i]].rev = edge_idx[i];
}
return _g;
}();

auto result = slope(g, s, t, flow_limit);

for (int i = 0; i < m; i++) {
auto e = g.elist[edge_idx[i]];
_edges[i].flow = _edges[i].cap - e.cap;
}

return result;
}

private:
int _n;
std::vector<edge> _edges;

// inside edge
struct _edge {
int to, rev;
Cap cap;
Cost cost;
};

std::vector<std::pair<Cap, Cost>> slope(internal::csr<_edge>& g,
int s,
int t,
Cap flow_limit) {
// variants (C = maxcost):
// -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0
// reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge

// dual_dist[i] = (dual[i], dist[i])
std::vector<std::pair<Cost, Cost>> dual_dist(_n);
std::vector<int> prev_e(_n);
std::vector<bool> vis(_n);
struct Q {
Cost key;
int to;
bool operator<(Q r) const { return key > r.key; }
};
std::vector<int> que_min;
std::vector<Q> que;
auto dual_ref = [&]() {
for (int i = 0; i < _n; i++) {
dual_dist[i].second = std::numeric_limits<Cost>::max();
}
std::fill(vis.begin(), vis.end(), false);
que_min.clear();
que.clear();

// que[0..heap_r) was heapified
size_t heap_r = 0;

dual_dist[s].second = 0;
que_min.push_back(s);
while (!que_min.empty() || !que.empty()) {
int v;
if (!que_min.empty()) {
v = que_min.back();
que_min.pop_back();
} else {
while (heap_r < que.size()) {
heap_r++;
std::push_heap(que.begin(), que.begin() + heap_r);
}
v = que.front().to;
std::pop_heap(que.begin(), que.end());
que.pop_back();
heap_r--;
}
if (vis[v]) continue;
vis[v] = true;
if (v == t) break;
// dist[v] = shortest(s, v) + dual[s] - dual[v]
// dist[v] >= 0 (all reduced cost are positive)
// dist[v] <= (n-1)C
Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;
for (int i = g.start[v]; i < g.start[v + 1]; i++) {
auto e = g.elist[i];
if (!e.cap) continue;
// |-dual[e.to] + dual[v]| <= (n-1)C
// cost <= C - -(n-1)C + 0 = nC
Cost cost = e.cost - dual_dist[e.to].first + dual_v;
if (dual_dist[e.to].second - dist_v > cost) {
Cost dist_to = dist_v + cost;
dual_dist[e.to].second = dist_to;
prev_e[e.to] = e.rev;
if (dist_to == dist_v) {
que_min.push_back(e.to);
} else {
que.push_back(Q{dist_to, e.to});
}
}
}
}
if (!vis[t]) {
return false;
}

for (int v = 0; v < _n; v++) {
if (!vis[v]) continue;
// dual[v] = dual[v] - dist[t] + dist[v]
//         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) +
//         (shortest(s, v) + dual[s] - dual[v]) = - shortest(s,
//         t) + dual[t] + shortest(s, v) = shortest(s, v) -
//         shortest(s, t) >= 0 - (n-1)C
dual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;
}
return true;
};
Cap flow = 0;
Cost cost = 0, prev_cost_per_flow = -1;
std::vector<std::pair<Cap, Cost>> result = {{Cap(0), Cost(0)}};
while (flow < flow_limit) {
if (!dual_ref()) break;
Cap c = flow_limit - flow;
for (int v = t; v != s; v = g.elist[prev_e[v]].to) {
c = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);
}
for (int v = t; v != s; v = g.elist[prev_e[v]].to) {
auto& e = g.elist[prev_e[v]];
e.cap += c;
g.elist[e.rev].cap -= c;
}
Cost d = -dual_dist[s].first;
flow += c;
cost += c * d;
if (prev_cost_per_flow == d) {
result.pop_back();
}
result.push_back({flow, cost});
prev_cost_per_flow = d;
}
return result;
}
};

}  // namespace atcoder


#line 1 "library/atcoder/scc.hpp"



#line 7 "library/atcoder/scc.hpp"

#line 1 "library/atcoder/internal_scc.hpp"



#line 7 "library/atcoder/internal_scc.hpp"

#line 9 "library/atcoder/internal_scc.hpp"

namespace atcoder {
namespace internal {

// Reference:
// R. Tarjan,
// Depth-First Search and Linear Graph Algorithms
struct scc_graph {
public:
explicit scc_graph(int n) : _n(n) {}

int num_vertices() { return _n; }

void add_edge(int from, int to) { edges.push_back({from, {to}}); }

// @return pair of (# of scc, scc id)
std::pair<int, std::vector<int>> scc_ids() {
auto g = csr<edge>(_n, edges);
int now_ord = 0, group_num = 0;
std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);
visited.reserve(_n);
auto dfs = [&](auto self, int v) -> void {
low[v] = ord[v] = now_ord++;
visited.push_back(v);
for (int i = g.start[v]; i < g.start[v + 1]; i++) {
auto to = g.elist[i].to;
if (ord[to] == -1) {
self(self, to);
low[v] = std::min(low[v], low[to]);
} else {
low[v] = std::min(low[v], ord[to]);
}
}
if (low[v] == ord[v]) {
while (true) {
int u = visited.back();
visited.pop_back();
ord[u] = _n;
ids[u] = group_num;
if (u == v) break;
}
group_num++;
}
};
for (int i = 0; i < _n; i++) {
if (ord[i] == -1) dfs(dfs, i);
}
for (auto& x : ids) {
x = group_num - 1 - x;
}
return {group_num, ids};
}

std::vector<std::vector<int>> scc() {
auto ids = scc_ids();
int group_num = ids.first;
std::vector<int> counts(group_num);
for (auto x : ids.second) counts[x]++;
std::vector<std::vector<int>> groups(ids.first);
for (int i = 0; i < group_num; i++) {
groups[i].reserve(counts[i]);
}
for (int i = 0; i < _n; i++) {
groups[ids.second[i]].push_back(i);
}
return groups;
}

private:
int _n;
struct edge {
int to;
};
std::vector<std::pair<int, edge>> edges;
};

}  // namespace internal

}  // namespace atcoder


#line 9 "library/atcoder/scc.hpp"

namespace atcoder {

struct scc_graph {
public:
scc_graph() : internal(0) {}
explicit scc_graph(int n) : internal(n) {}

void add_edge(int from, int to) {
int n = internal.num_vertices();
assert(0 <= from && from < n);
assert(0 <= to && to < n);
internal.add_edge(from, to);
}

std::vector<std::vector<int>> scc() { return internal.scc(); }

private:
internal::scc_graph internal;
};

}  // namespace atcoder


#line 1 "library/atcoder/segtree.hpp"



#line 7 "library/atcoder/segtree.hpp"

#line 9 "library/atcoder/segtree.hpp"

namespace atcoder {

template <class S, S (*op)(S, S), S (*e)()> struct segtree {
public:
segtree() : segtree(0) {}
explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}
explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {
log = internal::ceil_pow2(_n);
size = 1 << log;
d = std::vector<S>(2 * size, e());
for (int i = 0; i < _n; i++) d[size + i] = v[i];
for (int i = size - 1; i >= 1; i--) {
update(i);
}
}

void set(int p, S x) {
assert(0 <= p && p < _n);
p += size;
d[p] = x;
for (int i = 1; i <= log; i++) update(p >> i);
}

S get(int p) const {
assert(0 <= p && p < _n);
return d[p + size];
}

S prod(int l, int r) const {
assert(0 <= l && l <= r && r <= _n);
S sml = e(), smr = e();
l += size;
r += size;

while (l < r) {
if (l & 1) sml = op(sml, d[l++]);
if (r & 1) smr = op(d[--r], smr);
l >>= 1;
r >>= 1;
}
return op(sml, smr);
}

S all_prod() const { return d[1]; }

template <bool (*f)(S)> int max_right(int l) const {
return max_right(l, [](S x) { return f(x); });
}
template <class F> int max_right(int l, F f) const {
assert(0 <= l && l <= _n);
assert(f(e()));
if (l == _n) return _n;
l += size;
S sm = e();
do {
while (l % 2 == 0) l >>= 1;
if (!f(op(sm, d[l]))) {
while (l < size) {
l = (2 * l);
if (f(op(sm, d[l]))) {
sm = op(sm, d[l]);
l++;
}
}
return l - size;
}
sm = op(sm, d[l]);
l++;
} while ((l & -l) != l);
return _n;
}

template <bool (*f)(S)> int min_left(int r) const {
return min_left(r, [](S x) { return f(x); });
}
template <class F> int min_left(int r, F f) const {
assert(0 <= r && r <= _n);
assert(f(e()));
if (r == 0) return 0;
r += size;
S sm = e();
do {
r--;
while (r > 1 && (r % 2)) r >>= 1;
if (!f(op(d[r], sm))) {
while (r < size) {
r = (2 * r + 1);
if (f(op(d[r], sm))) {
sm = op(d[r], sm);
r--;
}
}
return r + 1 - size;
}
sm = op(d[r], sm);
} while ((r & -r) != r);
return 0;
}

private:
int _n, size, log;
std::vector<S> d;

void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
};

}  // namespace atcoder


#line 1 "library/atcoder/string.hpp"



#line 9 "library/atcoder/string.hpp"

namespace atcoder {

namespace internal {

std::vector<int> sa_naive(const std::vector<int>& s) {
int n = int(s.size());
std::vector<int> sa(n);
std::iota(sa.begin(), sa.end(), 0);
std::sort(sa.begin(), sa.end(), [&](int l, int r) {
if (l == r) return false;
while (l < n && r < n) {
if (s[l] != s[r]) return s[l] < s[r];
l++;
r++;
}
return l == n;
});
return sa;
}

std::vector<int> sa_doubling(const std::vector<int>& s) {
int n = int(s.size());
std::vector<int> sa(n), rnk = s, tmp(n);
std::iota(sa.begin(), sa.end(), 0);
for (int k = 1; k < n; k *= 2) {
auto cmp = [&](int x, int y) {
if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];
int rx = x + k < n ? rnk[x + k] : -1;
int ry = y + k < n ? rnk[y + k] : -1;
return rx < ry;
};
std::sort(sa.begin(), sa.end(), cmp);
tmp[sa[0]] = 0;
for (int i = 1; i < n; i++) {
tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
}
std::swap(tmp, rnk);
}
return sa;
}

// SA-IS, linear-time suffix array construction
// Reference:
// G. Nong, S. Zhang, and W. H. Chan,
// Two Efficient Algorithms for Linear Time Suffix Array Construction
template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>
std::vector<int> sa_is(const std::vector<int>& s, int upper) {
int n = int(s.size());
if (n == 0) return {};
if (n == 1) return {0};
if (n == 2) {
if (s[0] < s[1]) {
return {0, 1};
} else {
return {1, 0};
}
}
if (n < THRESHOLD_NAIVE) {
return sa_naive(s);
}
if (n < THRESHOLD_DOUBLING) {
return sa_doubling(s);
}

std::vector<int> sa(n);
std::vector<bool> ls(n);
for (int i = n - 2; i >= 0; i--) {
ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);
}
std::vector<int> sum_l(upper + 1), sum_s(upper + 1);
for (int i = 0; i < n; i++) {
if (!ls[i]) {
sum_s[s[i]]++;
} else {
sum_l[s[i] + 1]++;
}
}
for (int i = 0; i <= upper; i++) {
sum_s[i] += sum_l[i];
if (i < upper) sum_l[i + 1] += sum_s[i];
}

auto induce = [&](const std::vector<int>& lms) {
std::fill(sa.begin(), sa.end(), -1);
std::vector<int> buf(upper + 1);
std::copy(sum_s.begin(), sum_s.end(), buf.begin());
for (auto d : lms) {
if (d == n) continue;
sa[buf[s[d]]++] = d;
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
sa[buf[s[n - 1]]++] = n - 1;
for (int i = 0; i < n; i++) {
int v = sa[i];
if (v >= 1 && !ls[v - 1]) {
sa[buf[s[v - 1]]++] = v - 1;
}
}
std::copy(sum_l.begin(), sum_l.end(), buf.begin());
for (int i = n - 1; i >= 0; i--) {
int v = sa[i];
if (v >= 1 && ls[v - 1]) {
sa[--buf[s[v - 1] + 1]] = v - 1;
}
}
};

std::vector<int> lms_map(n + 1, -1);
int m = 0;
for (int i = 1; i < n; i++) {
if (!ls[i - 1] && ls[i]) {
lms_map[i] = m++;
}
}
std::vector<int> lms;
lms.reserve(m);
for (int i = 1; i < n; i++) {
if (!ls[i - 1] && ls[i]) {
lms.push_back(i);
}
}

induce(lms);

if (m) {
std::vector<int> sorted_lms;
sorted_lms.reserve(m);
for (int v : sa) {
if (lms_map[v] != -1) sorted_lms.push_back(v);
}
std::vector<int> rec_s(m);
int rec_upper = 0;
rec_s[lms_map[sorted_lms[0]]] = 0;
for (int i = 1; i < m; i++) {
int l = sorted_lms[i - 1], r = sorted_lms[i];
int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;
int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;
bool same = true;
if (end_l - l != end_r - r) {
same = false;
} else {
while (l < end_l) {
if (s[l] != s[r]) {
break;
}
l++;
r++;
}
if (l == n || s[l] != s[r]) same = false;
}
if (!same) rec_upper++;
rec_s[lms_map[sorted_lms[i]]] = rec_upper;
}

auto rec_sa =
sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);

for (int i = 0; i < m; i++) {
sorted_lms[i] = lms[rec_sa[i]];
}
induce(sorted_lms);
}
return sa;
}

}  // namespace internal

std::vector<int> suffix_array(const std::vector<int>& s, int upper) {
assert(0 <= upper);
for (int d : s) {
assert(0 <= d && d <= upper);
}
auto sa = internal::sa_is(s, upper);
return sa;
}

template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {
int n = int(s.size());
std::vector<int> idx(n);
iota(idx.begin(), idx.end(), 0);
sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });
std::vector<int> s2(n);
int now = 0;
for (int i = 0; i < n; i++) {
if (i && s[idx[i - 1]] != s[idx[i]]) now++;
s2[idx[i]] = now;
}
return internal::sa_is(s2, now);
}

std::vector<int> suffix_array(const std::string& s) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return internal::sa_is(s2, 255);
}

// Reference:
// T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
// Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
// Applications
template <class T>
std::vector<int> lcp_array(const std::vector<T>& s,
const std::vector<int>& sa) {
int n = int(s.size());
assert(n >= 1);
std::vector<int> rnk(n);
for (int i = 0; i < n; i++) {
rnk[sa[i]] = i;
}
std::vector<int> lcp(n - 1);
int h = 0;
for (int i = 0; i < n; i++) {
if (h > 0) h--;
if (rnk[i] == 0) continue;
int j = sa[rnk[i] - 1];
for (; j + h < n && i + h < n; h++) {
if (s[j + h] != s[i + h]) break;
}
lcp[rnk[i] - 1] = h;
}
return lcp;
}

std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return lcp_array(s2, sa);
}

// Reference:
// D. Gusfield,
// Algorithms on Strings, Trees, and Sequences: Computer Science and
// Computational Biology
template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {
int n = int(s.size());
if (n == 0) return {};
std::vector<int> z(n);
z[0] = 0;
for (int i = 1, j = 0; i < n; i++) {
int& k = z[i];
k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);
while (i + k < n && s[k] == s[i + k]) k++;
if (j + z[j] < i + z[i]) j = i;
}
z[0] = n;
return z;
}

std::vector<int> z_algorithm(const std::string& s) {
int n = int(s.size());
std::vector<int> s2(n);
for (int i = 0; i < n; i++) {
s2[i] = s[i];
}
return z_algorithm(s2);
}

}  // namespace atcoder


#line 1 "library/atcoder/twosat.hpp"



#line 6 "library/atcoder/twosat.hpp"

#line 8 "library/atcoder/twosat.hpp"

namespace atcoder {

// Reference:
// B. Aspvall, M. Plass, and R. Tarjan,
// A Linear-Time Algorithm for Testing the Truth of Certain Quantified Boolean
// Formulas
struct two_sat {
public:
two_sat() : _n(0), scc(0) {}
explicit two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}

void add_clause(int i, bool f, int j, bool g) {
assert(0 <= i && i < _n);
assert(0 <= j && j < _n);
scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));
scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));
}
bool satisfiable() {
auto id = scc.scc_ids().second;
for (int i = 0; i < _n; i++) {
if (id[2 * i] == id[2 * i + 1]) return false;
_answer[i] = id[2 * i] < id[2 * i + 1];
}
return true;
}
std::vector<bool> answer() { return _answer; }

private:
int _n;
std::vector<bool> _answer;
internal::scc_graph scc;
};

}  // namespace atcoder


#line 6 "Contests/AtCoder_arc132/arc132_a/main.cpp"
using namespace atcoder;

// define your macros here.
#define MOD 1000000007
#define PI 3.14159265358979323846264338327950288419
#define IINF 1001001001
#define LINF 1001001001001001001LL

#define ll long long
#define VLL vector<ll>
#define PLL pair<ll, ll>
#define pb push_back
#define mpair make_pair
#define pm(first, second) pb(mpair((first), (second)))
#define pff first.first
#define pfs first.second
#define psf second.first
#define pss second.second

#define REP(i,n) for(ll i = 0; i < (ll)(n); i++)
#define REPS(i, n) for(ll i = 1; i <= (ll)(n); i++)
#define RREP(i, n) for(int i = ((ll)(n)-1); i >= 0; i--)
#define RREPS(i, n) for(int i = ((ll)(n)); i > 0; i--)
#define FOR(i, a, b) for(ll i = (a); i < (b); i++)
#define SZ(x) ((ll)(x).size())
#define ALL(x) (x).begin(), (x).end()
#define RALL(x) (x).rbegin(), (x).rend()
#define MAX(a, b) max((ll)(a), (ll)(b))
#define MIN(a, b) min((ll)(a), (ll)(b))
#define DCEIL(a, b) (((a)+(b)-1)/(b))
#define UNIQUE(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
#define outyn(flag) cout << ((flag)? "Yes": "No") << endl
#define outYN(flag) cout << ((flag)? "YES": "NO") << endl
#define out(output) cout << (output) << endl

template<class T>bool chmax(T &a, const T &b) { return a < b && (a = b, true); }
template<class T>bool chmin(T &a, const T &b) { return a > b && (a = b, true); }
ll qp(ll a, ll b){ll ans=1;do{if(b&1)ans=1LL*ans*a;a=1LL*a*a;}while(b>>=1);return ans;}
ll qp(ll a, ll b, ll mo){ll ans=1;do{if(b&1)ans=1LL*ans*a%mo;a=1LL*a*a%mo;}while(b>>=1);return ans;}
int DX[4] = {1, 0, -1, 0};
int DY[4] = {0, 1, 0, -1};

#define int long long

void solve(){
// write your solution here.

int N;
cin >> N;
VLL R(N), C(N);
REP(i, N){
cin >> R[i];
}
REP(i, N){
cin >> C[i];
}

int q, r, c;
cin >> q;
REP(i, q){
cin >> r >> c;
r--;
c--;
if(R[r]-1+C[c]-1 >= N-1) cout << "#";
else cout << ".";
}
out("");

}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
// Fasterize input/output script
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(100);
// scanf/printf user should delete this fasterize input/output script

int t = 1;
//cin >> t; // comment out if solving multi testcase
for(int testCase = 1;testCase <= t;++testCase){
solve();
}
return 0;
}

#include <iostream>
#include <iomanip>
#include <fstream>
#include <cstdio>
#include <sstream>
#include <cassert>
#include <vector>
#include <numeric>
#include <string>
#include <bitset>
#include <cmath>
#include <complex>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <random>
#include <chrono>
#include <ctime>
#include <ext/pb_ds/detail/standard_policies.hpp>
#include <ext/pb_ds/assoc_container.hpp>

/*
⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄
⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄
⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄
⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄
⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰
⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤
⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗
⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄
⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄
⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄
⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄
⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄
⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴
⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿
*/

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef long double ld;
typedef double db;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
#define all(x) (x).begin(), (x).end()
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

template <typename A, typename B>
string to_string(pair<A, B> p);

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p);

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p);

string to_string(const string& s) {
return '"' + s + '"';
}

string to_string(const char* s) {
return to_string((string) s);
}

string to_string(vector<bool> v) {
bool first = true;
string res = "{";
for (int i = 0; i < static_cast<int>(v.size()); i++) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(v[i]);
}
res += "}";
return res;
}

template <typename A>
string to_string(A v) {
bool first = true;
string res = "{";
for (const auto &x : v) {
if (!first) {
res += ", ";
}
first = false;
res += to_string(x);
}
res += "}";
return res;
}

template <typename A, typename B>
string to_string(pair<A, B> p) {
return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p) {
return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";
}

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) {
return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";
}

void debug_out() { cout << "\n"; }
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
cout << " " << to_string(H);
debug_out(T...);
}

#ifdef CLOWN
#define dbg(...) cout << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);
#else
#define dbg(...);
#endif

int test = 0;

void fastio() {
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
}
#define int ll
void solve() {
int n;
cin >> n;
vector<int> a(n);
vector<int> b(n);

for (int i = 0; i < n; i++) cin >> a[i];
for (int i = 0; i < n; i++) cin >> b[i];

int ans = 0;

for (int bit = 0; bit <= 28; bit++) {
vector<int> c(n), d(n);
for (int i = 0; i < n; i++) {
c[i] = a[i] & (((1LL << (bit + 1)) - 1));
d[i] = b[i] & (((1LL << (bit + 1)) - 1));
}
int cur = 0;
dbg(cur);

sort(all(c));
sort(all(d));
for (int i = 0; i < n; i++) {
int l = lower_bound(all(d), (1LL<< bit) - c[i]) - d.begin();
int r = upper_bound(all(d), 2 * (1LL << bit) - c[i] - 1) - d.begin();
cur += r - l;
l = lower_bound(all(d), 3 * (1LL << bit) - c[i]) - d.begin();
r = upper_bound(all(d), 4 * (1LL << bit) - c[i] - 1) - d.begin();
cur += r - l;
}
dbg(cur)
ans |= (cur % 2) * (1 << bit);
}
cout << ans << "\n";
}

int32_t main() {
#ifdef CLOWN
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
int t = 1;
fastio();
if (test) cin >> t;
while (t--) { solve(); }
return 0;
}
#include <bits/stdc++.h>
#include <boost/range.hpp>
#include <boost/range/algorithm.hpp>
#include <boost/multi_array.hpp>
#include <boost/container/static_vector.hpp>
#include <boost/assign.hpp>

using namespace std;
using namespace boost;
using namespace container;
using namespace assign;

void salve();
int main(void){
cin.tie(nullptr);
ios::sync_with_stdio(false);
salve();
return 0;
}

template<class R>
istream& operator >> (istream& is,R r){
typename range_const_iterator<R>::type i = begin(r), e = end(r);
while(i!=e){
cin >> i;
++i;
}
return is;
}
using ll = int64_t;
template<typename T,size_t S = 0>
using vec = static_vector<T,S>;
using ivec = vec<int>;
using llvec = vec<ll>;


void salve(void){
ll n,m;
cin >> n >> m;



if(n > m/2){
cout << m/2;
}else{
cout << n+(m-n*2)/4;
}
}

#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;
using ll = long long;
const int INF = INT_MAX;
const ll LINF = LLONG_MAX;
bool chmin(int& a, int b){ if(a > b){ a = b; return 1; } return 0; }
bool chmax(int& a, int b){ if(a < b){ a = b; return 1; } return 0; }
int mod = 1000000007;
int mod2 = 998244353;

int main() {
int N;
cin >> N;
vector<int> A(N);
for (int i = 0; i < N; i++) cin >> A[i];
ll temp = 1;
ll nowv = -1;
ll ans = N;
int l = 0;
for (int i = 0; i < N - 1; i++) {
if (nowv == -1) nowv = A[i];
if ((nowv & A[i+1]) == 0) {
temp++;
nowv ^= A[i+1];
}
else if (temp > 1 && (nowv & A[i+1]) != 0) {
ans += (temp * (temp-1)) / 2LL;
while(temp > 1) {
nowv ^= A[l];
l++;
if ((nowv & A[i+1]) == 0) {
ll t = temp - 1;
ans -= (t * (t - 1)) / 2LL;
nowv ^= A[i+1];
break;
}
temp--;
}
if (temp == 1) {l++; nowv = -1;}
}
else {l++; nowv = -1;}
if (i == N - 2 && temp > 1) ans += (temp * (temp-1)) / 2LL;
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long Int;
Int INF = 1LL << 60;

int main() {
int A, B, C, X, Y, numABMax;
Int ans = INF;

cin >> A >> B >> C >> X >> Y;

numABMax = max(X, Y) * 2;

for (int i = 0; i <= numABMax; i += 2) {
Int sumPrice = 0;

sumPrice = A * max((X - i / 2), 0) + B * max((Y - i / 2), 0) + C * i; 
ans = min(ans, sumPrice);
}

cout << ans << endl;

return 0;
}


#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1c;std::string _1b="\x2c\x20";bool _15=true;int _12=0;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _16="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _13="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _17="\033[0m";std::string _b(std::string _1d){if(_1d=="red")return _1;if(_1d=="green")return _2;if(_1d=="yellow")return _16;if(_1d=="blue")return _3;if(_1d=="magenta")return _4;if(_1d=="cyan")return _5;if(_1d=="red bold")return _6;if(_1d=="green bold")return _7;if(_1d=="yellow bold")return _13;if(_1d=="blue bold")return _8;if(_1d=="magenta bold")return _9;if(_1d=="cyan bold")return _a;if(_1d=="reset")return _17;return "";}public:logger(std::ostream&_1c):_1c(&_1c){}logger&set_ostream(std::ostream&_1c){this->_1c=&_1c;return*this;}logger&set_sep(const std::string&_1b){this->_1b=_1b;return*this;}logger&assert_exit(){_15=true;return*this;}logger&assert_noexit(){_15=false;return*this;}logger&set_exit_code(int _c){_12=_c;return*this;}logger&endl(){*_1c<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_1b).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1c<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_18){log("{");for(auto it=_18.begin();it!=_18.end();++it){if(it!=_18.begin())log(_1b);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _19="cyan"){_19=_b(_19);return log(_19).log(x).log("\x3a\x20").log(_17);}template<class...T>logger&operator()(T..._1a){return log(_1a...).endl();}template<class...T>logger&_d(const std::string&_e,int _f,const std::string&_10,bool _1a,const std::string&_14,T..._11){if(!_1a){endl();hint(_e,"magenta").hint(_f,"magenta").log(_16).log("Assertion `").log(_13).log(_10).log(_16).log("` failed").log(_17).endl();if(_14!="")hint("detail","magenta").hint(_14)(_11...);if(_15)exit(_12);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _9,size_t _3>class buffer_reader{protected:FILE*src;_9*const buff;_9*buff_end;_9*buff_pos;void _4(){buff_end=buff+fread(buff,sizeof(_9),_3,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_1):src(_1),buff(new _9[_3]){_4();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_9 get()const{return*buff_pos;}_9 next(){_9 result=get();buff_pos++;if(buff_pos==buff_end)_4();return result;}~buffer_reader(){fclose(src);delete[]buff;}};
using optimal_reader=buffer_reader<char,1<<16>;
template<class _7>class scanner:protected _7{private:using _7::get;using _7::next;inline bool _5(char c){return c<=' ';}inline bool _2(char c){return c=='\n'||c=='\r';}int _6(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _7::_7;char next_char(){while(_5(get()))next();return next();}char*next_token(char*s){while(_5(get()))next();while(!_5(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_5(get()))next();while(!_2(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_6();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_6();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _8>_8 next_integer(){_8 sign=_6();_8 result(0);while(isdigit(get()))result=result*_8(10)+_8(next()-'0');return sign*result;}double next_double(){int sign=_6();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _3 inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _1=true;bool operator()(){return _1?(_1=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_3 std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_3 std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_3 std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_3 std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_2 { CM_INNER_ATINIT##line## _2 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_2 { ~CM_INNER_ATEXIT##line## _2 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _3
#include <algorithm>
// #include "/home/jack/cm/intm"
// #include "/home/jack/cm/string"

cm::scanner<cm::optimal_reader> sc(stdin);

long long   m[110], f[125010];
int         p[110], v[110], p1[110], la[110];
inline bool cmp(int a, int b)
{
return v[a] * m[b] > v[b] * m[a];
}
int main()
{
int n   = sc.next_int();
int x   = sc.next_int();
int d   = sc.next_int();
int num = 0, ans = 0;
v[1]  = 1;
p1[1] = 1;
m[1]  = sc.next_int();
for (int i = 2; i <= n; i++)
{
m[i]  = sc.next_int();
p[i]  = sc.next_int();
v[i]  = 1;
p1[i] = i;
}

for (int i = n; i >= 2; i--)
{
m[p[i]] += m[i];
v[p[i]] += v[i];
num += v[i] * std::min(n, d);
la[i] = std::max(d - n, 0);
}

la[1] = x;
std::sort(p1 + 1, p1 + n + 1, cmp);
for (int i = 1; i <= num; i++)
f[i] = 1ll << 60;
for (int i = 2; i <= n; i++)
{
for (int j = num; j >= 0; j--)
if (f[j] < (1ll << 60))
{
for (int k = 1; k <= std::min(n, d); k++)
f[j + k * v[i]] = std::min(f[j + k * v[i]], f[j] + k * m[i]);
}
}

for (int i = 0; i <= num; i++)
if (f[i] <= x)
{
int x1 = x - f[i];
int vv = i;
for (int j = 1; j <= n; j++)
{
int x2 = std::min(x1 / m[p1[j]], 1ll * la[p1[j]]);
vv += x2 * v[p1[j]];
x1 -= x2 * m[p1[j]];
}
ans = std::max(ans, vv);
}

printf("%d\n", ans);
}

#include <bits/stdc++.h>

using namespace std;
using ll = long long;

int main(){
int n; cin >> n;
ll a[n];

for(int i = 0; i < n; i++){
cin >> a[i];
}

int l = 0, r = -1;
ll ans = 0;
ll sum = 0;
ll cur = 0;

while(l < n){
while(r + 1 < n && ((cur ^ a[r + 1]) == (sum + a[r + 1]))){
r++;
cur ^= a[r];
sum += a[r];
}
ans += (r-l+1);
sum -= a[l];
cur ^= a[l];
l++;
}

cout << ans << endl;

return 0;
}

#include<bits/stdc++.h>
using namespace std;
const int maxn=2e4+10;
const int maxm=5e5+10;
int n,m,l,r,ans;
struct node {
int id,p,oth;
} a[maxn];
int Map[maxn];
int dfs_time,low[maxn],dfn[maxn],scc[maxn];
int to[maxm],ne[maxm],id,po[maxn],sccid;
stack<int> S;
bool cmp(node aa,node bb) {
if (aa.p==bb.p) return aa.id<bb.id;
return aa.p<bb.p;
}
bool flag;
void tarjan(int x) {
S.push(x);
dfn[x]=low[x]=++dfs_time;
for (int i=po[x]; i; i=ne[i]) {
if (dfn[to[i]]==0) {
tarjan(to[i]);
if (!flag) return;
low[x]=min(low[x],low[to[i]]);
} else if (scc[to[i]]==0) {
low[x]=min(low[x],dfn[to[i]]);
}
}
if (dfn[x]==low[x]) {
++sccid;
while (!S.empty()) {
scc[S.top()]=sccid;
if (scc[a[S.top()].oth]==sccid) {
flag=false;
return;
}
if (S.top()==x) {
S.pop();
break;
}
S.pop();
}
}
}
inline void add(int x,int y) {
id++;
to[id]=y;
ne[id]=po[x];
po[x]=id;
}
bool check(int x) {
id=0;
sccid=0;
dfs_time=0;
memset(po,0,sizeof(po));
memset(low,0,sizeof(low));
memset(scc,0,sizeof(scc));
memset(dfn,0,sizeof(dfn));
for (int i=1; i<m; i++) {
int last=min(m,i+9);
for (int j=i+1; j<=last; j++) {
if (a[j].p-a[i].p<x) {
add(i,a[j].oth);
add(j,a[i].oth);
} else break;
}
}
flag=1;
tarjan(1);
for (int i=1; i<=m; i++) {
if (!dfn[i]) tarjan(i);
if (flag==0) return 0;
}
return true;
}
int main() {
scanf("%d",&n);
for (int i=1,x,y; i<=n; i++) {
scanf("%d%d",&x,&y);
if (x>y) swap(x,y);
a[i].id=i,a[i].p=x,a[i].oth=i+n;
a[i+n].id=i+n,a[i+n].p=y,a[i+n].oth=i;
}
m=n+n;
r=max(abs(a[n+1].p-a[2].p),abs(a[n+2].p-a[1].p));
r=max(r,max(abs(a[2].p-a[1].p),abs(a[n+2].p-a[n+1].p)));
sort(a+1,a+n+1,cmp);
l=a[2].p-a[1].p;
for (int i=3; i<=n; i++) l=min(l,a[i].p-a[i-1].p);
sort(a+1,a+m+1,cmp);
for (int i=1; i<=m; i++) Map[a[i].id]=i;
for (int i=1; i<=m; i++) a[i].oth=Map[a[i].oth];
while (l<=r) {
int mid=(l+r)>>1;
if (check(mid)) {
ans=mid;
l=mid+1;
} else r=mid-1;
}
cout<<ans;
return 0;
}
#define _USE_MATH_DEFINES
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cmath>
#include <cassert>
#include <numeric>
#include <queue>
#include <stack>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto& i:a)
#define forec(i,a) for(const auto& i:a)
#define all(x) (x).begin(),(x).end()
#define chmin(x,y) (x)=((x)<(y))?(x):(y);
#define chmax(x,y) (x)=((x)>(y))?(x):(y);
#ifdef _DEBUG
#define PRINTF(...) printf("  ");printf(__VA_ARGS__)
#else
#define PRINTF(...)
#endif
#ifdef _DEBUG
template<typename T>
std::ostream& operator << (std::ostream & os, const std::vector<T> & vec) {
os << "{";
for (size_t i = 0, size = vec.size(); i < size; i++) {
os << vec[i] << (i == size - 1 ? "}" : ", ");
}
return os;
}
#define dump(...) printf_all_for_dump(#__VA_ARGS__,__VA_ARGS__);
void printf_for_dump() {}
template <class Head, class... Tail>
void printf_for_dump(Head && head, Tail &&... tail) {
std::cout << head;
if (sizeof...(Tail)) std::cout << ", ";
printf_for_dump(std::forward<Tail>(tail)...);
}
template <class... Args>
void printf_all_for_dump(const char* s, Args&&... args) {
std::cout << "  ";
if (sizeof...(Args) > 1) std::cout << "{" << s << "}={";
else std::cout << s << "=";
printf_for_dump(args...);
if (sizeof...(Args) > 1) std::cout << "}";
std::cout << std::endl;
}
#else
#define dump(...)
#endif

using ll = int64_t;
using ull = uint64_t;
//constexpr int INF = 1e9;
constexpr ll LINF = static_cast<ll>(1e18);

using namespace std;

//// variables

//constexpr ll MOD = (ll)1e9 + 7;

//vector<vector<ll>> G; // adjacency list which describes an unweighted graph
//
//struct Edge {
//	ll u; // src
//	ll v; // dest
//	ll w; // weight
//};
//vector<vector<Edge>> G; // adjacency list which describes a weighted graph

/// <summary>
/// Maximum flow problem solver whitch uses Dinic's algorithm
/// time complexity is O(V^2 E)
/// </summary>
/// <typeparam name="flow_t"></typeparam>
template< typename flow_t >
struct Dinic {
Dinic(int V) : graph(V) {}

void add_edge(int from, int to, flow_t cap, int idx = -1) {
graph[from].emplace_back(Edge{ to, cap, (int)graph[to].size(), false, idx });
graph[to].emplace_back(Edge{ from, 0, (int)graph[from].size() - 1, true, idx });
}

flow_t max_flow(int s, int t) {
flow_t flow = 0;
while (bfs(s, t)) {
iter.assign(graph.size(), 0);
flow_t f = 0;
while ((f = dfs(s, t, INF)) > 0) flow += f;
}
return flow;
}

private:
const flow_t INF = numeric_limits< flow_t >::max();

struct Edge {
int to;
flow_t cap;
int rev;
bool isrev;
int idx;
};

vector< vector< Edge > > graph;
vector< int > min_cost, iter;

bool bfs(int s, int t) {
min_cost.assign(graph.size(), -1);
queue< int > que;
min_cost[s] = 0;
que.push(s);
while (!que.empty() && min_cost[t] == -1) {
int p = que.front();
que.pop();
for (auto& e : graph[p]) {
if (e.cap > 0 && min_cost[e.to] == -1) {
min_cost[e.to] = min_cost[p] + 1;
que.push(e.to);
}
}
}
return min_cost[t] != -1;
}

flow_t dfs(int idx, const int t, flow_t flow) {
if (idx == t) return flow;
for (int& i = iter[idx]; i < graph[idx].size(); i++) {
Edge& e = graph[idx][i];
if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {
flow_t d = dfs(e.to, t, min(flow, e.cap));
if (d > 0) {
e.cap -= d;
graph[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}
};

struct Point {
ll x, y;
};

int main()
{
ios::sync_with_stdio(false);
cin.tie(nullptr);

//
// init valriables
//


//
// input
//

ll N;
cin >> N;

// input graph
vector<Point> R(N);
vector<Point> B(N);
for (ll i = 0; i < N; i++) {
cin >> R[i].x >> R[i].y;
}
for (ll i = 0; i < N; i++) {
cin >> B[i].x >> B[i].y;
}


//
// calc
//

Dinic<ll> dinic(N*2+2);
for (ll i = 0; i < N; i++) {
for (ll j = 0; j < N; j++) {
if (R[i].x < B[j].x && R[i].y < B[j].y) {
dinic.add_edge(i, N + j, 1);
}
}
}

int s = N * 2;
int t = N * 2 + 1;
for (ll i = 0; i < N; i++) {
dinic.add_edge(s, i, 1);
}
for (ll j = 0; j < N; j++) {
dinic.add_edge(N + j, t, 1);
}
ll ans = dinic.max_flow(s, t);

//
// output answer
//
cout << ans << endl;

//cout << x << " "<< y <<endl;
//printf("%.12f\n", x); // output double

//for (ll i = 0; i < N; i++) {
//	cout << i << " ";
//	cout << i << endl;
//}
//cout << endl;

//if (ans) {
//	cout << "Yes" << endl;
//}
//else {
//	cout << "No" << endl;
//}

return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;

const int maxn = 5e5 + 10;
const int inf = 0x7ffffff;

void solve()
{
int n;
cin >> n;
vector<int> vec(n);
for(int &i:vec)
cin >> i;
int pos = 0;
for (int i = 0; i < n;i++)
{
if (vec[i] == 1)
{
pos = i;
break;
}
}
bool flag = (vec[(pos + 1) % n] == 2) ? true : false;
if(flag)
{
cout << min(n - pos + 2, pos) << "\n";
}
else
{
cout << min(pos + 2, n - pos) << "\n";
}
}

int main()
{
#ifdef BUG
freopen("in","r",stdin);
#endif
ios::sync_with_stdio(false);
cin.tie(0);
int T = 1;
//cin >> T;
while(T-- > 0)
solve();

}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 5e5 + 5)

int n, d, q;
int a[N], to[N];
int mn[N];

int main() {
qread(n, d);
rep(i, 1, n) qread(a[i]);
int nw = d;
to[0] = d; mn[n + 1] = 1;
rep(i, 1, n) {
To_min(nw, abs(nw - a[i]));
to[i] = nw;
}
per(i, n, 1) {
if(a[i] >= 2 * mn[i + 1]) mn[i] = mn[i + 1];
else mn[i] = mn[i + 1] + a[i];
}
qread(q);
W(q) {
int x; qread(x);
if(to[x - 1] >= mn[x + 1]) puts("YES");
else puts("NO");
}
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
int main(){
int n;
cin>>n;
map<int,int>mp;
for(int i=2;i<=n;i++){
int d=i;
for(int j=2;j*j<=d;j++){
if(d%j==0){
while(d%j==0){
mp[j]++;
d=d/j;
}
}
}
if(d>1) mp[d]++;
}
ll ans=1;
for(auto &m:mp){
ans=ans*(m.second+1)%mod;
}
cout<<ans<<endl;
return 0;
}

#include<bits/stdc++.h>
using namespace std;
const int maxn=520000;
const int mod=1000000007;
int n,fa[maxn];
int tot=0,pre[maxn],now[maxn],son[maxn];
int id[maxn],idn=0,dep[maxn],f[maxn][20];
int st[maxn],top=0,h[maxn],k=0,sum0[maxn],sum1[maxn];
vector<int> S[maxn],G[maxn];
int power(int x,int y)
{
int ans=1;
while(y)
{
if(y&1)
ans=1ll*ans*x%mod;
x=1ll*x*x%mod;
y>>=1;
}
return ans;
}
bool cmp(int x,int y){return id[x]<id[y];}
void put(int x,int y)
{
pre[++tot]=now[x];
now[x]=tot;
son[tot]=y;
}
int LCA(int x,int y)
{
if(dep[x]<dep[y])
swap(x,y);
for(int i=19;i>=0;i--)
if(dep[f[x][i]]>=dep[y])
x=f[x][i];
if(x==y)
return x;
for(int i=19;i>=0;i--)
if(f[x][i]!=f[y][i])
x=f[x][i],y=f[y][i];
return f[x][0];
}
void dfs(int x,int dp)
{
id[x]=++idn;dep[x]=dp;f[x][0]=fa[x];S[dp].push_back(x);
for(int i=1;i<=19;i++)
f[x][i]=f[f[x][i-1]][i-1];
for(int p=now[x];p;p=pre[p])
dfs(son[p],dp+1);
}
void calc(int x)
{
sum0[x]=sum1[x]=0;
if(!G[x].size())
return sum0[x]=sum1[x]=1,void();
int ans=1,sum=1;
for(auto t:G[x])
{
calc(t);
ans=1ll*ans*sum0[t]%mod;
sum=1ll*sum*(sum0[t]+sum1[t])%mod;
}
for(auto t:G[x])
sum1[x]=(sum1[x]+1ll*ans*power(sum0[t],mod-2)%mod*sum1[t]%mod)%mod;
sum0[x]=(0ll+sum-sum1[x]+mod)%mod;
}
void build()
{
sort(h+1,h+k+1,cmp);
st[top=1]=0;G[0].clear();
for(int i=1;i<=k;i++)
if(h[i])
{
int Lca=LCA(h[i],st[top]);
if(Lca!=st[top])
{
while(id[st[top-1]]>id[Lca])
G[st[top-1]].push_back(st[top]),top--;
if(st[top-1]!=Lca)
G[Lca].clear(),G[Lca].push_back(st[top]),st[top]=Lca;
else
G[Lca].push_back(st[top]),top--;
}
st[++top]=h[i];G[h[i]].clear();
}
for(int i=1;i<top;i++)
G[st[i]].push_back(st[i+1]);
}
int main()
{
scanf("%d",&n);
for(int i=1;i<=n;i++)
scanf("%d",&fa[i]),put(fa[i],i);
dfs(0,1);
int ans=0;
for(int i=1;S[i].size();i++)
{
k=0;
for(auto t:S[i])
h[++k]=t;
build();calc(0);
ans=(0ll+ans+1ll*power(2,n+1-S[i].size())*sum1[0]%mod)%mod;
}
printf("%d\n",ans);

return 0;
}
#include<iostream>
#include<cstring>
#include<cstdio>
#define pii pair<int,int>
#define MP make_pair
#define fi first
#define se second
using namespace std;
const int N=2010;
int n,m;
pii st[N];
int a[N][N];
int R[N][N];
char s[N][N];
int l[N],r[N];
int MAX(int x,int y){return x>y?x:y;}
bool chk(int x,int y)
{
int sum=0;
sum+=(s[x][y]=='.'),sum+=(s[x+1][y]=='.');
sum+=(s[x][y+1]=='.'),sum+=(s[x+1][y+1]=='.');
return sum%2==0;
}
int main()
{
scanf("%d%d",&n,&m);
for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
for(int i=1;i<n;i++) for(int j=1;j<m;j++) a[i][j]=chk(i,j);
int ans=0;n--,m--;
for(int i=1;i<=n;i++)
{
int lst=m+1;
for(int j=m;j>=1;j--){if(!a[i][j]) lst=j;R[i][j]=lst;}
}
for(int j=1;j<=m;j++)
{
int top=0;
for(int i=1;i<=n;i++)
{
while(top&&R[i][j]<=st[top].fi) top--;
l[i]=st[top].se,st[++top]=MP(R[i][j],i);
}
top=0;
for(int i=n;i>=1;i--)
{
while(top&&R[i][j]<=st[top].fi) top--;
r[i]=top?st[top].se:n+1,st[++top]=MP(R[i][j],i);
}
for(int i=1;i<=n;i++)
ans=MAX(ans,(R[i][j]-j+1)*(r[i]-l[i]));
}
printf("%d",MAX(ans,MAX(n+1,m+1)));
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define all(x) (x).begin(),(x).end()


int main(){
string S;
cin>>S;    
ll N=S.size();
ll ans=N;
for(ll i=0;i<N-1;i++){
if(S[i]!=S[i+1]){
ans=min(ans,max(i+1,N-i-1));
}
}
cout<<ans<<endl;
}
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN=305;
ll f[MAXN][MAXN],a[MAXN][MAXN],ans=0,n;
int main(){
scanf("%lld",&n);
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
scanf("%lld",&f[i][j]);
a[i][j]=1e18;
if(i==j)a[i][j]=0;
}
}
for(int i=1;i<=n;i++){
for(int j=i+1;j<=n;j++){
bool flag=0;
for(int k=1;k<=n;k++){
if(k==i||k==j)continue;
if(f[i][k]+f[k][j]==f[i][j]){
flag=1;
break;
}
}
if(!flag){
a[i][j]=f[i][j];
a[j][i]=f[i][j];
ans+=f[i][j];
}
}
}
for(int k=1;k<=n;k++){
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
}
}
}
bool p=0;
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
if(a[i][j]!=f[i][j])p=1;
}
}
if(p)puts("-1");
else cout<<ans<<endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
template<typename T, int maxn, int type>
struct sparse{
vector<T> val[22];
sparse(){rep(__lg(maxn)+1) val[i].resize(max(0ll,maxn-pow2(i)+1));}
inline T oper(T i, T j){return type?max(i,j):min(i,j);}
void init(vector<T>& vec){
rep(sz(vec)) val[0][i]=vec[i];
rep2(i,1,__lg(maxn)+1) rep1(j,sz(vec)-pow2(i)+1) val[i][j]=oper(val[i-1][j],val[i-1][j+pow2(i-1)]);
}
T query(int l, int r){return oper(val[__lg(r-l+1)][l],val[__lg(r-l+1)][r-pow2(__lg(r-l+1))+1]);}
};
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,k,a[55],maxx=10'000'000'000'000'000;

void orzck(){
cin >> k;
n=50;
rep(n) a[i]=i;
rep3(i,n-1,0) if(k%(n+1)) a[i]++,k--;
int de=maxx/(n+1)+1;
rep(n){
if(k<=de*(n+1)) a[i]+=k,k=0;
else a[i]+=de*(n+1),k-=de*(n+1);
}
print(n);
rep(n) print0(a[i]);
cout << "\n";
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
using namespace std;

#define fast ios::sync_with_stdio(false); cin.tie(0);
#define fi first
#define se second
#define pb push_back
#define em emplace
#define eb emplace_back
#define mp make_pair
#define all(v) (v).begin(), (v).end()
#define pre(x) cout<<fixed; cout.precision(x);

typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 1e9;
const ll INF = 1e18;
const ll Mod = inf + 7;

int n, m, s, t;
vector<pii> g[1000010];

vector<ll> dijk(int r) {
priority_queue<pll, vector<pll>, greater<pll>> pq;

pq.em(0, r);
vector<ll> d(n+1, -1);

while(pq.size()) {
int x = pq.top().se;
ll cost = pq.top().fi;
pq.pop();

if(d[x] >= 0) continue;
d[x] = cost;

for(auto i : g[x]) {
if(d[i.fi] < 0) pq.em(cost + i.se, i.fi);
}
}

return d;
}

vector<ll> ways(int r, vector<ll> &d) {
vector<pll> v;
for(int i=1; i<=n; i++) v.eb(d[i], i);
sort(all(v));

vector<ll> w(n+1, 0);
w[r] = 1;

for(auto i : v) {
for(auto j : g[i.se]) {
if(d[j.fi] == d[i.se] + j.se) {
w[j.fi] += w[i.se];
w[j.fi] %= Mod;
}
}
}

return w;
}

int main() {
fast;

cin >> n >> m;
cin >> s >> t;
for(int i=1; i<=m; i++) {
int u, v, w;
cin >> u >> v >> w;
g[u].eb(v, 2*w);
g[v].eb(u, 2*w);
}

vector<ll> d[2], w[2];
d[0] = dijk(s);
d[1] = dijk(t);
w[0] = ways(s, d[0]);
w[1] = ways(t, d[1]);

ll W = d[0][t]/2;
ll ans = w[0][t] * w[0][t] % Mod;
for(int i=1; i<=n; i++) {
if(d[0][i] == W && d[1][i] == W) {
ans += Mod - w[0][i] * w[0][i] % Mod * w[1][i] % Mod * w[1][i] % Mod;
ans %= Mod;
}
else if(d[0][i] < W) {
for(auto j : g[i]) {
if(d[0][i] + d[1][j.fi] + j.se == 2 * W && d[1][j.fi] < W) {
ans += Mod - w[0][i] * w[0][i] % Mod * w[1][j.fi] % Mod * w[1][j.fi] % Mod;
ans %= Mod;
}
}
}
}

cout << ans;
}
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;

const int N = 1e5 + 10;

int s[N];

int main()
{

for (int i = 1; i < N; i++) s[i] = s[i - 1] + i;

int n; cin >> n;

cout << lower_bound(s + 1, s + N + 1, n) - s << endl;


return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=200005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn];

void orzck(){
cin >> n;
rep(n) cin >> a[i];
if(n%2==0){
rep3(i,n-1,0) if(i&1) print0(a[i]);
rep(n) if(i%2==0) print0(a[i]);
}
else{
rep3(i,n-1,0) if(i%2==0) print0(a[i]);
rep(n) if(i&1) print0(a[i]);
}
cout << "\n";
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
//#pragma GCC target("avx2,fma")
#define rep(i,l,r) for (int i = l; i < r; i++)
#define repr(i,r,l) for (int i = r; i >= l; i--)
#define X first
#define Y second
#define pb push_back
#define endl '\n'
#define debug(x) cerr << #x << " : " << x << endl;
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pll;
const long long int N = 7e5+20,mod = 998244353,inf = 1e18,sq = 500;
inline int mkay(int a,int b){
if (a+b >= mod) return a+b-mod;
return a+b;
}
inline int poww(int a,int k){
int z = 1;
while (k){
if (k&1) z = 1ll*z*a%mod;
a = 1ll*a*a%mod;
k >>= 1;
}
return z;
}
int fac[N],inv[N],pw[N];
inline int c(int r,int n){
if (r > n || r < 0) return 0;
return 1ll*fac[n]*inv[r]%mod*inv[n-r]%mod;
}
int main(){
ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
int k,n;
cin >> k >> n;
fac[0] = 1;
inv[0] = 1;
pw[0] = 1;
int R = 2*(n+k+1);
rep(i,1,R){
fac[i] = 1ll*fac[i-1]*i%mod;
inv[i] = poww(fac[i],mod-2);
pw[i] = mkay(pw[i-1],pw[i-1]);
}
rep(i,2,2*k+1){
int t = i/2;
if (k+1 < i){
t = (k-(i-k)+1) >> 1;
}
if (i&1){
int ans = 0;
rep(j,0,t+1){
int z = 1ll*pw[j]*c(j,t)%mod;
ans = mkay(ans,1ll*z*c(j+k-2*t-1,n+k-2*t-1)%mod);
}
cout << ans << endl;
continue;
}
else{
if (k+1 >= i) t--;
int ans = 0;
rep(j,0,t+1){
int z = 1ll*pw[j]*c(j,t)%mod;
ans = mkay(ans,1ll*z*c(j+k-2*t-2,n+k-2*t-2)%mod);
}
rep(j,0,t+1){
int z = 1ll*pw[j]*c(j,t)%mod;
ans = mkay(ans,1ll*z*c(j+k-2*t-2,n+k-2*t-3)%mod);
}
cout << ans << endl;
}
}
}

#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll k,i,dis[100002];
bool vis[100002];
struct node{
ll x,z;
}u,v;
bool operator <(node a,node b){
return a.z>b.z;
}
priority_queue<node> h;
int main()
{
scanf("%lld",&k);
memset(dis,127,sizeof(dis));
for(i=1;i<=9;i++){
u.x=i%k;
u.z=i;
dis[u.x]=min(dis[u.x],i);
h.push(u);
}
while(!h.empty()){
u=h.top();
h.pop();
if(vis[u.x])
continue;
vis[u.x]=true;
for(i=0;i<=9;i++){
v.x=(u.x*10+i)%k;
v.z=u.z+i;
if(v.z<dis[v.x]){
dis[v.x]=v.z;
h.push(v);
}
}
}
printf("%lld",dis[0]);
return 0;
}
#include <bits/stdc++.h>
#define int long long
namespace mystd {
inline int read() {
char c = getchar();
int x = 0, f = 1;
while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
return x * f;
}
inline void write(int x) {
if (x < 0) x = ~(x - 1), putchar('-');
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}
}
using namespace std;
using namespace mystd;

const int maxn = 3e3 + 300;
int n, mod, res, fac[maxn], inv[maxn], ifac[maxn], s[maxn][maxn];

void init(int lim) {
fac[0] = inv[1] = ifac[0] = s[0][0] = 1;
for (int i = 2; i <= lim; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for (int i = 1; i <= lim; i++) fac[i] = fac[i - 1] * i % mod, ifac[i] = ifac[i - 1] * inv[i] % mod;
for (int i = 1; i <= lim; i++) {
for (int j = 1; j <= i; j++) {
s[i][j] = (s[i - 1][j - 1] + j * s[i - 1][j]) % mod;
}
}
}

int C(int n, int m) { return fac[n] * ifac[m] % mod * ifac[n - m] % mod; }
int ksm(int p, int q, int m) {
int res = 1;
while (q) {
if (q & 1) res = res * p % m;
p = p * p % m;
q >>= 1;
}
return res;
}

signed main() {
n = read(), mod = read();
init(n + 1);
for (int k = 0; k <= n; k++) {
int tp = 0, pw = 1, p = ksm(2, n - k, mod);
for (int i = 0; i <= k; i++) {
tp = (tp + s[k + 1][i + 1] * pw % mod) % mod;
pw = pw * p % mod;
}
res = ((res + ksm(-1, k, mod) * C(n, k) % mod * ksm(2, ksm(2, n - k, mod - 1), mod) % mod * tp % mod) % mod + mod) % mod;
}
write(res);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,x,y,a[maxn];

bool check(int k){
int res=0;
rep(n) if(a[i]>=k*y) res+=ceiling(a[i]-k*y,x-y);
return res<=k;
}

void orzck(){
cin >> n >> x >> y;
rep(n) cin >> a[i];
int l=0,r=49e9;
while(l<r){
int mid=l+r>>1;
if(check(mid)) r=mid;
else l=mid+1;
}
print(l);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
#define ll long long int
#define fast_io std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL)
#define endl '\n'
using namespace std;


void solve(){
int a,b;cin>>a>>b;

cout<<a+500000000ll*b<<"\n";

}

int main()
{
fast_io;
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif

// Code
int t = 1;
// cin>>t;
while(t--){
solve();
}

return 0;
}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define int long long
//#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>
//#define ordered_multiset tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>

const int intmin = -100000000000000000LL;
const int intmax = 100000000000000000LL;

struct edge{
int a, b, cost;
};

struct city{
int a, b, idx;
};

bool srtA(city a, city b){
return a.a < b.a;
}

bool srtB(city a, city b){
return a.b < b.b;
}

bool srtEdge(edge a, edge b){
return a.cost < b.cost;
}

vector<int> par(100001, 0), siz(100001, 1);

int findRoot(int x){
if(x == par[x]){
return x;
}
return par[x] = findRoot(par[x]);
}

bool unite(int a, int b){
a = findRoot(a);
b = findRoot(b);

if(a == b){
return false;
}

if(siz[a] < siz[b]){
swap(a, b);
}

siz[a] += siz[b];
par[b] = a;

return true;
}

vector<edge> edges;

int kruskals(){
int ans = 0;

for (int i = 0; i < (int)edges.size(); ++i)
{   
if(unite(edges[i].a, edges[i].b)){
ans += edges[i].cost;
}
}

return ans;
}

int32_t main(){
ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

int n;
cin >> n;

iota(par.begin(), par.end(), 0);

vector<city> arr(n), arr1, arr2;

for (int i = 0; i < n; ++i)
{
cin >> arr[i].a >> arr[i].b;
arr[i].idx = i;
}

arr1 = arr;
arr2 = arr;
sort(arr1.begin(), arr1.end(), srtA);
sort(arr2.begin(), arr2.end(), srtB);

for (int i = 1; i < n; ++i)
{
edges.push_back({arr1[i-1].idx, arr1[i].idx, arr1[i].a - arr1[i-1].a});
}

for (int i = 1; i < n; ++i)
{
edges.push_back({arr2[i-1].idx, arr2[i].idx, arr2[i].b - arr2[i-1].b});
}

sort(edges.begin(), edges.end(), srtEdge);

cout << kruskals() << '\n';
}

#include<bits/stdc++.h>
#define int long long
#define gc getchar()
#define cin(a) a=read()
#define M 1000011
#define P 1000000007
using namespace std;

//== == == =read== == == =
int read(){
int x=0;bool fl=0;char s=gc;
while(!isdigit(s)){if(s=='-')fl=1;s=gc;}
while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=gc;
return fl?-x:x;
}

//== == == =type== == == =
int n,k,ans,h[M],inv[M],a[M],b[M],d[M],c[M],p[M];
char s[M];

//== == == =ksm== == == =
int ksm(int x,int y){
int res=1;
while(y){
if(y&1)res=1ll*res*x%P;
y>>=1;x=1ll*x*x%P;
}
return res;
}

//== == == =init== == == =
void init(){
h[0]=1;
for(int i=1;i<M;i++)h[i]=1ll*h[i-1]*i%P;
inv[M-1]=ksm(h[M-1],P-2);
for(int i=M-2;i>=0;i--)inv[i]=1ll*(i+1)*inv[i+1]%P;
}

//== == == =C== == == =
int C(int x,int y){
if(x<y||y<0)return 0;
return 1ll*h[x]*inv[y]%P*inv[x-y]%P;
}

//== == == =check== == == =
int check(int len){
int sum=0,r=1,num=h[len];if(!len)return 1;
for(int i=1;i<=k;i++)c[i]=0;
for(int i=1;i<=len;i++)b[i]=a[len-i+1];b[len+1]=0;
for(int i=1;i<=k;i++)if(s[i]=='r'&&r<=len)b[c[i]=r]--,p[r++]=i;
if(b[r])return 0;r=1;
for(int i=1;i<=k;i++)if(s[i]=='b'&&b[r]&&p[r]<i)b[c[i]=r]--,p[r++]=i;
if(b[r])return 0;r=1;
for(int i=1;i<=k;i++)if(!c[i]&&b[r]&&p[r]<i&&!--b[r])r++;
if(b[r])return 0;
for(int i=1;i<=len;i++)sum+=a[i];
for(int i=1;i<=n;i++)num=1ll*num*inv[d[i]]%P;
return 1ll*C(n+1+2*(len-d[1]),2*sum)*num%P;
}

//== == == =Search== == == =
void Search(int now,int all,int x){
ans=(ans+check(x))%P;
for(int i=now;all+1+max(1ll,2*i-3)<=n;i++){
d[i]++;a[x+1]=i;
Search(i,all+1+max(1ll,2*i-3),x+1);
d[i]--;a[x+1]=0;
}
}

//== == == =main== == == =
signed main(){
cin(n);cin(k);init();scanf("%s",s+1);
Search(1,-1,0);cout<<ans<<'\n';
return 0;
}
#include<bits/stdc++.h>
#define isnum(ch) ('0'<=ch&&ch<='9')
#define int long long
using namespace std;
inline int read()
{
int s=0,f=1;char _ch=getchar();
while(!isnum(_ch)) (_ch=='-')&&(f=-1),_ch=getchar();
while(isnum(_ch)) s=s*10+_ch-48,_ch=getchar();
return s*f;
}
const int mod=1e9+7;
int n,m,ln,A[20],f[20][1<<16],fac[1<<21],inv[1<<21],Ans;
inline int C(int n,int m){return n<m||m<0?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}
inline int sgn(int x){if(x&1)return mod-1;else return 1;}
inline int qpw(int x,int p){int s=1;for(;p;p>>=1,x=1ll*x*x%mod)if(p&1)s=1ll*s*x%mod;return s;}
signed main()
{
n=read(),m=read(),ln=1<<n;
fac[0]=1;for(int i=1;i<=ln;i++)fac[i]=1ll*fac[i-1]*i%mod;
inv[ln]=qpw(fac[ln],mod-2);for(int i=ln;i;i--)inv[i-1]=1ll*i*inv[i]%mod;
for(int i=1;i<=m;i++)A[i]=read();
reverse(A+1,A+1+m);
//	f[m+1][0]=1;
f[0][0]=1;
for(int i=0;i<m;i++)for(int j=0;j<ln;j++)
{
f[i+1][j]=(f[i+1][j]+f[i][j])%mod;
for(int k=0;k<n;k++)
{
//		cout<<(~(j>>k)&1)<<'\n';
//		if(bool(~(j>>k&1))!=bool(!(j>>k&1)))
//			cout<<"F";	
if(!((j>>k)&1))
f[i+1][j|(1<<k)]=(f[i+1][j|(1<<k)]+1ll*f[i][j]*C(ln-A[i+1]-j,(1<<k)-1)%mod*fac[1<<k]%mod)%mod;
}
//		f[i][j]=(f[i][j]+1ll*fac[1<<k]*f[i+1][j^(1<<k)]%mod*C(ln-A[i]-(j^(1<<k)),(1<<k)-1)%mod)%mod;
}
for(int i=0;i<ln;i++)
Ans=(Ans+1ll*sgn(__builtin_popcount(i))*f[m][i]%mod*fac[ln-1-i]%mod)%mod;
cout<<(1ll*Ans*ln%mod)<<'\n';

return 0;
}

#include <bits/stdc++.h>

#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")

#define ll long long
#define ld long double
#define si short int
#define i8 __int128
#define pii pair<int, int>
#define pll pair<ll, ll>
#define pld pair<ld, ld>
#define psi pair<si, si>
#define pi8 pair<i8, i8>
#define pq priority_queue
#define fi first
#define se second

#define sqr(x) ((x)*(x))
#define pow2(x) (1ll << (x))
#define debug(x) cout << #x << " = " << (x) << '\n'
#define debugV(x, a) cout << #x << "[" << (a) << "] = " << (x[a]) << '\n'

#define IOI using
#define he namespace
#define ikou std

IOI he ikou;

const ll ModA = 998244353;
const ll ModC = 1e9 + 7;
const ll INF = 1e18;
const ll iINF = 1e9;

const ld EPS = 1e-9;
const ld iEPS = 1e-6;

int main() {
ios_base::sync_with_stdio(false); cin.tie(NULL);

ll N, ans = 0, curmindiff = INF;
cin >> N;
bool equal = 1;
for (ll A, B, i = 1; i <= N; i++) {
cin >> A >> B;
if (A != B) {equal = 0;}
ans += A;
if (A > B) {
curmindiff = min(curmindiff, B);
}
}
if (equal) {
cout << "0\n";
return 0;
}
if (curmindiff != INF) {
ans -= curmindiff;
}

cout << ans << '\n';
}
#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <charconv>
#include <cmath>
#include <iomanip>
#include <limits>
#include <functional>
using namespace std;

#define rep(i, n) for (long i = 0; i < (long)(n); i++)
using ll = long long;


int main() {
ll s,c;
cin>>s>>c;
if(s*2>=c){
cout<<c/2<<endl;
exit(0);
}
c-=s*2;
cout<<s+c/4<<endl;
}

#include <bits/stdc++.h>

typedef long double ld;
#define int long long

#define gcd            __gcd
#define endl           "\n"
#define setbits(x)     __builtin_popcountll(x)
#define zrobits(x)     __builtin_ctzll(x)
#define mod            1000000007
#define mod2           998244353
#define maxe           *max_element
#define mine           *min_element
#define inf            1e18
#define pb             push_back
#define all(x)         x.begin(), x.end()
#define f              first
#define s              second
#define lb             lower_bound
#define ub             upper_bound
#define ins            insert
#define sz(x)          (int)(x).size()
#define mk             make_pair
#define deci(x, y)     fixed<<setprecision(y)<<x
#define w(t)           int t; cin>>t; while(t--)
#define nitin          ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define PI             3.141592653589793238
#define mem0(x)        memset(x,0,sizeof x)
#define mem1(x)        memset(x,-1,sizeof x)
#define pr             pair<int,int>
#define vi             vector<int>
#define vvi            vector<vi>
#define vpr            vector<pr>
using namespace std;
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.f << ", " << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }

#ifdef NITIN
#define dbg(...) cerr << "(" << #__VA_ARGS__ << "):", dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif
void solve() {
int n;
cin>>n;
int tot=0;
bool greater=false;
int val=INT_MAX;
for(int i=0;i<n;i++) {
int a, b;
cin >> a >> b;
tot += a;
if (b < a) {
greater = true;
val = min(val, b);
}
}
if(greater){
cout<<tot-val<<endl;
}else{
cout<<0<<endl;
}

}

int32_t main() {
nitin;

solve();
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <set>
#include <numeric>
#include <string>
#include <sstream>
#include <iomanip>
#define MOD (1000000007)
using namespace std;
typedef long long Int;
typedef long long ll;

class UnionFind {
public:
vector<int> par; 

UnionFind(int N){ 
par.resize(N);
for(int i = 0; i < N; i++) par[i] = i;
}

int root(int x) { 
if (par[x] == x) return x;
return par[x] = root(par[x]);
}

void unite(int x, int y) { 
int rx = root(x); 
int ry = root(y); 
if (rx == ry) return; 
par[rx] = ry; 
}

bool same(int x, int y) { 
int rx = root(x);
int ry = root(y);
return rx == ry;
}
};

int main() {
int N;
Int A, B;
cin >> N >> A >> B;
vector<Int> X(N);
for (int i = 0; i < N; i++) cin >> X[i];
UnionFind uf(N);
for (int i = 0; i < N-1; i++)
if (A * (X[i+1]-X[i]) < B) uf.unite(i, i+1);
Int ans = 0;
for (int i = 0; i < N-1; i++) {
if (uf.same(i, i+1)) ans += A * (X[i+1]-X[i]);
else ans += B;
}
cout << ans << endl;  
return 0;
}

#include <bits/stdc++.h>
#include <random>
#include <array>
#ifdef _MSC_VER
#include <ppl.h>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#else
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

/** compro_io **/

/* tuple */
// out
namespace aux {
template<typename T, unsigned N, unsigned L>
struct tp {
static void output(std::ostream& os, const T& v) {
os << std::get<N>(v) << ", ";
tp<T, N + 1, L>::output(os, v);
}
};
template<typename T, unsigned N>
struct tp<T, N, N> {
static void output(std::ostream& os, const T& v) { os << std::get<N>(v); }
};
}
template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {
os << '[';
aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);
return os << ']';
}

template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x);

/* pair */
// out
template<class S, class T>
std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {
return os << "[" << p.first << ", " << p.second << "]";
}
// in
template<class S, class T>
std::istream& operator>>(std::istream& is, const std::pair<S, T>& p) {
return is >> p.first >> p.second;
}

/* container */
// out
template<class Ch, class Tr, class Container>
std::basic_ostream<Ch, Tr>& operator<<(std::basic_ostream<Ch, Tr>& os, const Container& x) {
bool f = true;
os << "[";
for (auto& y : x) {
os << (f ? "" : ", ") << y;
f = false;
}
return os << "]";
}
// in
template <
class T,
class = decltype(std::begin(std::declval<T&>())),
class = typename std::enable_if<!std::is_same<T, std::string>::value>::type
>
std::istream& operator>>(std::istream& is, T& a) {
for (auto& x : a) is >> x;
return is;
}

/* struct */
template<typename T>
auto operator<<(std::ostream& out, const T& t) -> decltype(out << t.stringify()) {
out << t.stringify();
return out;
}

/* setup */
struct IOSetup {
IOSetup(bool f) {
if (f) { std::cin.tie(nullptr); std::ios::sync_with_stdio(false); }
std::cout << std::fixed << std::setprecision(15);
}
} iosetup(true);

/** string formatter **/
template<typename... Ts>
std::string format(const std::string& f, Ts... t) {
size_t l = std::snprintf(nullptr, 0, f.c_str(), t...);
std::vector<char> b(l + 1);
std::snprintf(&b[0], l + 1, f.c_str(), t...);
return std::string(&b[0], &b[0] + l);
}

template<typename T>
std::string stringify(const T& x) {
std::ostringstream oss;
oss << x;
return oss.str();
}

/* dump */
#define ENABLE_DUMP
#ifdef ENABLE_DUMP
#define DUMPOUT std::cerr
std::ostringstream DUMPBUF;
#define dump(...) do{DUMPBUF<<"  ";DUMPBUF<<#__VA_ARGS__<<" :[DUMP - "<<__LINE__<<":"<<__FUNCTION__<<"]"<<std::endl;DUMPBUF<<"    ";dump_func(__VA_ARGS__);DUMPOUT<<DUMPBUF.str();DUMPBUF.str("");DUMPBUF.clear();}while(0);
void dump_func() { DUMPBUF << std::endl; }
template <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPBUF << head; if (sizeof...(Tail) == 0) { DUMPBUF << " "; } else { DUMPBUF << ", "; } dump_func(std::move(tail)...); }
#else
#define dump(...) void(0);
#endif

/* timer */
class Timer {
double t = 0, paused = 0, tmp;
public:
Timer() { reset(); }
static double time() {
#ifdef _MSC_VER
return __rdtsc() / 3.0e9;
#else
unsigned long long a, d;
__asm__ volatile("rdtsc"
: "=a"(a), "=d"(d));
return (d << 32 | a) / 3.0e9;
#endif
}
void reset() { t = time(); }
void pause() { tmp = time(); }
void restart() { paused += time() - tmp; }
double elapsed_ms() { return (time() - t - paused) * 1000.0; }
} timer;

/* rand */
struct Xorshift {
uint64_t x = 88172645463325252LL;
void set_seed(unsigned seed, int rep = 100) { x = uint64_t((seed + 1) * 10007); for (int i = 0; i < rep; i++) next_int(); }
unsigned next_int() { x = x ^ (x << 7); return x = x ^ (x >> 9); }
unsigned next_int(unsigned mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % mod; }
unsigned next_int(unsigned l, unsigned r) { x = x ^ (x << 7); x = x ^ (x >> 9); return x % (r - l + 1) + l; } // inclusive
double next_double() { return double(next_int()) / UINT_MAX; }
} rnd;

/* shuffle */
template<typename T>
void shuffle_vector(std::vector<T>& v, Xorshift& rnd) {
int n = v.size();
for (int i = n - 1; i >= 1; i--) {
int r = rnd.next_int(i);
std::swap(v[i], v[r]);
}
}

/* split */
std::vector<std::string> split(std::string str, const std::string& delim) {
for (char& c : str) if (delim.find(c) != std::string::npos) c = ' ';
std::istringstream iss(str);
std::vector<std::string> parsed;
std::string buf;
while (iss >> buf) parsed.push_back(buf);
return parsed;
}

template<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) {
std::fill((T*)array, (T*)(array + N), val);
}
template<typename T, typename ...Args> auto make_vector(T x, int arg, Args ...args) { if constexpr (sizeof...(args) == 0)return std::vector<T>(arg, x); else return std::vector(arg, make_vector<T>(x, args...)); }
template<typename T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }
template<typename T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }



using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;



int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

ll H, W;
cin >> H >> W;

if (H % 3 == 0 || W % 3 == 0) {
cout << 0 << endl;
return 0;
}

ll ans = INT64_MAX;

if (H > 3) {
chmin(ans, W);
}

if (W > 3) {
chmin(ans, H);
}

for (ll h = 1; h < H; h++) {
ll s[3];
s[0] = h * W;
s[1] = (H - h) * (W / 2);
s[2] = H * W - s[0] - s[1];
sort(s, s + 3);
chmin(ans, s[2] - s[0]);
}

for (ll w = 1; w < W; w++) {
ll s[3];
s[0] = w * H;
s[1] = (W - w) * (H / 2);
s[2] = H * W - s[0] - s[1];
sort(s, s + 3);
chmin(ans, s[2] - s[0]);
}

cout << ans << endl;

return 0;
}
#line 1 "/Users/nok0/Documents/Programming/nok0/cftemp.hpp"
#include <bits/stdc++.h>
using namespace std;

#pragma region Macros
// rep macro
#define foa(v, a) for(auto &v : a)
#define REPname(a, b, c, d, e, ...) e
#define REP(...) REPname(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)
#define REP0(x) for(int i = 0; i < (x); ++i)
#define REP1(i, x) for(int i = 0; i < (x); ++i)
#define REP2(i, l, r) for(int i = (l); i < (r); ++i)
#define REP3(i, l, r, c) for(int i = (l); i < (r); i += (c))
#define REPSname(a, b, c, ...) c
#define REPS(...) REPSname(__VA_ARGS__, REPS1, REPS0)(__VA_ARGS__)
#define REPS0(x) for(int i = 1; i <= (x); ++i)
#define REPS1(i, x) for(int i = 1; i <= (x); ++i)
#define RREPname(a, b, c, d, e, ...) e
#define RREP(...) RREPname(__VA_ARGS__, RREP3, RREP2, RREP1, RREP0)(__VA_ARGS__)
#define RREP0(x) for(int i = (x)-1; i >= 0; --i)
#define RREP1(i, x) for(int i = (x)-1; i >= 0; --i)
#define RREP2(i, r, l) for(int i = (r)-1; i >= (l); --i)
#define RREP3(i, r, l, c) for(int i = (r)-1; i >= (l); i -= (c))
#define RREPSname(a, b, c, ...) c
#define RREPS(...) RREPSname(__VA_ARGS__, RREPS1, RREPS0)(__VA_ARGS__)
#define RREPS0(x) for(int i = (x); i >= 1; --i)
#define RREPS1(i, x) for(int i = (x); i >= 1; --i)

// name macro
#define pb push_back
#define eb emplace_back
#define SZ(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define popcnt(x) __builtin_popcountll(x)
template <class T = int>
using V = std::vector<T>;
template <class T = int>
using VV = std::vector<std::vector<T>>;
template <class T>
using pqup = std::priority_queue<T, std::vector<T>, std::greater<T>>;
using ll = long long;
using ld = long double;
using int128 = __int128_t;
using pii = std::pair<int, int>;
using pll = std::pair<long long, long long>;

// input macro
template <class T, class U>
std::istream &operator>>(std::istream &is, std::pair<T, U> &p) {
is >> p.first >> p.second;
return is;
}
template <class T>
std::istream &operator>>(std::istream &is, std::vector<T> &v) {
for(T &i : v) is >> i;
return is;
}
std::istream &operator>>(std::istream &is, __int128_t &a) {
std::string s;
is >> s;
__int128_t ret = 0;
for(int i = 0; i < s.length(); i++)
if('0' <= s[i] and s[i] <= '9')
ret = 10 * ret + s[i] - '0';
a = ret * (s[0] == '-' ? -1 : 1);
return is;
}
namespace scanner {
void scan(int &a) { std::cin >> a; }
void scan(long long &a) { std::cin >> a; }
void scan(std::string &a) { std::cin >> a; }
void scan(char &a) { std::cin >> a; }
void scan(char a[]) { std::scanf("%s", a); }
void scan(double &a) { std::cin >> a; }
void scan(long double &a) { std::cin >> a; }
template <class T, class U>
void scan(std::pair<T, U> &p) { std::cin >> p; }
template <class T>
void scan(std::vector<T> &a) { std::cin >> a; }
void INPUT() {}
template <class Head, class... Tail>
void INPUT(Head &head, Tail &...tail) {
scan(head);
INPUT(tail...);
}
}  // namespace scanner
#define VEC(type, name, size)     \
std::vector<type> name(size); \
scanner::INPUT(name)
#define VVEC(type, name, h, w)                                    \
std::vector<std::vector<type>> name(h, std::vector<type>(w)); \
scanner::INPUT(name)
#define INT(...)     \
int __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define LL(...)            \
long long __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define STR(...)             \
std::string __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define CHAR(...)     \
char __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define DOUBLE(...)     \
double __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)
#define LD(...)              \
long double __VA_ARGS__; \
scanner::INPUT(__VA_ARGS__)

// output-macro
template <class T, class U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {
os << p.first << " " << p.second;
return os;
}
template <class T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &a) {
for(int i = 0; i < int(a.size()); ++i) {
if(i) os << " ";
os << a[i];
}
return os;
}
std::ostream &operator<<(std::ostream &dest, __int128_t &value) {
std::ostream::sentry s(dest);
if(s) {
__uint128_t tmp = value < 0 ? -value : value;
char buffer[128];
char *d = std::end(buffer);
do {
--d;
*d = "0123456789"[tmp % 10];
tmp /= 10;
} while(tmp != 0);
if(value < 0) {
--d;
*d = '-';
}
int len = std::end(buffer) - d;
if(dest.rdbuf()->sputn(d, len) != len) {
dest.setstate(std::ios_base::badbit);
}
}
return dest;
}
template <class T>
void print(const T a) { std::cout << a << '\n'; }
template <class Head, class... Tail>
void print(Head H, Tail... T) {
std::cout << H << ' ';
print(T...);
}
template <class T>
void printel(const T a) { std::cout << a << '\n'; }
template <class T>
void printel(const std::vector<T> &a) {
for(const auto &v : a)
std::cout << v << '\n';
}
template <class Head, class... Tail>
void printel(Head H, Tail... T) {
std::cout << H << '\n';
printel(T...);
}
void Yes(const bool b = true) { std::cout << (b ? "Yes\n" : "No\n"); }
void No() { std::cout << "No\n"; }
void YES(const bool b = true) { std::cout << (b ? "YES\n" : "NO\n"); }
void NO() { std::cout << "NO\n"; }
void err(const bool b = true) {
if(b) {
std::cout << "-1\n", exit(0);
}
}

//debug macro
namespace debugger {
template <class T>
void view(const std::vector<T> &a) {
std::cerr << "{ ";
for(const auto &v : a) {
std::cerr << v << ", ";
}
std::cerr << "\b\b }";
}
template <class T>
void view(const std::vector<std::vector<T>> &a) {
std::cerr << "{\n";
for(const auto &v : a) {
std::cerr << "\t";
view(v);
std::cerr << "\n";
}
std::cerr << "}";
}
template <class T, class U>
void view(const std::vector<std::pair<T, U>> &a) {
std::cerr << "{\n";
for(const auto &p : a) std::cerr << "\t(" << p.first << ", " << p.second << ")\n";
std::cerr << "}";
}
template <class T, class U>
void view(const std::map<T, U> &m) {
std::cerr << "{\n";
for(const auto &p : m) std::cerr << "\t[" << p.first << "] : " << p.second << "\n";
std::cerr << "}";
}
template <class T, class U>
void view(const std::pair<T, U> &p) { std::cerr << "(" << p.first << ", " << p.second << ")"; }
template <class T>
void view(const std::set<T> &s) {
std::cerr << "{ ";
for(auto &v : s) {
view(v);
std::cerr << ", ";
}
std::cerr << "\b\b }";
}

template <class T>
void view(const T &e) { std::cerr << e; }
}  // namespace debugger
#ifdef LOCAL
void debug_out() {}
template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
debugger::view(H);
std::cerr << ", ";
debug_out(T...);
}
#define debug(...)                                                \
do {                                                          \
std::cerr << __LINE__ << " [" << #__VA_ARGS__ << "] : ["; \
debug_out(__VA_ARGS__);                                   \
std::cerr << "\b\b]\n";                                   \
} while(false)
#else
#define debug(...) (void(0))
#endif

// vector macro
template <class T>
int lb(const std::vector<T> &a, const T x) { return std::distance((a).begin(), std::lower_bound((a).begin(), (a).end(), (x))); }
template <class T>
int ub(const std::vector<T> &a, const T x) { return std::distance((a).begin(), std::upper_bound((a).begin(), (a).end(), (x))); }
template <class T>
void UNIQUE(std::vector<T> &a) {
std::sort(a.begin(), a.end());
a.erase(std::unique(a.begin(), a.end()), a.end());
}
template <class T>
std::vector<T> press(std::vector<T> &a) {
auto res = a;
UNIQUE(res);
for(auto &v : a)
v = lb(res, v);
return res;
}
#define SORTname(a, b, c, ...) c
#define SORT(...) SORTname(__VA_ARGS__, SORT1, SORT0, ...)(__VA_ARGS__)
#define SORT0(a) std::sort((a).begin(), (a).end())
#define SORT1(a, c) std::sort((a).begin(), (a).end(), [](const auto x, const auto y) { return x c y; })
template <class T>
void ADD(std::vector<T> &a, const T x = 1) {
for(auto &v : a) v += x;
}
template <class T>
void SUB(std::vector<T> &a, const T x = 1) {
for(auto &v : a) v -= x;
}
std::vector<std::pair<char, int>> rle(const string &s) {
int n = s.size();
std::vector<std::pair<char, int>> ret;
for(int l = 0; l < n;) {
int r = l + 1;
for(; r < n and s[l] == s[r]; r++) {}
ret.emplace_back(s[l], r - l);
l = r;
}
return ret;
}
template <class T>
std::vector<std::pair<T, int>> rle(const std::vector<T> &v) {
int n = v.size();
std::vector<std::pair<T, int>> ret;
for(int l = 0; l < n;) {
int r = l + 1;
for(; r < n and v[l] == v[r]; r++) {}
ret.emplace_back(v[l], r - l);
l = r;
}
return ret;
}
std::vector<int> iota(int n) {
std::vector<int> p(n);
std::iota(p.begin(), p.end(), 0);
return p;
}
template <class T>
struct cum_vector {
public:
cum_vector() = default;
template <class U>
cum_vector(const std::vector<U> &vec) : cum((int)vec.size() + 1) {
for(int i = 0; i < (int)vec.size(); i++)
cum[i + 1] = cum[i] + vec[i];
}
T prod(int l, int r) {
return cum[r] - cum[l];
}

private:
std::vector<T> cum;
};

// math macro
template <class T, class U>
inline bool chmin(T &a, const U &b) { return a > b ? a = b, true : false; }
template <class T, class U>
inline bool chmax(T &a, const U &b) { return a < b ? a = b, true : false; }
template <class T>
T divup(T x, T y) { return (x + y - 1) / y; }
template <class T>
T POW(T a, long long n) {
T ret = 1;
while(n) {
if(n & 1) ret *= a;
a *= a;
n >>= 1;
}
return ret;
}
// modpow
long long POW(long long a, long long n, const int mod) {
long long ret = 1;
a = (a % mod + mod) % mod;
while(n) {
if(n & 1) (ret *= a) %= mod;
(a *= a) %= mod;
n >>= 1;
}
return ret;
}
template <class T, class F>
T bin_search(T ok, T ng, const F &f) {
while(abs(ok - ng) > 1) {
T mid = (ok + ng) >> 1;
(f(mid) ? ok : ng) = mid;
}
return ok;
}
template <class T, class F>
T bin_search(T ok, T ng, const F &f, int loop) {
for(int i = 0; i < loop; i++) {
T mid = (ok + ng) / 2;
(f(mid) ? ok : ng) = mid;
}
return ok;
}

// others
struct fast_io {
fast_io() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);
}
} fast_io_;
const int inf = 1e9;
const ll INF = 1e18;
#pragma endregion

void main_();

int main() {
main_();
return 0;
}
#line 1 "/Users/nok0/Documents/Programming/nok0/atcoder/modint.hpp"



#line 6 "/Users/nok0/Documents/Programming/nok0/atcoder/modint.hpp"
#include <type_traits>

#ifdef _MSC_VER
#include <intrin.h>
#endif

#line 1 "/Users/nok0/Documents/Programming/nok0/atcoder/internal_math.hpp"



#line 5 "/Users/nok0/Documents/Programming/nok0/atcoder/internal_math.hpp"

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

// @param m `1 <= m`
// @return x mod m
constexpr long long safe_mod(long long x, long long m) {
x %= m;
if (x < 0) x += m;
return x;
}

// Fast modular multiplication by barrett reduction
// Reference: https://en.wikipedia.org/wiki/Barrett_reduction
// NOTE: reconsider after Ice Lake
struct barrett {
unsigned int _m;
unsigned long long im;

// @param m `1 <= m < 2^31`
explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

// @return m
unsigned int umod() const { return _m; }

// @param a `0 <= a < m`
// @param b `0 <= b < m`
// @return `a * b % m`
unsigned int mul(unsigned int a, unsigned int b) const {
// [1] m = 1
// a = b = im = 0, so okay

// [2] m >= 2
// im = ceil(2^64 / m)
// -> im * m = 2^64 + r (0 <= r < m)
// let z = a*b = c*m + d (0 <= c, d < m)
// a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im
// c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2
// ((ab * im) >> 64) == c or c + 1
unsigned long long z = a;
z *= b;
#ifdef _MSC_VER
unsigned long long x;
_umul128(z, im, &x);
#else
unsigned long long x =
(unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
unsigned int v = (unsigned int)(z - x * _m);
if (_m <= v) v += _m;
return v;
}
};

// @param n `0 <= n`
// @param m `1 <= m`
// @return `(x ** n) % m`
constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
if (m == 1) return 0;
unsigned int _m = (unsigned int)(m);
unsigned long long r = 1;
unsigned long long y = safe_mod(x, m);
while (n) {
if (n & 1) r = (r * y) % _m;
y = (y * y) % _m;
n >>= 1;
}
return r;
}

// Reference:
// M. Forisek and J. Jancina,
// Fast Primality Testing for Integers That Fit into a Machine Word
// @param n `0 <= n`
constexpr bool is_prime_constexpr(int n) {
if (n <= 1) return false;
if (n == 2 || n == 7 || n == 61) return true;
if (n % 2 == 0) return false;
long long d = n - 1;
while (d % 2 == 0) d /= 2;
constexpr long long bases[3] = {2, 7, 61};
for (long long a : bases) {
long long t = d;
long long y = pow_mod_constexpr(a, t, n);
while (t != n - 1 && y != 1 && y != n - 1) {
y = y * y % n;
t <<= 1;
}
if (y != n - 1 && t % 2 == 0) {
return false;
}
}
return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

// @param b `1 <= b`
// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g
constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
a = safe_mod(a, b);
if (a == 0) return {b, 0};

// Contracts:
// [1] s - m0 * a = 0 (mod b)
// [2] t - m1 * a = 0 (mod b)
// [3] s * |m1| + t * |m0| <= b
long long s = b, t = a;
long long m0 = 0, m1 = 1;

while (t) {
long long u = s / t;
s -= t * u;
m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b

// [3]:
// (s - t * u) * |m1| + t * |m0 - m1 * u|
// <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)
// = s * |m1| + t * |m0| <= b

auto tmp = s;
s = t;
t = tmp;
tmp = m0;
m0 = m1;
m1 = tmp;
}
// by [3]: |m0| <= b/g
// by g != b: |m0| < b/g
if (m0 < 0) m0 += b / s;
return {s, m0};
}

// Compile time primitive root
// @param m must be prime
// @return primitive root (and minimum in now)
constexpr int primitive_root_constexpr(int m) {
if (m == 2) return 1;
if (m == 167772161) return 3;
if (m == 469762049) return 3;
if (m == 754974721) return 11;
if (m == 998244353) return 3;
int divs[20] = {};
divs[0] = 2;
int cnt = 1;
int x = (m - 1) / 2;
while (x % 2 == 0) x /= 2;
for (int i = 3; (long long)(i)*i <= x; i += 2) {
if (x % i == 0) {
divs[cnt++] = i;
while (x % i == 0) {
x /= i;
}
}
}
if (x > 1) {
divs[cnt++] = x;
}
for (int g = 2;; g++) {
bool ok = true;
for (int i = 0; i < cnt; i++) {
if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
ok = false;
break;
}
}
if (ok) return g;
}
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

// @param n `n < 2^32`
// @param m `1 <= m < 2^32`
// @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)
unsigned long long floor_sum_unsigned(unsigned long long n,
unsigned long long m,
unsigned long long a,
unsigned long long b) {
unsigned long long ans = 0;
while (true) {
if (a >= m) {
ans += n * (n - 1) / 2 * (a / m);
a %= m;
}
if (b >= m) {
ans += n * (b / m);
b %= m;
}

unsigned long long y_max = a * n + b;
if (y_max < m) break;
// y_max < m * (n + 1)
// floor(y_max / m) <= n
n = (unsigned long long)(y_max / m);
b = (unsigned long long)(y_max % m);
std::swap(m, a);
}
return ans;
}

}  // namespace internal

}  // namespace atcoder


#line 1 "/Users/nok0/Documents/Programming/nok0/atcoder/internal_type_traits.hpp"



#line 7 "/Users/nok0/Documents/Programming/nok0/atcoder/internal_type_traits.hpp"

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value ||
std::is_same<T, __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int128 =
typename std::conditional<std::is_same<T, __uint128_t>::value ||
std::is_same<T, unsigned __int128>::value,
std::true_type,
std::false_type>::type;

template <class T>
using make_unsigned_int128 =
typename std::conditional<std::is_same<T, __int128_t>::value,
__uint128_t,
unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
is_signed_int128<T>::value ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
std::is_signed<T>::value) ||
is_signed_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<(is_integral<T>::value &&
std::is_unsigned<T>::value) ||
is_unsigned_int128<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
is_signed_int128<T>::value,
make_unsigned_int128<T>,
typename std::conditional<std::is_signed<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using is_unsigned_int =
typename std::conditional<is_integral<T>::value &&
std::is_unsigned<T>::value,
std::true_type,
std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
std::make_unsigned<T>,
std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


#line 14 "/Users/nok0/Documents/Programming/nok0/atcoder/modint.hpp"

namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
using mint = static_modint;

public:
static constexpr int mod() { return m; }
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

static_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
static_modint(T v) {
long long x = (long long)(v % (long long)(umod()));
if (x < 0) x += umod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
static_modint(T v) {
_v = (unsigned int)(v % umod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v -= rhs._v;
if (_v >= umod()) _v += umod();
return *this;
}
mint& operator*=(const mint& rhs) {
unsigned long long z = _v;
z *= rhs._v;
_v = (unsigned int)(z % umod());
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
if (prime) {
assert(_v);
return pow(umod() - 2);
} else {
auto eg = internal::inv_gcd(_v, m);
assert(eg.first == 1);
return eg.second;
}
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static constexpr unsigned int umod() { return m; }
static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
using mint = dynamic_modint;

public:
static int mod() { return (int)(bt.umod()); }
static void set_mod(int m) {
assert(1 <= m);
bt = internal::barrett(m);
}
static mint raw(int v) {
mint x;
x._v = v;
return x;
}

dynamic_modint() : _v(0) {}
template <class T, internal::is_signed_int_t<T>* = nullptr>
dynamic_modint(T v) {
long long x = (long long)(v % (long long)(mod()));
if (x < 0) x += mod();
_v = (unsigned int)(x);
}
template <class T, internal::is_unsigned_int_t<T>* = nullptr>
dynamic_modint(T v) {
_v = (unsigned int)(v % mod());
}

unsigned int val() const { return _v; }

mint& operator++() {
_v++;
if (_v == umod()) _v = 0;
return *this;
}
mint& operator--() {
if (_v == 0) _v = umod();
_v--;
return *this;
}
mint operator++(int) {
mint result = *this;
++*this;
return result;
}
mint operator--(int) {
mint result = *this;
--*this;
return result;
}

mint& operator+=(const mint& rhs) {
_v += rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator-=(const mint& rhs) {
_v += mod() - rhs._v;
if (_v >= umod()) _v -= umod();
return *this;
}
mint& operator*=(const mint& rhs) {
_v = bt.mul(_v, rhs._v);
return *this;
}
mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

mint operator+() const { return *this; }
mint operator-() const { return mint() - *this; }

mint pow(long long n) const {
assert(0 <= n);
mint x = *this, r = 1;
while (n) {
if (n & 1) r *= x;
x *= x;
n >>= 1;
}
return r;
}
mint inv() const {
auto eg = internal::inv_gcd(_v, mod());
assert(eg.first == 1);
return eg.second;
}

friend mint operator+(const mint& lhs, const mint& rhs) {
return mint(lhs) += rhs;
}
friend mint operator-(const mint& lhs, const mint& rhs) {
return mint(lhs) -= rhs;
}
friend mint operator*(const mint& lhs, const mint& rhs) {
return mint(lhs) *= rhs;
}
friend mint operator/(const mint& lhs, const mint& rhs) {
return mint(lhs) /= rhs;
}
friend bool operator==(const mint& lhs, const mint& rhs) {
return lhs._v == rhs._v;
}
friend bool operator!=(const mint& lhs, const mint& rhs) {
return lhs._v != rhs._v;
}

private:
unsigned int _v;
static internal::barrett bt;
static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder


#line 4 "/Users/nok0/Documents/Programming/nok0/math/factorial.hpp"

#line 6 "/Users/nok0/Documents/Programming/nok0/math/factorial.hpp"

template <class T>
struct factorial {
public:
static int MAX;
static std::vector<T> fac, finv, inv;

factorial() {}

T binom(int n, int r) {
if(n < r or n < 0 or r < 0) return T(0);
assert(n < MAX);
return fac[n] * finv[r] * finv[n - r];
}

T large_binom(int n, int r) {
if(n < r or n < 0 or r < 0) return T(0);
assert(r < MAX);
T ret = finv[r];
for(int i = 1; i <= r; ++i)
ret *= (n + 1 - i);
return ret;
}

static void set_size(int n = 3000000) {
MAX = (n > 1 ? n : 1) + 1;
if((int)fac.size() >= MAX) return;
fac.resize(MAX);
finv.resize(MAX);
inv.resize(MAX);
const int MOD = T::mod();
fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for(int i = 2; i < MAX; i++) {
fac[i] = fac[i - 1] * i;
inv[i] = (T)MOD - inv[MOD % i] * (MOD / i);
finv[i] = finv[i - 1] * inv[i];
}
}
};
template <class T>
int factorial<T>::MAX = 0;
template <class T>
std::vector<T> factorial<T>::fac;
template <class T>
std::vector<T> factorial<T>::finv;
template <class T>
std::vector<T> factorial<T>::inv;
#line 3 "/Users/nok0/Documents/Programming/nok0/math/modint_iostream.hpp"

#line 5 "/Users/nok0/Documents/Programming/nok0/math/modint_iostream.hpp"
template <int m>
std::istream &std::operator>>(std::istream &is, atcoder::static_modint<m> &a) {
long long v;
is >> v;
a = v;
return is;
}
template <int m>
std::istream &std::operator>>(std::istream &is, atcoder::dynamic_modint<m> &a) {
long long v;
is >> v;
a = v;
return is;
}
template <int m>
std::ostream &std::operator<<(std::ostream &os, const atcoder::static_modint<m> &a) { return os << a.val(); }
template <int m>
std::ostream &std::operator<<(std::ostream &os, const atcoder::dynamic_modint<m> &a) { return os << a.val(); }
#line 3 "d.cpp"

using mint = atcoder::modint1000000007;

mint res;
void main_() {
factorial<mint>::set_size();
factorial<mint> fac;

INT(n, m);
STR(s);
VEC(pii, lr, m);

foa(p, lr) p.first--;
sort(all(lr), [](pii x, pii y) {
if(x.first != y.first)
return x.first < y.first;
else
return x.second > y.second;
});
V<pii> nlr;
int rig = -1;
foa(p, lr) {
if(rig > p.second) continue;
rig = p.second;
nlr.pb(p);
}
lr = move(nlr);
m = SZ(lr);

vector dp(m + 1, vector(n + 1, mint(0)));

V<> one(n);
REP(i, n) { one[i] = s[i] == '1'; }

cum_vector<int> cum(one);

dp[0][cum.prod(lr[0].first, lr[0].second)] = 1;
REP(i, m) {
if(i + 1 < m) {
auto [nl, nr] = lr[i + 1];
int len = max(lr[i].second - nl, 0);
int olen = min(lr[i].second, lr[i + 1].first) - lr[i].first;
REP(j, lr[i].second - lr[i].first + 1) {
int def = cum.prod(max(nl, lr[i].second), nr);
REP(k, len + 1) {
dp[i + 1][def + k] += dp[i][j] * fac.binom(olen, j - k);
}
}
} else {
REP(j, n + 1) {
res += dp[i][j] * fac.binom(lr.back().second - lr.back().first, j);
}
}
}
print(res);
}

#include<bits/stdc++.h>
#define endl "\n"
using namespace std;
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
int n, x, sum=0;
cin >> n;
map<long long int,long long int>mp;
while(n--)
{
cin >> x;
mp[x]++;
}
map<long long int, long long int>::iterator it;
for(it=mp.begin();it!=mp.end();it++)
{
if(it->first==it->second)
continue;
else if(it->first>it->second)
sum+=it->second;
else sum+=(it->second-it->first);
}
cout << sum;
return 0; //Abdullah
}

#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+5;
inline ll read()
{
ll x=0;
ll bei=1;
char ch=getchar();
while(ch<'0'||ch>'9')
{
if(ch=='-')
bei=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9')
{
x=x*10+ch-'0';
ch=getchar();
}
return x*bei;
}
ll a[N],b[N];
int main()
{
ll S=0;
int n=read();
for(int i = 1; i <= n; ++i)
{
a[i]=read();
b[i]=read();
S += a[i];
}
ll ans=0;
for(int i = 1; i <= n; ++i)
{
if(b[i] < a[i])
{
ans = max(ans,S-b[i]);
}
}
printf("%lld\n", ans);
return 0;
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e5 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 3005)
def(p, int, 1e9 + 7)

int n, m;
int pre[N];
string s;
int to[N];
ll dp[N][N];

int main() {
ios; cin >> n >> m;
cin >> s; s = ' ' + s + '0';
++n;
rep(i, 1, n) pre[i] = pre[i - 1] + (s[i] == '1'), to[i] = i;
rep(i, 1, m) {
int l, r;
cin >> l >> r;
To_max(to[l], r);
}
rep(i, 1, n) To_max(to[i], to[i - 1]);
dp[1][pre[to[1]]] = 1;
rep(i, 2, n) {
int nw = pre[to[i]] - pre[to[i - 1]];
rep(j, 0, to[i - 1] - i + 1) dp[i][j + nw] = (dp[i - 1][j] + dp[i - 1][j + 1]) % p; 
}
cout << dp[n][0] << endl;
return 0;
}
#include <bits/stdc++.h>
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define ll long long
#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define fi first
#define se second
#define mp make_pair
#define Ld long double
#define pii pair<int, int>

using namespace std;

const int N = 3e5 + 5;

struct Node {
int ls, rs, sze, rnd, x;
ll sum;
} ;
struct fhq {
int rt = 0, cnt = 0;
Node t[N];

void pushup(int x) {
t[x].sze = t[t[x].ls].sze + t[t[x].rs].sze + 1;	
t[x].sum = t[t[x].ls].sum + t[t[x].rs].sum + t[x].x;
}

int New(int x) {
++cnt;

t[cnt].ls = t[cnt].rs = 0;
t[cnt].sze = 1;
t[cnt].rnd = rand();
t[cnt].x = t[cnt].sum = x;

return cnt;
}

int merge(int x, int y) {
if(!x || !y) return x + y;
if(t[x].rnd < t[y].rnd) {
t[x].rs = merge(t[x].rs, y);
pushup(x);
return x;
}
else {
t[y].ls = merge(x, t[y].ls);
pushup(y);
return y;
}
}

void split(int r, int &x, int &y, int k) {
if(!r) return x = y = 0, void();
if(t[r].x <= k) {
x = r;
split(t[x].rs, t[x].rs, y, k);
}
else {
y = r;
split(t[y].ls, x, t[y].ls, k);
}
pushup(r);
}

void splitrk(int r, int &x, int &y, int k) {
if(!r) return x = y = 0, void();
if(t[t[r].ls].sze + 1 <= k) {
x = r;
splitrk(t[x].rs, t[x].rs, y, k - t[t[r].ls].sze - 1);
}
else {
y = r;
splitrk(t[y].ls, x, t[y].ls, k);
}
pushup(r);
}

void insert(int x) {
int l, r;
split(rt, l, r, x);
rt = merge(l, merge(New(x), r));
}

void del(int x) {
int l, mid, r;
split(rt, l, r, x - 1);
split(r, mid, r, x);
mid = merge(t[mid].ls, t[mid].rs);
rt = merge(l, merge(mid, r));
}
} T[2];

int n;
int a[N];
int sz[2];
ll s1, s2;

ll get() {
ll ret;
int nd1 = sz[0] - n, nd2 = sz[1] - n;

if(!nd1) ret = s1;
else {
int l, r;
T[0].splitrk(T[0].rt, l, r, nd1);
ret = s1 - T[0].t[l].sum;
T[0].merge(l, r);
}

if(!nd2) ret -= s2;
else {
int l, r;
T[1].splitrk(T[1].rt, l, r, sz[1] - nd2);
ret -= s2 - T[1].t[r].sum;
T[1].merge(l, r);
}

return ret;
}

int main() {
srand(19260817);
ios;
cin >> n;
rep(i, 1, n * 3) cin >> a[i];
rep(i, 1, n) s1 += a[i], T[0].insert(a[i]);
rep(i, n + 1, 3 * n) s2 += a[i], T[1].insert(a[i]);
sz[0] = n, sz[1] = n * 2;
ll ans = get();
rep(i, n + 1, 2 * n) {
s1 += a[i], s2 -= a[i];
T[0].insert(a[i]);
T[1].del(a[i]);
++sz[0], --sz[1];
ans = max(ans, get());
}
cout << ans << endl;
return 0;
}
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC optimization ("unroll-loops")
#define ll long long int
#define pb push_back
#define mod 1000000007
#define inarr(i,arr,n); for(ll i=0;i<n;i++) cin >> arr[i];
#define outarr(i,arr,n); for(ll i=0;i<n;i++) cout<<arr[i]<<' ';
#define swap(a,b,t) {t=a;a=b;b=t;}
#define ve vector
#define all(x) x.begin(), x.end()
#define sz(a) (int)((a).size())
#define fi first
#define se second
#define pa pair
#define fastio  {ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);}
#define ll long long int
#define fr(i, a, b) for (long long int i = a; i <= b; i++)
#define frn(i, a, b) for (long long int i = a; i >= b; i--)
#define mk make_pair
#define endl "\n"
#define setvector(vname,value,size); for(int i=0;i<size;i++)vname[i]=value;
const ll inf = 1e18;
int main()
{
fastio;
ll n;
cin>>n;
ve <ll> A(n);
ve <ll> B(n);
fr(i, 0, n-1)
{
cin>>A[i]>>B[i];
}
ll ans = 0;
ll diff = ans;
fr(i, 0, n-1)
{
ans += (A[i]) * (B[i] > A[i]);
diff += (B[i] - A[i]) * (B[i] > A[i]);
}

//cout<<diff<<endl;

ll m1 = inf;
fr(i, 0, n-1)
{
if((A[i] >= B[i])&&(diff>0))
{
if(A[i] > B[i])
m1 = min(m1, B[i]);
ans += A[i];
}
}    
if(m1 != inf)
ans -= m1;
cout<<ans<<endl;
}
#include <algorithm>
#include <iomanip>
#include <array>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <deque>
#include <functional>
#include <iostream>
#include <iterator>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <numeric>
#include <vector>
#include <climits>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
#endif
#define GET_MACRO(_1, _2, _3, NAME, ...) NAME
#define _rep(i, n) _rep2(i, 0, n)
#define _rep2(i, a, b) for(int i = (int)(a); i < (int)(b); i++)
#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
using i64 = long long;
template<class T, class U>
bool chmin(T& a, const U& b) { return (b < a) ? (a = b, true) : false; }
template<class T, class U>
bool chmax(T& a, const U& b) { return (b > a) ? (a = b, true) : false; }

template<typename T>istream& operator>>(istream&i,vector<T>&v){rep(j,v.size())i>>v[j];return i;}
template<typename T>string join(vector<T>&v){stringstream s;rep(i,v.size())s<<' '<<v[i];return s.str().substr(1);}
template<typename T>ostream& operator<<(ostream&o,vector<T>&v){if(v.size())o<<join(v);return o;}
template<typename T>string join(vector<vector<T>>&vv){string s="\n";rep(i,vv.size())s+=join(vv[i])+"\n";return s;}
template<typename T>ostream& operator<<(ostream&o,vector<vector<T>>&vv){if(vv.size())o<<join(vv);return o;}
template<class T> using pq = priority_queue<T, vector<T>, greater<T>>;

template<int VH, int VW> struct Sum2D {
int v[VH][VW];
void set(int x, int y, i64 c) { v[y][x] = c; }
void build() {
rep(y, 0, VH) rep(x, 0, VW) {
if (0 < y) v[y][x] += v[y - 1][x];
if (0 < x) v[y][x] += v[y][x - 1];
if (0 < y && 0 < x) v[y][x] -= v[y - 1][x - 1];
}
}
int get(int sx, int sy, int tx, int ty) {
assert(sx <= tx && sy <= ty);
i64 rs = v[ty][tx];
if (0 < sx) rs -= v[ty][sx - 1];
if (0 < sy) rs -= v[sy - 1][tx];
if (0 < sx && 0 < sy) rs += v[sy - 1][sx - 1];
return rs;
}
};

i64 n, k;
Sum2D<4010, 4010> BR, WR;
vector B(2005, vector<int>(2005)); 
vector W(2005, vector<int>(2005)); 

int main() {
cin >> n >> k;

i64 kk = 2 * k;
vector<int> x(n), y(n);
vector<string> s(n);
rep(i, n) cin >> x[i] >> y[i] >> s[i];

rep(i, n) {
if(s[i] == "B") B[y[i]%kk][x[i]%kk]++;
if(s[i] == "W") W[y[i]%kk][x[i]%kk]++;
}

rep(i, 2 *kk) rep(j, 2 * kk) {
BR.set(i, j, B[i%kk][j%kk]);
WR.set(i, j, W[i%kk][j%kk]);
}

BR.build();
WR.build();

i64 ans = 0;

rep(i, kk) rep(j, kk) {
i64 b = BR.get(i, j, i + k - 1, j + k - 1) + BR.get(i + k, j + k, i + kk - 1, j + kk - 1);
i64 w = WR.get(i + k, j, i + kk - 1, j + k - 1) + WR.get(i, j + k, i + k - 1, j + kk - 1);
chmax(ans, b + w);
}

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+7;
int read()  {
int x=0,f=1;char s=getchar();
for(;s>'9'||s<'0';s=getchar()) if(s=='-') f=-1;
for(;s>='0'&&s<='9';s=getchar()) x=x*10+s-'0';
return x*f;
}
int n,id[N],mmp,val[N],pos[N];
struct edge {
int id,val,type;
bool operator < (const edge &b) const {
return val<b.val;
}
}a[N];
struct node {int v,nxt;}e[N<<1];
int head[N],tot;
void add(int u,int v) {
e[++tot].v=v;
e[tot].nxt=head[u];
head[u]=tot;
}
int low[N],dfn[N],stak[N],top,cnt,vis[N],belong[N],scc;
void clear() {
cnt=scc=tot=0;
mmp=n+n;
memset(head,0,sizeof(head));
memset(dfn,0,sizeof(dfn));
memset(id,0,sizeof(id));
}
void tarjan(int u) {
low[u]=dfn[u]=++cnt;
vis[u]=1;
stak[++top]=u;
for(int i=head[u];i;i=e[i].nxt) {
int v=e[i].v;
if(!dfn[v]) {
tarjan(v);
low[u]=min(low[u],low[v]);
} else if(vis[v]) {
low[u]=min(low[u],dfn[v]);
}
}
if(low[u]==dfn[u]) {
++scc;
while(stak[top]!=u) {
vis[stak[top]]=0;
belong[stak[top]]=scc;
top--;
}
vis[stak[top]]=0;
belong[stak[top]]=scc;
top--;
}
}
namespace seg {
#define ls rt<<1
#define rs rt<<1|1
void build(int l,int r,int rt) {
if(l==r) return id[rt]=pos[((a[l].id-1)^1)+1],void();
int mid=(l+r)>>1;
id[rt]=++mmp;
build(l,mid,ls);
build(mid+1,r,rs);
add(id[rt],id[ls]),add(id[rt],id[rs]);
}
void update(int u,int L,int R,int l,int r,int rt) {
if(L>R) return;
if(L<=l&&r<=R) return add(u,id[rt]);
int mid=(l+r)>>1;
if(L<=mid) update(u,L,R,l,mid,ls);
if(R>mid) update(u,L,R,mid+1,r,rs);
}
}
bool check(int mid) {
clear();
seg::build(1,n+n,1);

for(int i=1;i<=n+n;++i) {
int l=upper_bound(val+1,val+n+n+1,val[i]-mid)-val;
int r=lower_bound(val+1,val+n+n+1,val[i]+mid)-val-1;
seg::update(i,max(l,1),i-1,1,n+n,1);
seg::update(i,i+1,min(r,2*n),1,n+n,1);
// printf("%d -> [%d,%d]\n",i,l,i-1);
// printf("%d -> [%d,%d]\n",i,i+1,r);
}
for(int i=1;i<=2*n;++i)
if(!dfn[i])
tarjan(i);
for(int i=1;i<=2*n;i+=2)
if(belong[pos[i]]==belong[pos[i+1]]) return 0;
return 1;
}
int main() {
n=read();
for(int i=1;i<=n;++i) {
a[2*i-1].id=2*i-1,a[2*i-1].val=read();
a[2*i].id=2*i,a[2*i].val=read();
}
sort(a+1,a+1+n+n);
for(int i=1;i<=n+n;++i) pos[a[i].id]=i,val[i]=a[i].val;
int l=0,r=1e9,ans=0;
while(l<=r) {
int mid=(l+r)>>1;
if(check(mid)) l=mid+1,ans=mid;
else r=mid-1;
}
printf("%d\n",ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define mp make_pair
#define si(x) int(x.size())
const int mod=998244353,MAX=2505;
const ll INF=1LL<<60;

int sz[53];
ll msum[53];
vector<int> G[53];

void make(int u){
for(int to:G[u]){
make(to);
sz[u]+=sz[to];
msum[u]+=msum[to];
}
}

const ll D=2500;

ll dpl[53][MAX],dpr[53][MAX];

int main() {

std::ifstream in("text.txt");
std::cin.rdbuf(in.rdbuf());
cin.tie(0);
ios::sync_with_stdio(false);

ll N,X,lim;cin>>N>>X>>lim;
for(int i=0;i<N;i++){
ll m,p;cin>>m;
msum[i]=m;
sz[i]=1;
if(i){
cin>>p;p--;
G[p].push_back(i);
}
}
make(0);

vector<pair<ll,int>> S(N);
for(int i=0;i<N;i++){
S[i]=mp(msum[i],sz[i]);
}
sort(all(S),[](auto a,auto b){
return a.fi*b.se>b.fi*a.se;
});

int n=-1;
for(int i=0;i<N;i++) if(S[i].se==N) n=i;

if(lim==0){
ll can=X/S[n].fi;
cout<<can*S[n].se<<endl;
return 0;
}

for(int i=0;i<53;i++) for(int j=0;j<MAX;j++) dpl[i][j]=dpr[i][j]=INF;
dpl[0][0]=0;
for(int i=0;i<N;i++){
ll w=S[i].fi,v=S[i].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpl[i][j-k*v]!=INF) chmin(dpl[i+1][j],dpl[i][j-k*v]+w*k);
}
}
}
}
dpr[N+1][0]=0;
for(int i=N;i>=1;i--){
ll w=S[i-1].fi,v=S[i-1].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpr[i+1][j-k*v]!=INF) chmin(dpr[i][j],dpr[i+1][j-k*v]-w*k);
}
}
}
}

ll ans=0;

for(int i=n;i+1<N;i++){
ll wsum=0,vsum=0;
for(int j=i+2;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+3][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+3][b];
if(W>X) continue;
ll V=vsum+a-b;
ll can=min(lim,(X-W)/(S[i+1].fi));
chmax(ans,V+can*S[i+1].se);
}
}
}
}

{
ll wsum=0,vsum=0;
for(int j=n+1;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[n][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[n+2][b]==INF) continue;
ll W=wsum+dpl[n][a]+dpr[n+2][b];
if(W>X) continue;
ll V=vsum+a-b;
ll can=(X-W)/(S[n].fi);
chmax(ans,V+can*S[n].se);
}
}
}
}

cout<<ans<<endl;
}

#pragma GCC optimize(2)
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

struct Node {
int l, r;

bool operator < (const Node &oth) const {
return l == oth.l ? r > oth.r : l < oth.l;
}
} a[N];

int n, m;
priority_queue<int, vector<int>, greater<int> > q;
vector<int> extra;

int main() {
qread(n, m);
rep(i, 1, n) qread(a[i].l, a[i].r);
sort(a + 1, a + n + 1);
int nw = 1;
rep(i, 1, n) {
q.push(a[i].r);
if(nw <= m && nw <= a[i].l) ++nw;
else {
extra.pb(q.top());
q.pop();
}
} 
sort(all(extra), greater<int>());
int ed = m, ans = 0;
for(int x : extra) {
if(x <= ed && ed >= nw) --ed;
else ++ans;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
#define int long long

namespace Solve {
using Long = long long;
using Double = long double;

int const INF = std::numeric_limits<signed>::max();
int const NINF = std::numeric_limits<signed>::min();
Long const LINF = std::numeric_limits<Long>::max();
Long const LNINF = std::numeric_limits<Long>::min();
Double const EPS = 1e-12l;

int const LGA = 19;
int const N = 2e5 + 10;
int const K = 2;
int const MOD = 998244353;
Double const RATE = 0.45;

struct BIT {
int tree[N + 2];

void add(int x, int v) {
for (; x <= N; x += x & (-x)) {
tree[x] += v;
}
}

int get(int x) {
int res = 0;
for (; x; x -= x & (-x)) {
res += tree[x];
}

return res;
}
};

BIT bit;
Long pre[N + 1];
int a[N + 1];
int n, k;

void init() {

}

void main() {
std::cin >> n >> k;

std::vector<Long> hash { 0 };
for (int i = 1; i <= n; i++) {
std::cin >> a[i];

pre[i] = pre[i - 1] + a[i];

hash.push_back(pre[i] - 1ll * k * i);
}

std::sort(hash.begin(), hash.end());
hash.erase(std::unique(hash.begin(), hash.end()), hash.end());

for (int i = 0; i <= n; i++) {
pre[i] = std::lower_bound(hash.begin(), hash.end(), pre[i] - 1ll * k * i) - hash.begin() + 1;
}

bit.add(pre[0], 1);

Long ans = 0;
for (int i = 1; i <= n; i++) {
ans += bit.get(pre[i]);
bit.add(pre[i], 1);
}

std::cout << ans << '\n';
}

void clear() {

}
}

signed main() {
//	freopen("d.in", "r", stdin);
//	freopen("d.out", "w", stdout);

std::ios::sync_with_stdio(false);
std::cin.tie(0);
std::cout.tie(0);

//	double start = clock();

int t = 1;
//	std::cin >> t;

Solve::init();

for (; t; t--) {
Solve::main();
Solve::clear();
}

//	std::cerr << "\nTIME: " << (clock() - start) / CLOCKS_PER_SEC << '\n';

return 0;
}
#include<bits/stdc++.h>
using namespace std;
int n,tot,head[100001],dis[100001];
struct node{
int to,w,nxt;
}e[200001];
void add(int u,int v,int w){
tot++;
e[tot].to=v;
e[tot].w=w;
e[tot].nxt=head[u];
head[u]=tot;
}
priority_queue<int,vector<int>,greater<int> > q;
int main(){
memset(dis,0x7f,sizeof(dis));
cin>>n;
for(int i=0;i<n;i++){
add(i,(i+1)%n,1);
add(i,(i*10)%n,0);
}
q.push(1);
dis[1]=0;
while(!q.empty()){
int x=q.top(); q.pop();
for(int i=head[x];i;i=e[i].nxt){
int y=e[i].to,w=e[i].w;
if(dis[y]>dis[x]+w){
dis[y]=dis[x]+w;
q.push(y);
}
}
}
cout<<dis[0]+1;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define fi first
#define se second

using namespace std;
using ll = long long;
using pll = pair<ll, ll>;
using pint = pair<int, int>;
using Graph = vector<vector<ll>>;

const long long INF = 1LL << 60;
const int MOD = 1e9+7;
const int mMOD = 998244353;

template<class T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; };
template<class T> bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; };
template<class T> void printGrid(vector<vector<T>>& G, int s = 3) { for (auto y : G) { for (auto x : y) cout << left << setw(s) << x; cout << endl; } }
template<class... T> void printEnum(T... args) { for (auto e : { args... }) { cout << e << " "; } cout << endl; }
template<class T> void printVec(vector<T>& v) { for (auto e : v) cout << e << " "; cout << endl; }
void printBit(ll n) {cout << bitset<60>(n) << endl;}
int strToInt(const string& s) {return stoi(s);}
ll strToLong(const string& s) {return stoll(s);}
template<class T> void out(T a) {cout << a << endl;}
template<class T> T round_up(T a, T b) { return ((a + (b-1)) / b); } 
template<class T> T gcd(T a, T b) { if (b==0) return a; else return gcd(b, a%b); }
template<class T> T lcm(T a, T b) { if (!a || !b) return 0; else return a * b / gcd(a, b);}
ll mpow(ll a, ll b, ll m){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= m; (a *= a) %= m; b /= 2; } return ans; }
void out(double ans) {cout << fixed << setprecision(10) << ans << endl;}
void out(bool ans) { if (ans) cout << "Yes" << endl; else cout << "No" << endl;}
bool compare(const pair<int, int>& a, const pair<int, int>& b) { if (a.first != b.first) return b.first < a.first; else return a.second < b.second; }
template<int MOD> struct Fp {
long long val;
constexpr Fp(long long v = 0) noexcept : val(v % MOD) {
if (val < 0) val += MOD;
}
constexpr int getmod() { return MOD; }
constexpr Fp operator - () const noexcept {
return val ? MOD - val : 0;
}
constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }
constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }
constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }
constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }
constexpr Fp& operator += (const Fp& r) noexcept {
val += r.val;
if (val >= MOD) val -= MOD;
return *this;
}
constexpr Fp& operator -= (const Fp& r) noexcept {
val -= r.val;
if (val < 0) val += MOD;
return *this;
}
constexpr Fp& operator *= (const Fp& r) noexcept {
val = val * r.val % MOD;
return *this;
}
constexpr Fp& operator /= (const Fp& r) noexcept {
long long a = r.val, b = MOD, u = 1, v = 0;
while (b) {
long long t = a / b;
a -= t * b; swap(a, b);
u -= t * v; swap(u, v);
}
val = val * u % MOD;
if (val < 0) val += MOD;
return *this;
}
constexpr bool operator == (const Fp& r) const noexcept {
return this->val == r.val;
}
constexpr bool operator != (const Fp& r) const noexcept {
return this->val != r.val;
}
friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {
return os << x.val;
}
friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {
if (n == 0) return 1;
auto t = modpow(a, n / 2);
t = t * t;
if (n & 1) t = t * a;
return t;
}
};
using mint = Fp<mMOD>;

int main() {
int N;
cin >> N;
Graph A(N, vector<ll>(N)), dp;

for (int i = 0; i < N; ++i) {
for (int j = 0; j < N; ++j) {
int a;
cin >> a;
A[i][j] = a;
}
}

dp = A;
for (int k = 0; k < N; ++k) {
for (int i = 0; i < N; ++i) {
for (int j = 0; j < N; ++j) {
if (i==k || j==k) continue;
if (dp[i][j] > dp[i][k] + dp[k][j]) {cout << -1 << endl; return 0;}
if (dp[i][j] == dp[i][k] + dp[k][j]) A[i][j] = 0;
}
}
}

ll ans = 0;
for (auto y : A) for (auto x : y) ans += x;
ans /= 2;
cout << ans << endl;
}
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>

using namespace std;


using ll = long long;
using ld = long double;

#define X first
#define Y second

const ll mod = 1000000007;
//const ll mod = 998244353;

ll gcd(ll a, ll b)
{
a = abs(a);
b = abs(b);
if (a==0 or b==0) return a+b;
return gcd(b,a%b);
}


ll sum(ll a, ll b)
{
a += b;
a %= mod;
return a;
}

ll sub(ll a, ll b)
{
a += mod-b;
a %= mod;
return a;
}

inline ll mul(ll a, ll b)
{
if (a*b<mod) return a*b;
return a*b%mod;
}

inline ll pew(ll a, ll b)
{
ll res = 1;
while (b)
{
if (b&1) res = mul(res,a);
a = mul(a,a);
b /= 2;
}
return res;
}



/*const int MOD = 998244353;
const int root = 31;
const int root_1 = 128805723;
const int root_pw = 1<<23;
const int root = 30;
const int MOD = 469762049;
const int root_1 = 15658735;
const int root_pw = 1<<26;*/

/*
void fft (vector<int> & a, bool invert) {
int n = (int) a.size();

for (int i=1, j=0; i<n; ++i) {
int bit = n >> 1;
for (; j>=bit; bit>>=1)
j -= bit;
j += bit;
if (i < j)
swap (a[i], a[j]);
}

for (int len=2; len<=n; len<<=1) {
int wlen = invert ? root_1 : root;
for (int i=len; i<root_pw; i<<=1)
wlen = int (wlen * 1ll * wlen % mod);
for (int i=0; i<n; i+=len) {
int w = 1;
for (int j=0; j<len/2; ++j) {
int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
a[i+j] = u+v < mod ? u+v : u+v-mod;
a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
w = int (w * 1ll * wlen % mod);
}
}
}
if (invert) {
int nrev = pew(n, mod-2);
for (int i=0; i<n; ++i)
a[i] = int (a[i] * 1ll * nrev % mod);
}
}*/

/*
int parent[1200001];
int rnk[1200001];


void make_set (int v) {
parent[v] = v;
rnk[v] = 0;
}

int find_set (int v) {
if (v == parent[v])
return v;
return parent[v] = find_set(parent[v]);
}

void union_sets (int a, int b) {
a = find_set(a);
b = find_set(b);
if (a != b) {
if (rnk[a] < rnk[b])
swap(a, b);
parent[b] = a;
if (rnk[a] == rnk[b])
++rnk[a];
}
}*/




int main()
{
ios_base::sync_with_stdio(false);
ll k;
cin >> k;
ll n = 50;
vector<ll> a(n);
for (ll i=0;i<k%n;i++)
{
a[i] = n;
}
for (ll i=k%n;i<n;i++)
{
a[i] = n-k%n-1;
}
for (ll i=0;i<n;i++)
{
a[i] += k/n;
}
cout << n << "\n";
for (ll i=0;i<n;i++) cout << a[i] << " ";
}
#include "bits/stdc++.h"
using namespace std;

#define rep(i, a, b) for(int i=a; i<=b; i++)
#define all(x) begin(x), end(x)
#define sz(x) (int) x.size()
#define f first
#define s second
#define nl "\n"
#define pb push_back
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll, int> pll;
const int MOD=1e9+7;

template <ll Mod>
struct ModInt {
ll n;

ModInt(const ll x = 0) : n(x) {
while (n < 0) n += Mod;
n %= Mod;
}
explicit operator int() const { return n; }
inline constexpr ModInt operator+(const ModInt r) const noexcept { return ModInt(*this) += r; }
inline constexpr ModInt operator-(const ModInt r) const noexcept { return ModInt(*this) -= r; }
inline constexpr ModInt operator*(const ModInt r) const noexcept { return ModInt(*this) *= r; }
inline constexpr ModInt operator/(const ModInt r) const noexcept { return ModInt(*this) /= r; }
inline constexpr ModInt &operator+=(const ModInt r) noexcept {
n += r.n;
if (n >= Mod) n -= Mod;
return *this;
}
inline constexpr ModInt &operator-=(const ModInt r) noexcept {
if (n < r.n) n += Mod;
n -= r.n;
return *this;
}
inline constexpr ModInt &operator*=(const ModInt r) noexcept {
n = n * r.n % Mod;
return *this;
}
inline constexpr ModInt &operator/=(const ModInt r) noexcept { return *this *= r.inv(); }

inline constexpr ModInt pow(ll x) const noexcept {
ModInt<Mod> ret(1), tmp(*this);
while (x) {
if (x&1) ret *= tmp;
tmp *= tmp;
x >>= 1;
}
return ret;
}
inline constexpr ModInt inv() const noexcept { return pow(Mod-2); }

friend ostream& operator<<(ostream& os, const ModInt& obj) { return os << obj.n; }
friend istream& operator>>(istream& is, ModInt& obj) {
ll t;
is >> t;
obj = ModInt(t);
return is;
}
};

constexpr ll mod = 1000000007; //check!
using mi = ModInt<mod>;
mi operator"" _mi(unsigned long long n) { return mi(n); }

const int N=100001;
int n, m, s, t;
vector<pii> adj[N];

int main(){
cin.tie(0)->sync_with_stdio(0);

cin >> n >> m >> s >> t;
vector<pair<pii, int>> edges;
rep(i,1,m){
int u, v, d; cin >> u >> v >> d;
adj[u].pb({v, d});
adj[v].pb({u, d});
edges.pb({{u, v}, d});
edges.pb({{v, u}, d});
}

auto dij=[&](int start, vector<pair<ll, mi>> &dist){
fill(all(dist), make_pair(1e18, mi(0)));
priority_queue<pll, vector<pll>, greater<pll>> pq;
pq.push({0, start});
while(!pq.empty()){
auto p=pq.top(); pq.pop();
ll d=p.f, x=p.s;
if(dist[x].f<=d) continue;
dist[x].f=d;
for(auto e:adj[x]){
pq.push({d+e.s, e.f});
}
}
vector<pair<ll, int>> vec;
rep(i,1,n) vec.pb({dist[i].f, i});
sort(all(vec));
dist[start].s=1;
for(auto p:vec){
int x=p.s;
for(auto e:adj[x]){
int k=e.f;
if(dist[k].f==dist[x].f+e.s) dist[k].s+=dist[x].s; 
}
}
};

vector<pair<ll, mi>> d1(n+1), dn(n+1);
dij(s, d1); dij(t, dn);
rep(i,1,n){
// cout << "d1 " << i << ": " << d1[i].f << " " << d1[i].s << '\n';
}

mi ans=d1[t].s*d1[t].s;
rep(i,1,n){
if(d1[i].f+dn[i].f==d1[t].f && d1[i].f==dn[i].f) ans-=d1[i].s*d1[i].s*dn[i].s*dn[i].s;
}
for(auto e:edges){
int a=e.f.f, b=e.f.s;
int d=e.s;
if(d1[a].f+d+dn[b].f==d1[t].f && d1[a].f+d!=dn[b].f && dn[b].f+d!=d1[a].f && max(d1[a].f, dn[b].f)<min(d1[a].f+d, dn[b].f+d)) ans-=d1[a].s*d1[a].s*dn[b].s*dn[b].s;
}
cout << ans;
}
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e5+10;

vector<int>G[maxn];
int w[maxn];

priority_queue< pair<int,int> >Q;
bool vis[maxn];

int main(){
int n;
scanf("%d",&n);
for (int i=1;i<n;i++) {
int x,y;
scanf("%d%d",&x,&y);
G[x].push_back(y);
G[y].push_back(x);
}
for (int i=1;i<=n;i++) w[i]=-100;
int k;
scanf("%d",&k);
for (int i=1;i<=k;i++){
int x,num;
scanf("%d%d",&x,&num);
w[x]=num;
Q.push(make_pair(-num,x));
}

while(!Q.empty()){
int val=-Q.top().first;
int id=Q.top().second;
Q.pop();
vis[id]=1;
for (int i=0;i<G[id].size();i++){
int v=G[id][i];
if(w[v]==-100){
w[v]=val+1;
Q.push(make_pair(-w[v],v));
continue;
}
if(!vis[v] && w[v]!=w[id]+1){
printf("No\n");
return 0;
}
}
}
printf("Yes\n");
for (int i=1;i<=n;i++) printf("%d\n",w[i]);
return 0;
}
#include<bits/stdc++.h>
using namespace std;
int main(){
int n,sum=0;
scanf("%d",&n);
for(int i=1;i<=n;i++){
sum=sum+i;

if(sum>=n)
{
printf("%d",i);
break;
}
}
}
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define N 200010
#define ll long long
using namespace std;
char s[N];int nxt[N],k,n;
ll w[N],fib[N];
void solve(ll r,int v)
{
if(r<=n){w[r]+=v;return;}
int p=0;
for(p=0;fib[p+1]*n+fib[p]*k<r;p++);
// cerr<<fib[p]<<" "<<fib[p-1]<<" "<<r-fib[p]*n-fib[p-1]*k<<endl;
solve(r-fib[p]*n-fib[p-1]*k,v);
w[k]+=v*fib[p-1],w[n]+=v*fib[p];
}
ll ans[26];
int main()
{
scanf("%s",s+1);
n=strlen(s+1)/2;
ll l,r;scanf("%lld%lld",&l,&r);
int p=0;
fib[1]=1;
for(int i=2;fib[i-1]<=2e18;i++) fib[i]=fib[i-1]+fib[i-2];
for(int i=2;i<=n;i++)
{
while(p && s[p+1]!=s[i]) p=nxt[p];
if(s[p+1]==s[i]) p++;
nxt[i]=p;
}
k=n-p;
solve(l-1,-1);solve(r,1);
// for(int i=1;i<=n;i++) cerr<<w[i]<<" ";cerr<<endl;
for(int i=n;i>=1;i--) w[i-1]+=w[i],ans[s[i]-'a']+=w[i];
for(int i=0;i<26;i++) printf("%lld ",ans[i]);
return 0;
}
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,b) for(int i=b-1;i>=0;i--)
#define rbit(i,a) for(int i=0;i<(1<<a);i++)
typedef long long ll;
typedef long double lld;
const ll mod=998244353;
using namespace std;
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
const string zton="0123456789";
const string atoz="abcdefghijklmnopqrstuvwxyz";
ll gcd(ll a,ll b){
ll r;
r=a%b;
if(r==0){
return b;
}
else{
return gcd(b,r);
}
}
typedef pair<int,int> P;


int main(void){
int N,K;
cin >> N >> K;
map<int,int> cnt;
rep(i,0,N){
int a;cin >> a;
a--;
if(!cnt.count(a))cnt[a]=0;
cnt[a]++;
}
vector<P> ca;
for(auto p:cnt){
ca.push_back({p.second,p.first});
}
sort(ca.begin(),ca.end());
int ext=ca.size()-K;
int ans=0;
int c=0;
while(ext>=1){
P p=ca.at(c);
ans+=p.first;
c++;
ext--;
}
cout << ans << endl;


}
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
cin.tie(0)->sync_with_stdio(false);
string s; cin >> s;
for (auto &it: s) it -= '0';
int ans = (int)s.size();
for (int i = 0; i + 1 < (int)s.size(); ++i)
{
if (s[i] != s[i + 1]) ans = min(ans, max(i + 1, (int)s.size() - i - 1));
}
cout << ans << '\n';
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; --i)

int main() {
int n;
cin >> n;
vi a(n);
rep(i, n) cin >> a[i];

ll se = 0, so = 0;
for (int k = 0; k < n; k += 2) se += max(a[k], 0);
for (int k = 1; k < n; k += 2) so += max(a[k], 0);

vi ret;
int bs = -1;
for (int k = (se < so ? 1 : 0); k < n; k += 2) {
if (a[k] > 0) {
bs = k;
break;
}
}
if (bs < 0) bs = max_element(a.begin(), a.end()) - a.begin();

ll rs = a[bs];
rep(i, bs) ret.push_back(0);
for (int k = bs + 1; k < n; k += 2) {
if (k + 1 < n) {
if (a[k + 1] > 0) {
ret.push_back(1);
rs += a[k + 1];
} else {
ret.push_back(2);
if (k + 1 == n - 1) ret.push_back(1);
}
} else {
ret.push_back(1);
}
}

cout << rs << '\n';
cout << ret.size() << '\n';
rep(i, ret.size()) cout << ret[i] + 1 << '\n';
return 0;
}

#include <bits/stdc++.h>
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }
using namespace std;
using ll=long long;

int main(){
ll n,m;cin>>n>>m;
ll ans=0;
ll t;
if(n>0){
t=min(n,m/2);
ans+=t;
m-=2*t;
}
ans+=m/4;
cout<<ans<<endl;
}


#include <bits/stdc++.h>
using namespace std;

int main() {
int n;
cin >> n;

int primes[n+1];
memset(primes, 0, sizeof(primes));

for(int i=1; i<=n; i++) {
int num = i;

while(num%2==0) {
primes[2]++;
num /= 2;
}

for(int j=3; j<=sqrt(num); j+=2) {
while(num%j==0) {
primes[j]++;
num /= j;
}
}

if(num>2) primes[num]++;
}

long long div = 1;

for(int i=1; i<=n; i++) {
if(primes[i]>0){
div = div*(primes[i]+1);
}
while(div>pow(10,9)) div -= pow(10,9) + 7;
}

cout << div;
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <unordered_map>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 998244353, LOG = 301;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);

int n, D; cin >> n >> D;
vector <int> a(n), pref(n + 1), sufMin(n + 1);
for (auto& x : a) cin >> x;
pref[0] = D;
for (int i = 1; i <= n; ++i) {
pref[i] = min(pref[i - 1], abs(pref[i - 1] - a[i - 1]));
}
sufMin[n] = !pref.back();
for (int i = n - 1; i >= 0; --i) {
if (abs(sufMin[i + 1] - a[i]) >= sufMin[i + 1])
sufMin[i] = sufMin[i + 1];
else
sufMin[i] = sufMin[i + 1] + a[i];
}

int q; cin >> q;
while (q--) {
int id; cin >> id;
cout << (sufMin[id] <= pref[id - 1] ? "YES" : "NO") << '\n';
}
return 0;
}
#include <iostream>
#include <utility>
#include <vector>
#include <cmath>
#include <algorithm>
#include <unordered_set>
#include <set>
#include <queue>
#include <cmath>
#include <numeric>
#include <sstream>
#include <string>
#include <map>
#include <unordered_map>
#include <deque>
#include <iomanip>
#include <unordered_set>
#include <limits>
#include <list>
#include <bitset>
#include <random>
#include <cstring>
#include <cassert>
#include <chrono>

#define sz(v) int (v.size())
#define ff first
#define err(x) cerr << "["#x"]  " << (x) << "\n"
#define errv(x) {cerr << "["#x"]  ["; for (const auto& ___ : (x)) cerr << ___ << ", "; cerr << "]\n";}
#define errvn(x, n) {cerr << "["#x"]  ["; for (auto ___ = 0; ___ < (n); ++___) cerr << (x)[___] << ", "; cerr << "]\n";}
#define ss second
#define pb push_back
#define all(a) a.begin(),a.end()
typedef long long ll;
typedef long double ld;
using namespace std;
const int MOD = 1000000007;
mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());

template<typename T1, typename T2>
inline bool relaxmi(T1 &a, const T2 &b) {
return a > b ? a = b, true : false;
}

template<typename T1, typename T2>
inline bool relaxma(T1 &a, const T2 &b) {
return a < b ? a = b, true : false;
}

double GetTime() { return clock() / (double) CLOCKS_PER_SEC; };
/// Actual code starts here
int n, k;
const int N = 100005;

void solve() {
cin >> n >> k;
if(k == 0) {
cout << 1ll * n * n;
return;
}
ll res = 0;
for(int i = 1;i <= n;i++) {
res += 1ll * max(0, i - k) * (n / i);
res += max(0, (n % i) - k + 1);
}
cout << res;
}

signed main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
//    freopen("input.txt", "r", stdin);
int tt = 1;
//cin >> tt;
while (tt--)
solve();
}

#include <bits/stdc++.h>
using namespace std;

int main(){
int a, b, ab, x, y;
cin >> a >> b >> ab >> x >> y;

int price = 0, pmin = INT_MAX;
for(int i = 0; i <= 2*max(x,y); i+= 2){
price = max(0, x-i/2)*a + max(0, y-i/2)* b + i*ab;
pmin = min(pmin, price);
}
cout << pmin << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*
しゃくとり
*/

int main(){
cincout();

ll N;
cin >> N;
ll A[N];
rep(i, N) cin >> A[i];

ll sum = 0;
ll xr = 0;
ll j = 0;
ll add = 0;
ll ans = 0;
rep(i, N){ // tail
while (j < N){
ll nsum = sum+A[j];
ll nxr = xr^A[j];
if (nsum != nxr) break;
sum += A[j];
xr ^= A[j];
++add;
ans += add;
++j;
}
sum -= A[i];
xr ^= A[i];
--add;
}
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long

ll n;
ll a[200005];
ll sum = 0;
ll ans = 1;

ll bit(ll x, ll i) {
return (x>>i) & 1;
}

ll extandable(ll &mask, ll next) {
for(ll i = 0; i <= 31; i++) {
if (bit(mask, i) & bit(next, i)) {
return false;
}
}
return true;
}

int main() {
cin >> n;
for(ll i = 1; i <= n; i++) {
cin >> a[i];
}
sum += a[1];

ll l = 1, r = 1;
while(l <= n) {
while(r < n) {
if (r + 1 <= n && extandable(sum, a[r+1])) {
//cout << l << " " << r << " " << ans << " " << sum << endl;
r++;
ans+= r-l+1;
sum+=a[r];
}
else {
break;
}
}
//cout << l << " " << r << " " << ans << " " << sum<< endl;

sum ^= a[l];
l++;

}
ans += n - r;
cout << ans << endl;
}

#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, n) for(int i = a; i < n; i++)
#define ll long long

int main(){
ll n, m; cin >> n >> m;
if(n == 1 and m == 1) cout << 1 << endl;
else if(n == 1 or m == 1) cout << max(max(n, m)-2, 0LL) << endl;
else if(n == 2 or m == 2) cout << 0 << endl;
else cout << (n-2)*(m-2) << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 3e3 + 5;

int mod;

int Add(int x, int y)
{
return x + y >= mod ? x + y - mod : x + y;
}

int Sub(int x, int y)
{
return x - y < 0 ? x - y + mod : x - y;
}

int Mul(int x, int y)
{
return 1ll * x * y % mod;
}

int BinPow(int n, int k)
{
int ans = 1, cur = n;
while(k)
{
if(k & 1)
{
ans = Mul(ans, cur);
}
cur = Mul(cur, cur);
k >>= 1;
}
return ans;
}

int n;
int C[MAXN][MAXN], dp2[MAXN][MAXN], dp1[MAXN], pw2[MAXN];

void Init()
{
C[0][0] = 1;

for(int i = 0; i <= n; i++)
{
dp2[i][0] = 1;
}
for(int i = 1; i <= n; i++)
{
C[i][0] = 1;
for(int j = 1; j <= i; j++)
{
dp2[i][j] = Add(dp2[i - 1][j - 1], Mul(j + 1, dp2[i - 1][j]));
C[i][j] = Add(C[i - 1][j - 1], C[i - 1][j]);
}
}
pw2[0] = 1;
for(int i = 1; i <= n; i++)
{
pw2[i] = pw2[i - 1] * 2 % (mod - 1);
}
}

int main()
{
ios_base::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
cin >> n >> mod;
Init();
int ans = BinPow(2, pw2[n]);
for(int i = 1; i <= n; i++)
{
for(int j = 0; j <= i; j++)
{
dp1[i] = Add(dp1[i], Mul(dp2[i][j], BinPow(2, (n - i) * j)));
}
int tmp = Mul(dp1[i], BinPow(2, pw2[n - i]));
if(i & 1)
{
ans = Sub(ans, Mul(C[n][i], tmp));
}
else
{
ans = Add(ans, Mul(C[n][i], tmp));
}
}
cout << ans << '\n';
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
int go(vi a, int n, int sg){
int pfs = 0, ans = 0;
for(int i=0; i<n; i++){
pfs += a[i];
if(pfs == 0){
pfs += sg; ans++;
}
else if(pfs*sg < 0){
ans += abs(pfs) + 1; pfs = sg; 
}
sg*=-1;
}
return ans;
}
void solve(){ 
int n; cin>>n;
vector<int> a(n);
for(int i=0; i<n; i++)
cin>>a[i];
int ans = go(a, n, 1);
ans = min(ans, go(a, n, -1));
cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>
using namespace std;

/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, 
rb_tree_tag, tree_order_statistics_node_update>;
*/

#define MOD 1000000007
typedef long long ll;
//#define int ll 

typedef pair<int, int> ii;
typedef vector<ll> vi;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define ff first
#define ss second
#define pb push_back
#define all(s) s.begin(), s.end()
#define tc int t; cin>>t; while(t--)
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
#define file_read(x,y) freopen(x, "r", stdin); \
freopen(y, "w", stdout);
#define fightFight cin.tie(0) -> sync_with_stdio(0)
#define show_vi(a)        \
cout << #a << "-->";  \
for (auto &x : a) cout << x << " "; \
cout << endl;

int main(){
fightFight;
ll n, a, b;	
cin >> n >> a >> b;
vi arr(n);
for (auto& s : arr) cin >> s;
ll x = 0;
for (int i = 1; i < n; i++) {
x += min((arr[i] - arr[i - 1]) * a, b);
}
cout << x << "\n";
}

#include <bits/stdc++.h>
#define _GLIBCXX_DEBUG
using ll = int64_t;
using namespace std;
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)

int main() {
ll N, M, answer;
cin >> N >> M;
answer = 0;
if(M/2 < N) answer = M/2;//cがN個のSに割り当て足りないならcを使い切って終わり
else {
M -= N * 2;//Sに割り当てた分を引く
answer += N + M/4;//sccを作るにはcが4つ必要
}
cout << answer << endl;
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
vector <int> a(n), b(n), curA, curB;
for (auto& x : a) cin >> x;
for (auto& x : b) cin >> x;

int ans = 0;

for (int i = 0; i < 29; ++i) {
curA = a, curB = b;
for (auto& x : curA) x %= (1ll << (i + 1));
for (auto& x : curB) x %= (1ll << (i + 1));

sort(curB.begin(), curB.end());
int L = (1ll << i), R = (2ll << i) - 1, cnt = 0;
int L2 = (3ll << i), R2 = (4ll << i) - 2;
for (int i = 0; i < n; ++i) {
cnt += upper_bound(curB.begin(), curB.end(), R - curA[i]) -
lower_bound(curB.begin(), curB.end(), L - curA[i]);
cnt += upper_bound(curB.begin(), curB.end(), R2 - curA[i]) -
lower_bound(curB.begin(), curB.end(), L2 - curA[i]);
}
ans += (cnt & 1) * (1ll << i);
}

cout << ans << '\n';

return 0;
}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;

const int maxn = 5e5 + 10;
const int inf = 0x7ffffff;

void solve()
{
int n;
cin >> n;
vector<int> r(n + 1), c(n + 1);
for (int i = 1; i <= n;i++)
cin >> r[i];
for (int i = 1; i <= n;i++)
cin >> c[i];
int q;
cin >> q;
for (int i = 1; i <= q;i++)
{
int a, b;
cin >> a >> b;
if(r[a]+c[b] > n)
cout << "#";
else
cout << ".";
}
}

int main()
{
#ifdef BUG
freopen("in","r",stdin);
#endif
ios::sync_with_stdio(false);
cin.tie(0);
int T = 1;
//cin >> T;
while(T-- > 0)
solve();

}
#include <bits/stdc++.h>
using namespace std;

int main (){
int64_t x,y; cin>>x>>y;
int c=0;

while (x<=y){
x*=2;
c++;
}

cout<<c<<endl;
}
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <iomanip>
#include <queue>
#include <cassert>
#include <bitset>
#include <iomanip>
#include <deque>
#include <cassert>
#include <numeric>

using namespace std;

#define debug(x) cout << #x << " is " << x << '\n';
#define ld long double
#define int long long

const int mod = 1e9 + 7, N = 5e6, M = 1e13;

vector <pair <int, int>> solve(vector <int> a) {
int idMax = 0, n = a.size();
for (int i = 0; i < n; ++i)
if (a[i] > a[idMax]) idMax = i;
vector <pair <int, int>> res;
res.push_back({ idMax, n - 1 });
res.push_back({ idMax, n - 1 });
for (int i = 1; i < n; ++i) {
res.push_back({ n - 1, n - 1 });
res.push_back({ n - 1, i });
}
return res;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
int n; cin >> n;
vector <int> a(n);
for (auto& x : a) cin >> x;
vector <int> b = a;
sort(b.begin(), b.end());
vector <pair <int, int>> res;
if (-b[0] > b.back()) {
for (auto& x : a) x = -x;
reverse(a.begin(), a.end());
res = solve(a);
for (auto& x : res)
x.first = n - 1 - x.first, x.second = n - 1 - x.second;
}
else res = solve(a);
cout << res.size() << '\n';
for (auto& x : res) {
cout << x.first + 1 << ' ' << x.second + 1 << '\n';

}
cout << '\n';
return 0;
}
#include<bits/stdc++.h>
typedef long long int ll;
using namespace std;
#define sz 500007
#define sz11 5000000
#define mod 1000000007
//#define mod 998244353
#define pr1 577
#define pr2 593
#define inf 1e18
#define f first
#define s second
#define pa pair<ll,ll>
#define eps 0.0000001
#define eps1 1e-8
#define pi acos(-1.0)
#define vec pair<pa,int>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll arr[sz],brr[sz],inv[sz],factinv[sz],fact[sz];
ll ncr(ll n,ll r)
{
if(r>n || r<0)
return 0;
ll a=(factinv[r]*factinv[n-r])%mod;
return (a*fact[n])%mod;
}
//find inv and factinv,fact for 1 to n
void calculatefact(int n)
{
inv[0] = inv[1] = 1;
factinv[0]=factinv[1]=1;
fact[0]=fact[1]=1; 
for(int i = 2; i <= n; i++)
{  
inv[i] = inv[mod % i] * (mod - mod / i) %mod;
factinv[i]=(factinv[i-1]*inv[i])%mod;
fact[i]=(fact[i-1]*i)%mod;
}
}
int main()
{
//ios_base::sync_with_stdio(0);cin.tie(0);
//freopen("handle_list.txt","r",stdin);
//freopen("updated_handle_list.txt","w",stdout);
int test_case=1;
// cin>>test_case;
//scanf("%d",&test_case);
//printf("%d %d\n",'−','-');
calculatefact(sz-7);
for(int cs=1;cs<=test_case;cs++)
{
ll n;
scanf("%lld",&n);
map<ll,ll>mp;
ll gp=0;
for(int i=1;i<=n+1;i++)
{
ll a;
scanf("%lld",&arr[i]);
if(mp[arr[i]])
gp=n-i+mp[arr[i]];
mp[arr[i]]=i;
}
// printf("%lld\n",gp);
for(int i=1;i<=n;i++)
{
ll ans=(ncr(n-1,i)+2*ncr(n-1,i-1)+ncr(n-1,i-2)-ncr(gp,i-1)+mod)%mod;
printf("%lld\n",ans);
}
printf("1\n");

}
return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
typedef long long ll;

int main()
{
int n; cin >> n;
int sum = 0, i = 1;
for (; sum < n; i++) sum += i;

cout << i - 1 << endl;

return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned int ull;
typedef pair<int, int> pil;
const ll ll_INF = 0x3f3f3f3f3f3f3f3f;
const ll ll_MAX = 0x7fffffffffffffff;
const int int_INF = 0x3f3f3f3f;
const int int_MAX = 0x7fffffff;
const double EPS = 1e-7;
const double PI = acos(-1.0);
const int dy[8] = {-1, 0, 1, 0, 1, -1, 1, -1};
const int dx[8] = {0, -1, 0, 1, 1, -1, -1, 1};
#define R register
#define _max(a, b) ((a) > (b) ? (a) : (b))
#define _min(a, b) ((a) < (b) ? (a) : (b))
#define _abs(a) ((a) > 0 ? (a) : -(a))
#define _swap(a, b) ((a) ^= (b) ^= (a) ^= (b))
#define _eql(x, y) (_abs((x) - (y)) < EPS)
const int MOD = 1e9 + 7;
const int MX = 100010;
ll _r() {
ll x = 0, f = 1;
char c = getchar();
while(c > '9' || c < '0') {
if(c == '-')
f = -1;
c = getchar();
}
while(c >= '0' && c <= '9')
x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
return f == -1 ? -x : x;
}
struct Node {
int v;
int _next;
} e[MX << 1];
int n, m, head[MX], cnt = 0;
int have[MX] = {0};
void addedge(int u, int v) {
e[++cnt].v = v;
e[cnt]._next = head[u];
head[u] = cnt;
}
priority_queue<pil, vector<pil>, greater<pil> > q;
void Init() {
n = _r();
int u, v;
for(int i = 1; i < n; i++) {
u = _r(), v = _r();
addedge(u, v);
addedge(v, u);
}
for(int i = 0; i <= n; i++)
have[i] = -int_INF;
m = _r();
for(int i = 0; i < m; i++) {
u = _r(), v = _r();
have[u] = v;
q.push(make_pair(v, u));
}
}
void solve() {
int u, v;
while(!q.empty()) {
pil now = q.top();
q.pop();
u = now.second;
for(int i = head[u]; i; i = e[i]._next) {
v = e[i].v;
if(have[v] == -int_INF) {
have[v] = have[u] + 1;
q.push(make_pair(have[v], v));
}
else if(abs(have[v] - have[u]) != 1) {
printf("No\n");
return;
}
}
}
printf("Yes\n");
for(int i = 1; i <= n; i++) {
printf("%d\n", have[i]);
}
}
int main() {
std::ios::sync_with_stdio(false);
#ifdef LOCAL
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
int t = 1;
// cin>> t;
while(t--) {
Init();
solve();
}
return 0;
}
#include "bits/stdc++.h"
using namespace std;

#define rep(i, a, b) for(int i=a; i<=b; i++)
#define all(x) begin(x), end(x)
#define sz(x) (int) x.size()
#define f first
#define s second
#define nl "\n"
#define pb push_back
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
const int MOD=1e9+7;

template <ll Mod>
struct ModInt {
ll n;

ModInt(const ll x = 0) : n(x) {
while (n < 0) n += Mod;
n %= Mod;
}
explicit operator int() const { return n; }
inline constexpr ModInt operator+(const ModInt r) const noexcept { return ModInt(*this) += r; }
inline constexpr ModInt operator-(const ModInt r) const noexcept { return ModInt(*this) -= r; }
inline constexpr ModInt operator*(const ModInt r) const noexcept { return ModInt(*this) *= r; }
inline constexpr ModInt operator/(const ModInt r) const noexcept { return ModInt(*this) /= r; }
inline constexpr ModInt &operator+=(const ModInt r) noexcept {
n += r.n;
if (n >= Mod) n -= Mod;
return *this;
}
inline constexpr ModInt &operator-=(const ModInt r) noexcept {
if (n < r.n) n += Mod;
n -= r.n;
return *this;
}
inline constexpr ModInt &operator*=(const ModInt r) noexcept {
n = n * r.n % Mod;
return *this;
}
inline constexpr ModInt &operator/=(const ModInt r) noexcept { return *this *= r.inv(); }

inline constexpr ModInt pow(ll x) const noexcept {
ModInt<Mod> ret(1), tmp(*this);
while (x) {
if (x&1) ret *= tmp;
tmp *= tmp;
x >>= 1;
}
return ret;
}
inline constexpr ModInt inv() const noexcept { return pow(Mod-2); }

friend ostream& operator<<(ostream& os, const ModInt& obj) { return os << obj.n; }
friend istream& operator>>(istream& is, ModInt& obj) {
ll t;
is >> t;
obj = ModInt(t);
return is;
}
};

constexpr ll mod = 1000000007; //check!
using mi = ModInt<mod>;
mi operator"" _mi(unsigned long long n) { return mi(n); }

int s;
bool pten[10000001];
short dig[30000001];

mi bpow(int a, int b){
if(b==0) return 1;
mi x=bpow(a, b/2);
x*=x;
if(b&1) x*=a;
return x;
}

int main(){
cin.tie(0)->sync_with_stdio(0);

cin >> s;

int x=1;
while(x<=1e7){
pten[x]=1;
x*=10;
}

mi ans=0;
int sum=1;
int j=1;
int cur=1;
dig[1]=1;
for(int i=1; i<1e7; i++){
while(sum<s){
j++;
if(j<=1e7 && pten[j]) cur++;
dig[j]=cur;
sum+=cur;
}
ans+=sum==s;
sum-=dig[i];
}

ans+=s/8;

auto go=[&](int i){
int len=s/i;
// cout << 9*pten[i-1]-len << "\n";
if(i>8 || 9*(int)bpow(10, i-1)>len) ans+=(mi)9*bpow(10, i-1)-len;
};

for(int i=1; i*i<=s; i++){
if(s%i) continue;
if(i>7) go(i); if(s/i>7 && i*i!=s) go(s/i);
}
cout << ans;
}

#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>

using namespace std;


using ll = long long;
using ld = long double;

#define X first
#define Y second

const ll mod = 1000000007;
//const ll mod = 998244353;

ll gcd(ll a, ll b)
{
a = abs(a);
b = abs(b);
if (a==0 or b==0) return a+b;
return gcd(b,a%b);
}


ll sum(ll a, ll b)
{
a += b;
a %= mod;
return a;
}

ll sub(ll a, ll b)
{
a += mod-b;
a %= mod;
return a;
}

inline ll mul(ll a, ll b)
{
if (a*b<mod) return a*b;
return a*b%mod;
}

inline ll pew(ll a, ll b)
{
ll res = 1;
while (b)
{
if (b&1) res = mul(res,a);
a = mul(a,a);
b /= 2;
}
return res;
}



/*const int MOD = 998244353;
const int root = 31;
const int root_1 = 128805723;
const int root_pw = 1<<23;
const int root = 30;
const int MOD = 469762049;
const int root_1 = 15658735;
const int root_pw = 1<<26;*/

/*
void fft (vector<int> & a, bool invert) {
int n = (int) a.size();

for (int i=1, j=0; i<n; ++i) {
int bit = n >> 1;
for (; j>=bit; bit>>=1)
j -= bit;
j += bit;
if (i < j)
swap (a[i], a[j]);
}

for (int len=2; len<=n; len<<=1) {
int wlen = invert ? root_1 : root;
for (int i=len; i<root_pw; i<<=1)
wlen = int (wlen * 1ll * wlen % mod);
for (int i=0; i<n; i+=len) {
int w = 1;
for (int j=0; j<len/2; ++j) {
int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
a[i+j] = u+v < mod ? u+v : u+v-mod;
a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
w = int (w * 1ll * wlen % mod);
}
}
}
if (invert) {
int nrev = pew(n, mod-2);
for (int i=0; i<n; ++i)
a[i] = int (a[i] * 1ll * nrev % mod);
}
}*/

/*
int parent[1200001];
int rnk[1200001];


void make_set (int v) {
parent[v] = v;
rnk[v] = 0;
}

int find_set (int v) {
if (v == parent[v])
return v;
return parent[v] = find_set(parent[v]);
}

void union_sets (int a, int b) {
a = find_set(a);
b = find_set(b);
if (a != b) {
if (rnk[a] < rnk[b])
swap(a, b);
parent[b] = a;
if (rnk[a] == rnk[b])
++rnk[a];
}
}*/




int main()
{
ios_base::sync_with_stdio(false);
ll n, m;
cin >> n >> m;
vector<ll> ok(n);
for (ll i=0;i<m;i++)
{
ll a, b;
cin >> a >> b;
a--, b--;
if (a==0) ok[b] |= 1;
if (b==n-1) ok[a] |= 2;
}
for (ll i=1;i+1<n;i++)
{
if (ok[i]==3)
{
cout << "POSSIBLE\n";
return 0;
}
}
cout << "IMPOSSIBLE\n";
}
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#include<stdlib.h>
#include<queue>
#include<ctime>
#include<map>
#include<set>
#include<unordered_map>
#define mpr(a,b) make_pair(a,b)
const long long N=100005;
const long long mod=1000000007;
using namespace std;
inline long long read()
{
long long x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9')
{
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9')
{
x=(x<<1)+(x<<3)+(ch^48);
ch=getchar();
}
return x*f;
}
inline void write(long long x){
if(x<0) putchar('-'), x=-x;
if(x>9) write(x/10);
putchar(x%10+'0');
}
deque<pair<long long ,long long > > q;
long long k;
bool vis[N];
int main()
{
k = read();
q.push_back(mpr(1,1));
while(!q.empty())
{
pair<long long ,long long > now = q.front();
q.pop_front();
if(vis[now.first]) continue;
vis[now.first] = true;
if(!now.first)
{
write(now.second);
return 0;
}
q.push_front(mpr(now.first*10%k,now.second));
q.push_back(mpr((now.first+1)%k,now.second+1));
}
return 0;
}



#include <bits/stdc++.h>

using namespace std ;

const int inf = 1e9 ;
const int MAX = 1000 + 10 ;
const int MAX2 = 5000 + 10 ;

int arr[MAX] ;
int n ;

vector< vector<int> >adj(MAX) ;

pair<int , int>ans[MAX] ;
int dp[MAX][MAX2] ;

void dfs(int node)
{
for(int i = 0 ; i < MAX2 ; ++i)
dp[node][i] = inf ;
dp[node][0] = 0 ;
for(auto &child : adj[node])
{
dfs(child) ;
int a = ans[child].first , b = ans[child].second ;
for(int i = MAX2-1 ; i >= 0 ; --i)
{
if(dp[node][i] == inf)
continue ;
int d = dp[node][i] ;
dp[node][i] = inf ;
int x = min(MAX2-1 , a + i) , y = min(MAX2-1 , b + d) ;
dp[node][max(x , y)] = min(dp[node][max(x , y)] , min(x , y)) ;
x = min(MAX2-1 , a + d) , y = min(MAX2-1 , b + i) ;
dp[node][max(x , y)] = min(dp[node][max(x , y)] , min(x , y)) ;
}
}
ans[node] = {inf , inf} ;
for(int i = 0 ; i < MAX2 ; ++i)
{
if(dp[node][i] == inf || dp[node][i] > arr[node])
continue ;
pair<int , int>p ;
if(i <= arr[node] && dp[node][i] != inf)
p = {dp[node][i] , arr[node]} ;
else
p = {arr[node] , i} ;
ans[node] = min(ans[node] , p) ;
}
if(ans[node] == make_pair(inf , inf))
{
cout<<"IMPOSSIBLE\n" ;
exit(0) ;
}
}

int main()
{
ios_base::sync_with_stdio(0) ;
cin.tie(0) ;
cin>>n ;
for(int i = 2 ; i <= n ; ++i)
{
int p ;
cin>>p ;
adj[p].push_back(i) ;
}
for(int i = 1 ; i <= n ; ++i)
cin>>arr[i] ;
dfs(1) ;
return cout<<"POSSIBLE\n" , 0 ;
}		
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;
using VI = vector<int>;
using VL = vector<LL>;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;

#define SZ(a) (int)a.size()
#define ALL(a) a.begin(), a.end()
#define MP make_pair
#define PB push_back
#define EB emplace_back
#define F first
#define S second
#define FOR(i, a, b) for (int i = (a); i<(b); ++i)
#define RFOR(i, b, a) for (int i = (b)-1; i>=(a); --i)
#define FILL(a, b) memset(a, b, sizeof(a))

void dout() { cerr << endl; }

template <typename Head, typename... Tail>
void dout(Head H, Tail... T) {
cerr << H << ' ';
dout(T...);
}

int main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int n, s = 0;
cin >> n;
vector<int> a(n);
for(int& ai: a)
{
cin >> ai;
s ^= ai;
}
bool lose = !(n & 1);
for(int ai: a)
lose &= s != ai;
cout << (lose ? "Lose\n" : "Win\n");
}

#include <bits/stdc++.h>
#define int long long

namespace Solve {
using Long = long long;
using Double = long double;

int const INF = std::numeric_limits<signed>::max();
int const NINF = std::numeric_limits<signed>::min();
Long const LINF = std::numeric_limits<Long>::max();
Long const LNINF = std::numeric_limits<Long>::min();
Double const EPS = 1e-12l;

int const LGA = 19;
int const N = 2e5 + 10;
int const K = 2;
int const MOD = 998244353;
Double const RATE = 0.45;

struct BIT {
int tree[N + 2];

void add(int x, int v) {
for (; x <= N; x += x & (-x)) {
tree[x] += v;
}
}

int get(int x) {
int res = 0;
for (; x; x -= x & (-x)) {
res += tree[x];
}

return res;
}
};

BIT bit;
Long pre[N + 1];
int a[N + 1];
int n, k;

void init() {

}

void main() {
std::cin >> n >> k;

std::vector<Long> hash { 0 };
for (int i = 1; i <= n; i++) {
std::cin >> a[i];

pre[i] = pre[i - 1] + a[i];

hash.push_back(pre[i] - 1ll * k * i);
}

std::sort(hash.begin(), hash.end());
hash.erase(std::unique(hash.begin(), hash.end()), hash.end());

for (int i = 0; i <= n; i++) {
pre[i] = std::lower_bound(hash.begin(), hash.end(), pre[i] - 1ll * k * i) - hash.begin() + 1;
}

bit.add(pre[0], 1);

Long ans = 0;
for (int i = 1; i <= n; i++) {
ans += bit.get(pre[i]);
bit.add(pre[i], 1);
}

std::cout << ans << '\n';
}

void clear() {

}
}

signed main() {
//	freopen("d.in", "r", stdin);
//	freopen("d.out", "w", stdout);

std::ios::sync_with_stdio(false);
std::cin.tie(0);
std::cout.tie(0);

//	double start = clock();

int t = 1;
//	std::cin >> t;

Solve::init();

for (; t; t--) {
Solve::main();
Solve::clear();
}

//	std::cerr << "\nTIME: " << (clock() - start) / CLOCKS_PER_SEC << '\n';

return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

struct Node {
int l, r;

bool operator < (const Node &oth) const {
return l == oth.l ? r > oth.r : l < oth.l;
}
} a[N];

int n, m;
priority_queue<int, vector<int>, greater<int> > q;
vector<int> extra;

int main() {
qread(n, m);
rep(i, 1, n) qread(a[i].l, a[i].r);
sort(a + 1, a + n + 1);
int nw = 1;
rep(i, 1, n) {
q.push(a[i].r);
if(nw <= m && nw <= a[i].l) ++nw;
else {
extra.pb(q.top());
q.pop();
}
} 
sort(all(extra), greater<int>());
int ed = m, ans = 0;
for(int x : extra) {
if(x <= ed && ed >= nw) --ed;
else ++ans;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define mp make_pair
#define si(x) int(x.size())
const int mod=998244353,MAX=2505;
const ll INF=1LL<<60;

int sz[53];
ll msum[53];
vector<int> G[53];

void make(int u){
for(int to:G[u]){
make(to);
sz[u]+=sz[to];
msum[u]+=msum[to];
}
}

const ll D=2500;

ll dpl[53][MAX],dpr[53][MAX];

int main() {

std::ifstream in("text.txt");
std::cin.rdbuf(in.rdbuf());
cin.tie(0);
ios::sync_with_stdio(false);

ll N,X,lim;cin>>N>>X>>lim;
for(int i=0;i<N;i++){
ll m,p;cin>>m;
msum[i]=m;
sz[i]=1;
if(i){
cin>>p;p--;
G[p].push_back(i);
}
}
make(0);

vector<pair<ll,int>> S(N);
for(int i=0;i<N;i++){
S[i]=mp(msum[i],sz[i]);
}
sort(all(S),[](auto a,auto b){
return a.fi*b.se>b.fi*a.se;
});

int n=-1;
for(int i=0;i<N;i++) if(S[i].se==N) n=i;

if(lim==0){
ll can=X/S[n].fi;
cout<<can*S[n].se<<endl;
return 0;
}

for(int i=0;i<53;i++) for(int j=0;j<MAX;j++) dpl[i][j]=dpr[i][j]=INF;
dpl[0][0]=0;
for(int i=0;i<N;i++){
ll w=S[i].fi,v=S[i].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpl[i][j-k*v]!=INF) chmin(dpl[i+1][j],dpl[i][j-k*v]+w*k);
}
}
}
}
dpr[N+1][0]=0;
for(int i=N;i>=1;i--){
ll w=S[i-1].fi,v=S[i-1].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpr[i+1][j-k*v]!=INF) chmin(dpr[i][j],dpr[i+1][j-k*v]-w*k);
}
}
}
}

ll ans=0;

for(int i=n-1;i+1<N;i++){
ll wsum=0,vsum=0;
for(int j=i+2;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+3][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+3][b];
if(W>X) continue;
ll V=vsum+a-b;
ll can=(X-W)/(S[i+1].fi);
if(i+1!=n) chmin(can,lim);
chmax(ans,V+can*S[i+1].se);
}
}
}
}

cout<<ans<<endl;
}

#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm> 
using namespace std;
const int N=2e5+5,M=1e6+5;
struct edge{
int v,nx;
}e[M];
struct node{
int pos,id;
}a[N<<1];
int n,ne,ans,cntn,f[N],id[M];
int tot,top,cnt,dfn[N],low[N],st[N],arr[N];
bool vis[N];
bool cmp(node u,node v){
return u.pos<v.pos;
}
void read(int u,int v)
{	e[++ne].v=v;
e[ne].nx=f[u];
f[u]=ne;
}
void build(int k,int l,int r)
{	id[k]=++cntn;
if(l==r)
{	read(id[k],(a[l].id+n)%(2*n));
return;
}
int mid=(l+r)>>1;
build(k<<1,l,mid);
build(k<<1|1,mid+1,r);
read(id[k],id[k<<1]),read(id[k],id[k<<1|1]);
}
void getlk(int k,int l,int r,int x,int y,int z)
{	if(y<x)return;
int mid=(l+r)>>1;
if(l==x&&r==y)read(z,id[k]);
else if(y<=mid)getlk(k<<1,l,mid,x,y,z);
else if(x>mid)getlk(k<<1|1,mid+1,r,x,y,z);
else getlk(k<<1,l,mid,x,mid,z),getlk(k<<1|1,mid+1,r,mid+1,y,z);
}
void Tarjan(int u)
{	dfn[u]=low[u]=++tot;vis[u]=1;
st[++top]=u;
for(int i=f[u];i;i=e[i].nx)
{	int v=e[i].v;
if(!dfn[v]){Tarjan(v);low[u]=min(low[u],low[v]);}
else if(vis[v])low[u]=min(low[u],dfn[v]);
}
if(dfn[u]==low[u])
{	cnt++;
while(st[top]!=u){arr[st[top]]=cnt,vis[st[top]]=0;top--;} 
arr[st[top]]=cnt,vis[st[top]]=0;top--;
}
}
bool check(int x)
{	top=ne=tot=cnt=0,cntn=2*n;
memset(f,0,sizeof(f));
memset(dfn,0,sizeof(dfn));
memset(low,0,sizeof(low));
build(1,1,cntn);
for(int i=1;i<=2*n;i++)
{	int l=upper_bound(a+1,a+1+2*n,(node){a[i].pos-x,0},cmp)-a;
int r=upper_bound(a+1,a+1+2*n,(node){a[i].pos+x-1,0},cmp)-a-1;
getlk(1,1,2*n,l,i-1,a[i].id);
getlk(1,1,2*n,i+1,r,a[i].id);
}
for(int i=1;i<=2*n;i++)
if(!dfn[i])Tarjan(i);
for(int i=1;i<=n;i++)
if(arr[i]==arr[i+n])return 0;
return 1;
}
int main()
{	scanf("%d",&n);
for(int i=1;i<=n;i++)
{	scanf("%d%d",&a[i].pos,&a[i+n].pos);
a[i].id=i,a[i+n].id=i+n;
}
sort(a+1,a+1+n*2,cmp);
int l=0,r=a[n+n].pos-a[1].pos+1;
while(l<=r)
{	int mid=(l+r)>>1;
if(check(mid))l=mid+1,ans=mid;
else r=mid-1;
}
printf("%d\n",ans);
return 0;
}
#include <bits/stdc++.h>
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = b; i >= a; i--)
#define cat(x) cerr << #x << " = " << x << "\n";
#define sz(x) int(x.size())
using ll = long long;
using namespace std;

const int N = 500;
const int P = 1e9 + 7;

int n, k, C[N][N], res, sum;
string s;
vector<int> v;

bool check(int add) {
int a = int(v.size()) - 1;
int b = int(v.size()) - 1;
int c = 0;
rep(i, 0, k - 1) {
if (s[i] == 'r') {
if (a >= 0) a--;
else if (add) add--;
else if (c) c--;
}
else {
if (b >= 0 && a < b) c += v[b--] / 2;
else if (c) c--;
}
}
return a == -1 && b == -1 && c == 0 && add == 0;
}

void work(int times) {
for (int add = 0; 1; add++) {
if (!check(add)) 
return;
int cnt = int(v.size()) + add;
int N = n - sum - add - (cnt - 1);
int M = 3 * cnt + 1 - add + sum;
if (N >= 0 && M >= 0 && N + M - 1 >= 0) {
res = (res + 1ll * times * C[N + M - 1][N] % P * C[cnt][add] % P) % P;
}
}
}

void dfs(int x, int times) {
if (x > n) {
work(times);
return;
}
int cnt = int(v.size());
int cur = 0;
while (sum + int(v.size()) - 1 <= n) {
dfs(x + 2, 1ll * times * C[cnt + cur][cur] % P);
v.push_back(x);
sum += x;
cur++;
}
while (!v.empty() && v.back() == x) {
v.pop_back();
sum -= x;
}
}

int main() {
cin.tie(0)->sync_with_stdio(0);

rep(i, 0, N - 1) {
C[i][0] = 1;
rep(j, 1, i)
C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;
}

cin >> n >> k >> s;
dfs(1, 1);
cout << res << "\n";
return 0;
}

#include<iostream>
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC optimization ("unroll-loops")
#define ll long long int
#define pb push_back
#define mod 1000000007
#define inarr(i,arr,n); for(ll i=0;i<n;i++) cin >> arr[i];
#define outarr(i,arr,n); for(ll i=0;i<n;i++) cout<<arr[i]<<' ';
#define swap(a,b,t) {t=a;a=b;b=t;}
#define ve vector
#define all(x) x.begin(), x.end()
#define sz(a) (int)((a).size())
#define fi first
#define se second
#define pa pair
#define fastio  {ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);}
#define ll long long int
#define fr(i, a, b) for (long long int i = a; i <= b; i++)
#define frn(i, a, b) for (long long int i = a; i >= b; i--)
#define mk make_pair
#define endl "\n"
#define setvector(vname,value,size); for(int i=0;i<size;i++)vname[i]=value;
const ll inf = 1e18;
int main()
{
fastio;
ll n;
cin>>n;
ve <ll> A(n);
ve <ll> B(n);
fr(i, 0, n-1)
{
cin>>A[i]>>B[i];
}
ll ans = 0;
ll diff = ans;
fr(i, 0, n-1)
{
ans += (A[i]) * (B[i] > A[i]);
diff += (B[i] - A[i]) * (B[i] > A[i]);
}

//cout<<diff<<endl;

ll m1 = inf;
fr(i, 0, n-1)
{
if((A[i] >= B[i])&&(diff>0))
{
if(A[i] > B[i])
m1 = min(m1, B[i]);
ans += A[i];
}
}    
if(m1 != inf)
ans -= m1;
cout<<ans<<endl;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

ll n, m;

int main() {
qread(n, m);
ll ans = 1e18;
rep(i, 1, m) {
ll nw1, nw2;
if(i % 2 == 0) nw1 = nw2 = i / 2 * n;
else if(n % 2 == 0) nw1 = nw2 = n / 2 * i;
else {
if(i > n) nw1 = i / 2 * n, nw2 = nw1 + n;
else nw1 = n / 2 * i, nw2 = nw1 + i;
}
ll s = n * m - i * n;
To_min(ans, max(max(abs(nw1 - s), abs(nw2 - s)), nw2 - nw1));
}
rep(i, 1, n) {
ll nw1, nw2;
if(i % 2 == 0) nw1 = nw2 = i / 2 * m;
else if(m % 2 == 0) nw1 = nw2 = m / 2 * i;
else {
if(i > m) nw1 = i / 2 * m, nw2 = nw1 + m;
else nw1 = m / 2 * i, nw2 = nw1 + i;
}
ll s = n * m - i * m;
To_min(ans, max(max(abs(nw1 - s), abs(nw2 - s)), nw2 - nw1));
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e5 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 3005)
def(p, int, 1e9 + 7)

int n, m;
int pre[N];
string s;
int to[N];
ll dp[N][N];

int main() {
ios; cin >> n >> m;
cin >> s; s = ' ' + s + '0';
++n;
rep(i, 1, n) pre[i] = pre[i - 1] + (s[i] == '1'), to[i] = i;
rep(i, 1, m) {
int l, r;
cin >> l >> r;
To_max(to[l], r);
}
rep(i, 1, n) To_max(to[i], to[i - 1]);
dp[1][pre[to[1]]] = 1;
rep(i, 2, n) {
int nw = pre[to[i]] - pre[to[i - 1]];
rep(j, 0, to[i - 1] - i + 1) dp[i][j + nw] = (dp[i - 1][j] + dp[i - 1][j + 1]) % p; 
}
cout << dp[n][0] << endl;
return 0;
}
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
#include<memory.h>
using namespace std;
#define N 200007
int n;
int a[N];
int b[N];
int main(){


long long sum=0;
scanf("%d",&n);
for(int i=1;i<=n;i++){
scanf("%d%d",&a[i],&b[i]);
sum+=a[i];
}
long long ans=0;
for(int i=1;i<=n;i++){
if(b[i]<a[i]){
ans=max(ans,sum-b[i]);
}

}
printf("%lld",ans);
}
#include<bits/stdc++.h>
using namespace std;
int main()
{
int n;
cin>>n;
unordered_map<int,int>m;
for(int i=0;i<n;i++)
{
int a;
cin>>a;
m[a]++;
}
int sum=0;
for(auto value : m){
if(value.first!=value.second && value.first>value.second ){
sum+=value.second;
}else if(value.first!=value.second && value.first<value.second){
sum=sum+(value.second-value.first);
}
}
cout<<sum;
}
#include <bits/stdc++.h>
#define M_PI       3.14159265358979323846   // pi

using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> P;
typedef tuple<ll, ll, ll> t3;
typedef tuple<ll, ll, ll, ll> t4;
typedef tuple<ll, ll, ll, ll, ll> t5;

#define rep(a,n) for(ll a = 0;a < n;a++)

template<typename T>
static inline void chmin(T& ref, const T  value) {
if (ref > value) ref = value;
}

template<typename T>
static inline void chmax(T& ref, const T value) {
if (ref < value) ref = value;
}

#include <atcoder/all>
using namespace atcoder;
typedef modint998244353 mint;

mint mpow(mint x, ll n) {
mint ans = 1;
while (n != 0) {
if (n & 1) ans = ans * x;
x = x * x;
n = n >> 1;
}
return ans;
}

mint inv_mod(mint a) { return a.inv(); }

class Factorial {
private:
vector<mint> fac;
vector<mint> ifac;
public:

static ll raw_per(ll n, ll k) {
ll c = 1;
for (int i = 1; i <= k; i++) {
c *= (n + 1 - i);
}
return c;
}

static ll raw_cmb(ll n, ll k) {
ll c = 1;
for (int i = 1; i <= k; i++) {
c *= (n + 1 - i);
c /= i;
}
return c;
}

Factorial(ll N) {
fac.push_back(1);
for (int i = 0; i < N; i++) fac.push_back(fac[i] * (i + 1));
ifac.resize(N + 1);
ifac[N] = inv_mod(fac[N]);
for (int i = 0; i < N; i++) ifac[N - 1 - i] = (ifac[N - i] * (N - i));
}

mint fact(ll a) { return fac[a]; }
mint ifact(ll a) { return ifac[a]; }

mint cmb(ll a, ll b) {
if (a == 0 && b == 0) return 1;
if (a < b || a < 0 || b < 0) return 0;
mint tmp = ifact(a - b) * ifact(b);
return tmp * fac[a];
}
mint per(ll a, ll b) {
if (a == 0 && b == 0) return 1;
if (a < b || a < 0 || b < 0) return 0;
return fac[a] * ifac[a - b];
}
};


double solve_ave(vector<ll> as) {
int n = as.size();
double left = 0, right = 1e10;
rep(i, 128) {
double mid = left + right;
mid /= 2;
vector<double> diff(n);
rep(i, n) diff[i] = as[i] - mid;
vector<double> dp(n + 2, 0);
for (int i = n - 1; i >= 0; i--) {
dp[i] = max(dp[i + 1], dp[i + 2]) + diff[i];
}
if (dp[0] >= 0 || dp[1] >= 0) {
left = mid;
}
else {
right = mid;
}
}
return left;
}

ll solve_mid(vector<ll> as) {
int n = as.size();
ll left = 0, right = 1e10;
while(right - left > 1) {
ll mid = left + right;
mid /= 2;
vector<ll> diff(n);
rep(i, n) {
if (as[i] >= mid) diff[i] = 1;
else diff[i] = -1;
}
vector<ll> dp(n + 2, 0);
for (int i = n - 1; i >= 0; i--) {
dp[i] = max(dp[i + 1], dp[i + 2]) + diff[i];
}
if (dp[0] >= 1 || dp[1] >= 1) {
left = mid;
}
else {
right = mid;
}
}
return left;
}


int main() {
ll n;
cin >> n;
vector<ll> as(n), bs(n);
ll sum = 0;
rep(i, n) {
cin >> as[i] >> bs[i];
sum += as[i];
}
ll l = 1e15;
rep(i, n) {
if (as[i] > bs[i]) {
chmin(l, bs[i]);
}
}
if (l == 1e15) {
cout << 0 << endl;
return 0;
}
cout << sum - l << endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
ios_base::sync_with_stdio(0); cin.tie(0);
string s;
vector<string> v = {"dream", "dreamer", "erase", "eraser"};
while (cin >> s) {
int n = s.size();
while (n > 0) {
bool found = 0;
for (const auto& t : v) {
int m = t.size();
if (n-m >= 0 && s.substr(n-m, m) == t) {
found = 1;
n -= m;
break;
}
}
if (!found) {
break;
}
}
cout << (n == 0? "YES" : "NO") << '\n';
}
return 0;
}

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <utility>
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <cstdio>
#include <limits>
#include <bitset>
#define rep(i,n) for(int i = 0; i < n; ++i)
#define rep1(i,n) for(int i = 1; i <= n; ++i)
//#define rev(i,s,t) for(int i = s; i >= t; --i) 
using namespace std;
template<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }
template<class T> inline int sz(T &a) { return a.size(); }
using ll = long long; using ld = long double;
using pi = pair<int,int>; using pl = pair<ll,ll>;
using vi = vector<int>; using vvi = vector<vi>;
using vl = vector<ll>; using vvl = vector<vl>;
using PQ = priority_queue<int, vi, greater<int>>;
const int inf = numeric_limits<int>::max();
const ll infll = numeric_limits<ll>::max();
vi dx = {1, 0, -1, 0};
vi dy = {0, 1, 0, -1};
template<typename T>
struct Vec2 {
T X; T Y;
bool operator == (const Vec2& r) const { return (X == r.X && Y == r.Y); }
bool operator != (const Vec2& r) const { return !(*this == r); }
bool operator < (const Vec2& r) const { if(X == r.X) return Y < r.Y; return X < r.X; }
bool operator > (const Vec2& r) const { if(X == r.X) return Y > r.Y; return X > r.X; }
};

// Modint
// modint<MOD> で宣言
template<long long MOD>
struct modint{
long long x;
long long mod = MOD;
modint(long long x=0):x(x%MOD){}
modint& operator+=(const modint a){ if((x+=a.x)>=MOD) x-=MOD; return *this; }
modint& operator-=(const modint a){ if((x += MOD-a.x)>=MOD) x-=MOD; return *this; }
modint& operator*=(const modint a){ (x*=a.x)%=MOD; return *this; }
modint operator+(const modint a) const{ modint res(*this); return res+=a; }
modint operator-(const modint a) const{ modint res(*this); return res-=a; }
modint operator*(const modint a) const{ modint res(*this); return res*=a; }
modint pow(long long t) const{ if(!t) return 1; modint a = pow(t>>1); a*=a; if(t&1) a*=*this; return a; }
modint inv() const{ return pow(MOD-2); }
modint& operator/=(const modint a){ return (*this) *= a.inv(); }
modint operator/(const modint a) const{ modint res(*this); return res/=a; }
};
using mint = modint<1000000007>;
using mint998 = modint<998244353>;
using vm = vector<mint>;
using vmm = vector<vm>;
using vm998 = vector<mint998>;
using vmm998 = vector<vm998>;
const int NMAX=1000010; // we can calculate nCk until n is equal to NMAX
mint fact[NMAX],infac[NMAX];
void Make_Fact(){ fact[0]=fact[1]=1; for(int i=2;i<=NMAX-1;++i){ fact[i]=fact[i-1]*(mint)i;}}
void Make_InvFact(){ infac[0]=infac[1]=1; for(int i=2;i<=NMAX-1;++i){ infac[i]=infac[i-1]/(mint)i;}}
mint Comb(int n,int k){ if(n<0||k<0||n-k<0) return 0; return fact[n]*infac[k]*infac[n-k]; }

//----------------------------
// 抽象化セグ木
// 二項演算と単位元を渡して使ってね
///****例****************************
//  auto f = [&](int a,int b){ return a+b;}; // 二項演算:和
//  int id = 0; //単位元:0
//  SegTree<decltype(f),int> seg(f,id);
//************************************
//----------------------------
template <typename F,typename T>
struct SegTree{
T identity; F merge; int size; vector<T> dat; // 二項演算merge,単位元identify
SegTree(F f,T id):merge(f),identity(id){} // 二項演算fと単位元idを渡して宣言する
void init(int n){ size = 1; while(size<=n) size *= 2; dat.resize(size*2-1,identity); } // データの要素の数nを渡して初期化、sizeはnより大きい2の冪乗  
void build(vector<T> vec){ rep(i,vec.size()) dat[size-1+i] = vec[i]; dfs(0); } // 配列を渡して0(n)で初期化  
T dfs(int k){ if(k>=size-1) return dat[k]; else return dat[k] = merge(dfs(2*k+1),dfs(2*k+2)); }
// index kの要素をaに変更
void update(int k,T a){ k += size - 1; dat[k] = a; while(k > 0){ k = (k-1)/2; dat[k] = merge(dat[2*k+1],dat[2*k+2]); } } 
// index kの要素にaを加算
void add(int k,T a){ k += size - 1; dat[k] += a; while(k > 0){ k = (k-1)/2; dat[k] = merge(dat[2*k+1],dat[2*k+2]); }}
// 区間[a,b)に対するクエリに答える。(k,l,r)=(0,0,size)
T query(int a,int b,int k,int l,int r){ if(r<=a||b<=l) return identity; if(a<=l&&r<=b) return dat[k];  else return merge(query(a,b,2*k+1,l,(l+r)/2),query(a,b,2*k+2,(l+r)/2,r)); }
T query(int a,int b){ return query(a, b, 0, 0, size); }
// デバッグ用
void show(){ int index = 0; int num = 1; while(index<size){ rep(i,num){ if(dat[i+index]==identity) cout << "e "; else cout << dat[i+index] << " "; } cout << "\n"; num *= 2; index = index*2+1; }}
};

struct UFT{
vector<int> par;//親
vector<int> rank;//木の深さ
vector<int> size;//木の大きさ
int n;

UFT(int _n) { n = _n; par.resize(n); rank.assign(n,0); size.assign(n,1); rep(i,n){ par[i] = i; }}
//xの根を返す
int find(int x) { if(par[x] == x) return x; else return par[x] = find(par[x]);}
//x,yを併合
void unite(int x,int y) {
x = find(x);
y = find(y);
if(x == y) return;
if(rank[x] < rank[y]){
par[x] = y;
size[y] += size[x];
}
else{
par[y] = x;
size[x] += size[y];
if(rank[x] == rank[y]) rank[x]++;
}
}
//x,yが同じグループにいるかどうかを返す
bool same(int x,int y) { return find(x) == find(y); }
//xの属する木のサイズを探す
int usize(int x) { return size[find(x)]; }
};

//****************************************
// MaxFlow
// Graph<X> gp(n);
// gp.add_edge(from, to, capacity);
// max_flow(s, t);
//****************************************

// status of edge
template <typename X>
struct Edge{
int from, to;
int rev;  //逆辺
X cap; // 容量

Edge() = default;

Edge(int from, int to, int rev, X cap) : from(from), to(to), rev(rev), cap(cap) {}
};

// status of node
template <typename X>
struct Node{ 
int idx;
vector<Edge<X>> edge;
//map<int,int> idtable; // map[to] = val: node[idx]からnode[to]に出るedgeのindexを返す

Node() = default;

explicit Node(int idx) : idx(idx) {}
};

template <typename X>
class Graph{
private:
int n; // number of node
int m; // number of edge
vector<Node<X>> node; 
X inf = numeric_limits<X>::max();

void Init_Node() {
rep(i,n) node.emplace_back(i);
}
public:
explicit Graph(int n) : n(n) {
Init_Node();
}

// 容量cap の辺を追加
void add_edge(int from, int to, X cap) { 
node[from].edge.emplace_back(from, to, node[to].edge.size(), cap);
//  node[from].idtable[to] = node[from].edge.size() - 1;
node[to].edge.emplace_back(to, from, node[from].edge.size() - 1, 0);
//    node[to].idtable[from] = node[to].edge.size() - 1;    
}

// from->toの辺(Edge<>)を返す
// Edge<X> get_edge(int from, int to) {
//   return node[from].edge[node[from].idtable[to]];
// }

// s->tの最大流
X max_flow(int s, int t) {
vi level(n);
vi iter(n);
auto bfs = [&]() {
level.assign(n, -1);
queue<int> q;
level[s] = 0;
q.push(s);
while( !q.empty() ) {
int v = q.front(); q.pop();
for(auto next: node[v].edge) {
if(next.cap > 0 && level[next.to] < 0) {
level[next.to] = level[v] + 1;
q.push(next.to);
}
}
}

};


auto dfs = [&](auto func, int v, X f) {
if(v == t) return f;
for(int &i = iter[v]; i < node[v].edge.size(); ++i) {
Edge<X> &e = node[v].edge[i];
if(e.cap > 0 && level[v] < level[e.to]) {
X d = func(func, e.to, min(f, e.cap));
if(d > 0) {
e.cap -= d;
node[e.to].edge[e.rev].cap += d;
return d;
}
}
}
return (X)0;
};

// main
X flow = 0;
for(;;) {
bfs();
if(level[t] < 0) return flow;
iter.assign(n, 0);
X f;
while((f = dfs(dfs, s, inf)) > 0) {
flow += f;
}
}
}

};

void Solve(){
int h,w; cin >> h >> w;
vector<string> s(h);
rep(i,h) {
cin >> s[i];
}
Graph<int> gp(h*w*2);
int st,go;
rep(i,h) {
vi tmp;
rep(j,w) {
if(s[i][j] != '.') {
tmp.push_back(i*w+j);
gp.add_edge(i*w+j, i*w+j+h*w, 1);
}
if(s[i][j] == 'S') st = i*w+j + h*w;
if(s[i][j] == 'T') go = i*w+j;
}
rep(j,sz(tmp)) {
rep(k,sz(tmp)) {
if(j == k) continue;
gp.add_edge(tmp[j]+h*w, tmp[k], inf/2);
}
}
}
rep(i,w) {
vi tmp;
rep(j,h) {
if(s[j][i] != '.') {
tmp.push_back(j*w+i);
}
}
rep(j,sz(tmp)) {
rep(k,sz(tmp)) {
if(j == k) continue;
gp.add_edge(tmp[j]+h*w, tmp[k], inf/2);
}
}
}
int res = gp.max_flow(st, go);
cout << (res >= inf/2 ? -1 : res) << "\n";

}
int main()
{
Solve();
return 0;
}

#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
map<LL, unordered_map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ihacoy ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
ll gcd(ll a, ll b) {
if(a==0) return b;
return gcd(b%a, a);
}
ll lcm(ll a, ll b) {
ll ans=a*b;
ans=ans/(gcd(a, b));
return ans;
}
#define dh << endl;
#define co cout <<
#define udh cout << '\n';
#define ci cin >>
#define fi first
#define se second
#define sp << " " <<
#define tes while(t--)
#define pb push_back
#define pf push_front
#define pob pop_back()
#define pof pop_front()
#define pll pair<ll, ll>
#define psl pair<string, ll>
#define mll map<ll, ll>
#define msl map<string, ll>
#define vec vector<int>
#define vecl vector<ll>
#define deq deque<ll>
#define gre greater<ll>()
#define sip return 0
#define str string
#define mp make_pair
#define ub upper_bound
#define lb lower_bound
#define bs binary_search
#define pq priority_queue<ll>
#define pqm priority_queue<ll, vector<ll>, greater<ll>>
int n, ti, cek, cekt;
bool bisa=true;
int main() {
ci n;
int t[n+1], x[n+1], y[n+1];
t[0]=0;
x[0]=0;
y[0]=0;
for(int i=1; i<=n; i++) {
ci t[i] >> x[i] >> y[i];
}
for(int i=1; i<=n; i++) {
cek=abs(x[i]-x[i-1])+abs(y[i]-y[i-1]);
cekt=t[i]-t[i-1];
if(cek%2+cekt%2==1 || cek>cekt) {
bisa=false;
break;
}
}
if(bisa) co "Yes";
else co "No";
}
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long int
#define pb push_back
const int N =1e6+7;
ll arr[N];
int main()
{
ios_base::sync_with_stdio(false);
cin.tie(NULL);
ll i, j, k,z, l,f,n,m, p,q,r, sum,x1,y1,g,x,y,ans,mx,mn,d,h,t;

cin>>arr[0]>>arr[1]>>arr[2];
sort(arr,arr+3);

if(arr[0]%2==arr[1]%2&&arr[1]%2==arr[2]%2)
{
cout<<(2*arr[2]-arr[0]-arr[1])/2<<endl;
}
else
{
//  cout<<arr[0]<<" "<<arr[1]<<" "<<arr[2]<<endl;
for(j=0;j<3;j++)
{
if(arr[j]%2==arr[(j+1)%3]%2)
{
arr[j]++;
arr[(j+1)%3]++;
break;
}
}
cout<<1+(2*arr[2]-arr[0]-arr[1])/2<<endl;

}




return 0;
}
/*
g++ -O2 --std=c++17 -D LOCAL A.cpp
*/

#include <iostream>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <functional> 
#include <string>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

typedef long long LL;

#ifdef LOCAL
#define dlog(x) { cerr << '[' << __LINE__ << "] " << x << endl; }
#define dvar(v) { cerr << '[' << __LINE__ << "] " << #v << " = " << v << endl; }
#define dvec(c) { cerr << '[' << __LINE__ << "] " << #c << " = "; for (int i = 0; i < c.size(); ++i) if (i == 0) cerr << '['<<i<<']'<<c[i]; else cerr << " ["<<i<<']'<<c[i]; cerr << endl; } 
#define dmap(m) { cerr << '[' << __LINE__ << "] " << #m << " = "; for (auto it: m) cerr << it.first << "=>" << it.second << ' '; cerr << endl; }
#define dset(s) { cerr << '[' << __LINE__ << "] " << #s << " = "; for (auto item: s) cerr << item << ' '; cerr << endl; }
#else
#define dlog(x)
#define dvar(v)
#define dvec(c)
#define dmap(m)
#define dset(s)
#endif

#define rep(i,n) for (int i = 0; i < int(n); ++i)
#define repr(i,from,to) for (int i = int(from); i <= int(to); ++i)
#define rrep(i,n) for (int i = (n)-1; 0 <= i; --i)
#define rrepr(i,from,to) for (int i = int(from); int(to) <= i; --i)
#define endl '\n'

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

#define dump(c) { for (auto it = c.begin(); it != c.end(); ++it) if (it == c.begin()) cout << *it; else cout << ' ' << *it; cout << endl; } 

typedef pair<int, int> P;
typedef pair<LL, LL> LP;
#ifndef F
#define F first
#define S second
#endif 


template<typename T1, typename T2>
ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
return os << p.F << ':' << p.S;
}


/*
== AC Library Cheat sheet
documentation: file:///Users/nobu/Downloads/ac-library/document_ja/index.html

mint
mint m.pow(int p)  //! return m^p
mint m.inv() //! returns i that gives (m * i).val() == 1 
int m.val() 

fenwick_tree (BIT)
fenwick_tree<T> fw(int n) //! init a[0] .. a[n-1] with all 0
void fw.add(int idx, T x); //! a[idx] += x
T fw.sum(int l, int r); //! return a[l] + .. + a[r-1]

dsu (UnionFind)
dsu d(int n)  //! prepare dsu with n nodes
void d.merge(int x, int y)  //! connect node x and y
bool d.same(int x, int y)  //! return true if node x and y are connected
int d.leader(int x)  //! return the leader node of the connected group
int d.size(int x) //! return the size of the group that node x belongs to
vector<vector<int>> d.groups() //! return a vector of vectors that contain the nodes in each group

scc_graph
scc_graph　g(int n)  //! create a directed graph with n nodes
g.add_edge(int from, int to)  //! create a directed edge from node from to node to
vector<vector<int>> g.scc()  //! return the vector of strongly connected components that are topologically sorted

segtree
segtree<S, op, e>
S: type of the monoid 
op: function to return the product of two elements
e: function to return the identity element such that op(x, e) == x fo any x 

lazy_segtree
lazy_segtree<S, op, e, F, mapping, composition, id>
F: type of parameters to define the operation applied to the target elements
mapping: function to return the element after applying the operation to the target element
composition: function to combine the two sets of operation parameters to one
id: function to return the operation parameter i such that mapping(i, x) = x for any x

using S = int;
S op(S a, S b) { return min(a, b); }
S e() { return INF; }
using F = int;
S mapping(F f, S x) { return min(f, x); }
F composition(F f, F g) { return min(f, g); }
F id() { return INF; }

*/

// int dx[] = { 0, -1, 1, 0 };
// int dy[] = { -1, 0, 0, 1 };

// int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 };
// int dy[] = { -1, -1, -1, 0, 0, 1, 1, 1 };

const int INF = 1e9+1e4;
const LL INFL = 1e18+1e9;
const int MOD = 1000000007;

#define USE_ACL
#ifdef USE_ACL

#include <atcoder/all>
using namespace atcoder;

using mint = static_modint<MOD>;

struct combination {
vector<mint> fact, ifact;
combination(int n):fact(n+1),ifact(n+1) {
assert(n < MOD);
fact[0] = 1;
for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;
ifact[n] = fact[n].inv();
for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;
}
mint operator()(int n, int k) {
if (k < 0 || k > n) return 0;
return fact[n]*ifact[k]*ifact[n-k];
}
};

ostream& operator<<(ostream& os, const mint& i) {
return os << i.val();
}

#endif


int main()
{
cin.tie(0);
ios::sync_with_stdio(0);
cout << setprecision(20);

int n;
cin >> n;
vector<int> a(n);
rep(i, n) cin >> a[i];
vector<LL> s(n);
map<int, P> mp; //! value -> { count, left-most-index };
rrep(i, n) {
++mp[a[i]].F;
mp[a[i]].S = i;
}
dmap(mp);
while (!mp.empty()) {
auto it = mp.end(); --it;
int v = it->F;
int cnt = it->S.F;
int lft = it->S.S;
mp.erase(it);
if (mp.empty()) {
s[lft] += (LL)v * cnt;
} else {
it = mp.end(); --it;
s[lft] += (LL)(v-it->F) * cnt;
it->S.F += cnt;
chmin(it->S.S, lft);
}
}
rep(i, n) cout << s[i] << endl;

cout << flush;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define mp make_pair
#define si(x) int(x.size())
const int mod=998244353,MAX=2505;
const ll INF=1LL<<60;

int sz[53];
ll msum[53];
vector<int> G[53];

void make(int u){
for(int to:G[u]){
make(to);
sz[u]+=sz[to];
msum[u]+=msum[to];
}
}

const ll D=2500;

ll dpl[53][MAX],dpr[53][MAX];

int main() {

std::ifstream in("text.txt");
std::cin.rdbuf(in.rdbuf());
cin.tie(0);
ios::sync_with_stdio(false);

ll N,X,lim;cin>>N>>X>>lim;
for(int i=0;i<N;i++){
ll m,p;cin>>m;
msum[i]=m;
sz[i]=1;
if(i){
cin>>p;p--;
G[p].push_back(i);
}
}
make(0);

vector<pair<ll,int>> S(N);
for(int i=0;i<N;i++){
S[i]=mp(msum[i],sz[i]);
}
sort(all(S),[](auto a,auto b){
return a.fi*b.se>b.fi*a.se;
});

int n=-1;
for(int i=0;i<N;i++) if(S[i].se==N) n=i;

if(lim==0){
ll can=X/S[n].fi;
cout<<can*S[n].se<<endl;
return 0;
}

for(int i=0;i<53;i++) for(int j=0;j<MAX;j++) dpl[i][j]=dpr[i][j]=INF;
dpl[0][0]=0;
for(int i=0;i<N;i++){
ll w=S[i].fi,v=S[i].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpl[i][j-k*v]!=INF) chmin(dpl[i+1][j],dpl[i][j-k*v]+w*k);
}
}
}
}
dpr[N+1][0]=0;
for(int i=N;i>=1;i--){
ll w=S[i-1].fi,v=S[i-1].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0){
if(dpr[i+1][j-k*v]!=INF) chmin(dpr[i][j],dpr[i+1][j-k*v]-w*k);
}
}
}
}

ll ans=0;

for(int i=n;i<N;i++){
if(i+1<N){
ll wsum=0,vsum=0;
for(int j=i+2;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+3][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+3][b];
if(W>X) continue;
ll V=vsum+a-b;
ll can=min(lim,(X-W)/(S[i+1].fi));
chmax(ans,V+can*S[i+1].se);
}
}
}

}
{
ll wsum=0,vsum=0;
for(int j=i+1;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+2][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+2][b];
if(W>X) continue;
ll V=vsum+a-b;
chmax(ans,V);
}
}
}
}
}

{
ll wsum=0,vsum=0;
for(int j=n+1;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[n][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[n+2][b]==INF) continue;
ll W=wsum+dpl[n][a]+dpr[n+2][b];
if(W>X) continue;
ll V=vsum+a-b;
ll can=(X-W)/(S[n].fi);
chmax(ans,V+can*S[n].se);
}
}
}
}

cout<<ans<<endl;
}

#include<bits/stdc++.h>
using namespace std;
#define re register
#define int long long
const int N=410,M=1e5+10,inf=0x7fffffff;

namespace MaxFlow{
int tot=1,head[N],cur[N],d[N];
int maxflow;
struct{int next,to,val;}edge[M];
inline void addedge(int from,int to,int val) {
edge[++tot].next=head[from]; edge[tot].to=to;edge[tot].val=val;head[from]=tot;
edge[++tot].next=head[to];edge[tot].to=from;edge[tot].val=0;head[to]=tot;
}

inline bool bfs(int s,int t){
memset(d,0,sizeof(d)); queue<int>q;
q.push(s); d[s]=1; cur[s]=head[s];
while(!q.empty()){
int u=q.front(); q.pop();
for(re int i=head[u];i;i=edge[i].next){
int v=edge[i].to;
if(edge[i].val&&!d[v]) cur[v]=head[v],d[v]=d[u]+1,q.push(v);
}
}
return d[t];
}

int dfs(int u,int in,int t){
if(u==t||in==0) return in;
int out=0;
for(re int i=cur[u];i&&in;i=edge[i].next){
cur[u]=i; int v=edge[i].to;
if(edge[i].val&&d[v]==d[u]+1){
int res=dfs(v,min(edge[i].val,in),t);
edge[i].val-=res,in-=res,edge[i^1].val+=res,out+=res;
if(in==0) break;
}
}
if(out==0) d[u]=0;
return out;
} 

inline void init(){tot=1, maxflow=0,memset(head,0,sizeof(head));}

inline void dinic(int s,int t){while(bfs(s,t)) maxflow+=dfs(s,inf,t);} 
}
using namespace MaxFlow;

inline int read(){
int x=0,f=1;char ch=getchar();
while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
return x*f;
}

const int _N=110;
int a[_N];

signed main(){
int n=read(),s=0,t=n+1,sum=0;
for(re int i=1;i<=n;++i) a[i]=-read();
for(re int i=1;i<=n;++i)
for(re int j=2;i*j<=n;++j)
addedge(i,i*j,inf);
for(int i=1;i<=n;++i){
if(a[i]>0) addedge(s,i,a[i]);
else addedge(i,t,-a[i]),sum-=a[i];
}
dinic(s,t);
cout<<sum-maxflow;
return 0;
}
/*       code by the cute PixelCat owo       */
/*   as cute as nacho neko (aka. my wife)!   */
//#pragma GCC optimize("O4,unroll-loops,no-stack-protector")
#include <bits/stdc++.h>
#define int LL  //__int128
#define double long double
using namespace std;
using LL = long long;
using uLL = unsigned long long;
using pii = pair<LL, LL>;

#define For(i, a, b) for (int i = a; i <= b; i++)
#define Fors(i, a, b, s) for (int i = a; i <= b; i += s)
#define Forr(i, a, b) for (int i = a; i >= b; i--)
#define F first
#define S second
#define L(id) (id * 2 + 1)
#define R(id) (id * 2 + 2)
#define LO(x) (x & (-x))

#define eb emplace_back
#define all(x) x.begin(), x.end()
#define sz(x) ((int)x.size())
#define mkp make_pair

#define MOD (LL)(998244353)
#define INF (LL)(9000'000'000'000'000'000)  // 9e18
#define EPS (1e-6)

#ifdef NYAOWO
#include "debug.hpp"
inline void USACO(const string &s) {
cerr << "USACO: " << s << "\n";
}
#else
#define debug(...)
inline void timer() {}
inline void USACO(const string &s) {
freopen((s + ".in").c_str(), "r", stdin);
freopen((s + ".out").c_str(), "w", stdout);
}
#endif

inline void NYA() {
ios::sync_with_stdio(false);
cin.tie(0);
}
inline int gcd(int a, int b) {
return __gcd(a, b);
}
inline int lcm(int a, int b) {
return a / gcd(a, b) * b;
}
int fpow(int b, int p, const int &mod) {
int ans = 1;
while (p) {
if (p & 1) ans = ans * b % mod;
p /= 2;
b = b * b % mod;
}
return ans;
}
int fpow(int b, int p) {
return fpow(b, p, MOD);
}
template <typename T>
inline void chmin(T &_a, const T &_b) {
if (_b < _a) _a = _b;
}
template <typename T>
inline void chmax(T &_a, const T &_b) {
if (_b > _a) _a = _b;
}
// mt19937_64 rng(
//     chrono::steady_clock::now().time_since_epoch().count());

struct BIT {
int n;
int a[200020];
void init(int _n) {
n = _n;
memset(a, 0, sizeof(a));
}
void add(int i, int x) {
while (i <= n) {
a[i] += x;
i += LO(i);
}
}
int ask(int i) {
int ans = 0;
while (i) {
ans += a[i];
i -= LO(i);
}
return ans;
}
} bit;

int a[200020];

int32_t main() {
NYA();
// nyaacho >/////<
// miku sama bless me >/////<
int n, k;
cin >> n >> k;
vector<int> al(1, 0);
For(i, 1, n) {
cin >> a[i];
a[i] -= k;
a[i] += a[i - 1];
al.eb(a[i]);
debug(i, a[i]);
}
sort(all(al));
al.erase(unique(all(al)), al.end());
auto pos = [&](int x) {
return upper_bound(all(al), x) - al.begin();
};
bit.init(n + 1);
bit.add(pos(0), 1);
int ans = 0;
For(i, 1, n) {
ans += bit.ask(pos(a[i]));
bit.add(pos(a[i]), 1);
debug(i, a[i], pos(a[i]));
}
cout << ans << "\n";
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int h, w;
cin >> h >> w;

vector<string> c(h);
for (auto& ci : c) {
cin >> ci;
}

array<pair<int, int>, 4> d \
= {{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}};

auto can_fill = [&] (int i, int j, int k) {
for (auto [di, dj] : d) {
if (0 <= i + di && i + di < h &&
0 <= j + dj && j + dj < w &&
c[i + di][j + dj] == '0' + k) {
return false;
}
}

return true;
};

for (int i = 0; i < h; ++i) {
for (int j = 0; j < w; ++j) {
if (c[i][j] == '.') {
for (int k = 1; k <= 5; ++k) {
if (can_fill(i, j, k)) {
c[i][j] = '0' + k;
}
}
}
}
}

for (auto ci : c) {
cout << ci << "\n";
}

return 0;
}

#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair <int, ll>;
using pll = pair <ll, ll>;

#define FIO() ios_base::sync_with_stdio(0);cin.tie(NULL);
const int mx = 1e5 + 9;

struct edge {
int u, v;
ll w;

};

bool operator<(edge e1, edge e2) {
return e1.w < e2.w;
}

int par[mx];
vector <pii> adj[mx], mst[mx];
vector <edge> edges;

int fnd(int x) {
if (x == par[x]) return x;
return par[x] = fnd(par[x]);
}


int main() {
FIO();

ll n;
cin >> n;
vector<pair<ll, ll>>xx;
vector<pair<ll, ll>>yy;

for(ll i = 0; i <= n; i++) par[i] = i;
for(ll i = 0; i < n; i++) {
ll x, y;
cin >> x >> y;
xx.push_back({x, i});
yy.push_back({y, i});
}

sort(xx.begin(), xx.end());
sort(yy.begin(), yy.end());

for(ll i = 0; i < n - 1; i++) {
edges.push_back({xx[i].second, xx[i + 1].second, abs(xx[i].first - xx[i + 1].first)});
edges.push_back({yy[i].second, yy[i + 1].second, abs(yy[i].first - yy[i + 1].first)});

}

sort(edges.begin(), edges.end());

ll total_wt = 0;
for (auto e : edges) {
int u = e.u, v = e.v;
ll w = e.w;
int pu = fnd(u), pv = fnd(v);
if (pu == pv) continue;

par[pu] = pv;
total_wt += w;
mst[u].emplace_back(v, w);
mst[v].emplace_back(u, w);
}

cout << total_wt << '\n';

}

#include <bits/stdc++.h>
#include <cstdlib> 
using namespace std;

int main() {
int N, K, i, C = 300000001, M, L;
cin >> N >> K;
vector<int> x(N);
for (i = 0; i < N; i++)
cin >> x[i];
for (i = 0; i <= N - K; i++) {
if (x[i] < 0 && 0 < x[i + K - 1]) {
M = min(-x[i], x[i + K - 1]) * 2 + max(-x[i], x[i + K - 1]);
C = min(M, C);
}
else {
M = max(abs(x[i]), abs(x[i + K - 1]));
C = min(M, C);
}
}
cout << C;
}
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,tot,head[maxn],dis[maxn];
struct node{
int to,w,nxt;
}edge[maxn<<1];
void add(int u,int v,int w){
edge[++tot].to=v;
edge[tot].w=w;
edge[tot].nxt=head[u];
head[u]=tot;
}
priority_queue<int,vector<int>,greater<int> > q;
int main(){
memset(dis,0x7f,sizeof(dis));
scanf("%d",&n);
for(register int i=0;i<n;i++){
add(i,(i+1)%n,1);
add(i,(i*10)%n,0);
}
q.push(1);
dis[1]=0;
while(!q.empty()){
int x=q.top(); q.pop();
for(register int i=head[x];i;i=edge[i].nxt){
int y=edge[i].to,w=edge[i].w;
if(dis[y]>dis[x]+w){
dis[y]=dis[x]+w;
q.push(y);
}
}
}
printf("%d\n",dis[0]+1);
return 0;
}
#include <stdio.h>
const int maxn = 2e5 + 10;
int a[maxn];
long long sum[maxn];

long long myabs(long long x)
{
return  x > 0 ? x : -x;
}
int main()
{
int n;
scanf("%d", &n);

for (int i = 0; i < n; i++) {
scanf("%d", &a[i]);

if(i == 0) {
sum[i] = a[i];
} else {
sum[i] = sum[i - 1] + a[i];
}
}

long long ans = 1e15;

for (int i = 0; i < n - 1; i++) {
long long tmp = myabs(sum[i] - (sum[n - 1] - sum[i]));

//printf("t = %lld\n", tmp);
if (tmp  < ans) ans = tmp;
}

printf("%lld\n", ans);
return 0;
}

#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>

using namespace std;


using ll = long long;
using ld = long double;

#define X first
#define Y second

const ll mod = 1000000007;
//const ll mod = 998244353;

ll gcd(ll a, ll b)
{
a = abs(a);
b = abs(b);
if (a==0 or b==0) return a+b;
return gcd(b,a%b);
}


ll sum(ll a, ll b)
{
a += b;
a %= mod;
return a;
}

ll sub(ll a, ll b)
{
a += mod-b;
a %= mod;
return a;
}

inline ll mul(ll a, ll b)
{
if (a*b<mod) return a*b;
return a*b%mod;
}

inline ll pew(ll a, ll b)
{
ll res = 1;
while (b)
{
if (b&1) res = mul(res,a);
a = mul(a,a);
b /= 2;
}
return res;
}



/*const int MOD = 998244353;
const int root = 31;
const int root_1 = 128805723;
const int root_pw = 1<<23;
const int root = 30;
const int MOD = 469762049;
const int root_1 = 15658735;
const int root_pw = 1<<26;*/

/*
void fft (vector<int> & a, bool invert) {
int n = (int) a.size();

for (int i=1, j=0; i<n; ++i) {
int bit = n >> 1;
for (; j>=bit; bit>>=1)
j -= bit;
j += bit;
if (i < j)
swap (a[i], a[j]);
}

for (int len=2; len<=n; len<<=1) {
int wlen = invert ? root_1 : root;
for (int i=len; i<root_pw; i<<=1)
wlen = int (wlen * 1ll * wlen % mod);
for (int i=0; i<n; i+=len) {
int w = 1;
for (int j=0; j<len/2; ++j) {
int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
a[i+j] = u+v < mod ? u+v : u+v-mod;
a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
w = int (w * 1ll * wlen % mod);
}
}
}
if (invert) {
int nrev = pew(n, mod-2);
for (int i=0; i<n; ++i)
a[i] = int (a[i] * 1ll * nrev % mod);
}
}*/

/*
int parent[1200001];
int rnk[1200001];


void make_set (int v) {
parent[v] = v;
rnk[v] = 0;
}

int find_set (int v) {
if (v == parent[v])
return v;
return parent[v] = find_set(parent[v]);
}

void union_sets (int a, int b) {
a = find_set(a);
b = find_set(b);
if (a != b) {
if (rnk[a] < rnk[b])
swap(a, b);
parent[b] = a;
if (rnk[a] == rnk[b])
++rnk[a];
}
}*/




int main()
{
ios_base::sync_with_stdio(false);
ll n;
cin >> n;
vector<ll> a(n);
for (ll i=0;i<n;i++)
{
cin >> a[i];
}
ll L = 0, R = mod*mod;
while (R-L>1)
{
ll S = 0;
ll M = (R+L)/2;
for (ll i=0;i<n;i++)
{
S += (a[i]+M)/(n+1);
}
if (S>=M) L = M;
else R = M;
}
for (ll M=max(R-n*n,1LL);M<=R;M++)
{
ll S = 0;
for (ll i=0;i<n;i++)
{
S += (a[i]+M)/(n+1);
}
if (S<M)
{
cout << M-1 << endl;
return 0;
}
}
}
#include <bits/stdc++.h>
using namespace std;
int main(){
int n;
cin >> n;
vector<vector<int>> vec(2,vector<int>(n));
for(int i=0;i<n;i++){
cin >> vec[0][i];
}
for(int i=0;i<n;i++){
cin >> vec[1][i];
}
vector<vector<int>> dp(3,vector<int>(n+1,0));
for(int i=1;i<=2;i++){
for(int j=1;j<=n;j++){
if(i==1&&j==1){
dp[i][j]=vec[0][0];
}
else{
dp[i][j]=max(dp[i][j-1],dp[i-1][j])+vec[i-1][j-1];
}
}
}
cout << dp[2][n] << endl;
}
#include<bits/stdc++.h>
using namespace std;
long long a[500500],b[500500],n,i,j,k=0,x;
int main()
{
scanf("%lld",&x);
for(i=1;i<=x;i++){
k+=i;
if(k>=x){
printf("%lld",i);
break;
}
}
return 0;}
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 2e5 + 10;
int a[N];

int main() {
int n,sum=0;
cin >> n;
for (int i = 1; i <= n; i++) {
sum += i;
if (sum >= n) {
printf("%d", i);
break;
}
}
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000000007

ll freq[100005];

ll fact[100005];

ll f(ll n)
{
if(fact[n])
return fact[n];
if(n == 0 || n == 1)
return 1;

fact[n] = (n*f(n-1))%mod;
return fact[n];
}

ll bigmod(ll b, ll p)
{
if(p == 0)
return 1;
if(p == 1)
return b%mod;

ll res = bigmod(b, p>>1);
res = (res*res)%mod;
if(p&1)
return (b*res)%mod;
return res;
}

ll invmod(ll b)
{
return bigmod(b, mod-2);
}

ll nCr(ll n, ll r)
{
if(n < r)
return 0;
return ((f(n) * invmod(f(r)))%mod * invmod(f(n-r)))%mod;
}

int main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

int n, a, i, k, x, y;

cin >> n;

for(i = 1; i <= n+1; i++)
{
cin >> a;

if(freq[a] != 0)
{
x = freq[a];
y = i;
}

freq[a] = i;
}

for(k = 1; k <= n+1; k++)
cout << ((nCr(n+1, k) - nCr(x-1 + n+1-y, k-1))%mod + mod)%mod << "\n";
}

#include <iostream>
#include <vector> 

int main()
{
int N,K;
std::cin >> N >> K;

int A;
int currentinttype=0;
std::vector<int> Alist(N,0);
std::vector<int> count(N,0);
for(int i = 0; i<N; i++){
std::cin >> A;
if(Alist[A-1]==0){
currentinttype += 1;
Alist[A-1] += 1;
count[Alist[A-1]-1] += 1;
}else{
count[Alist[A-1]-1] -= 1;
Alist[A-1] += 1;
count[Alist[A-1]-1] += 1;
}
}

int result=0;
int deleteinttype=0;
if(currentinttype<K){
std::cout << 0 << std::endl;
return 0;   
}
for(int i = 0; i<N; i++){
if(deleteinttype+count[i]<currentinttype-K){
result += count[i]*(i+1);
deleteinttype += count[i];
}else{
result += (currentinttype-K-deleteinttype)*(i+1);
std::cout << result << std::endl;
return 0;
}
}
std::cout << result << std::endl;
return 0;
}
#include <bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
typedef long long ll;
using namespace std;

string s;
int freq[2];

int main(){
cin >> s;
int len = s.size();
int ans = s.size();
for(int i = 1; i < s.size(); i++){
if(s[i] != s[i-1]){
ans = min(ans,max(i, len-i));
}
}
cout << ans << endl;
}

#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
using ll = long long;

// #define DEBUG



void Main(){
ll s, c; cin >> s >> c;
ll res = min(s, c/2); s -= res; c -= res*2;
if (c >= 4){ res += c/4; }
cout << res;
}

int main(){
#ifndef DEBUG
ios_base::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
#endif
cout.setf(ios::fixed);
cout.precision(0);
Main();
}

#include <iostream>
#include <cstdio>
#include <cstring>
#include <sstream>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <cmath>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <limits.h>
#include <stack>
#include <fstream>
#include <list>
#include <sstream>
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;

typedef long long ll;
typedef pair<int, int> PII;
const double eps = 2e-9;
const int INF = 1e9, mod = 998244353;
const double pi = acos(-1.0);
const int N = 1e5 + 10;
set<int> a[N];
struct Row
{
int num, row;
}rows[N];
struct Col
{
int num, col;
}cols[N];
bool cmp1(Row &A, Row &B)
{
return A.num > B.num;
}
bool cmp2(Col &A, Col &B)
{
return A.num < B.num;
}
map<int, vector<pair<int, int>>> m;
char ans[N];
int main()
{
IOS;
int n, q;
cin >> n;
for (int i = 1; i <= n; i++)
{
int r;
cin >> r;
rows[i] = {r, i};
}
for (int i = 1; i <= n; i++)
{
int c;
cin >> c;
cols[i] = {c, i};
}
sort(rows + 1, rows + n + 1, cmp1);
sort(cols + 1, cols + n + 1, cmp2);
set<int> ori;
cin >> q;
for (int i = 1; i <= q; i++)
{
int r, c;
cin >>r >> c;
m[c].push_back(make_pair(r, i));
}
for (int i = 1; i <= n; i++)
{
ori.insert(rows[i].row);
if (m.count(cols[i].col) != 0)
{
for (int j = 0; j < m[cols[i].col].size(); j++)
if (ori.find(m[cols[i].col][j].first) != ori.end())
ans[m[cols[i].col][j].second] = '#';
else ans[m[cols[i].col][j].second] = '.';
}
}


for (int i = 1; i <= q; i++)
cout << ans[i];
cout << endl;



return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7;

void cut(vector <int> &a, int l, int r) {
vector <int> newA;
for (int i = 0; i < a.size(); ++i) {
if (i < l or i > r)
newA.push_back(a[i]);
}
a = newA;
}

bool check(vector <int> a, vector <int> ops, int ans) {
for (int i = 0; i < ops.size(); ++i) {
if (ops[i] == 0 or ops[i] == a.size() - 1) {
cut(a, ops[i], ops[i]);
} 
else {
a[ops[i] - 1] = a[ops[i] - 1] + a[ops[i] + 1];
cut(a, ops[i], ops[i] + 1);
}
}
assert(a.size() == 1);
return a[0] == ans;
}

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);
int n; cin >> n;
vector <int> a(n), sum(2), A;

int maxNeg = -1;
for (int i = 0; i < n; ++i) {
cin >> a[i];
sum[i & 1] += a[i] * (a[i] > 0);
if (a[i] <= 0) {
if (maxNeg == -1 or a[maxNeg] < a[i]) maxNeg = i;
}
}
A = a;
if (max(sum[0], sum[1]) == 0) {
cout << a[maxNeg] << '\n' << n - 1 << '\n';
for (int i = 0; i < maxNeg; ++i) cout << "1\n";
for (int i = maxNeg + 1; i < n; ++i) cout << n - i + 1 << '\n';
return 0;
}

int ans = max(sum[0], sum[1]);
vector <int> ops;
if (sum[1] > sum[0]) {
cut(a, 0, 0);
ops.push_back(0);
}
while (a[0] <= 0) {
cut(a, 0, 1);
ops.push_back(0);
ops.push_back(0);
}

while (true) {
int cur = 0;
int id = -1;
for (int i = cur + 2; i < a.size(); i += 2) {
if (a[i] > 0) {
id = i;
break;
}
}
if (id == -1) {
while (a.size() > 1) {
ops.push_back(a.size() - 1);
a.pop_back();
}
break;
}
int curLen = id - 1 - cur;
while (curLen > 1) {
curLen -= 2;
ops.push_back(2);
cut(a, 1, 2);
}
ops.push_back(1);
cut(a, 0, 1);
}
cout << ans << '\n' << ops.size() << '\n';
for (auto& x : ops) cout << x + 1 << '\n';

assert(check(A, ops, ans));

return 0;
}

#include <iostream>
using namespace std;
const int N=100010;
const long long INF=1e18+7;
int a[N];
int main(){
int n;
cin>>n;
for(int i=0;i<n;i++)cin>>a[i];
long long ans=INF;
for(int i=0;i<2;i++){
long long t=0,sumn=0;
for(int j=0;j<n;j++){
t+=a[j];
if(t<1&&(i%2==j%2)){
sumn+=1-t;
t=1;
}
if(t>-1&&(i%2!=j%2)){
sumn+=t+1;
t=-1;
}
}
ans=min(ans,sumn);
}
cout<<ans;
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using ll = long long;
#define int ll
#define rng(i, a, b) for (int i = int(a); i < int(b); i++)
#define rep(i, b) rng(i, 0, b)
#define ALL(a) (a).begin(), (a).end()
template <class t, class u> void chmax(t& a, u b) {
if (a < b) a = b;
}
template <class t, class u> void chmin(t& a, u b) {
if (b < a) a = b;
}
template <class t> using vc = vector<t>;
template <class t> using vvc = vc<vc<t>>;
using pi = pair<int, int>;
using vi = vc<int>;
using uint = unsigned;
using ull = unsigned long long;
int popcount(signed t) { return __builtin_popcount(t); }
int popcount(ll t) { return __builtin_popcountll(t); }
bool ispow2(int i) { return i && (i & -i) == i; }
ll mask(int i) { return (ll(1) << i) - 1; }
int lcm(int a, int b) { return a / __gcd(a, b) * b; }
signed main() {
cin.tie(0);
ios::sync_with_stdio(0);
cout << fixed << setprecision(20);
int n, a, b;
cin >> n >> a >> b;
vi x(n);
rep(i, n) cin >> x[i];
int ans = 0;
rep(i, n - 1) { ans += min(b, a * (x[i + 1] - x[i])); }
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;

inline void read(int &x)
{
x = 0; bool f = 1; char ch = getchar();
for (; ch < '0' || ch > '9'; ch = getchar())
if (ch == '-') f = 0;
for (; ch >= '0' && ch <= '9'; ch = getchar())
x = (x << 3) + (x << 1) + (ch ^ '0');
x = f ? x : -x;
}

void write(int x)
{
if (x < 0) putchar('-'), x = -x;
if (x >= 10) write(x / 10);
putchar(x % 10 + '0');
}

const int NR = 2e6 + 5;

struct SimpleEdge
{
int u, v;
};

struct Edge
{
int u, v, w, nxt;
};

struct Node
{
int id, dis;

bool operator < (const Node &rhs) const
{
return dis > rhs.dis;
}
};

int en, head[NR], n, m, node, anc[NR], id[NR], dis[NR], ans;
bool vis[NR], flag[NR];
Edge e[NR];
vector < SimpleEdge > g[NR];
vector < int > t;

int find(int x)
{
if (x == anc[x]) return x;
return anc[x] = find(anc[x]);
}

void merge(int u, int v)
{
int ancu = find(u), ancv = find(v);
if (ancu != ancv) anc[ancu] = ancv;
}

void addedge(int u, int v, int w)
{
en++;
e[en] = {u, v, w, head[u]};
head[u] = en;
}

void dijkstra(int s)
{
for (int i = 0; i < NR; ++i)
vis[i] = 0, dis[i] = 1e9;
priority_queue < Node > pq;
dis[s] = 0, pq.push({s, 0});
while (!pq.empty())
{
int u = pq.top().id; pq.pop();
if (vis[u]) continue;
vis[u] = 1;
for (int i = head[u]; i; i = e[i].nxt)
{
int v = e[i].v, w = e[i].w;
if (dis[v] > dis[u] + w) dis[v] = dis[u] + w, pq.push({v, dis[v]});
}
}
}

signed main()
{
read(n), read(m); node = n;
for (int i = 1; i <= m; ++i)
{
int u, v, c; read(u), read(v), read(c);
g[c].push_back({u, v});
}
for (int c = 1; c <= (int)1e6; ++c)
{
if (g[c].empty()) continue;
t.clear();
for (auto i : g[c]) t.push_back(i.u), t.push_back(i.v);
sort(t.begin(), t.end());
auto it = unique(t.begin(), t.end());
t.erase(it, t.end());
for (auto i : t) anc[i] = i, id[i] = 0;
for (auto i : g[c]) merge(i.u, i.v);
for (auto u : t)
{
int ancu = find(u);
if (!id[ancu]) id[ancu] = ++node;
addedge(u, id[ancu], 1), addedge(id[ancu], u, 1);
} 
}
dijkstra(1);
if (dis[n] == 1e9) ans = -1;
else ans = dis[n] / 2;
write(ans);
return 0;
}
//#include <bits/stdc++.h>
//using namespace std;
//#if __has_include(<atcoder/all>)
//#include <atcoder/all>
//using namespace atcoder;
//#endif

#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <queue>
#include <map>
#include <iomanip>
#include <string>
#include <functional>
using namespace std;
using Graph = vector<vector<int>>;
const long long INF = 1LL << 60;

using ll = long long;
using ld = long double;
using ull = unsigned long long;
#define endl "\n"
typedef pair<int, int> Pii;
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))
#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)
#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define ALL(x) begin(x), end(x)
#define PB push_back
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(s) (s).begin(),(s).end()
#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)
#define drep(i, n) drep2(i, n, 0)
#define rever(vec) reverse(vec.begin(), vec.end())
#define sor(vec) sort(vec.begin(), vec.end())
#define fi first
#define se second
#define pb push_back
#define P pair<ll,ll>
#define PQminll priority_queue<ll, vector<ll>, greater<ll>>
#define PQmaxll priority_queue<ll,vector<ll>,less<ll>>
#define PQminP priority_queue<P, vector<P>, greater<P>>
#define PQmaxP priority_queue<P,vector<P>,less<P>>
#define NP next_permutation
//typedef string::const_iterator State;
//class ParseError {};
//const ll mod = 1000000009;
const ll mod = 998244353;
//const ll mod = 1000000007;
const ll inf = 4100000000000000000ll;
const ld eps = ld(0.000000000001);
const long double pi = 3.141592653589793;
template<class T>void vcin(vector<T>& n) { for (int i = 0; i<int(n.size()); i++) cin >> n[i]; }
template<class T, class K>void vcin(vector<T>& n, vector<K>& m) { for (int i = 0; i<int(n.size()); i++) cin >> n[i] >> m[i]; }
template<class T>void vcout(vector<T>& n) { for (int i = 0; i<int(n.size()); i++) { cout << n[i] << " "; }cout << endl; }
template<class T>void vcin(vector<vector<T>>& n) { for (int i = 0; i<int(n.size()); i++) { for (int j = 0; j<int(n[i].size()); j++) { cin >> n[i][j]; } } }
template<class T>void vcout(vector<vector<T>>& n) { for (int i = 0; i<int(n.size()); i++) { for (int j = 0; j<int(n[i].size()); j++) { cout << n[i][j] << " "; }cout << endl; }cout << endl; }
void yes(bool a) { cout << (a ? "yes" : "no") << endl; }
void YES(bool a) { cout << (a ? "YES" : "NO") << endl; }
void Yes(bool a) { cout << (a ? "Yes" : "No") << endl; }
void possible(bool a) { cout << (a ? "possible" : "impossible") << endl; }
void Possible(bool a) { cout << (a ? "Possible" : "Impossible") << endl; }
void POSSIBLE(bool a) { cout << (a ? "POSSIBLE" : "IMPOSSIBLE") << endl; }
template<class T>void print(T a) { cout << a << endl; }
template<class T, class F>void print(pair<T, F> a) { cout << a.fi << " " << a.se << endl; }
template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> void ifmin(T t, T u) { if (t > u) { cout << -1 << endl; } else { cout << t << endl; } }
template<class T> void ifmax(T t, T u) { if (t > u) { cout << -1 << endl; } else { cout << t << endl; } }
ll fastgcd(ll u, ll v) { ll shl = 0; while (u && v && u != v) { bool eu = !(u & 1); bool ev = !(v & 1); if (eu && ev) { ++shl; u >>= 1; v >>= 1; } else if (eu && !ev) { u >>= 1; } else if (!eu && ev) { v >>= 1; } else if (u >= v) { u = (u - v) >> 1; } else { ll tmp = u; u = (v - u) >> 1; v = tmp; } }return !u ? v << shl : u << shl; }
ll modPow(ll a, ll n, ll mod) { if (mod == 1) return 0; ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }
vector<ll> divisor(ll x) { vector<ll> ans; for (ll i = 1; i * i <= x; i++) { if (x % i == 0) { ans.push_back(i); if (i * i != x) { ans.push_back(x / ans[i]); } } }sor(ans); return ans; }
//ll pop(ll x) { return __builtin_popcountll(x); }
ll poplong(ll x) { ll y = -1; while (x) { x /= 2; y++; }return y; }

//void cincout() {
//    ios::sync_with_stdio(false);
//    std::cin.tie(nullptr);
//    cout << fixed << setprecision(10);
//}






int main() {


ll A, B, C, X, Y;
cin >> A >> B >> C >> X >> Y;

ll val = A * X + B * Y;

ll x = X;
ll y = Y;

ll maxZ2 = max(X,Y);
for (int64_t z2 = 1; z2 <= maxZ2; z2++) {

x -= 1;
y -= 1;
if (x < 0)x = 0;
if (y < 0)y = 0;

ll newVal = A * x + B * y + C * 2 * z2;
chmin(val,newVal);

}

print(val);

return 0;
}


#include <bits/stdc++.h>
#include <atcoder/all>
#define rep(i, n) for (ll i = 0; i < (n); ++i)
#define sz(x) ll(x.size())
#define debug(x) cerr<<#x<<" = "<<x<<'\n'
#define show(x) {for(auto i:x){cout<<i<<" ";} cout<<endl;}
#define shows(x) {for(auto y:x){show(y);}}
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define NG {puts("-1"); return 0;}
#define OUT(x) {cout<<x<<'\n'; return 0;}
#define pcnt __builtin_popcountll
using namespace std;
using namespace atcoder;
using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using tii=tuple<int, int, int>;
using tll=tuple<ll, ll, ll>;
template<typename T>bool chmin(T&x,const T&y) {if(x>y){x=y;return true;} else return false;}
template<typename T>bool chmax(T&x,const T&y) {if(x<y){x=y;return true;} else return false;}
const ll LINF = 2e18;
const ll INF = 2e9;
const ll MX = 200005;
ll pow(ll a,ll n){ll x=1;for(;n;n/=2)n&1?x=x*a:0,a=a*a;return x;}
ll pom(ll a,ll n,int m){a%=m;if(a==0){return 0;}ll x=1;for(;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}
ll lcm(ll a, ll b) { return a / gcd(a, b) * b;}

int main() {
// 20個のbitのindexを保持
ll N;
cin >> N;
vector<ll> A(N);
rep(i, N) cin >> A[i];
ll ans = 0;
vector<ll> bit(20, -1);
ll left = -1;
rep(i, N) {
rep(j, 21) {
if ((A[i] >> j) & 1) {
// A[i]のj個目のbitが立っている
chmax(left, bit[j]);
bit[j] = i;
}
}
ans += i - left;
}
cout << ans << '\n';
return 0;
}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;
#define pairll pair<ll,ll>
#define lpairll pair<ll, pairll>

#define fr first
#define sc second
#define pb push_back
#define mp make_pair
#define repp(i,a,b) for(ll i = (a); i <= (b); i++)
#define repm(i, a, b) for (ll i = (a); i >= (b); i--)
#define repz(i, a, b) for (ll i = (a); i < (b); i++)

const ll MOD = 1e9+7, N = 4e5 + 5, M = 1e6+5, INF = 1e18;

ll tc = 1, n, m=0, k[N], h[N], ar[N], pr[N], xr[N];
string ye = "YES", no = "NO", s, t, s1, s2, op;

void fastt(){
ios_base::sync_with_stdio(0);
cin.tie(NULL); 
cout.tie(NULL);
}

void input(){
cin >> n;
pr[0] = 0, xr[0] = 0;
repp(i,1,n) cin >> ar[i], pr[i] = pr[i-1] + ar[i], xr[i] = xr[i-1]^ar[i];
}

void solve(){
repp(i,1,n){
ll l = i, r = n, idx;
while(l <= r){
ll mid = (l+r)/2, sum, xro;
sum = pr[mid] - pr[i-1], xro = xr[mid]^xr[i-1]; 
if(sum == xro){
l = mid+1;
idx = mid;
}
else 
r = mid-1;
}
m += (idx-i+1);
}
cout << m << endl;
}

int main(){
fastt();
//cin >> tc;
while(tc--){
input();
solve();
}
}

/*

*/
//-----------------------------------------------------------------------------------
//  ****   Header   ****{{{
#include <functional>
#include <ios>
#include <iostream>
#include <cctype>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <iterator>
#include <set>
#include <sstream>
#include <cstring>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>
#include <bitset>
#include <numeric>
#include <typeinfo>
#include <typeindex>
#include <iomanip>
#include <cassert>
#include <climits>
#include <map>

using namespace std;

static const size_t npos = -1;
typedef long long ll;
const int inf = INT_MAX / 2;
const long long INF = 1LL << 62;
const long long mod = 1e9+7;
#define all(x) (x).begin(),(x).end()
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define reps(i, n) for (int i = 1; i < (int)(n); i++)
#define fore(i,a) for(auto &i:a)
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }


#ifdef LOCAL
#include "debug"
#endif

#ifndef LOCAL
#define debug(...)  // 42
#define log(...)
#define dump(...)
#endif

// }}}
//-----------------------------------------------------------------------------------



int main() {

int a, b, c, x, y;
cin >> a >> b >> c >> x >> y;

ll am, bm, cm, ans=inf;
for(int i=0;i/2<=max(x,y);i+=2){
cm=(c*i);
am=(x-i/2)*a;
if(am<0) am=0;
bm=(y-i/2)*b;
if(bm<0) bm=0;
chmin(ans,am+bm+cm);
}
cout << ans << endl;



}

#include <bits/stdc++.h>
using namespace std;

inline void read(int &x)
{
x = 0; bool f = 1; char ch = getchar();
for (; ch < '0' || ch > '9'; ch = getchar())
if (ch == '-') f = 0;
for (; ch >= '0' && ch <= '9'; ch = getchar())
x = (x << 3) + (x << 1) + (ch ^ '0');
x = f ? x : -x;
}

void write(int x)
{
if (x < 0) putchar('-'), x = -x;
if (x >= 10) write(x / 10);
putchar(x % 10 + '0');
}

const int NR = 2e6 + 5;

struct SimpleEdge
{
int u, v;
};

struct Edge
{
int u, v, w, nxt;
};

struct Node
{
int id, dis;

bool operator < (const Node &rhs) const
{
return dis > rhs.dis;
}
};

int en, head[NR], n, m, node, anc[NR], id[NR], dis[NR], ans;
bool vis[NR], flag[NR];
Edge e[NR];
vector < SimpleEdge > g[NR];
vector < int > t;

int find(int x)
{
if (x == anc[x]) return x;
return anc[x] = find(anc[x]);
}

void merge(int u, int v)
{
int ancu = find(u), ancv = find(v);
if (ancu != ancv) anc[ancu] = ancv;
}

void addedge(int u, int v, int w)
{
en++;
e[en] = {u, v, w, head[u]};
head[u] = en;
}

void dijkstra(int s)
{
for (int i = 0; i < NR; ++i)
vis[i] = 0, dis[i] = 1e9;
priority_queue < Node > pq;
dis[s] = 0, pq.push({s, 0});
while (!pq.empty())
{
int u = pq.top().id; pq.pop();
if (vis[u]) continue;
vis[u] = 1;
for (int i = head[u]; i; i = e[i].nxt)
{
int v = e[i].v, w = e[i].w;
if (dis[v] > dis[u] + w) dis[v] = dis[u] + w, pq.push({v, dis[v]});
}
}
}

signed main()
{
read(n), read(m); node = n;
for (int i = 1; i <= m; ++i)
{
int u, v, c; read(u), read(v), read(c);
g[c].push_back({u, v});
}
for (int c = 1; c <= (int)1e6; ++c)
{
if (g[c].empty()) continue;
t.clear();
for (auto i : g[c]) t.push_back(i.u), t.push_back(i.v);
sort(t.begin(), t.end());
auto it = unique(t.begin(), t.end());
t.erase(it, t.end());
for (auto i : t) anc[i] = i, id[i] = 0;
for (auto i : g[c]) merge(i.u, i.v);
for (auto u : t)
{
int ancu = find(u);
if (!id[ancu]) id[ancu] = ++node;
addedge(u, id[ancu], 1), addedge(id[ancu], u, 1);
} 
}
dijkstra(1);
if (dis[n] == 1e9) ans = -1;
else ans = dis[n] / 2;
write(ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define MOD 1000000007

int main(){
ll n;
cin>>n;

ll arr[100001]={0};

for(int i=1;i<=n;i++){
ll x=i;

while(x%2==0){
x/=2;
arr[2]++;
}

for(int j=3;j<=x;j+=2){
while(x%j==0){
x/=j;
arr[j]++;
}
}
}

ll ans=1;

for(int i=1;i<=100000;i++){
ans=(ans*(arr[i]+1))%MOD;
}

cout<<ans<<endl;
return 0;
}

#include <iostream>
using namespace std;
const int N=100010;
const long long INF=1e18+7;
int a[N];
int main(){
int n;
cin>>n;
for(int i=0;i<n;i++)cin>>a[i];
long long ans=INF;
for(int i=0;i<2;i++){
long long t=0,sumn=0;
for(int j=0;j<n;j++){
t+=a[j];
if(t<1&&(i%2==j%2)){
sumn+=1-t;
t=1;
}
if(t>-1&&(i%2!=j%2)){
sumn+=t+1;
t=-1;
}
}
ans=min(ans,sumn);
}
cout<<ans;
return 0;
}
#include<iostream>
#include <atcoder/maxflow>

using namespace std;
using namespace atcoder;

int main() {
int N;
cin >> N;
vector<pair<int, int>> vp_red;
mf_graph<int> graph(N*2+2);
for(int i=1;i<=N;i++) {
int a, b;
cin >> a >> b;
vp_red.push_back(make_pair(a, b));
graph.add_edge(0, i, 1);
}

for(int i=1;i<=N;i++) {
int a, b;
cin >> a >> b;
for(int j=0;j<N;j++) {
if(vp_red[j].first < a && vp_red[j].second < b) {
graph.add_edge(j+1, i+N, 1);
}
}
graph.add_edge(i+N, N*2+1, 1);
}

cout << graph.flow(0, N*2+1) << endl;
}
#include <iostream>
#include <cstdio>
#include <cstring>
#include <sstream>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <cmath>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <limits.h>
#include <stack>
#include <fstream>
#include <list>
#include <sstream>
#define IOS ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
using namespace std;

typedef long long ll;
typedef pair<int, int> PII;
const double eps = 2e-9;
const int INF = 1e9, mod = 998244353;
const double pi = acos(-1.0);
const int N = 1e5 + 10;
set<int> a[N];
struct Row
{
int num, row;
}rows[N];
struct Col
{
int num, col;
}cols[N];
bool cmp1(Row &A, Row &B)
{
return A.num > B.num;
}
bool cmp2(Col &A, Col &B)
{
return A.num < B.num;
}
map<int, vector<pair<int, int>>> m;
char ans[N];
int main()
{
IOS;
int n, q;
cin >> n;
for (int i = 1; i <= n; i++)
{
int r;
cin >> r;
rows[i] = {r, i};
}
for (int i = 1; i <= n; i++)
{
int c;
cin >> c;
cols[i] = {c, i};
}
sort(rows + 1, rows + n + 1, cmp1);
sort(cols + 1, cols + n + 1, cmp2);
set<int> ori;
cin >> q;
for (int i = 1; i <= q; i++)
{
int r, c;
cin >>r >> c;
m[c].push_back(make_pair(r, i));
}
for (int i = 1; i <= n; i++)
{
ori.insert(rows[i].row);
if (m.count(cols[i].col) != 0)
{
for (int j = 0; j < m[cols[i].col].size(); j++)
if (ori.find(m[cols[i].col][j].first) != ori.end())
ans[m[cols[i].col][j].second] = '#';
else ans[m[cols[i].col][j].second] = '.';
}
}


for (int i = 1; i <= q; i++)
cout << ans[i];
cout << endl;



return 0;
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; --i)

int main() {
ll n, m;
cin >> n >> m;
if (m < 2 * n) {
cout << m / 2 << endl;
} else {
cout << n + (m - 2 * n) / 4 << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define ll long long
string x;


int main() {
cin >> x;
int sz = x.size();
int center = sz/2;
int ans = sz;
if (sz % 2 == 1) {
char point = x[center];
int i = 1;
while(i + center < sz) {
//cout << "::" << i << " " << x[center + i] << " " << x[center - i] <<  endl;
if (x[center + i] != point || x[center - i] != point) {
ans = center + i;
break;
}
i++;
}
} 
else {
if (x[center - 1] == x[center]) {
int i = 1;
char point = x[center];
while(i + center < sz) {
//cout << i << " " << x[center + i]  << " " << x[center - i - 1] << endl;
if (x[center + i] != point || x[center - i - 1] != point) {
ans = center + i;
break;
}
i++;
}
}
else {
ans = center;
}
}
cout << ans << endl;

}
//UnionFind

#define _GLIBCXX_DEBUG
#define ll long long
#include <bits/stdc++.h>
using namespace std;
using Graph = vector<vector<int>>;

void print(auto a){
cout << a;
}

void prints(auto a){
cout << a << " ";
}

void printl(auto a){
cout << a << endl;
}

void printl(){
cout << endl;
}

void fix(int n){
cout << fixed << setprecision(n);
}

int siz(string s){
return (int)s.size();
}

struct UnionFind{
vector<int> par, rank, siz;

UnionFind(int n): par(n, -1), rank(n, 0), siz(n, 1){}

int root(int x){
if(par[x] == -1) return x;
else return par[x] = root(par[x]);
}

bool issame(int x, int y){
return root(x) == root(y);
}

bool unite(int x, int y){
int rx = root(x), ry = root(y);
if(rx == ry) return false;
if(rank[rx] < rank[ry]) swap(rx, ry);
par[ry] = rx;
if(rank[rx] == rank[ry]) rank[rx]++;
siz[rx] += siz[ry];
return true;
}

int size(int x){
return siz[root(x)];
}
};

ll RD(ll a, ll b){
return (a/b)*b;
}

ll RU(ll a, ll b){
return ((a+b-1)/b)*b;
}

int main(){
int N, K; cin >> N >> K;
vector<int> X(200001, 0);
for(int i = 0; i < N; i++){
int A; cin >> A;
X[A]++;
}
sort(X.rbegin(), X.rend());
int ans = N;
for(int i = 0; i < K; i++){
ans -= X[i];
}
printl(ans);
}
#include<iostream>
#include<algorithm>
using namespace std;
int n,sum;
const int N=2e5+10;
int a[N];
int main (){
int i=1;
cin>>n;
while(sum<n){
sum+=i;
if(i==n){
printf("%d\n",i);
return 0;
}
i++;

}
printf("%d\n",i-1);
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <math.h>
#include <numeric>
#include <list>
#include <queue>
#include <string>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <string>   


using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<long long,long long> pll;
typedef vector<vector<int>> vvi;
typedef vector<vector<int>> vi;
typedef pair<pair<int,int>, int> ppiii;
typedef pair<int, pair<int,int>> pipii;
typedef pair<int,char> pic;
typedef pair<char,int> pci;
typedef pair<string,string> pss;

ll MX = 100000 + 10;
ll MOD = 1000*1000*1000 + 7;

vector<ll> fact(MX, 1);

ll powmod(ll a, ll b, ll p){
a %= p;
if (a == 0) return 0;
ll product = 1;
while(b > 0){
if (b&1){    // you can also use b % 2 == 1
product *= a;
product %= p;
--b;
}
a *= a;
a %= p;
b /= 2;    // you can also use b >> 1
}
return product;
}

ll inv(ll a, ll p){
return powmod(a, p-2, p);
}

ll nCk(ll n, ll k, ll p){
return ((fact[n] * inv(fact[k], p) % p) * inv(fact[n-k], p)) % p;
}

void genFact() {
for (ll i = 2; i < MX; i++) {
fact[i] = (fact[i-1] * i) % MOD;
}
}

void solve() {
genFact();
ll n; cin >> n;
n++;
vector<ll> in(n);
map<int,int> cnt;
ll tar = -1;
for(auto& it : in) {
cin >> it;
cnt[it]++;
if (cnt[it] == 2) {
tar = it; 
}
}
vector<ll> res(n);
for(ll i = 1; i <= n; i++) {
res[i-1] = nCk(n, i, MOD);
//cout << i << " " << res[i - 1] << endl;
}
ll pref = 0, suff = 0;
for(int i = 0; i < n; i++) {
if (in[i] == tar) break;
pref++;
}
for (int i = n - 1; i >= 0; i--) {
if (in[i] == tar) break;
suff++;
}
//cout << tar << " " << pref << " " << suff << endl;
for (int i = 0; i <= suff + pref; i++) {
ll ways = nCk(suff+pref, i, MOD);
res[i] = (res[i] - ways + MOD) % MOD;
}
for (auto it : res) cout << it << endl;
cout << endl;

}




int main() {
ios_base::sync_with_stdio(0);
cin.tie(0);
int t = 1;
//cin >> t;
while(t--) {
solve();
}
}







#include<cstdio>
#include<vector>
#include<cmath>
#define N 300001
using namespace std;
long long fsum[N],a[N],l[N],r[N],num[N],jc[N];
int n,num1=0,bits;
vector<long long>p1[N];
long long abs1(long long x)
{
if (x<0) return -x;
return x;
}
void rebuild()
{
if (p1[1][0]!=1)
{
num1++;num1--;
}
int s1=0;
for (int i=1;i<=num1;i++)
{
for (int j=1;j<=p1[i][0];j++)
{
s1++;
a[s1]=p1[i][j];
}
}
num1=0;
for (int i=1;i<=s1;i++)
{
if (i%bits==1)
{
num1++;
p1[num1][0]=0;fsum[num1]=0;
}
p1[num1][0]++;
p1[num1].resize(p1[num1][0]+1);
p1[num1][p1[num1][0]]=a[i];
fsum[num1]+=a[i];
}
}
void insert(int x)
{
int s1=0;
for (int i=1;i<=num1;i++)
{
if (s1+p1[i][0]>=x)
{
for (int j=1;j<=p1[i][0];j++)
a[j]=p1[i][j];
p1[i][0]++;p1[i].resize(p1[i][0]+1);
for (int j=p1[i][0];j>x-s1+1;j--) p1[i][j]=p1[i][j-1];
p1[i][x-s1+1]=0;
break;
}
s1+=p1[i][0];
}
}
void change(int k,long long x,int typ)
{
int s1=0;
for (int i=1;i<=num1;i++)
{
if (s1+p1[i][0]>=k)
{
if (typ==1)
{
p1[i][k-s1]+=x;
fsum[i]+=x;
}
else
{
fsum[i]-=p1[i][k-s1];
fsum[i]+=x;
p1[i][k-s1]=x;
}
break;
}
s1+=p1[i][0];
}
}
long long ask(int k)
{
int s1=0;
for (int i=1;i<=num1;i++)
{
if (s1+p1[i][0]>=k)
{
return p1[i][k-s1];
break;
}
s1+=p1[i][0];
}
}
int main()
{
scanf("%d",&n);
for (int i=1;i<=n;i++) scanf("%lld%lld",&l[i],&r[i]);
long long sl=-1e15;
num1=1;
fsum[1]=2*1e15;
jc[0]=0;
for (int i=1;i<=n*2+1;i++) p1[i].resize(1);
p1[1].resize(2); p1[1][0]=1;
p1[1][1]=2*1e15;
bits=sqrt(n);
for (int i=1;i<=n;i++)
{
if (i==3)
{
n++;n--;
}
if (i%bits==1) 
rebuild();
long long sum=0;
change(i,r[i-1]-l[i-1]+r[i]-l[i],1);
change(1,l[i]-r[i],1);
//	num[i]+=r[i-1]-l[i-1]+(r[i]-l[i]);
//	num[1]-=r[i]-l[i];
int s1=0;
for (int i1=1;i1<=num1;i1++)
{
if (sum+fsum[i1]>=l[i]-sl)
{
for (int j=1;j<=p1[i1][0];j++)
{
s1++;
if (sum+p1[i1][j]>=l[i]-sl)
{
insert(s1);
insert(s1+1);
if (sum+num[j]==l[i]-sl)
{
change(s1+2,0,0);
break;
}
long long pj=ask(s1);
change(s1,l[i]-sl-sum,0); 
//	change(j+1,-num[j+1]);
change(s1+2,pj-(l[i]-sl-sum),0);
break;
}
sum+=p1[i1][j];
}
break;
}
s1+=p1[i1][0];
sum+=fsum[i1];
}
//	for (int i1=1;i1<=num1;i1++)
//		for (int j=1;j<=p1[i1][0];j++) printf("%lld ",p1[i1][j]);
//	printf("\n");
jc[i]=sl;
s1=0;
for (int i1=1;i1<=num1;i1++)
{
if (s1+p1[i1][0]>=i)
{
for (int j=1;j<=p1[i1][0];j++)
{
s1++;
jc[i]+=p1[i1][j];
if (s1==i) break;
}
break;
}
jc[i]+=fsum[i1];
s1+=p1[i1][0];
}
//	printf("%lld\n",jc[i]);
//	for (int j=1;j<=i;j++)
//		jc[i]+=num[j];	
}
long long sum=0;
long long last=jc[n];
for (int i=n;i>=1;i--)
{
sum+=abs1(last-l[i]);
//	printf("%lld\n",last);
if (i!=1)
{
if (last<=jc[i-1])
{
if (last+r[i]-l[i]>=jc[i-1])
last=jc[i-1];
else	last+=r[i]-l[i];
}
else
{
if (jc[i-1]+r[i-1]-l[i-1]>=last)
last=jc[i-1];
else	last-=r[i-1]-l[i-1];
}
}
}
printf("%lld\n",sum);
}
#include "bits/stdc++.h"
using namespace std;

#define rep(i, a, b) for(int i=a; i<=b; i++)
#define all(x) begin(x), end(x)
#define sz(x) (int) x.size()
#define f first
#define s second
#define nl "\n"
#define pb push_back
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
const int MOD=1e9+7;

template <ll Mod>
struct ModInt {
ll n;

ModInt(const ll x = 0) : n(x) {
while (n < 0) n += Mod;
n %= Mod;
}
explicit operator int() const { return n; }
inline constexpr ModInt operator+(const ModInt r) const noexcept { return ModInt(*this) += r; }
inline constexpr ModInt operator-(const ModInt r) const noexcept { return ModInt(*this) -= r; }
inline constexpr ModInt operator*(const ModInt r) const noexcept { return ModInt(*this) *= r; }
inline constexpr ModInt operator/(const ModInt r) const noexcept { return ModInt(*this) /= r; }
inline constexpr ModInt &operator+=(const ModInt r) noexcept {
n += r.n;
if (n >= Mod) n -= Mod;
return *this;
}
inline constexpr ModInt &operator-=(const ModInt r) noexcept {
if (n < r.n) n += Mod;
n -= r.n;
return *this;
}
inline constexpr ModInt &operator*=(const ModInt r) noexcept {
n = n * r.n % Mod;
return *this;
}
inline constexpr ModInt &operator/=(const ModInt r) noexcept { return *this *= r.inv(); }

inline constexpr ModInt pow(ll x) const noexcept {
ModInt<Mod> ret(1), tmp(*this);
while (x) {
if (x&1) ret *= tmp;
tmp *= tmp;
x >>= 1;
}
return ret;
}
inline constexpr ModInt inv() const noexcept { return pow(Mod-2); }

friend ostream& operator<<(ostream& os, const ModInt& obj) { return os << obj.n; }
friend istream& operator>>(istream& is, ModInt& obj) {
ll t;
is >> t;
obj = ModInt(t);
return is;
}
};

constexpr ll mod = 1000000007; //check!
using mi = ModInt<mod>;
mi operator"" _mi(unsigned long long n) { return mi(n); }

int s;
bool pten[10000001];
short dig[226000001];

mi bpow(int a, int b){
if(b==0) return 1;
mi x=bpow(a, b/2);
x*=x;
if(b&1) x*=a;
return x;
}

int main(){
cin.tie(0)->sync_with_stdio(0);

cin >> s;

int x=1;
while(x<=1e7){
pten[x]=1;
x*=10;
}

mi ans=0;
int sum=1;
int j=1;
int cur=1;
dig[1]=1;
for(int i=1; i<1e7; i++){
while(sum<s){
j++;
if(j<=1e7 && pten[j]) cur++;
dig[j]=cur;
sum+=cur;
}
ans+=sum==s;
sum-=dig[i];
}

ans+=s/8;

auto go=[&](int i){
int len=s/i;
// cout << 9*pten[i-1]-len << "\n";
if(i>8 || 9*(int)bpow(10, i-1)>len) ans+=(mi)9*bpow(10, i-1)-len;
};

for(int i=1; i*i<=s; i++){
if(s%i) continue;
if(i>7) go(i); if(s/i>7 && i*i!=s) go(s/i);
}
cout << ans;
}

#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>

using namespace std;


using ll = long long;
using ld = long double;

#define X first
#define Y second

const ll mod = 1000000007;
//const ll mod = 998244353;

ll gcd(ll a, ll b)
{
a = abs(a);
b = abs(b);
if (a==0 or b==0) return a+b;
return gcd(b,a%b);
}


ll sum(ll a, ll b)
{
a += b;
a %= mod;
return a;
}

ll sub(ll a, ll b)
{
a += mod-b;
a %= mod;
return a;
}

inline ll mul(ll a, ll b)
{
if (a*b<mod) return a*b;
return a*b%mod;
}

inline ll pew(ll a, ll b)
{
ll res = 1;
while (b)
{
if (b&1) res = mul(res,a);
a = mul(a,a);
b /= 2;
}
return res;
}



/*const int MOD = 998244353;
const int root = 31;
const int root_1 = 128805723;
const int root_pw = 1<<23;
const int root = 30;
const int MOD = 469762049;
const int root_1 = 15658735;
const int root_pw = 1<<26;*/

/*
void fft (vector<int> & a, bool invert) {
int n = (int) a.size();

for (int i=1, j=0; i<n; ++i) {
int bit = n >> 1;
for (; j>=bit; bit>>=1)
j -= bit;
j += bit;
if (i < j)
swap (a[i], a[j]);
}

for (int len=2; len<=n; len<<=1) {
int wlen = invert ? root_1 : root;
for (int i=len; i<root_pw; i<<=1)
wlen = int (wlen * 1ll * wlen % mod);
for (int i=0; i<n; i+=len) {
int w = 1;
for (int j=0; j<len/2; ++j) {
int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
a[i+j] = u+v < mod ? u+v : u+v-mod;
a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
w = int (w * 1ll * wlen % mod);
}
}
}
if (invert) {
int nrev = pew(n, mod-2);
for (int i=0; i<n; ++i)
a[i] = int (a[i] * 1ll * nrev % mod);
}
}*/

/*
int parent[1200001];
int rnk[1200001];


void make_set (int v) {
parent[v] = v;
rnk[v] = 0;
}

int find_set (int v) {
if (v == parent[v])
return v;
return parent[v] = find_set(parent[v]);
}

void union_sets (int a, int b) {
a = find_set(a);
b = find_set(b);
if (a != b) {
if (rnk[a] < rnk[b])
swap(a, b);
parent[b] = a;
if (rnk[a] == rnk[b])
++rnk[a];
}
}*/


vector<vector<ll>> g;
vector<ll> b, was, nxt, dp, dp2;

ll dfs0(ll u)
{
if (was[u]==1)
{
return u;
}
was[u] = 1;
ll x = dfs0(nxt[u]);
if (x!=-1) b.push_back(u);
if (x==u) return -1;
return x;
}

void dfs(ll u, ll p)
{
ll k = 0;
for (ll v: g[u])
{
if (v==p) continue;
dfs(v,u);
k++;
}
vector<ll> D(k+2);
for (ll v: g[u])
{
if (v==p) continue;
if (dp[v]>k+1) continue;
D[dp[v]] = 1;
}
ll z = 0;
for (ll i=0;i<=k+1;i++)
{
if (D[i]==0)
{
if (z==0) dp[u] = i;
else dp2[u] = i;
z++;
if (z==2) return;
}
}
}

int main()
{
ios_base::sync_with_stdio(false);
ll n;
cin >> n;
vector<ll> p(n);
g.resize(n);
was.resize(n);
nxt.resize(n);
dp.resize(n);
dp2.resize(n);
for (ll i=0;i<n;i++)
{
cin >> p[i];
p[i]--;
g[p[i]].push_back(i);
nxt[i] = p[i];
}
dfs0(0);
ll sz = b.size();
for (ll i=0;i<sz;i++)
{
dfs(b[i],b[(i+1)%sz]);
}
vector<ll> a(sz), a2(sz);
for (ll i=0;i<sz;i++)
{
a[i] = dp[b[i]];
a2[i] = dp2[b[i]];
}
reverse(a.begin(),a.end());
reverse(a2.begin(),a2.end());
{
ll x = a[0];
for (ll i=0;i<sz;i++)
{
if (a[(i+1)%sz]==x) x = a2[(i+1)%sz];
else x = a[(i+1)%sz];
}
if (a[0]==x)
{
cout << "POSSIBLE\n";
return 0;
}
}
{
ll x = a2[0];
for (ll i=0;i<sz;i++)
{
if (a[(i+1)%sz]==x) x = a2[(i+1)%sz];
else x = a[(i+1)%sz];
}
if (a2[0]==x)
{
cout << "POSSIBLE\n";
return 0;
}
}
cout << "IMPOSSIBLE\n";
}
#include <bits/stdc++.h>
using namespace std;
vector<int> a[100005];
int n,x,y,f=0,s=0,c[100005],Ca[100005],c1[100005],Ca1[100005];
int main(){
cin>>n;
for(int i=1;i<n;i++){
cin>>x>>y;
a[x].push_back(y);
a[y].push_back(x);
}
queue<int> q,q1;
memset(c,0,sizeof(c)),memset(c1,0,sizeof(c1));
c[1]=Ca[1]=c1[n]=Ca1[n]=1;
q.push(1),q1.push(n);
while(!q.empty()){
int now=q.front();
q.pop();
for(int i=0;i<a[now].size();i++){
int now1=a[now][i];
if(c[now1])continue;
Ca[now1]=Ca[now]+1;
c[now1]=1;
q.push(now1);
}
}
while(!q1.empty()){
int now=q1.front();
q1.pop();
for(int i=0;i<a[now].size();i++){
int now1=a[now][i];
if(c1[now1])continue;
Ca1[now1]=Ca1[now]+1;
c1[now1]=1;
q1.push(now1);
}
}
for(int i=2;i<n;i++){
if(Ca[i]>Ca1[i])s++;
else f++;
}
if(f>s)cout<<"Fennec";
else cout<<"Snuke";
return 0;
}
#include <iostream>
#include <cstdio>
#include <vector>

typedef long long ll;

const int N = 5010;
const int mod = 1e9 + 7;

int n;
std::vector<int> e[N];
int siz[N], tmp[N], f[N][N], g[N];

inline int read() {
int x = 0, f = 1;
char ch = std::getchar();
while (ch < '0' || ch > '9') {
if (ch == '-') f = -1;
ch = std::getchar();
}
while ('0' <= ch && ch <= '9') {
x = (x<<3) + (x<<1) + ch - '0';
ch = std::getchar();
}
return x * f;
}

void dfs(int u, int fa) {
f[u][siz[u]=1] = 1;
for (int v : e[u]) {
if (v == fa) continue;
dfs(v, u);
for (int i = 1; i <= siz[u] + siz[v]; i++)
tmp[i] = 0;
for (int i = 1; i <= siz[u]; i++)
for (int j = 0; j <= siz[v]; j++)
(tmp[i+j] += (ll)f[u][i] * f[v][j] % mod) %= mod;
for (int i = 1; i <= siz[u] + siz[v]; i++)
f[u][i] = tmp[i];
siz[u] += siz[v];
}
for (int i = 2; i <= siz[u]; i += 2)
(f[u][0] += mod - (ll)f[u][i] * g[i] % mod) %= mod;
}

int main() {
n = read();
for (int i = 1; i < n; i++) {
int u = read(), v = read();
e[u].push_back(v); e[v].push_back(u);
}
g[0] = 1;
for (int i = 2; i <= n; i += 2)
g[i] = (ll)g[i-2] * (i-1) % mod;
dfs(1, 0);
std::printf("%d\n", (mod-f[1][0])%mod);
return 0;
}
#include<cassert>
#include<cctype>
#include<cerrno>
#include<cfloat>
#include<ciso646>
#include<climits>
#include<clocale>
#include<cmath>
#include<csetjmp>
#include<csignal>
#include<cstdarg>
#include<cstddef>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<bitset>
#include<complex>
#include<deque>
#include<exception>
#include<fstream>
#include<functional>
#include<iomanip>
#include<ios>
#include<iosfwd>
#include<iostream>
#include<istream>
#include<iterator>
#include<limits>
#include<list>
#include<map>
#include<memory>
#include<new>
#include<numeric>
#include<ostream>
#include<queue>
#include<set>
#include<sstream>
#include<stack>
#include<stdexcept>
#include<streambuf>
#include<string>
#include<typeinfo>
#include<utility>
#include<valarray>
#include<vector>
using namespace std;
typedef long long ll;
inline long long read()
{
long long tmptmp=0,f=1;
char tt=getchar();
while (!isdigit(tt))
{
if (tt=='-') f=-1;
tt=getchar();
}
while (isdigit(tt)) tmptmp=(tmptmp<<1)+(tmptmp<<3)-'0'+tt,tt=getchar();
return tmptmp*f;
}
inline void write(long long numnum)
{
static char buf[40];
static int len=-1;
if (numnum>=0)
do
{
buf[++len]=numnum%10+48,numnum/=10;
} while(numnum);
else
{
putchar('-');
do
{
buf[++len]=-(numnum%10)+48,numnum/=10;
} while(numnum);
}
while (len>=0)
putchar(buf[len--]);
}
inline void write(long long numnum,char cccc)
{
static char buf[40];
static int len=-1;
if (numnum>=0)
do
{
buf[++len]=numnum%10+48,numnum/=10;
} while(numnum);
else
{
putchar('-');
do
{
buf[++len]=-(numnum%10)+48,numnum/=10;
} while(numnum);
}
while (len>=0)
putchar(buf[len--]);
putchar(cccc);
}
struct edge
{
ll u,v,n,w;
} e[1000005];
ll h[500005],k,len,w,d[500005],ans;
bool vis[500005];
inline void add(int u,int v)
{
e[++len].u=u,e[len].v=v,e[len].n=h[u],h[u]=len;
}
inline void add(int u,int v,ll w)
{
e[++len].u=u,e[len].v=v,e[len].w=w,e[len].n=h[u],h[u]=len;
}
inline void dijk(int );
int main()
{
k=read();
ans=k;
for (int i=0;i<=k;++i)
for (int j=0;j<=9;++j)
add(i,(i*10+j)%k,j);
dijk(0);
write(ans);
return 0;
}
inline void dijk(int s)
{
memset(d,0x3f,sizeof(d));
memset(vis,0,sizeof(vis));
priority_queue<pair<ll,int> > q;
d[s]=0;
q.push(make_pair(0,s));
while (!q.empty())
{
int t=q.top().second;
q.pop();
if (vis[t])
continue;
vis[t]=1;
for (int b=h[t];b;b=e[b].n)
{
int v=e[b].v;
if (v==0 && t!=0)
ans=min(ans,d[t]+e[b].w);
if (d[v]>d[t]+e[b].w)
{
d[v]=d[t]+e[b].w;
q.push(make_pair(-d[v],v));
}
}
}
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 2e5 + 5)

struct Node {
int l, r;

bool operator < (const Node &oth) const {
return l == oth.l ? r > oth.r : l < oth.l;
}
} a[N];

int n, m;
priority_queue<int, vector<int>, greater<int> > q;
vector<int> extra;

int main() {
qread(n, m);
rep(i, 1, n) qread(a[i].l, a[i].r);
sort(a + 1, a + n + 1);
int nw = 1;
rep(i, 1, n) {
q.push(a[i].r);
if(nw <= m && nw <= a[i].l) ++nw;
else {
extra.pb(q.top());
q.pop();
}
} 
sort(all(extra), greater<int>());
int ed = m, ans = 0;
for(int x : extra) {
if(x <= ed && ed >= nw) --ed;
else ++ans;
}
cout << ans << endl;
return 0;
}
#include<bits/extc++.h>
#include<bits/stdc++.h>
//#define clock chrono1:steady_clock::now().time_since_epoch().count()
//#define x() real()
//#define y() imag()
#define int long long
//#define double long double

using namespace std;

using pii = pair<int, int>;
using pll = pair<long long, long long>;
using orderedSet = __gnu_pbds::tree<pii, __gnu_pbds::null_type, less<pii>,
__gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;

//order_of_key(x): number of items strictly smaller than x
//find_by_order(k): K-th element in a set (0-based)

signed main() {
ios::sync_with_stdio(false), cin.tie(NULL);

int n, k; cin >> n >> k;
vector<int> pre(n + 1, 0);
for(int i = 1; i <= n; i++) {
cin >> pre[i];
pre[i] += pre[i - 1];
}

int ans = 0;
orderedSet se;
int cnt = 0;
for(int i = 1; i <= n; i++) {
se.insert(make_pair(pre[i - 1] - k * i + k, cnt++));
ans += se.order_of_key(make_pair(pre[i] - k * i, cnt));
}

cout << ans << '\n';

return 0;
}

#include<bits/stdc++.h>
using namespace std;
#define re register
#define int long long
const int N=410,M=1e5+10,inf=0x7fffffff;

namespace MaxFlow{
int tot=1,head[N],cur[N],d[N];
int maxflow;
struct{int next,to,val;}edge[M];
inline void addedge(int from,int to,int val) {
edge[++tot].next=head[from]; edge[tot].to=to;edge[tot].val=val;head[from]=tot;
edge[++tot].next=head[to];edge[tot].to=from;edge[tot].val=0;head[to]=tot;
}

inline bool bfs(int s,int t){
memset(d,0,sizeof(d)); queue<int>q;
q.push(s); d[s]=1; cur[s]=head[s];
while(!q.empty()){
int u=q.front(); q.pop();
for(re int i=head[u];i;i=edge[i].next){
int v=edge[i].to;
if(edge[i].val&&!d[v]) cur[v]=head[v],d[v]=d[u]+1,q.push(v);
}
}
return d[t];
}

int dfs(int u,int in,int t){
if(u==t||in==0) return in;
int out=0;
for(re int i=cur[u];i&&in;i=edge[i].next){
cur[u]=i; int v=edge[i].to;
if(edge[i].val&&d[v]==d[u]+1){
int res=dfs(v,min(edge[i].val,in),t);
edge[i].val-=res,in-=res,edge[i^1].val+=res,out+=res;
if(in==0) break;
}
}
if(out==0) d[u]=0;
return out;
} 

inline void init(){tot=1, maxflow=0,memset(head,0,sizeof(head));}

inline void dinic(int s,int t){while(bfs(s,t)) maxflow+=dfs(s,inf,t);} 
}
using namespace MaxFlow;

inline int read(){
int x=0,f=1;char ch=getchar();
while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
return x*f;
}

const int _N=110;
int a[_N];

signed main(){
int n=read(),s=0,t=n+1,sum=0,tmp=0;
for(re int i=1;i<=n;++i) a[i]=read();
for(re int i=1;i<=n;++i)
for(re int j=2;i*j<=n;++j)
addedge(i,i*j,inf);
for(int i=1;i<=n;++i){
sum+=a[i];
if(a[i]>0) addedge(i,t,a[i]);
else addedge(s,i,-a[i]),tmp-=a[i];
}
dinic(s,t);
cout<<sum+tmp-maxflow;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define mp make_pair
#define si(x) int(x.size())
const int mod=998244353,MAX=2605;
const ll INF=1LL<<61;

int sz[MAX];
ll msum[MAX];
vector<int> G[MAX];

void make(int u){
for(int to:G[u]){
make(to);
sz[u]+=sz[to];
msum[u]+=msum[to];
}
}

const ll D=2550;

ll dpl[53][MAX],dpr[53][MAX];

int main() {

std::ifstream in("text.txt");
std::cin.rdbuf(in.rdbuf());
cin.tie(0);
ios::sync_with_stdio(false);

ll N,X,lim;cin>>N>>X>>lim;
for(int i=0;i<N;i++){
ll m,p;cin>>m;
msum[i]=m;
sz[i]=1;
if(i){
cin>>p;p--;
G[p].push_back(i);
}
}
make(0);

vector<pair<ll,int>> S(N);
for(int i=0;i<N;i++){
S[i]=mp(msum[i],sz[i]);
}
sort(all(S),[](auto a,auto b){
return a.fi*b.se>b.fi*a.se;
});

int n=-1;
for(int i=0;i<N;i++) if(S[i].se==N) n=i;

if(lim==0){
ll can=X/S[n].fi;
cout<<can*S[n].se<<endl;
return 0;
}

//for(int i=0;i<N;i++) cout<<S[i].fi<<" "<<S[i].se<<endl;

for(int i=0;i<53;i++) for(int j=0;j<MAX;j++) dpl[i][j]=dpr[i][j]=INF;
dpl[0][0]=0;
for(int i=0;i<N;i++){
ll w=S[i].fi,v=S[i].se;
for(int j=0;j<=D;j++){
for(int k=0;k<=min(N,lim);k++){
if(j-k*v>=0) chmin(dpl[i+1][j],dpl[i][j-k*v]+w*k);
}
}
}
dpr[N+1][D]=0;
for(int i=N;i>=1;i--){
ll w=S[i-1].fi,v=S[i-1].se;
for(int j=D;j>=0;j--){
for(int k=0;k<=min(N,lim);k++){
if(j+k*v<=D) chmin(dpr[i][j],dpr[i+1][j+k*v]-w*k);
}
}
}

ll ans=0;

for(int i=n;i<N;i++){
if(i+1<N){
ll wsum=0,vsum=0;
for(int j=i+2;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+3][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+3][b];
if(W>X) continue;
ll V=vsum+a-(D-b);
ll can=min(lim,(X-W)/(S[i+1].fi));
chmax(ans,V+can*S[i+1].se);
}
}
}

}
{
ll wsum=0,vsum=0;
for(int j=i+1;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[i+1][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[i+2][b]==INF) continue;
ll W=wsum+dpl[i+1][a]+dpr[i+2][b];
if(W>X) continue;
ll V=vsum+a-(D-b);
chmax(ans,V);
}
}
}
}
}

{
ll wsum=0,vsum=0;
for(int j=n+1;j<N;j++){
if(S[j].fi<=INF/lim){
wsum+=S[j].fi*lim;
vsum+=S[j].se*lim;
chmin(wsum,INF);
}else{
wsum=INF;
break;
}
}
if(wsum<INF){
for(int a=0;a<=D;a++){
if(dpl[n][a]==INF) continue;
for(int b=0;b<=D;b++){
if(dpr[n+2][b]==INF) continue;
ll W=wsum+dpl[n][a]+dpr[n+2][b];
if(W>X) continue;
ll V=vsum+a-(D-b);
ll can=(X-W)/(S[n].fi);
chmax(ans,V+can*S[n].se);
}
}
}
}

cout<<ans<<endl;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*

*/

int main(){
cincout();

ll N, M;
cin >> N >> M;
ll ans = 0;

// 1,2
ll add = min(N, M/2);
ans += add;
N-=add;
M-=add*2;

// 0,4
ans += M/4;
cout << ans << endl;
}
#include <bits/stdc++.h>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
#endif
using ll = long long;
using ld = long double;
using ull = unsigned long long;
#define endl "\n"
typedef pair<int,int> Pii;
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))
#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)
#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)
#define ALL(x) begin(x), end(x)
#define PB push_back
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(s) (s).begin(),(s).end()
#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)
#define drep(i, n) drep2(i, n, 0)
#define rever(vec) reverse(vec.begin(), vec.end())
#define sor(vec) sort(vec.begin(), vec.end())
#define fi first
#define se second
#define pb push_back
//#define P pair<ll,ll>
#define PQminll priority_queue<ll, vector<ll>, greater<ll>>
#define PQmaxll priority_queue<ll,vector<ll>,less<ll>>
#define PQminP priority_queue<P, vector<P>, greater<P>>
#define PQmaxP priority_queue<P,vector<P>,less<P>>
#define NP next_permutation
typedef string::const_iterator State;
class ParseError {};
//const ll mod = 1000000009;
const ll mod = 998244353;
//const ll mod = 1000000007;
const ll inf = 4100000000000000000ll;
const ld eps = ld(0.00000000000001);
const long double pi = 3.141592653589793;
template<class T>void vcin(vector<T> &n){for(int i=0;i<int(n.size());i++) cin>>n[i];}
template<class T,class K>void vcin(vector<T> &n,vector<K> &m){for(int i=0;i<int(n.size());i++) cin>>n[i]>>m[i];}
template<class T>void vcout(vector<T> &n){for(int i=0;i<int(n.size());i++){cout<<n[i]<<" ";}cout<<endl;}
template<class T>void vcin(vector<vector<T>> &n){for(int i=0;i<int(n.size());i++){for(int j=0;j<int(n[i].size());j++){cin>>n[i][j];}}}
template<class T>void vcout(vector<vector<T>> &n){for(int i=0;i<int(n.size());i++){for(int j=0;j<int(n[i].size());j++){cout<<n[i][j]<<" ";}cout<<endl;}cout<<endl;}
void yes(bool a){cout<<(a?"yes":"no")<<endl;}
void YES(bool a){cout<<(a?"YES":"NO")<<endl;}
void Yes(bool a){cout<<(a?"Yes":"No")<<endl;}
void possible(bool a){ cout<<(a?"possible":"impossible")<<endl; }
void Possible(bool a){ cout<<(a?"Possible":"Impossible")<<endl; }
void POSSIBLE(bool a){ cout<<(a?"POSSIBLE":"IMPOSSIBLE")<<endl; }
template<class T>void print(T a){cout<<a<<endl;}
template<class T>auto min(const T& a){ return *min_element(all(a)); }
template<class T>auto max(const T& a){ return *max_element(all(a)); }
template<class T,class F>void print(pair<T,F> a){cout<<a.fi<<" "<<a.se<<endl;}
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0;}
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0;}
template<class T> void ifmin(T t,T u){if(t>u){cout<<-1<<endl;}else{cout<<t<<endl;}}
template<class T> void ifmax(T t,T u){if(t>u){cout<<-1<<endl;}else{cout<<t<<endl;}}
ll fastgcd(ll u,ll v){ll shl=0;while(u&&v&&u!=v){bool eu=!(u&1);bool ev=!(v&1);if(eu&&ev){++shl;u>>=1;v>>=1;}else if(eu&&!ev){u>>=1;}else if(!eu&&ev){v>>=1;}else if(u>=v){u=(u-v)>>1;}else{ll tmp=u;u=(v-u)>>1;v=tmp;}}return !u?v<<shl:u<<shl;}
ll modPow(ll a, ll n, ll mod) { if(mod==1) return 0;ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }
vector<ll> divisor(ll x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++){ if(x % i == 0) {ans.push_back(i); if(i*i!=x){ ans.push_back(x / ans[i]);}}}sor(ans); return ans; }
ll pop(ll x){return __builtin_popcountll(x);}
ll poplong(ll x){ll y=-1;while(x){x/=2;y++;}return y;}

void cincout() {
ios::sync_with_stdio(false);
std::cin.tie(nullptr);
cout<< fixed << setprecision(20);
}

int main() {
cincout();
ll a,b,c;
cin>>a>>b>>c;
for(int i=0;i<=100;i++){
if(i>=a&&i>=b&&i>=c){
ll ans=3*i-a-b-c;
if(ans%2==0){
cout<<ans/2<<endl;
return 0;
}
}
}
}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int dist(int x1, int y1, int x2, int y2)
{
return abs(x1 - x2) + abs(y1 - y2);
}

int main(){
#ifdef LOCAL
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
freopen("error.txt", "w", stderr);
#endif
cin.tie(0) -> ios_base::sync_with_stdio(0);

int n;
cin >> n;
vector<int> t(n+1);
vector<pair<int,int>> x(n+1);
t[0] = 0, x[0].first = 0, x[0].second = 0;
for(int i=1;i<=n;i++)
cin >> t[i] >> x[i].first >> x[i].second;
bool ok = 1;
for(int i=1;i<=n;i++)
{
int d = dist(x[i].first, x[i].second, x[i-1].first, x[i-1].second);
if(t[i] - t[i-1] > d && ((t[i] - t[i-1]) - d) & 1) {
ok = 0;
} else if(t[i] - t[i-1] < d) ok = 0;
}
if(ok) puts("Yes");
else puts("No");


}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll infl = 1LL << 60;
ll ans = infl;

void solve(ll h, ll w) {
for (ll i = 1; i < h; ++i) {
ll s1 = i*w, s2 = (h-i)/2*w, s3 = (h-i+1)/2*w;
ll diff = max(abs(s1-s2), max(abs(s1-s3), abs(s2-s3)));
ans = min(ans, diff);

s2 = w/2*(h-i);
s3 = (w+1)/2*(h-i);
diff = max(abs(s1-s2), max(abs(s1-s3), abs(s2-s3)));
ans = min(ans, diff);
}

}

int main()
{
ll h ,w;
cin >> h >> w;

solve(h, w);
solve(w, h);

cout << ans << endl;
return 0;
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

def(N, int, 1e5 + 5)

struct Node {
int x, y, id;

bool operator < (const Node &oth) const {
return x < oth.x;
}
} a[N], b[N];

int n, ida, idb, dis;
int idcnt;
bool vis[N];
map<int, int> id;
set<Node> ss[N << 1], sd[N << 1];
queue<int> q;
map<int, int> cnt1, cnt2;
map<pii, bool> has;

void Push(int x) {
if(vis[x]) return ;
vis[x] = 1;
q.push(x);
ss[id[a[x].x + a[x].y]].erase(a[x]);
sd[id[a[x].x - a[x].y]].erase(a[x]);
}

ll calc() {
ll ret = 0;
int cnt = 0;
rep(i, 1, n) if(vis[i]) b[++cnt] = a[i];
sort(b + 1, b + cnt + 1);
int nw = 1;
rep(i, 1, cnt) {
while(b[nw].x < b[i].x - dis) --cnt1[b[nw].x + b[nw].y], --cnt2[b[nw].x - b[nw].y], ++nw;
ret += cnt1[b[i].x + b[i].y - dis] + cnt2[b[i].x - b[i].y - dis];
++cnt1[b[i].x + b[i].y]; ++cnt2[b[i].x - b[i].y];
if(has[mp(b[i].x - dis, b[i].y)]) --ret;
has[mp(b[i].x, b[i].y)] = 1;
}
return ret;
}

int main() {
qread(n, ida, idb);
rep(i, 1, n) {
qread(a[i].x, a[i].y);
a[i].id = i;
if(!id[a[i].x + a[i].y]) {
id[a[i].x + a[i].y] = ++idcnt;
ss[idcnt].insert(a[i]);
}
else ss[id[a[i].x + a[i].y]].insert(a[i]);

if(!id[a[i].x - a[i].y]) {
id[a[i].x - a[i].y] = ++idcnt;
sd[idcnt].insert(a[i]);
} 
else sd[id[a[i].x - a[i].y]].insert(a[i]);
}
dis = abs(a[ida].x - a[idb].x) + abs(a[ida].y - a[idb].y);
Push(ida), Push(idb);
set<Node> It it; int nw;
while(!q.empty()) {
int u = q.front();
q.pop();
// cout << "now : " << u << endl;

// 1
nw = id[a[u].x + a[u].y + dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].end()) {
// cout << "1 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 3
nw = id[a[u].x + a[u].y - dis];
it = ss[nw].lower_bound(a[u]);
while(it != ss[nw].begin()) {
--it;
// cout << "3 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = ss[nw].lower_bound(a[u]);
}

// 2
nw = id[a[u].x - a[u].y - dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].begin()) {
--it;
// cout << "2 : " << it -> id << endl;
if(it -> y < a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// 4
nw = id[a[u].x - a[u].y + dis];
it = sd[nw].lower_bound(a[u]);
while(it != sd[nw].end()) {
// cout << "4 : " << it -> id << endl;
if(it -> y > a[u].y) break;
Push(it -> id);
it = sd[nw].lower_bound(a[u]);
}

// cout << endl;
}
// rep(i, 1, n) cout << vis[i] << " \n"[i == n];
cout << calc() << endl;
return 0;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include <bits/stdc++.h>

#include <atcoder/maxflow>
#include <atcoder/modint>
using namespace atcoder;
using namespace std;
#define REP(i, m, n) for (int64_t i = (int64_t)(m); i < (int64_t)(n); i++)
#define rep(i, n) REP(i, 0, n)
#define rep1(i, n) for (int64_t i = 1; i <= (int)(n); i++)
#define rrep(i, n) for (int64_t i = (n - 1); i >= 0; i--)
#define rrep1(i, n) for (int64_t i = (n); i > 0; i--)
#define all(v) v.begin(), v.end()
using vi = vector<int64_t>;
using vvi = vector<vi>;
using vb = vector<bool>;
using vvb = vector<vb>;
using vc = vector<char>;
using vvc = vector<vc>;
using vs = vector<string>;
using vvs = vector<vs>;
using vd = vector<long double>;
using vvd = vector<vd>;
using pii = pair<int64_t, int64_t>;
using vp = vector<pii>;
using vvp = vector<vp>;
using mint = modint998244353;
using vm = vector<mint>;
using vvm = vector<vm>;
using mii = map<int64_t, int64_t>;
using pdi = pair<long double, int64_t>;
const int64_t INF = 3e18;
const vi dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};

template <typename T>
bool chmax(T &a, const T &b) {
if (a < b) {
a = b;
return true;
}
return false;
}

template <typename T>
bool chmin(T &a, const T &b) {
if (a > b) {
a = b;
return true;
}
return false;
}

int64_t to_int(char c) { return c - '0'; }

int main() {
int64_t n;
cin >> n;
vi a(n), b(n);
rep(i, n) cin >> a[i] >> b[i];

int64_t ans = 0, minimum = INF;
rep(i, n) {
ans += a[i];
if (a[i] > b[i]) chmin(minimum, b[i]);
}

if (minimum == INF)
ans = 0;
else
ans -= minimum;

cout << ans << endl;
}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> 
#include <ext/pb_ds/detail/standard_policies.hpp>
using namespace __gnu_pbds;
using namespace std;
#define getbit(n, i) (((n) & (1LL << (i))) != 0) 
#define setbit0(n, i) ((n) & (~(1LL << (i)))) 
#define setbit1(n, i) ((n) | (1LL << (i))) 
#define togglebit(n, i) ((n) ^ (1LL << (i))) 
#define lastone(n) ((n) & (-(n))) 
char gap = 32;
#define int long long
#define ll long long 
#define lll __int128_t
#define pb push_back
typedef tree<
int,
null_type,
less<int>,
rb_tree_tag,
tree_order_statistics_node_update>
ordered_set;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
ll hashPrime = 1610612741;

signed main(){
ios_base::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
string s, t;
cin >> s >> t;
int sz1 = s.size();
int sz2 = t.size();
int cumsum1[sz1 + 1];
int cumsum2[sz2 + 1];
memset(cumsum1, 0, sizeof(cumsum1));
memset(cumsum2, 0, sizeof(cumsum2));
for(int i = 1; i <= sz1; i++) {
if(s[i - 1] == 'A') cumsum1[i] = cumsum1[i - 1] + 2;
else cumsum1[i] = cumsum1[i - 1] + 1;
}
for(int i = 1; i <= sz2; i++) {
if(t[i - 1] == 'A') cumsum2[i] = cumsum2[i - 1] + 2;
else cumsum2[i] = cumsum2[i - 1] + 1;
}
int q;
cin >> q;
while(q--) {
int a, b, c, d;
cin >> a >> b >> c >> d;
int temp1 = cumsum1[b] - cumsum1[a - 1];
int temp2 = cumsum2[d] - cumsum2[c - 1];
if(abs(temp1 - temp2) % 3 == 0) {
cout << "YES\n";
}
else {
cout << "NO\n";
}
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
int64_t N, T;
cin >> N >> T;
int64_t INF = 100000000000000;
vector<int64_t> t(N);
for (int i = 0; i < N; i++)cin >> t.at(i);
t.push_back(INF);
int64_t Tbegin = 0, Tend = T, now = 0, ans = 0;

for (int i = 0; now!=INF; i++) {
auto iter=prev(lower_bound(t.begin(), t.end(), Tend));
int ti = *iter;
if (ti!=now) {
now = ti;
Tend = ti + T;
}
else {
ans += Tend - Tbegin;
now = *(++iter);
Tbegin = now;
Tend = now + T;
}
}
cout << ans << endl;
return 0;
}
//#define _GLIBCXX_DEBUG
#pragma GCC target("avx")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")

#include <bits/stdc++.h>
using namespace std;
#if __has_include(<atcoder/all>)
#include <atcoder/all>
using namespace atcoder;
using mint = modint998244353;
#endif

using ll = long long;
using ld = long double;
using vi = vector<int>;
using vll = vector<ll>;
using vii = vector<vector<int>>; 
using vvll = vector<vector<ll>>;
const ll INF = 1ll<<60;
const ld EPS = 1.0/1e9;
#define endl "\n"
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)
#define all(x) (x).begin(),(x).end()
#define del(x) sort(all(x)); x.erase(unique(all(x)),x.end());

#define DEBUG_

template <typename T>
istream &operator>>(istream &is, vector<T> &vec) {
for (T &x : vec) is >> x;
return is;
}
template<typename T>
ostream& operator << (ostream &os, vector<T>& vec){
os << "{";
for(int i=0;i<vec.size();i++){
os << vec[i] << (i+1==vec.size() ? "" : ", ");
}
os << "}";
return os;
}
template <typename T, typename U>
ostream &operator<<(ostream &os, pair<T, U> &pair_var) {
os << "(" << pair_var.first << ", " << pair_var.second << ")";
return os;
}
template <typename T, typename U>
ostream &operator<<(ostream &os, map<T, U> &map_var) {
os << "{";
repi(itr, map_var) {
os << *itr;
itr++;
if (itr != map_var.end()) os << ", ";
itr--;
}
os << "}";
return os;
}
template <typename T>
ostream &operator<<(ostream &os, set<T> &set_var) {
os << "{";
repi(itr, set_var) {
os << *itr;
itr++;
if (itr != set_var.end()) os << ", ";
itr--;
}
os << "}";
return os;
}

#define DUMPOUT cerr

void dump_func() {
DUMPOUT << endl;
}
template <class Head, class... Tail>
void dump_func(Head &&head, Tail &&... tail) {
DUMPOUT << head;
if (sizeof...(Tail) > 0) {
DUMPOUT << ", ";
}
dump_func(std::move(tail)...);
}
#ifdef DEBUG_
#define DEB
#define dump(...)                                                              \
DUMPOUT << "  " << string(#__VA_ARGS__) << ": "                            \
<< "[" << to_string(__LINE__) << ":" << __FUNCTION__ << "]"        \
<< endl                                                            \
<< "    ",                                                         \
dump_func(__VA_ARGS__)
#else
#define DEB if (false)
#define dump(...)
#endif


int main(){
ios_base::sync_with_stdio(0);
cin.tie(0);
ll n; cin >> n;
vll a(n); cin >> a;
a.insert(a.begin(),0);
a.insert(a.end(),0);
dump(a);
vector<ll>diff(n+1);
ll sum=0;
rep(i,1,n+1){
sum += abs(a[i]-a[i-1]);
diff[i-1]=abs(a[i+1]-a[i])+abs(a[i]-a[i-1])-abs(a[i+1]-a[i-1]);
}
sum += abs(a[n+1]-a[n]);
rep(i,0,n){
cout << sum - diff[i] << endl;
}
}
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
//#pragma GCC target("avx2,fma")
#define rep(i,l,r) for (int i = l; i < r; i++)
#define repr(i,r,l) for (int i = r; i >= l; i--)
#define X first
#define Y second
#define pb push_back
#define endl '\n'
#define debug(x) cerr << #x << " : " << x << endl;
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pll;
const long long int N = 7e5+20,mod = 1e9+7,inf = 1e18,sq = 500;
inline int mkay(int a,int b){
if (a+b >= mod) return a+b-mod;
return a+b;
}
inline int poww(int a,int k){
int z = 1;
while (k){
if (k&1) z = 1ll*z*a%mod;
a = 1ll*a*a%mod;
k >>= 1;
}
return z;
}
int main(){
ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
int n,k;
cin >> n >> k;
int t = n/k;
ll ans = 0;
ans += t;
ans += 1ll*t*(t-1)*3;
ans += 1ll*t*(t-1)*(t-2);
if ((k&1) == 0){
if (n%k >= k/2) t++;
ans += t;
ans += 1ll*t*(t-1)*3;
ans += 1ll*t*(t-1)*(t-2);
}
cout << ans;

}

#include<bits/stdc++.h>
using namespace std;
int main(){
int h,w,n;
cin>>h>>w>>n;
vector<int> a(n);
for(int i=0;i<n;i++) cin>>a[i];
int cur=0;
for(int i=0;i<h;i++){
vector<int> s;
for(int j=0;j<w;j++){
if(a[cur]){
s.push_back(cur+1);
a[cur]--;
}else{
cur++;
s.push_back(cur+1);
a[cur]--;
}
}
if(i%2){
reverse(s.begin(),s.end());
}
for(int i=0;i<w;i++) cout<<s[i]<<" ";
cout<<endl;
}
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <unordered_map>

using namespace std;

int goodSequence(vector<long long>& seq) {
unordered_map<long long, int> mp;
int delta = 0;
for (long long val : seq) {
mp[val]++;
}

for (pair<long long, int> entry : mp) {
if (entry.first != entry.second) {
delta += (entry.second > entry.first) ? entry.second - entry.first : entry.second;
}
}
return delta;
}

int main() {
int N;
int i = 0;
cin >> N;
vector<long long> seq(N);
while (N--) {
cin >> seq[i++];
}
cout << goodSequence(seq);
return 0;
}
#include <bits/stdc++.h>
using namespace std;

/*
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, 
rb_tree_tag, tree_order_statistics_node_update>;
*/

#define MOD 1000000007
typedef long long ll;
//#define int ll 

typedef pair<int, int> ii;
typedef vector<ll> vi;
typedef vector<bool> vb;
typedef vector<vi> vvi;
typedef vector<ii> vii;
typedef vector<vii> vvii;
#define ff first
#define ss second
#define pb push_back
#define all(s) s.begin(), s.end()
#define tc int t; cin>>t; while(t--)
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
#define file_read(x,y) freopen(x, "r", stdin); \
freopen(y, "w", stdout);
#define fightFight cin.tie(0) -> sync_with_stdio(0)
#define show_vi(a)        \
cout << #a << "-->";  \
for (auto &x : a) cout << x << " "; \
cout << endl;
#define MAXN (1e5 + 5)
int main(){
fightFight;
int n;	
cin >> n;
vi arr(n);
for (auto& s : arr) cin >> s;
vii a(MAXN, {0,0}), b(MAXN, {0,0});
for (int i = 0; i < MAXN; i++) {
a[i].ss = i;
b[i].ss = i;
}
for (int i = 0; i < n; i += 2) {
a[arr[i]].ff++;
}
for (int i = 1; i < n; i += 2) {
b[arr[i]].ff++;
}
sort(all(a), greater<>());
sort(all(b), greater<>());
ll ans = 0;
if (a[0].ss != b[0].ss) {
ans = n - a[0].ff - b[0].ff;
}
else {
ans = n - max(a[0].ff + b[1].ff, a[1].ff + b[0].ff);
}
cout << ans << "\n";
}

#include <bits/stdc++.h>
using namespace std;

int main(){

ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

int n;cin>>n;
vector<int> a(26,50), b(26,0);
for(int i=0;i<n;i++){
b=vector<int> (26,0);

string s;cin>>s;
for(int j=0;j<(int)s.length();j++)
b[s[j]-'a']++;

for(int j=0;j<26;j++)	a[j]=min(a[j], b[j]);
}

for(int i=0;i<26;i++)
for(int j=1;j<=a[i];j++)	cout<<(char)('a'+i);

return 0;	

}
#include <bits/stdc++.h>
#define int long long
#define Mid ((l + r) / 2)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
const int N = 1e6 + 1009;
const int mod = 1e9 + 7;
int n, m, k, inv[N], fac[N], pw[N];
void init() {
inv[0] = inv[1] = fac[0] = fac[1] = 1;
for(int i = 2; i < N; i++) fac[i] = fac[i - 1] * i % mod;
for(int i = 2; i < N; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
for(int i = 2; i < N; i++) inv[i] = inv[i - 1] * inv[i] % mod;
pw[0] = 1;
for(int i = 1; i < N; i++) pw[i] = pw[i - 1] * 3 % mod;
}
int C(int n, int m) {
if(m < 0 || m > n) return 0;
return fac[n] * inv[n - m] % mod * inv[m] % mod;
}
signed main() {
#ifndef ONLINE_JUDGE
freopen("data.in", "r", stdin);
freopen("data.out", "w", stdout);
#endif
ios::sync_with_stdio(0);
cin.tie(0);
cin >> n >> m >> k;
int ans = 0;
init();
int s = 1;
for(int i = n; i <= n + m + k; i++) {
ans = (ans + s * pw[n + m + k - i] % mod * C(i - 1, n - 1) % mod) % mod;
if(0 >= i + 1 - n - k && i + 1 - n <= m) s = s * 2 % mod;
else if(i + 1 - n - k <= 0 && i + 1 - n > m) s = ((s * 2 - C(i - n, m)) % mod + mod) % mod;
else if(i + 1 - n - k > 0 && i + 1 - n <= m) s = ((s * 2 - C(i - n, i - n - k)) % mod + mod) % mod;
else s = (((s * 2 - C(i - n, m)) % mod - C(i - n, i - n - k)) % mod + mod) % mod;
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)
using namespace std;

typedef long long ll;

int main() {
int N, K;
cin >> N >> K;

ll ans = 0;
rep2(b, K + 1, N + 1) {
int p = (N + 1) / b;
ans += p * (b - K);
if(p > 0 && K == 0) ans--;

ans += max(0, (N+1)%b - K);
}

cout << ans << endl;

return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,k,a[maxn],minn,maxx,pos,q;
bool dir;

void add(int val){
if(minn+val>=k) minn=maxx=pos=k;
else if(maxx+val<=k) minn+=val,maxx+=val;
else minn+=val,maxx=k;
}

void sub(int val){
if(maxx-val<=0) minn=maxx=0,pos=k;
else if(minn-val>=0) minn-=val,maxx-=val;
else pos+=val-minn,minn=0,maxx-=val;
}

void orzck(){
cin >> k >> n;
rep(n) cin >> a[i];
minn=0,maxx=k,pos=0;
vector<int> vec;
rep(n) vec.pb(a[n-1-i]);
int cur=0;
cin >> q;
while(q--){
int t,x;
cin >> t >> x;
while(1){
if(sz(vec)&&vec.back()<t){
if(dir) add(vec.back()-cur);
else sub(vec.back()-cur);
cur=vec.back();
vec.pop_back();
dir^=1;
}
else{
if(dir) add(t-cur);
else sub(t-cur);
cur=t;
break;
}
}
if(x<=pos) print(minn);
else if(x>=pos+(maxx-minn)) print(maxx);
else print(minn+x-pos);
}
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef double db;
#define pairll pair<ll,ll>
#define lpairll pair<ll, pairll>

#define fr first
#define sc second
#define pb push_back
#define mp make_pair
#define repp(i,a,b) for(ll i = (a); i <= (b); i++)
#define repm(i, a, b) for (ll i = (a); i >= (b); i--)
#define repz(i, a, b) for (ll i = (a); i < (b); i++)

const ll MOD = 1e9+7, N = 2e5 + 5, M = 1e6+5, INF = 1e18;

ll tc = 1, n, m=0, vis[N], k, ar[N], idx;
string ye = "YES", no = "NO", s, t, s1, s2, op;
set<ll> stz;
vector<ll> v;

void fastt(){
ios_base::sync_with_stdio(0);
cin.tie(NULL); 
cout.tie(NULL);
}

void input(){
cin >> n >> k;
repp(i,1,n){
cin >> ar[i];
if(ar[i] == 1) idx = i;
}
}

void solve(){
ll ans = n, l = max(1LL,idx-k+1), r = min(n,idx+k-1);
k--;
if(!k){
cout << n << endl;
return;
}
repp(i,l,r){
ll L = i, R = i+k;
ll sum = 1, dl = i-1, dr = n-R;
sum += (dl+k-1)/(k);
sum += (dr+k-1)/(k);
ans = min(ans,sum);
}
cout << ans << endl;
}

int main(){
fastt();
//cin >> tc;
while(tc--){
input();
solve();
}
}

/*

*/
#include<bits/stdc++.h>
using namespace std;

int n;
long long a[2][100010];

int main() {
scanf("%d",&n);
for(int i=1;i<=n;i++) scanf("%lld",&a[0][i]),a[0][i]=a[0][i-1]+a[0][i];
for(int i=1;i<=n;i++) scanf("%lld",&a[1][i]),a[1][i]=a[1][i-1]+a[1][i];
long long ans=0;
for(int i=1;i<=n;i++) ans=max(ans,a[0][i]+a[1][n]-a[1][i-1]);
printf("%lld\n",ans);
return 0;
}

#include <bits/stdc++.h>
#include <algorithm>
#include <functional>
#include <cmath>
#include<string>
//#include <atcoder/all>
#define _GLIBCXX_DEBUG
#define all(v) v.begin(),v.end()
#define emp " "
#define rep(i,l,n) for(ll i = l; i < (ll)(n); i++)
using namespace std;
//using namespace atcoder;
using ll = long long;
using vs = vector<string>;
using vi = vector<ll>;
using mii = map<ll,ll>;
using vb = vector<bool>;
using Graph = vector<vector<int>>;
ll mod = 1000000007;

struct num {
ll x;
ll y;

num(ll a,ll b) {
x = a;
y = b;
}
};


int main() {
cout << fixed << setprecision(10);

ll n;
cin >> n;

vi b;

ll cnt = 0;

rep(i,0,n) {

cnt++;
ll a;
cin >> a;


if(cnt % 2) {
b.push_back(a);
}
else {
b.insert(b.begin(),a);
}


/*	for(auto x : b) {
cout << x << emp;
}
cout << endl;*/

}


if(cnt % 2) {
reverse(b.begin(),b.end());
}

rep(i,0,b.size()) {
if(i + 1 == b.size()) {
cout << b[i] << endl;
}
else {
cout << b[i] << emp;
}
}





return 0;
}

#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<assert.h>
#include<random>
#include<string>
#include<algorithm>
#include<queue>
#include<bitset>

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()

const long long mod = 1e9 + 7;
const long long inf = 1e18;
const int N = 100010;

using ll = long long;

using namespace std;

ll a[N];

void solve()
{
int n, t;
cin >> n >> t;

for (int i = 0; i < n; i++)
cin >> a[i];

ll _m = inf;
ll _ans = -inf, cnt = 0;

for (int i = 0; i < n; i++)
{
if (_ans < a[i] - _m)
{
_ans = a[i] - _m;
cnt = 1;
}
else if (_ans == a[i] - _m)
{
cnt++;
}
_m = min(_m, a[i]);
}

cout << cnt << '\n';
}

signed main()
{
ios_base::sync_with_stdio(0);
cin.tie(0);

solve();

return 0;
}
#include <bits/stdc++.h>
namespace mystd {
inline int read() {
char c = getchar();
int x = 0, f = 1;
while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
return x * f;
}
inline void write(int x) {
if (x < 0) x = ~(x - 1), putchar('-');
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}
}
using namespace std;
using namespace mystd;

const int inf = __INT_MAX__;
const int maxn = 2020;
int n, c[maxn << 1], s[maxn << 1];
int pw[maxn], pb[maxn], ww[maxn][maxn], wb[maxn][maxn], dp[maxn][maxn];

int main() {
n = read();
for (int i = 1; i <= n << 1; i++) {
scanf("%s", s), s[i] = read();
c[i] = s[0] == 'B';
}
for (int i = 1; i <= n << 1; i++) {
if (c[i]) pb[s[i]] = i;
else pw[s[i]] = i;
}
for (int i = 0; i <= n - 1; i++) {
for (int j = 1; j <= i; j++) {
ww[i][0] += pw[j] > pw[i + 1];
wb[0][i] += pb[j] > pb[i + 1];
}
}
for (int i = 0; i <= n; i++) {
for (int j = 1; j <= n; j++) {
wb[j][i] += wb[j - 1][i] + (pw[j] > pb[i + 1]);
ww[i][j] += ww[i][j - 1] + (pb[j] > pw[i + 1]);
}
}
for (int i = 0; i <= n; i++) {
for (int j = 0; j <= n; j++) {
dp[i][j] = inf * (i != 0 || j != 0);
if (i) dp[i][j] = min(dp[i - 1][j] + ww[i - 1][j], dp[i][j]);
if (j) dp[i][j] = min(dp[i][j - 1] + wb[i][j - 1], dp[i][j]);
}
}
write(dp[n][n]);
return 0;
}

#include<bits/stdc++.h>
#define ll long long
#define Il inline
#define Re register
#define mem(u,v) memset(u,v,sizeof(u))
#define rep(i,a,b) for(Re ll i=(a);i<=(b);i++)
#define drep(i,a,b) for(Re ll i=(a);i>=(b);i--)
#define go(u) for(ll i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)
#define _go(u) for(ll i=Head[u],v=E[i].to;i;i=E[i].nxt,v=E[i].to)
#define writesp(x) write(x),putchar(' ')
#define writeln(x) write(x),puts("")
using namespace std;
Il ll read(){ll sum=0,f=0;char ch=getchar();for(;!isdigit(ch);ch=getchar())f|=(ch=='-');for(;isdigit(ch);ch=getchar())sum=((sum<<1)+(sum<<3)+(ch^48));return f?-sum:sum;}
void write(const ll x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar(x%10+'0');}
#define N 550000
ll n,a[N],l[N],r[N],tmp[N],kk,kkk,c[N],ans;bool vis[N];
ll lb(ll x){return x&(-x);}
void ad(ll x,ll k){for(ll i=x;i<=n;i+=lb(i))c[i]+=k;}
ll gs(ll x){ll sum=0;for(ll i=x;i>0;i-=lb(i))sum+=c[i];return sum;}
int main(){
n=read();rep(i,1,n)l[i]=read(),r[i]=read();
rep(i,1,n-1)if(l[i]>l[i+1])return puts("-1"),0;
rep(i,1,n-1)if(r[i]>r[i+1])return puts("-1"),0;
a[1]=r[1];a[n]=l[n];
drep(i,n-1,1)if(l[i]<l[i+1])a[i]=l[i];
rep(i,2,n)if(r[i-1]<r[i])a[i]=r[i];
rep(i,1,n)vis[a[i]]=1;
rep(i,1,n)if(!vis[i])tmp[++kkk]=i;
rep(i,1,n)if(!a[i])a[i]=tmp[++kk];
rep(i,1,n)vis[i]=0;vis[0]=1;
rep(i,1,n){if(vis[a[i]])return puts("-1"),0;vis[a[i]]=1;}
//	rep(i,1,n)cout<<a[i]<<' ';puts("");
ll tmp=0;
rep(i,1,n){tmp=max(tmp,a[i]);if(tmp!=r[i])return puts("-1"),0;}
tmp=998244353123;
drep(i,n,1){tmp=min(tmp,a[i]);if(tmp!=l[i])return puts("-1"),0;}
//	rep(i,1,n)cout<<a[i]<<' ';puts("");
drep(i,n,1)ans+=gs(a[i]),ad(a[i],1);
writeln(ans);
}///asd
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i = 0; i < (n); i++)
#define rep1(i, n) for(int i = 1; i <= (n); i++)
#define co(x) cout << (x) << "\n"
#define cosp(x) cout << (x) << " "
#define ce(x) cerr << (x) << "\n"
#define cesp(x) cerr << (x) << " "
#define pb push_back
#define mp make_pair
#define Would
#define you
#define please

//なんこれ？

const int cm = 1 << 17;
char cn[cm], * ci = cn + cm, ct;
inline char getcha() {
if (ci - cn == cm) { fread_unlocked(cn, 1, cm, stdin); ci = cn; }
return *ci++;
}
inline int getint() {
int A = 0;
if (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';
else while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';
return A;
}

const int dm = 1 << 21;
char dn[dm], * di = dn;

int main() {
cin.tie(0);
ios::sync_with_stdio(false);


int N = getint();
int X[200000], X2[200000];
rep(i, N) X2[i] = (X[i] = getint());

//int L = 0;
//int R = 1e9 + 1;
//while (L < R) {
//	int H = (L + R) / 2;
//	int k = 0;
//	rep(i, N) k += X[i] <= H;
//	if (k < N / 2) L = H + 1;
//	else R = H;
//}
//int L2 = L;
//int R2 = 1e9 + 1;
//while (L2 < R2) {
//	int H = (L2 + R2) / 2;
//	int k = 0;
//	rep(i, N) k += X[i] <= H;
//	if (k < N / 2 + 1) L2 = H + 1;
//	else R2 = H;
//}

nth_element(X, X + N / 2, X + N);
nth_element(X, X + N / 2 - 1, X + N / 2);
int L = X[N / 2 - 1];
int L2 = X[N / 2];
int K = L;
int keta1 = 0, keta2 = 0;
char C1[10], C2[10];
while (L) {
*(C1 + keta1) = '0' + L % 10;
L /= 10;
keta1++;
}
while (L2) {
*(C2 + keta2) = '0' + L2 % 10;
L2 /= 10;
keta2++;
}

rep(i, N) {
if (X2[i] > K) {
for (int i = keta1 - 1; i >= 0; i--)* di++ = (*(C1 + i));
*di++ = '\n';
}
else {
for (int i = keta2 - 1; i >= 0; i--)* di++ = (*(C2 + i));
*di++ = '\n';
}
}

fwrite_unlocked(dn, di - dn, 1, stdout);

Would you please return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
ll x=0;
bool f=0;
char c=getchar();
while(!isdigit(c)){
if(c=='-') f=1;
c=getchar();
}
while(isdigit(c)){
x=x*10+c-'0';
c=getchar();
}
return f?-x:x;
}
const int maxn=1e3+5,maxm=2e5+5;
int n,m;
struct edge{
int v,id;
};
vector<edge> g[maxn];
bool vis[maxn][maxn];
void dfs(int u,bool* vis){
vis[u]=1;
for(edge e:g[u]) if(!vis[e.v]) dfs(e.v,vis);
}
bool ans[maxm];
int main(){
n=read();
m=read();
for(int i=1;i<=m;i++){
int u,v;
u=read();
v=read();
g[u].push_back({v,i});
}
for(int i=1;i<=n;i++) dfs(i,vis[i]);
for(int i=1;i<=n;i++){
memset(vis[0],0,sizeof(vis[0]));
vis[0][i]=1;
for(edge e:g[i])
if(vis[0][e.v]) ans[e.id]=1;
else dfs(e.v,vis[0]);
reverse(g[i].begin(),g[i].end());
memset(vis[0],0,sizeof(vis[0]));
vis[0][i]=1;
for(edge e:g[i])
if(vis[0][e.v]) ans[e.id]=1;
else dfs(e.v,vis[0]);
for(edge e:g[i]) ans[e.id]^=vis[e.v][i];
}
for(int i=1;i<=m;i++) printf(ans[i]?"diff\n":"same\n");
#ifdef LOCAL
fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
return 0;
}
#include <iostream>
#include<vector>
using namespace std;
using ll = long long;

int main(){
ll N, T; cin >> N >> T;
vector<ll>t(N);
for (ll i = 0; i < N; i++)cin >> t[i];

ll x = 0;
for (ll i = 0; i < N-1; i++) {
//次がT秒以内のとき
if (t[i + 1] <= t[i] + T) {
x += t[i + 1] - t[i];
}
//次がT秒よりも後のとき
else {
x += T;
}
}
//最後に押したときの時間を足す
x += T;

cout << x << endl;

}

#include<bits/stdc++.h>
using namespace std;

long long n,p,dat[1000001],c[1000001];
long long sto[1000001],b[1000001];
long long temp;

inline long long lowbit(long long x);
inline void update(long long x,long long v);
inline long long sum(long long x);

int main()
{
cin>>n;
cin>>p;
for(long long i=1;i<=n;++i)
{
scanf("%lld",&dat[i]);
dat[i]+=dat[i-1];
}
for(long long i=1;i<=n;i++)
{
b[i]=dat[i]-p*i;
sto[i]=b[i];
}
sort(sto+1,sto+1+n);
temp=unique(sto+1,sto+1+n)-sto-1;
for(long long i=0;i<=n;i++)
b[i]=lower_bound(sto+1,sto+1+temp,b[i])-sto;
long long a=0;
for(long long i=0;i<=n;i++)
{
a+=sum(b[i]);
update(b[i],1);
}
cout<<a;
}

inline long long lowbit(long long x)
{
return x&(-x);
}

inline void update(long long x,long long v)
{
for(long long i=x;i<=1000000;i+=lowbit(i))
c[i]+=v;
}

inline long long sum(long long x)
{
if(x==0) return 0;
long long ans=0;
for(long long i=x;i;i-=lowbit(i))
ans+=c[i];
return ans;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll MOD = 1e9+7;

ll mul(ll a, ll b) { return (a%MOD) * (b%MOD) % MOD; }
ll modpow(ll b, ll p) { return !p? 1 : mul(modpow(mul(b,b),p/2), p&1? b : 1); }

int main() {
ios_base::sync_with_stdio(0); cin.tie(0);
int n;
while (cin >> n) {
vector<int> v(n);
for (int i = 0; i < n; i++) {
cin >> v[i];
}
sort(v.begin(), v.end());
int ok = 1;
if (n % 2 == 0) {
for (int i = 0, g = 1; i < n && ok; i += 2, g += 2) {
if (v[i] != g || v[i+1] != g) {
ok = 0;
}
}
} else {
if (v[0] != 0) {
ok = 0;
}
for (int i = 1, g = 2; i < n && ok; i += 2, g += 2) {
if (v[i] != g || v[i+1] != g) {
ok = 0;
}
}
}
cout << (!ok? 0 : modpow(2,n/2)) << '\n';
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 500+10, M = 998'244'353;

ll scani(){
ll a; cin >> a;
return a;
}

int main(){
ios::sync_with_stdio(false);
cout.tie(NULL); cin.tie(NULL);

int n, d; cin >> n >> d;
vector<int> a(n);
for(int i = 0; i < n; i++) a[i] = scani()-1;

/*vector<bool> used(n, false);
for(int i = 0; i < n; i++)
if(a[i] != -1) used[a[i]-1] = true;
vector<int> missed;
for(int i = 0; i < n; i++)
if(!used[i]) missed.push_back(i);*/

vector<vector<ll>> dp(n+1, vector<ll>(1<<2*d+1, 0));    // has bit mask from parent
dp[0][(1<<d+1)-1] = 1;
for(int i = 0; i < n; i++){
for(int val = 1; val < 1<<2*d+1; val+=2){
int myVal = val>>1;
for(int j = -d; j <= d; j++){
//if(i+j >= 0 && i+j < n){
if(!(myVal & (1<<j+d)) && (a[i] == i+j || a[i] < 0)){
dp[i+1][myVal | (1<<j+d)] += dp[i][val];
dp[i+1][myVal | (1<<j+d)] %= M;
}
//}
}
}
}

cout << dp[n][(1<<d+1)-1];
}

/* Code by Saborit */
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#pragma GCC optimize("Ofast") 
#define MX 100005
#define INF (1<<30)
#define EPS 1e-9
#define MOD 1000000007
#define mid (x+xend)/2
#define izq nod*2
#define der nod*2+1
#define fr first
#define sc second
#define pb push_back
#define mp make_pair
#define chmax(X, Y) (X) = max(X, (Y))
#define all(X) (X).begin(), (X).end()
#define unique(X) (X).resize(unique(all(X)) - (X).begin())
#ifdef LOCAL 
#include "debug.h"
#endif
using namespace std;
using namespace __gnu_pbds;
typedef long long int64;
typedef unsigned long long unt64;

int n;
int A[MX];

int main(void){
//~ freopen("a.in", "r", stdin);
//~ freopen("a.out", "w", stdout);

scanf("%d", &n);

int ma = -INF;
for(int i=1; i<=n; i++){
scanf("%d", &A[i]);

chmax(ma, A[i]);
}

int x = -1;
for(int i=1; i<=n; i++) if( A[i] != ma ){
if( x == -1 ){
x = A[i];
}
else if( min(x, ma - x) < min(A[i], ma - A[i]) ){
x = A[i];
}
else if( min(x, ma - x) == min(A[i], ma - A[i]) && A[i] > x ){
x = A[i];
}
}

printf("%d %d\n", ma, x);

return 0;
}

#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int _=300003;
int n,m;
int c[_];
void add(int x,int v){for(int i=x;i<=m;i+=(i&-i)) c[i]+=v;}
int qry(int x){int r=0;for(int i=x;i;i-=(i&-i)) r+=c[i];return r;}
int read(){
char c=getchar();int x=0;
while (c<48||c>57) c=getchar();
do x=(x<<1)+(x<<3)+(c^48),c=getchar();
while (c>=48&&c<=57);
return x;
}
vector< pair<int,int> > a[_];
int main(){
n=read(); m=read();
for(int i=1;i<=n;++i){
int l=read(),r=read();
a[r-l+1].push_back(make_pair(l,r));
}
int cnt=n;
for(int i=1;i<=m;++i){
int r=cnt;
for(int o=i;o<=m;o+=i) r+=qry(o);
printf("%d\n",r);
for(pair<int,int> o:a[i]){
add(o.first,1);
add(o.second+1,-1);
}
cnt-=a[i].size();
}
return 0;
}

#include <cstdio>
using namespace std;
const int N=25003,K=403;
const int P=1000000007;
int f[N][K],g[N][K];
int a[N],prod[K];
int n,k,m;
int read(){
char c=getchar();int x=0;
while (c<48||c>57) c=getchar();
do x=(x<<1)+(x<<3)+(c^48),c=getchar();
while (c>=48&&c<=57);
return x;
}
int qp(int a,int b=P-2){
int r=1;
while (b){
if (b&1) r=1ll*r*a%P;
a=1ll*a*a%P;
b>>=1;
}
return r;
}
bool vis[K];
int buc[K];
int main(){
n=read(); k=read(); m=read();
for (int i=1; i<=m; ++i) a[i]=read();
int tot=1ll*qp(k,n-m)*(n-m+1)%P;
int cnt=0,ans=0,L=1,R=m;
for (int i=1; i<=m; ++i){
cnt+=!buc[a[i]],++buc[a[i]];
if (i>k) --buc[a[i-k]],cnt-=!buc[a[i-k]];
if (cnt==k){
printf("%d\n",tot);
return 0;
}
}
while (L<=m&&!vis[a[L]]) vis[a[L++]]=1; --L;
for (int i=1; i<=k; ++i) vis[i]=0;
while (R>=1&&!vis[a[R]]) vis[a[R--]]=1; ++R;
for (int i=1; i<=k; ++i) vis[i]=0;
f[1][1]=g[1][1]=k;
for (int i=2; i<=n; ++i){
for (int j=1; j<k; ++j)
f[i][j]=(1ll*f[i-1][j-1]*(k-j+1)+g[i-1][j])%P;
for (int j=k-1; j; --j)
g[i][j]=(f[i][j]+g[i][j+1])%P;
}
prod[k]=1;
for (int i=2; i<=k; ++i)
prod[k]=1ll*prod[k]*i%P;
prod[k]=qp(prod[k]);
for (int i=1; i<k; ++i)
prod[k-i]=1ll*prod[k-i+1]*i%P;
if (L>=m||R<=1){
for (int i=1; i<=n-m+1; ++i)
for (int j=m; j<k&&j<i+m; ++j)
ans=(ans+1ll*f[i+m-1][j]
*g[n-i-m+j+1][j]%P*prod[j])%P;
ans=1ll*ans*prod[m]%P;
}
else{
for (int i=1; i<=n-m+1; ++i)
ans=(ans+1ll*g[i+L-1][L]*g[n-i-R+2][m-R+1])%P;
ans=1ll*ans*prod[L]%P*prod[m-R+1]%P;
}
printf("%d\n",(P-ans+tot)%P);
return 0;
}

#pragma GCC optimize ("O3")
#pragma GCC target ("avx")
//#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i = 0; i < (n); i++)
#define rep1(i, n) for(int i = 1; i <= (n); i++)
#define co(x) cout << (x) << "\n"
#define cosp(x) cout << (x) << " "
#define ce(x) cerr << (x) << "\n"
#define cesp(x) cerr << (x) << " "
#define pb push_back
#define mp make_pair
#define chmin(x, y) x = min(x, y)
#define chmax(x, y) x = max(x, y)
#define Would
#define you
#define please

const int cm = 1 << 17;
char cn[cm], * ci = cn + cm, ct;
inline char getcha() {
if (ci - cn == cm) { fread_unlocked(cn, 1, cm, stdin); ci = cn; }
return *ci++;
}
inline int getint() {
int A = 0;
if (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';
else while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';
return A;
}

const int dm = 1 << 20;
char dn[dm], * di = dn;
inline void putint(int X) {
if (X == 0) {
*di++ = '0';
*di++ = '\n';
return;
}
int keta = 0;
char C[10];
while (X) {
*(C + keta) = '0' + X % 10;
X /= 10;
keta++;
}
for (int i = keta - 1; i >= 0; i--)* di++ = (*(C + i));
*di++ = '\n';
}

int main() {
//cin.tie(0);
//ios::sync_with_stdio(false);


int X = getint(), K = getint();
int r[100002];
rep1(i, K) r[i] = getint();
r[0] = 0;
r[K + 1] = 2e9;

int L = 0;
int R = X;
int takasa = 0;
int katamuki = -1;
int *ri = r;

int Q = getint();
rep(i, Q) {
int t = getint(), a = getint();

while (t > *(ri + 1)) {
takasa += katamuki * (*(ri + 1) - *ri);
if (katamuki < 0) {
L -= min(0, takasa + L);
R -= min(0, takasa + R);
}
else {
L -= max(0, takasa + L - X);
R -= max(0, takasa + R - X);
}
ri++;
katamuki *= -1;
}
chmax(a, L);
chmin(a, R);
a += takasa + katamuki * (t - *ri);
chmax(a, 0);
chmin(a, X);
putint(a);
}

fwrite(dn, 1, di - dn, stdout);

Would you please return 0;
}
#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int N = 2e5 + 5;

struct BIT{
int tree[N];
void add(int i, int v){
for(;i<N;i+=(i&-i)) tree[i] += v;
}

int get(int i){
int r = 0;
for(;i>0;i-=(i&-i)) r += tree[i];
return r;
}

int get(int l, int r){
return get(r) - get(l - 1);
}
}tree;

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

string s; cin>>s;
int n = s.size();
s = "#" + s;
vector<deque<int>> cmp(26);
for(int i=1;i<=n;i++){
cmp[s[i] - 'a'].push_back(i);
}

for(int cc = 0, i=0;i<26;i++){
cc += (cmp[i].size()&1);
if(cc > 1) { cout<<-1<<"\n"; return 0; }
}

int l = 1, r = n, res = 0;
while(l < r){
ar<int, 2> c, p = {(int)1e9, (int)-1e9};
for(int i=0;i<26;i++){
if(cmp[i].empty()) continue;
if(cmp[i].front() < p[0]) p[0] = cmp[i].front(), c[0] = i;
if(cmp[i].back() > p[1]) p[1] = cmp[i].back(), c[1] = i;
}

//~ cout<<c[0]<<" "<<c[1]<<"\n";
auto moveL = [&](){
int x = cmp[c[0]].back(); 
int tx = x + tree.get(x);
tree.add(x, -1); 
res += (r - tx); cmp[c[0]].pop_back();
cmp[c[0]].pop_front();
};

auto moveR = [&](){
int y = cmp[c[1]].front(); 
int ty = y + tree.get(y);
tree.add(1, 1), tree.add(y, -1);
res += (ty - l); cmp[c[1]].pop_front();
cmp[c[1]].pop_back();
};
if(c[0] == c[1]){
cmp[c[0]].pop_back();
cmp[c[1]].pop_front();
l++, r--;
continue;
}

if(cmp[c[0]].back() == p[0]){
moveR();
} else if(cmp[c[1]].front() == p[1]){
moveL();
} else {
int x = cmp[c[0]].back(), y = cmp[c[1]].front();
x += tree.get(x), y += tree.get(y);
//~ cout<<x<<" "<<y<<"\n";
if(r - x <= y - l){
moveL();
} else {
moveR();
}
} l++, r--;
}

cout<<res<<"\n";
}

#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int N = 2e5 + 5;

struct BIT{
int tree[N];
void add(int i, int v){
for(;i<N;i+=(i&-i)) tree[i] += v;
}

int get(int i){
int r = 0;
for(;i>0;i-=(i&-i)) r += tree[i];
return r;
}

int get(int l, int r){
return get(r) - get(l - 1);
}
}tree;

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

string s; cin>>s;
int n = s.size();
s = "#" + s;
vector<deque<int>> cmp(26);
for(int i=1;i<=n;i++){
cmp[s[i] - 'a'].push_back(i);
}

for(int cc = 0, i=0;i<26;i++){
cc += (cmp[i].size()&1);
if(cc > 1) { cout<<-1<<"\n"; return 0; }
}

int l = 1, r = n, res = 0;
while(l < r){
ar<int, 2> c, p = {(int)1e9, (int)-1e9};
for(int i=0;i<26;i++){
if(cmp[i].empty()) continue;
if(cmp[i].front() < p[0]) p[0] = cmp[i].front(), c[0] = i;
if(cmp[i].back() > p[1]) p[1] = cmp[i].back(), c[1] = i;
}

//~ cout<<c[0]<<" "<<c[1]<<"\n";
auto moveL = [&](){
int x = cmp[c[0]].back(); 
int tx = x + tree.get(x);
tree.add(x, -1); 
res += (r - tx); cmp[c[0]].pop_back();
cmp[c[0]].pop_front();
};

auto moveR = [&](){
int y = cmp[c[1]].front(); 
int ty = y + tree.get(y);
tree.add(1, 1), tree.add(y, -1);
res += (ty - l); cmp[c[1]].pop_front();
cmp[c[1]].pop_back();
};
if(c[0] == c[1]){
cmp[c[0]].pop_back();
cmp[c[1]].pop_front();
l++, r--;
continue;
}

if(cmp[c[0]].back() == p[0]){
moveR();
} else if(cmp[c[1]].front() == p[1]){
moveL();
} else {
moveL();
//~ int x = cmp[c[0]].back(), y = cmp[c[1]].front();
//~ x += tree.get(x), y += tree.get(y);
//~ cout<<x<<" "<<y<<"\n";
//~ if(r - x <= y - l){
//~ } else {
//~ moveR();
//~ }
} l++, r--;
}

cout<<res<<"\n";
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
int n;
cin>>n;
vi p(n);
rep(i,n) cin>>p[i],p[i]--;
int ans=0;
rep(i,n){
if(p[i]!=i) continue;
ans++;
if(i==0) swap(p[i],p[i+1]);
else if(i==n-1) swap(p[i],p[i-1]);
else if(p[i-1]==i-1||p[i]==i+1) swap(p[i],p[i-1]);
else swap(p[i],p[i+1]);
}
cout<<ans<<endl;
}
#include<iostream>
#include<cstdio>
#define N 25000
#define MAXN 200000
#define K 400
#define mod 1000000007
using namespace std;
int read()
{
char c=0;
int sum=0;
while (c<'0'||c>'9') c=getchar();
while ('0'<=c&&c<='9') sum=sum*10+c-'0',c=getchar();
return sum;
}
int n,k,m,a[N+1],f[N+1],g[N+1],dp[N+1],DP[N+1][2],sf[N+1],sg[N+1],sdp[N+1],SDP[N+1][2],fac[MAXN+1],invfac[MAXN+1],ans;
bool used[K+1],F[N+1],G[N+1];
int fast_pow(int a,int b)
{
int res=1,mul=a;
while (b)
{
if (b&1) res=1ll*res*mul%mod;
mul=1ll*mul*mul%mod,b>>=1;
}
return res;
}
int A(int x,int y)
{
if (x<y) return 0;
return 1ll*fac[x]*invfac[x-y]%mod;
}
int C(int x,int y)
{
if (x<y) return 0;
return 1ll*fac[x]*invfac[y]%mod*invfac[x-y]%mod;
}
void Add(int &x,int d)
{
x=(x+d)%mod;
return;
}
int main()
{
//freopen("sequence.in","r",stdin);
//freopen("sequence.out","w",stdout);
bool op=0;
n=read(),k=read(),m=read(),fac[0]=1;
for (int i=1;i<=m;++i) a[i]=read(),op|=used[a[i]],used[a[i]]=1;
for (int i=1;i<=MAXN;++i) fac[i]=1ll*fac[i-1]*i%mod;
invfac[MAXN]=fast_pow(fac[MAXN],mod-2);
for (int i=MAXN-1;i>=0;--i) invfac[i]=1ll*invfac[i+1]*(i+1)%mod;
if (k>n) puts("0");
else if (op)
{
if (m>=k)
{
for (int i=1;i<=m-k+1;++i)
{
op=1;
for (int j=1;j<=k;++j) used[j]=0;
for (int j=i;j<=i+k-1;++j) used[a[j]]=1;
for (int j=1;j<=k;++j) op&=used[j];
if (op)
{
printf("%lld\n",1ll*fast_pow(k,n-m)*(n-m+1)%mod);
return 0;
}
}
}
op=0;
for (int i=1;i<=k;++i) used[i]=0;
for (int i=1;i<=m;++i) op|=used[a[i]],F[i]=!op,used[a[i]]=1;
op=0;
for (int i=1;i<=k;++i) used[i]=0;
for (int i=m;i>=1;--i) op|=used[a[i]],G[m-i+1]=!op,used[a[i]]=1;
f[0]=sf[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k||F[k-i])
{
for (int j=max(i-k+1,0);j<i;++j) Add(f[i],-1ll*f[j]*fac[i-j]%mod);
if (i>=k) Add(f[i],-1ll*sf[i-k]*fac[k]%mod);
}
sf[i]=(f[i]+1ll*sf[i-1]*k%mod)%mod;
}
g[0]=sg[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k||G[k-i])
{
for (int j=max(i-k+1,0);j<i;++j) Add(g[i],-1ll*g[j]*fac[i-j]%mod);
if (i>=k) Add(g[i],-1ll*sg[i-k]*fac[k]%mod);
}
sg[i]=(g[i]+1ll*sg[i-1]*k%mod)%mod;
}
for (int i=0;i<=n-m;++i) ans=(ans-1ll*sf[i]*sg[n-m-i]%mod)%mod;
printf("%lld\n",((ans+1ll*fast_pow(k,n-m)*(n-m+1)%mod)%mod+mod)%mod);
}
else
{
dp[0]=sdp[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k-m+1)
{
for (int j=max(i-k+1,0);j<i;++j) Add(dp[i],-1ll*dp[j]*fac[i-j]%mod);
if (i>=k) Add(dp[i],-1ll*sdp[i-k]*fac[k]%mod);
}
sdp[i]=(dp[i]+1ll*sdp[i-1]*k%mod)%mod;
}
for (int i=0;i<=n-m;++i) ans=(ans-1ll*sdp[i]*sdp[n-m-i]%mod)%mod;
DP[0][0]=SDP[0][0]=-1;
for (int i=1;i<=n;++i)
{
if (i>=k)
{
for (int j=max(i-k+1,0);j<i;++j)
{
Add(DP[i][0],-1ll*DP[j][0]*fac[i-j]%mod);
Add(DP[i][1],-1ll*DP[j][1]*fac[i-j]%mod);
Add(DP[i][1],-1ll*DP[j][0]*fac[i-j]%mod*min(i-j,k-m+1)%mod);
}
Add(DP[i][0],-1ll*SDP[i-k][0]*fac[k]%mod);
Add(DP[i][1],-1ll*SDP[i-k][1]*fac[k]%mod);
Add(DP[i][1],-1ll*SDP[i-k][0]*fac[k]%mod*(k-m+1)%mod);
}
SDP[i][0]=(DP[i][0]+1ll*SDP[i-1][0]*k%mod)%mod,SDP[i][1]=(DP[i][1]+1ll*SDP[i-1][1]*k%mod)%mod;
}
printf("%lld\n",(((ans+1ll*SDP[n][1]*fast_pow(A(k,m),mod-2)%mod)%mod+1ll*fast_pow(k,n-m)*(n-m+1)%mod)%mod+mod)%mod);
}
return 0;
}

#include <bits/stdc++.h>
#include <cmath>

#define all(x) (x).begin(),(x).end()

using ll = long long;
const ll INF = 1LL<<60;
const int inf = INT_MAX / 2;

using namespace std;

int main() {
int n;
cin >> n;
int a[n];
for(int i = 0; i < n; i++) cin >> a[i];

map<int, int> m;
for(int i = 0; i < n; i++) {
m[a[i]]++;
}
for(auto& x : m) {
x.second--;
}
/*for(auto x : m) {
cout << x.second << endl;
}*/
int num = m.size();
int ex = n - num;
if(ex % 2 != 0) num--; 
cout << num << endl;

/*stack<int> s;
for(int i = n-1; i >= 0; i--) s.push(a[i]);

while(true) {
vector<int> x;
for(int i = 0; i < 3; i++) {
x.push_back(s.top());
s.pop();
}
sort(all(x));
//cout << "x" << endl;
//for(auto z : x) cout << z << endl;
//cout << m[x[0]] << endl;
m[x[0]]--;
//cout << m[x[0]] << endl;
m[x[2]]--;
s.push(x[1]);
bool ok = true;
for(auto k : m) {
//cout << k.second << endl;
if(k.second > 0) {
ok = false;
}
if(ok == false) break;
}
if(ok) break;
}

cout << s.size() << endl;*/

return 0;
}
/* Code by Saborit */
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#pragma GCC optimize("Ofast") 
#define MX 100005
#define INF (1<<30)
#define EPS 1e-9
#define MOD 1000000007
#define mid (x+xend)/2
#define izq nod*2
#define der nod*2+1
#define fr first
#define sc second
#define pb push_back
#define mp make_pair
#define all(X) (X).begin(), (X).end()
#define unique(X) (X).resize(unique(all(X)) - (X).begin())
#ifdef LOCAL 
#include "debug.h"
#endif
using namespace std;
using namespace __gnu_pbds;
typedef long long int64;
typedef unsigned long long unt64;

int n;
int A[MX];

int main(void){
//~ freopen("a.in", "r", stdin);
//~ freopen("a.out", "w", stdout);

scanf("%d", &n);

int ma = -INF, p = -1;
for(int i=1; i<=n; i++){
scanf("%d", &A[i]);

if( ma < A[i] ){
p = i;
ma = A[i];
}
}

int x = -1;
for(int i=1; i<=n; i++) if( p != i ){
if( x == -1 || min(x, ma - x) < min(A[i], ma - A[i]) ){
x = A[i];
}
}

printf("%d %d\n", ma, x);

return 0;
}

#include <bits/stdc++.h>
//#pragma comment(linker, "/STACK:50000000")
using namespace std;

#define mp make_pair
#define ll long long
#define all(_v) _v.begin(),_v.end()
#define ld long double
#define pb push_back
#define fi first
#define se second
#define pii pair<int, int>
const int mod = (int)1e9 + 7;
const int N = (int)1e5 + 100;
int dp[100][5][5];
int a[100];
void work(){
ll n;
cin >> n;
int m = 0;
for(;n;n >>= 1){
a[m++] = n & 1;
}
dp[0][1][0] = 1;
for(int i = 0;i < m;i++){
for(int w = 0;w < 3;w++){
for(int is = 0;is < 2;is++){
for(int d = 0;d < 2;d++){
for(int p = 0;p <= d;p++){
int az = (d + p + is) & 1;
int bz = (d + p + is) >> 1;
int op = 0;
if(az == a[i])op = w; else if(az > a[i])op = 2;
dp[i + 1][op][bz] += dp[i][w][is];
if(dp[i + 1][op][bz] >= mod)dp[i + 1][op][bz] -= mod;
}
}
}
}
}
cout << (dp[m][0][0] + dp[m][1][0]) % mod;
}
int main(){
ios_base::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
int CNTT = 1;
//cin >> CNTT;
for(int NUM = 1;NUM <= CNTT;NUM++){
work();
}
return 0;
}

# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
map<char,int> mp;
int n;
ll f[20000010],g[20000010];
char s[20];
void FWT(ll *f,bool flag)
{
for(int i=0;i<n;i++)
for(int j=0;j<(1<<(n<<1));j++)
if((j>>(i<<1))&3)
f[j&(~(3<<(i<<1)))]+=(flag?1:-1)*f[j];
}
int main()
{
mp['P']=1;mp['R']=2;mp['S']=3;
int p,q,x;
cin>>n>>p>>q;
for(int i=1;i<=p;i++)
{
scanf("%s",s);x=0;
for(int i=0;i<n;i++) x=(x<<2)+mp[s[i]];
f[x]++;
}
for(int i=1;i<=q;i++)
{
scanf("%s",s);x=0;
for(int i=0;i<n;i++) x=(x<<2)+mp[s[i]];
g[x]++;
}
FWT(f,1);FWT(g,1);
for(int i=0;i<(1<<(n<<1));i++) f[i]*=g[i];
FWT(f,0);
for(int i=0;i<n;i++)
{
for(int j=0;j<(1<<(n<<1));j++) g[j]=f[j],f[j]=0;
for(int j=0;j<(1<<(n<<1));j++)
{
int k=((j>>(i<<1))&3),tj=(j&(~(3<<(i<<1))));
if(!k) f[tj|(1<<(i<<1))]+=g[j],f[tj|(2<<(i<<1))]+=g[j],f[tj|(3<<(i<<1))]+=g[j];
else if(k==1) f[tj|(1<<(i<<1))]+=g[j],f[tj|(2<<(i<<1))]+=g[j];
else if(k==2) f[tj|(2<<(i<<1))]+=g[j],f[tj|(3<<(i<<1))]+=g[j];
else if(k==3) f[tj|(3<<(i<<1))]+=g[j],f[tj|(1<<(i<<1))]+=g[j];
}
}
for(int i=0;i<(1<<(n<<1));i++)
{
bool ok=1;
for(int j=0;j<n;j++) ok&=(((i>>(j<<1))&3)>0);
if(ok) printf("%lld\n",1ll*p*q-f[i]);
}
return 0;
}
#include <bits/stdc++.h>
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(ri,n) for(int ri = (int)(n-1); ri >= 0; ri--)
#define rep2(i,x,n) for(int i = (int)(x); i < (int)(n); i++)
#define rrep2(ri,x,n) for(int ri = (int)(n-1); ri >= (int)(x); ri--)
#define repit(itr,x) for(auto itr = x.begin(); itr != x.end(); itr++)
#define rrepit(ritr,x) for(auto ritr = x.rbegin(); ritr != x.rend(); ritr++)
#define ALL(x) x.begin(), x.end()
using ll = long long;
using namespace std;

int main() {
int n, w;
cin >> n >> w;
vector vv(4, vector<int>());
int base = 0;
rep(i, n) {
int w, v;
cin >> w >> v;
if(i == 0) base = w;
int idx = w - base;
vv.at(idx).push_back(v);
}
rep(i, 4) sort(ALL(vv.at(i)), greater<int>());
vector sums(4, vector<ll>());
rep(i, 4) {
vector<ll> ss(vv.at(i).size()+1, 0);
rep(j, vv.at(i).size()) ss.at(j+1) = ss.at(j) + vv.at(i).at(j);
sums.at(i) = ss;
}
ll ans = 0;
rep(i, sums.at(0).size())rep(j, sums.at(1).size())rep(k, sums.at(2).size())rep(l, sums.at(3).size()) {
ll ww = (ll)base*i;
ww += (ll)(base+1)*j;
ww += (ll)(base+2)*k;
ww += (ll)(base+3)*l;
if(ww > w) continue;
ll add = sums.at(0).at(i);
add += sums.at(1).at(j);
add += sums.at(2).at(k);
add += sums.at(3).at(l);
ans = max(ans, add);
}
cout << ans << endl;
return 0;
}
#include <bits/stdc++.h>
#define _for(i,a,b) for(int i=a;i<=b;++i)
#define for_(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
using namespace std;
const int N=1e6+10,inf=0x3f3f3f3f;
ll n,p,a[N],b[N],bb[N],ans;map<ll,ll>c;
ll lowbit(ll x){return x&-x;}
void update(ll x){while(x<=n)++c[x],x+=lowbit(x);}
ll query(ll x){
ll sum=0;
while(x)sum+=c[x],x-=lowbit(x);
return sum;
}int main(){
scanf("%lld%lld",&n,&p);
_for(i,1,n)scanf("%lld",&a[i]);
_for(i,1,n)b[i]=b[i-1]+a[i]-p,bb[i]=b[i];
sort(bb+1,bb+n+1);
ll tmp=unique(bb+1,bb+n+1)-bb-1;
_for(i,0,n)b[i]=lower_bound(bb+1,bb+tmp+1,b[i])-bb;
_for(i,0,n)ans+=query(b[i]),update(b[i]);
printf("%lld\n",ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
/*
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
*/
const int maxn=100005,maxm=260,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,deg[maxn];
vector<int> adj[maxn],vec;
bool isleaf[maxn];

void dfs(int u, int par){
vec.pb(u);
int cnt=0;
for(auto v: adj[u]) if((!isleaf[v])&&v!=par) dfs(v,u),cnt++;
assert(cnt<=1);
}

vector<int> solve(){
vector<int> res(n);
int cur=0;//filled cnt
rep(sz(vec)){
int x=0;
if(i==0||i==sz(vec)-1) x=sz(adj[vec[i]])-1;
else x=sz(adj[vec[i]])-2;
res[cur+x]=cur;
rep2(j,cur,cur+x) res[j]=cur+1+(j-cur);
cur+=x+1;
}
return res;
}

void orzck(){
cin >> n;
rep(n-1){
int u,v;
cin >> u >> v;
u--,v--;
adj[u].pb(v),adj[v].pb(u);
deg[u]++,deg[v]++;
}
if(n==2){
print(1,2);
return;
}
rep(n) isleaf[i]=deg[i]==1;
rep(n) if(isleaf[i]) for(auto v: adj[i]) deg[v]--;
rep(n) if(deg[i]>2){
print(-1);
return;
}
rep(n) if((!isleaf[i])&&deg[i]<=1){
dfs(i,-1);
break;
}
assert(sz(vec));
if(sz(vec)==1){
int u=vec[0];
vec={adj[u][0],u,adj[u][1]};
}
else{
int u,v;
for(auto i: adj[vec[0]]) if(isleaf[i]){
u=i;
break;
}
for(auto i: adj[vec.back()]) if(isleaf[i]){
v=i;
break;
}
vec.insert(vec.begin(),u);
vec.pb(v);
}
bug(vec);
vector<int> res1,res2;
res1=solve();
reverse(all(vec));
res2=solve();
rep(n) if(res1[i]!=res2[i]){
if(res1[i]>res2[i]) res1=res2;
break;
}
rep(n) print0(res1[i]+1);
cout << "\n";
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>
#define File(name) freopen(#name".in", "r", stdin); freopen(#name".out", "w", stdout);
#define ri int
#define Int inline int
#define Void inline void
#define Bool inline bool
#define LL inline long long
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
template<typename T>
inline T read(){
T n = 0; int f = 1; char ch = getchar();
while(!isdigit(ch)){
if(ch == '-') f = -1;
ch = getchar();
}
while(isdigit(ch)){
n = n * 10 + ch - '0';
ch = getchar();
}
return f * n;
}
template<typename T>
void write(T n){
if(n/10) write(n/10);
putchar(n%10+'0');
}
void input() {}
template<typename Type, typename... Types>
void input(Type &arg, Types&... args){
arg = read<Type>();
input(args...);
}
namespace Main{
const int N = 1005;
const int M = 200005;
int n, m;
bool can[N][N], vis[N], flag[M];
vector<pair<int, int> > g[N], edges;
void dfs(int s, int u){
can[s][u] = true;
for(pair<int, int> v: g[u]){
if(can[s][v.first]) continue;
dfs(s, v.first);
}
}
void dfs2(int u){
vis[u] = true;
for(pair<int, int> v: g[u]){
if(vis[v.first]) continue;
dfs2(v.first);
}
}
void Main(){
input(n, m);
for(int i = 0, u, v; i < m; i++){
input(u, v);
g[u].push_back(make_pair(v, i));
edges.push_back(make_pair(u, v));
}
for(int i = 1; i <= n; i++) dfs(i, i);
for(int i = 1; i <= n; i++){
memset(vis, 0, sizeof(vis));
vis[i] = true;
for(pair<int, int> v: g[i]){
if(vis[v.first]) { flag[v.second] = true; continue; }
dfs2(v.first);
}
memset(vis, 0, sizeof(vis));
vis[i] = true;
for(int j = g[i].size() - 1; j >= 0; j--){
pair<int, int> v = g[i][j];
if(vis[v.first]) { flag[v.second] = true; continue; }
dfs2(v.first);
}
}
for(int i = 0; i < m; i++)
puts(can[edges[i].second][edges[i].first] ^ flag[i] ? "diff" : "same");
return;
}
} // namespace
int main(){
#ifdef Liuxizai
freopen("in", "r", stdin);
freopen("out", "w", stdout);
#endif // Liuxizai
Main::Main();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define rrep(i, a, b) for (int i = (a); i >= (b); --i)
#define PB push_back
#define ar2 array<int, 2>
typedef long long LL;
int P = 998244353;
const LL INF = 2e11;
const int N = 5005;
mt19937 rng(time(0));

int T, n, m, C[N][N];

int main() {
cin >> n >> m >> P;
C[0][0] = 1;
rep(i, 1, N - 1) {
C[i][0] = C[i][i] = 1;
rep(j, 1, i - 1) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;
}

int ans = (m == n - 1) + max(0, min(m, n / 2) - 1);
rep(x, 1, n - 1) rep(y, max(x, n / 2), (n + x) / 2)
ans = (ans + 1ll * C[y][x] * C[x + 1][n + x - 2 * y] % P * max(0, min(y, m) - max(x, 3) + 1)) % P;
cout << ans << endl;
return 0;
}
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
/// Macros
#define int long long
#define ll long long
#define sz size
#define ull unsigned long long
#define ld long double
#define vi vector<int>
#define ii pair<int,int>
#define vii vector<ii>
#define fst first
#define scd second
#define pb push_back
#define fl '\n'
#define el endl
#define all(x) x.begin() , x.end()
#define rall(x) x.rbegin() , x.rend()
#define IOS ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
/// Functions
#define random() __builtin_ia32_rdtsc()
#define lgx(x,n) ( log(n) / log(x) )
#define lg2(x) 31-__builtin_clz(x)
#define lg2ll(x) 63-__builtin_clzll(x)
#define pi acos(-1)
/// Red-Black Tree Template
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>
//using namespace __gnu_pbds;
//typedef tree < long long ,  null_type ,  less<long long> ,  rb_tree_tag ,  tree_order_statistics_node_update > ordered_set;
//#define less_than(n) order_of_key(n)
//#define en_pos(n) find_by_order(n)
/// Prime numbers  173,179,311,331,737,1009,2011,2027,3079,4001,100003
///===================================================================
///Quick Pow
//ull qpow(ull x, ull e){
//	if(!e) return 1;
//	if(e&1) return (qpow(x , e-1)*x) % MOD;
//	return qpow((x*x) % MOD , e>>1) % MOD;
//}
///Criba de factores primos
//void Criba(int n){
//    fact[2]=2;
//    for(int i=2; i<n; i+=2) fact[i]=2;
//    for(int i=3; i<n; i+=2){
//        if(fact[i]==inf){
//            fact[i]=i;
//            for(int j=i*i; j<n; j+=i+i) fact[j]=min(fact[j], i);
//        }
//    }
//}
///Sacar los factores primos en O(factores)
//fill(fact, fact+mxn, inf);
//Criba(mxn);
//while(num!=1){
//    if(fact[num]==di) vec[vec.sz()-1].scd++;
//    else vec.push_back({fact[num], 1});
//    di=fact[num];
//    num/=fact[num];
//}
//for(auto i:vec){
//    sum+=(qpow(i.fst, i.scd+1)-1)/(i.fst-1);
//}
using namespace std;

const int mxn=2e6+10, base=10;

int n, m, a, b, id, ans, ar[mxn], mk[mxn], nf[]={0, 0, 1, -1}, nc[]={1, -1, 0, 0};
char abc[]={'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
vector<int>v[mxn], vv[mxn];

void dfs(int a, int cl){
mk[a]=cl;
vv[cl].pb(a);
for(auto b:v[a]){
if(mk[b]!=0) continue;
dfs(b, cl);
}
}

void Solve(){

cin>>n>>m;
for(int i=1; i<=n; i++){
cin>>ar[i];
if(ar[i]==i) ans++;
}

for(int i=1; i<=m; i++){
cin>>a>>b;
v[a].pb(b);
v[b].pb(a);
}

id=1;
for(int i=1; i<=n; i++){
if(mk[i]==0){
dfs(i, id);
for(auto j:vv[id]){
if(mk[ar[j]]==id&&ar[j]!=j) ans++;
}
id++;
}
}

cout<<ans;
}

int32_t main(){

//    freopen("text.in", "r", stdin);

IOS;

cout.setf(ios::fixed);
cout.precision(0);

Solve();

return 0;
}

// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
int n, t; cin>>n>>t;
int maxq = 0;
vector<int> a(n);
for(int i=0; i<n; i++){
cin>>a[i];
}
maxq = a[n-1];
int del = 0;
for(int i=n-2; i>=0; i--){
del = max(del, maxq - a[i]);
mxi(maxq, a[i]);
}
map<int, int> mp, mp2;
for(int i=0; i<n; i++)
mp2[a[i]]++;
int ans = 0;
for(int i=n-1; i>=0; i--){
ans += min(mp2[a[i]], mp[a[i] + del]);
mp2[a[i]]--;
mp[a[i]]++;
}
cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

int main() {
int n; qread(n);
deque<int> q;
rep(i, 1, n) {
int x; qread(x);
if(i & 1) q.pb(x);
else q.push_front(x);
}
if(n & 1) while(!q.empty()) printf("%d ", q.back()), q.pop_back();
else while(!q.empty()) printf("%d ", q.front()), q.pop_front();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ld = long double;
// --------------------------------------------------------
#define FOR(i,l,r) for (ll i = (l); i < (r); ++i)
#define RFOR(i,l,r) for (ll i = (r)-1; (l) <= i; --i)
#define REP(i,n) FOR(i,0,n)
#define RREP(i,n) RFOR(i,0,n)
#define ALL(c) (c).begin(), (c).end()
#define RALL(c) (c).rbegin(), (c).rend()
#define SORT(c) sort(ALL(c))
#define RSORT(c) sort(RALL(c))
#define MIN(c) *min_element(ALL(c))
#define MAX(c) *max_element(ALL(c))
#define SUMLL(c) accumulate(ALL(c), 0LL)
#define COUNT(c,v) count(ALL(c),(v))
#define SZ(c) ((ll)(c).size())
#define BIT(b,i) (((b)>>(i)) & 1)
#define PCNT(b) __builtin_popcountll(b)
#define CIN(c) cin >> (c)
#define COUT(c) cout << (c) << '\n'
#ifdef _LOCAL
#define debug_bar cerr << "--------------------\n";
#define debug(x) cerr << "l." << __LINE__ << " : " << #x << " = " << (x) << '\n'
#define debug_pair(x) cerr << "l." << __LINE__ << " : " << #x << " = (" << x.first << "," << x.second << ")\n";
template<class T> void debug_line(const vector<T>& ans, int l, int r, int L = 0) { cerr << "l." << L << " :"; for (int i = l; i < r; i++) { cerr << ' ' << ans[i]; } cerr << '\n'; }
#else
#define cerr if (false) cerr
#define debug_bar
#define debug(x)
#define debug_pair(x)
template<class T> void debug_line([[maybe_unused]] const vector<T>& ans, [[maybe_unused]] int l, [[maybe_unused]] int r, [[maybe_unused]] int L = 0) {}
#endif
template<class... T> void input(T&... a) { (cin >> ... >> a); }
void print() { cout << '\n'; }
template<class T> void print(const T& a) { cout << a << '\n'; }
template<class T, class... Ts> void print(const T& a, const Ts&... b) { cout << a; (cout << ... << (cout << ' ', b)); cout << '\n'; }
template<class T> void cout_line(const vector<T>& ans, int l, int r) { for (int i = l; i < r; i++) { if (i != l) { cout << ' '; } cout << ans[i]; } cout << '\n'; }
template<class T> bool chmin(T& a, const T b) { if (b < a) { a = b; return 1; } return 0; }
template<class T> bool chmax(T& a, const T b) { if (a < b) { a = b; return 1; } return 0; }
ll llceil(ll a, ll b) { assert(b > 0); return (a + b - 1) / b; }
ll llpow(ll x, ll n) { assert(n >= 0); if (n == 0) { return 1; }; ll res = llpow(x, n>>1); res *= res; if (n & 1) { res *= x; } return res; }
ll bitlen(ll b) { if (b <= 0) { return 0; } return (64LL - __builtin_clzll(b)); }
ll digit_len(ll n) { assert(n >= 0); if (n == 0) { return 1; } ll sum = 0; while (n > 0) { sum++; n /= 10; } return sum; }
ll digit_sum(ll n) { assert(n >= 0); ll sum = 0; while (n > 0) { sum += n % 10; n /= 10; } return sum; }
ll digit_prod(ll n) { assert(n >= 0); if (n == 0) { return 0; } ll prod = 1; while (n > 0) { prod *= n % 10; n /= 10; } return prod; }
string toupper(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = toupper(T[i]); } return T; }
string tolower(const string& S) { string T(S); for (int i = 0; i < (int)T.size(); i++) { T[i] = tolower(T[i]); } return T; }
int a2i(const char& c) { assert(islower(c)); return (c - 'a'); }
int A2i(const char& c) { assert(isupper(c)); return (c - 'A'); }
char i2a(const int& i) { assert(0 <= i && i < 26); return ('a' + i); }
char i2A(const int& i) { assert(0 <= i && i < 26); return ('A' + i); }
using P = pair<ll,ll>;
using VP = vector<P>;
using VVP = vector<VP>;
using VS = vector<string>;
using VVS = vector<VS>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using VB = vector<bool>;
using VVB = vector<VB>;
using VVVB = vector<VVB>;
using VD = vector<double>;
using VVD = vector<VD>;
using VVVD = vector<VVD>;
using VLD = vector<ld>;
using VVLD = vector<VLD>;
using VVVLD = vector<VVLD>;
const ld EPS = 1e-10;
const ld PI  = acosl(-1.0);
constexpr ll MOD = 1000000007;
// constexpr ll MOD = 998244353;
constexpr int inf = (1 << 30) - 1;   // 1073741824 - 1
constexpr ll INF = (1LL << 62) - 1;  // 4611686018427387904 - 1
// --------------------------------------------------------
// #include <atcoder/all>
// using namespace atcoder;


// References:
//   mint:
//     <https://github.com/atcoder/live_library/blob/master/mint.cpp>
//     <https://noshi91.hatenablog.com/entry/2019/03/31/174006>
//     <https://ei1333.github.io/luzhiled/snippets/math/mod-int.html>
//     <https://gist.github.com/MiSawa/dc78c3eb3ca16051818759ea069e8ccb>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>
//   combination:
//     <https://github.com/atcoder/live_library/blob/master/comb.cpp>
//     <https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp>

struct mint {
ll x;
constexpr mint(ll x = 0) noexcept : x((x % MOD + MOD) % MOD) {}

constexpr mint& operator+=(const mint& a) noexcept {
if ((x += a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator-=(const mint& a) noexcept {
if ((x += MOD - a.x) >= MOD) x -= MOD;
return *this;
}
constexpr mint& operator*=(const mint& a) noexcept { (x *= a.x) %= MOD; return *this; }
constexpr mint& operator/=(const mint& a) noexcept { return *this *= a.inv(); }

constexpr mint operator-() const noexcept { return mint(-x); }
constexpr mint operator+(const mint& a) const noexcept { return mint(*this) += a; }
constexpr mint operator-(const mint& a) const noexcept { return mint(*this) -= a; }
constexpr mint operator*(const mint& a) const noexcept { return mint(*this) *= a; }
constexpr mint operator/(const mint& a) const noexcept { return mint(*this) /= a; }
constexpr bool operator==(const mint& a) const noexcept { return x == a.x; }
constexpr bool operator!=(const mint& a) const noexcept { return x != a.x; }

constexpr mint pow(ll n) const {
if (n == 0) return 1;
mint res = pow(n >> 1);
res *= res;
if (n & 1) res *= *this;
return res;
}
constexpr mint inv() const { return pow(MOD - 2); }

friend istream& operator>>(istream& is, mint& a) noexcept {
ll v; is >> v;
a = mint(v);
return is;
}
friend ostream& operator<<(ostream& os, const mint& a) noexcept {
return os << a.x;
}
};
using VM = vector<mint>;
using VVM = vector<VM>;
using VVVM = vector<VVM>;
using VVVVM = vector<VVVM>;


struct combination {
vector<mint> fact_, ifact_, inv_;
int n_;
combination() {}
combination(int n) : fact_(n+1,0), ifact_(n+1,0), inv_(n+1,0) {
assert(n != 0);
assert(n < MOD);
n_ = n;
fact_[0] = 1; fact_[1] = 1;
ifact_[0] = 1; ifact_[1] = 1;
inv_[1] = 1;
for(int i = 2; i <= n; ++i) {
fact_[i] = fact_[i-1] * i;
inv_[i] = -inv_[MOD%i] * (MOD/i);
ifact_[i] = ifact_[i-1] * inv_[i];
}
}

mint P(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k];
}
mint C(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0 || n < k) return 0;
assert(n <= n_);
return fact_[n] * ifact_[n-k] * ifact_[k];
}
mint H(const int& n, const int& k) const noexcept {
if (n < 0 || k < 0) return 0;
assert(n + k - 1 <= n_);
return C(n + k - 1, k);
}
mint fact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return fact_[n];
}
mint ifact(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return ifact_[n];
}
mint inv(const int& n) const noexcept {
assert(n <= n_);
if (n < 0) return 0;
return inv_[n];
}
};


int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout << fixed << setprecision(15);

ll N, M; cin >> N >> M;
ll S, T; input(S, T);
S--; T--;
VVP G(N);
REP(_,M) {
ll u, v, w; cin >> u >> v >> w;
u--; v--;
G[u].emplace_back(v, w);
G[v].emplace_back(u, w);
}

VVP G2(N);  // 最短路に使われる辺のみ残した逆辺グラフ

VLL dist(N, INF); dist[S] = 0;
VM numS(N, 0); numS[S] = 1;  // S からの最短経路数
{
using Tp = tuple<ll,ll>;
priority_queue<Tp, vector<Tp>, greater<Tp>> pq; pq.emplace(0, S);
while (not pq.empty()) {
auto [min_dist, u] = pq.top(); pq.pop();
if (dist[u] < min_dist) continue;
for (const auto& [v, w] : G[u]) {
if (chmin(dist[v], dist[u] + w)) {
pq.emplace(dist[v], v);
numS[v] = numS[u];
G2[v].clear();
G2[v].emplace_back(u, w);
} else if (dist[v] == dist[u] + w) {
numS[v] += numS[u];
G2[v].emplace_back(u, w);
}
}
}
}

mint ans = numS[T].pow(2);
{
VM numT(N, 0); numT[T] = 1;  // T からの最短経路数
using Tp = tuple<ll,ll>;
priority_queue<Tp, vector<Tp>, greater<Tp>> pq; pq.emplace(0, T);
VB vis(N,false); vis[T] = true;
while (not pq.empty()) {
auto [t, u] = pq.top(); pq.pop();
ll s = dist[u];
assert(s + t == dist[T]);

// 頂点で出会うケース
if (s == t) ans -= (numT[u]*numS[u]).pow(2);

for (const auto& [v, w] : G2[u]) {
numT[v] += numT[u];
// 辺で出会うケース
if (t < s && t+w > s-w) ans -= (numT[u]*numS[v]).pow(2);
if (vis[v]) continue;
vis[v] = true;
pq.emplace(t + w, v);
}
}
}
print(ans);

return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*
5 2 3 1 4 == 2
~~~~~

1 2 3 4 5
2 1 3 4 5
2 2 1 2 2
*/

int main(){
cincout();

ll N, K;
cin >> N >> K;
cout << (N-1 + K-2)/(K-1) << endl;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=205,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,x[maxn],y[maxn];
modint res;

void orzck(){
cin >> n;
rep(n) cin >> x[i] >> y[i];
res=modint(2).Pow(n)-1-n;
rep(n) rep2(j,i+1,n){
int cnt=0;
rep1(k,n) if(k!=i&&k!=j&&x[k]<=max(x[i],x[j])&&x[k]>=min(x[i],x[j])&&y[k]<=max(y[i],y[j])&&y[k]>=min(y[i],y[j])&&(x[k]-x[i])*(y[k]-y[j])==(y[k]-y[i])*(x[k]-x[j])) cnt++;
res-=modint(2).Pow(cnt);
bug(i,j,cnt);
}
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include<bits/stdc++.h>

using namespace std;
using ll = long long;

int main(){
ll n,k;
cin >> n >> k;

if(k == 0){
cout << n*n << endl;
return 0;
}

//ll ans = (n-k)*(n-k+1)/2;
ll ans = 0;

for(ll i = k+1;i <= n;++i){
ll tmp = ((n+1)/(i));
ll m = n-(tmp)*i+1-k;
if(m > 0) ans += m;
ans += tmp*(i-k);
}
cout << ans << endl;

}
#include <bits/stdc++.h>
using namespace std;

using ll=long long;

const int N=1e5+1, mod=1e9+7;
ll x[N], y[N];

int main(){

ios_base::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

int n,m;cin>>n>>m;
for(int i=1;i<=n;i++)	cin>>x[i];
for(int i=1;i<=m;i++)	cin>>y[i];

ll ansX=0;
for(int i=1;i<n;i++){
ansX+=(x[i+1]-x[i])*i*(n-i);
ansX%=mod;
}

ll ansY=0;
for(int i=1;i<m;i++){
ansY+=(y[i+1]-y[i])*i*(m-i);
ansY%=mod;
}

cout<<(ansX*ansY)%mod<<"\n";

return 0;	

}
#ifdef LOCAL
//#define _GLIBCXX_DEBUG
#endif
//#pragma GCC target("avx512f,avx512dq,avx512cd,avx512bw,avx512vl")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> P;
typedef pair<int, int> Pi;
typedef vector<ll> Vec;
typedef vector<int> Vi;
typedef vector<string> Vs;
typedef vector<char> Vc;
typedef vector<P> VP;
typedef vector<vector<ll>> VV;
typedef vector<vector<int>> VVi;
typedef vector<vector<char>> VVc;
typedef vector<vector<vector<ll>>> VVV;
typedef vector<vector<vector<vector<ll>>>> VVVV;

#define endl '\n'
#define REP(i, a, b) for(ll i=(a); i<(b); i++)
#define PER(i, a, b) for(ll i=(a); i>=(b); i--)
#define rep(i, n) REP(i, 0, n)
#define per(i, n) PER(i, n, 0)
const ll INF=1e18+18;
const ll MOD=1000000007;
#define Yes(n) cout << ((n) ? "Yes" : "No") << endl;
#define YES(n) cout << ((n) ? "YES" : "NO") << endl;
#define ALL(v) v.begin(), v.end()
#define rALL(v) v.rbegin(), v.rend()
#define pb(x) push_back(x)
#define mp(a, b) make_pair(a,b)
#define Each(a,b) for(auto &a :b)
#define rEach(i, mp) for (auto i = mp.rbegin(); i != mp.rend(); ++i)
#define SUM(a) accumulate(ALL(a),0LL)
#ifdef LOCAL
#define dbg(x_) cerr << #x_ << ":" << x_ << endl;
#define dbgmap(mp) cerr << #mp << ":"<<endl; for (auto i = mp.begin(); i != mp.end(); ++i) { cerr << i->first <<":"<<i->second << endl;}
#define dbgset(st) cerr << #st << ":"<<endl; for (auto i = st.begin(); i != st.end(); ++i) { cerr << *i <<" ";}cerr<<endl;
#define dbgarr(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j]<<" ";}cerr<<endl;}
#define dbgdp(n,arr) rep(i,n){cerr<<arr[i]<<" ";}cerr<<endl;
#else
#define dbg(...)
#define dbgmap(...)
#define dbgset(...)
#define dbgarr(...)
#define dbgdp(...)
#endif
#define out(a) cout<<a<<endl
#define out2(a,b) cout<<a<<" "<<b<<endl
#define vout(v) rep(i,v.size()){cout<<v[i]<<" ";}cout<<endl
#define Uniq(v) v.erase(unique(v.begin(), v.end()), v.end())
#define fi first
#define se second

template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }

template<typename T1, typename T2>
ostream &operator<<(ostream &s, const pair<T1, T2> &p) { return s<<"("<<p.first<<", "<<p.second<<")"; }

template<typename T1, typename T2>
istream &operator>>(istream &i, pair<T1, T2> &p) { return i>>p.first>>p.second; }

template<typename T>istream& operator>>(istream&i,vector<T>&v)
{rep(j,v.size())i>>v[j];return i;}

// vector
template<typename T>
ostream &operator<<(ostream &s, const vector<T> &v) {
int len=v.size();
for(int i=0; i<len; ++i) {
s<<v[i];
if(i<len-1) s<<"	";
}
return s;
}

// 2 dimentional vector
template<typename T>
ostream &operator<<(ostream &s, const vector<vector<T> > &vv) {
s<<endl;
int len=vv.size();
for(int i=0; i<len; ++i) {
s<<vv[i]<<endl;
}
return s;
}

int solve(){
ll h,w,n;
cin>>h>>w>>n;
VP vp(n);
cin>>vp;
rep(i,n){
vp[i].fi--;
vp[i].se--;
}
set<P> black;
set<P> st;
Vec dy = {0,1,0,-1,1,1,-1,-1,0};
Vec dx = {1,0,-1,0,1,-1,1,-1,0};
auto in = [&](ll y, ll x) {
return y >= 0 && y < h && x >= 0 && x < w;
};
Vec ans(10);
Each(p, vp){
auto [i,j] = p;
rep(k, 9){
ll ny = i+dy[k];
ll nx = j+dx[k];
if(in(ny,nx)){
st.insert(mp(ny,nx));
}
}
black.insert(mp(i,j));
}
ll mx = (h-2)*(w-2);
dbgset(black);
dbgset(st);
Each(p, st){
auto [i,j] = p;
ll cnt = 0;
bool ok = true;
rep(k, 9){
ll ny = i+dy[k];
ll nx = j+dx[k];
if(in(ny,nx)){
if(black.find(mp(ny,nx)) != black.end())cnt++;
}else{
ok = false;
break;
}
}
if(!ok)continue;
if(cnt){ans[cnt]++;}
}
REP(i,1,10)mx-=ans[i];
ans[0] = mx;
rep(i,10)out(ans[i]);
return  0;
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout<<std::setprecision(10);
//    ll T;
//    cin>>T;
//    while(T--)
solve();
}

// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline ll read(){
ll x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

const int N=100005;

ll sz[N],D[N];
int dad[N],n;
int id[N];

set<pair<ll,int>>s;

vector<int>adj[N];
ll all;
void dfs(int u,int dep){
all+=dep;
for(auto v:adj[u])dfs(v,dep+1);
}

int main(){
n=read();
rep(i,1,n)D[i]=read(),id[i]=i,s.insert({D[i],i});
sort(id+1,id+n+1,[&](int x,int y){
return D[x]<D[y];
});
per(i,n,2){
int u=id[i];s.erase({D[u],u});
sz[u]++;
ll qwq=D[u]-n+2*sz[u];
auto it=s.lower_bound({qwq,-1});
if(it==s.end()||it->fir!=qwq){
return puts("-1"),0;
}
dad[u]=it->sec;
sz[dad[u]]+=sz[u];
}

rep(i,1,n)adj[dad[i]].pb(i);
dfs(id[1],0);
if(D[id[1]]!=all)return puts("-1"),0;

rep(i,1,n)if(dad[i])printf("%d %d\n",dad[i],i);
return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int xy=2e5+10;
int a[xy];
int main(){
int N;cin>>N;
int sum2=0,sum1=0,sum4=0,sum;
for(int i=0;i<N;++i){
int x;scanf("%d",&x);
if(x%2==0){
if(x%4==0) sum4++;
else sum2++;
}
}
sum1=N-sum2-sum4;
if(sum1<=sum4+1&&sum2==0||sum2==N||sum1<sum4+1&&sum2!=0) cout<<"Yes"<<endl;
else cout<<"No"<<endl;
// cout<<"sum1="<<sum1<<"  sum2="<<sum2<<"  sum4="<<sum4<<"  sum="<<sum;
return 0;
}
#include<iostream>
#include<algorithm>
#include<string>
#include<math.h>
#include <queue>
#include <bitset>
#include <sstream>
#include<vector>
using namespace std;
int main() {
long long N, K;
cin >> N >> K;
long long answer = 0;
long long M = N / K;
long long L = 0;
if (K % 2 == 0) {
for(int i=1;i<=N;i++){
if(i%K==K/2)L++;
}
}
answer = answer + M * M * M + L * L * L;
cout << answer;
}


///*Bismillahir Rahmanir Rahim*///
///*Assalamualaikum*///


/************************************
* MOHAMMAD SABBIR MUSFIQUE
* handle : sabbir_063
* MIST , Bangladesh
* *********************************/

// include C++ header files  //

#include<bits/stdc++.h>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<vector>
#include<cstdio>
#include<algorithm>
#include<map>

// include C header files  //

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

//      define  //

#define in long long
#define du double
#define dub long double

//      loop     //

#define loop(i,n) for(in i=0;i<n;i++)
#define loop1(i,n) for(in i=1;i<=n;i++)
#define lop(i,a,n) for(in i=a;i<n;i++)
#define rloop(i,n) for(in i=n-1;i>=0;i--)
#define rloop1(i,n) for(in i=n;i>0;i--)

//      Vector    //

#define pb push_back
#define po pop_out
#define lb lower_baound
#define ub upper_bound
#define bs binary_search

#define iter vector<in>::iterator it ;
#define itter vector<int>::iterator it ;

//      map     //

#define mp_ss map < string , string > 
#define mp_si map < string , int > 
#define mp_is map < int , string > 
#define mp_ii map < int , int > 
#define mp_ll map < in , in > 

#define mpp_it_si map < string , int > ::iterator
#define mpp_it_is map < int , string > ::iterator
#define mpp_it_ii map < int , int > ::iterator
#define mpp_it_ss map < string , string > ::iterator
#define mpp_it_ll map < in , in > ::iterator

#define endl "\n"
#define LSD ios_base::sync_with_stdio(false) ; cin.tie(0) ; cout.tie(0) ;
#define tc int t , hi ; cin >> t ; for( hi=0 ; hi<t ; hi++ )


/********************                CODE START               ********************/



using namespace std ;


int main()
{
LSD

mp_ii mp ; int n ; cin >> n ; 
mpp_it_ii it ;
int cnt=0 , i=0 , j=0 ;

while(n--)
{
int q ; cin >> q ;
mp[q]++ ;
}

for(it = mp.begin();it!=mp.end();it++)
{
i=it->first , j=it->second ;
if(j>=i) cnt+=j-i ;
else cnt+=j ;
}

cout << cnt ;

return 0 ;

}

/***************************************************
*                                                 *
*        PERA                                     *
*                NAI                              *
*                       CHILL                     *
*                               BESI              *
*                                                 *
* *************************************************/
// Problem: AT3981 [ARC093D] Dark Horse
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT3981
// Memory Limit: 250 MB
// Time Limit: 2000 ms
// Start Coding at 2022-01-22 14:37:46
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define int long long 
using namespace std;

const int MAXN = 18;
const int MAXM = (1 << MAXN) + 5;
const int MOD  = 1e9 + 7;
int inline read(){
int x = 0, f = 0; char ch = getchar();
while(ch < '0' || ch > '9') f ^= (ch == '-'), ch = getchar();
while(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = getchar();
return f ? -x : x;
}

int n, m;
int a[MAXN];
int f[MAXN][MAXM];

// ===== start math functions =============
int fac[MAXM], ifac[MAXM];
int qpow(int x, int y) {
int ret = 1;
while(y) { 
if(y & 1) ret = ret * x % MOD;
y >>= 1; x = x * x % MOD;
}
return ret;
}
void prework(int n) {
fac[0] = ifac[0] = 1;
for(int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % MOD;
ifac[n] = qpow(fac[n], MOD - 2);
for(int i = n - 1; i >= 1; --i) ifac[i] = ifac[i + 1] * (i + 1) % MOD;
}
int C(int n, int m) { 
if(n < 0 || m < 0 || n - m < 0) return 0ll;
return fac[n] * ifac[n - m] % MOD * ifac[m] % MOD;
}
// ===== end math functions ===============

signed main(){
n = read(); m = read(); prework(1 << n);
for(int i = 0; i < m; ++i) a[i] = read();
sort(a, a + m); f[m][0] = 1;
for(int i = m; i >= 1; --i) {
for(int s = 0; s < (1 << n); ++s) {
f[i - 1][s] = (f[i - 1][s] + f[i][s]) % MOD;
for(int k = 0; k < n; ++k) {
if(s & (1 << k)) continue;
f[i - 1][s | (1 << k)] = (f[i - 1][s | (1 << k)] + \
f[i][s] * C((1 << n) - a[i - 1] - s, (1 << k) - 1) % MOD * fac[1 << k] % MOD ) % MOD;
}
}
}

// for(int i = 0; i <= m; ++i) {
// for(int s = 0; s < (1 << n); ++s)
// fprintf(stderr, "%lld ", f[0][s]);
// fprintf(stderr, "\n");
// }

int ans = 0, d = 0, tmp;
for(int s = 0; s < (1 << n); ++s) {
d = 0; 
for(int i = 0; i < n; ++i) if(s & (1 << i)) ++d;
tmp = f[0][s] * fac[(1 << n) - s - 1] % MOD;
if(d & 1) ans = (ans - tmp + MOD) % MOD;
else ans = (ans + tmp) % MOD;
}
printf("%lld\n", ans * (1 << n) % MOD);
}
#include <iostream>
using namespace std;
int main(){
int n,t,ans=0,last;
cin>>n>>t>>last;
while(--n){
int tt;
cin>>tt;
ans+=min(tt-last,t);
last=tt;
}
cout<<ans+t;
return 0;
}
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define gap " "
using namespace std;
const int N = 1e5 + 10;
const int mod = 1e9 + 7;
int as[N], bs[N], at[N], bt[N];
int32_t main() {
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
string s, t;
cin >> s >> t;
for (int i = 0;i < s.length(); ++i) {
as[i + 1] = as[i];
bs[i + 1] = bs[i];
if (s[i] == 'A') ++as[i + 1];
else ++bs[i + 1];
}

for (int i = 0; i < t.length(); ++i) {
at[i + 1] = at[i];
bt[i + 1] = bt[i];
if (t[i] == 'A')  ++at[i + 1];
else ++bt[i + 1];
}

int q; cin >> q;
while (q--) {
int l1, r1, l2, r2;
cin >> l1 >> r1 >> l2 >> r2;
int a1 = as[r1] - as[l1 - 1];
int b1 = bs[r1] - bs[l1 - 1];
int a2 = at[r2] - at[l2 - 1];
int b2 = bt[r2] - bt[l2 - 1];
//   cout << a1 << gap << b1 << gap << a2 << gap << b2 << endl;
a1 += (2 * b1);
a2 += (2 * b2);
a1 %= 3;
a2 %= 3;
if (a1 == a2) cout << "YES\n";
else cout << "NO\n";
/// cout.flush();
}


}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll read() {
ll x=0, f=1; char ch=' ';
while(!isdigit(ch)) { ch=getchar(); if(ch=='-') f=-1; }
while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch-48), ch=getchar();
return x*f;
}
int m, n, a[200005];
ll c[800005][2], f[200005], pre[200005], ans=1e18;
void build(int o, int l, int r) {
c[o][0]=c[o][1]=1e18;
if(l==r) return;
int mid=(l+r)>>1;
build(o*2, l, mid);
build(o*2+1, mid+1, r);
}
void change(int o, int l, int r, int k, ll x, int type) {
if(l==r) {
c[o][type]=min(c[o][type], x);
return;
}
int mid=(l+r)>>1;
if(k<=mid) change(o*2, l, mid, k, x, type);
else change(o*2+1, mid+1, r, k, x, type);
c[o][type]=min(c[o*2][type], c[o*2+1][type]);
}
ll query(int o, int l, int r, int s, int t, int type) {
if(l>=s&&r<=t) return c[o][type];
ll mid=(l+r)>>1, ans=1e18;
if(s<=mid) ans=min(ans, query(o*2, l, mid, s, t, type));
if(t>mid) ans=min(ans, query(o*2+1, mid+1, r, s, t, type));
return ans;
}
void solve(int A, int B) {
a[0]=A;
f[1]=abs(a[1]-B);
for(int i=1;i<=n;i++) pre[i]=pre[i-1]+abs(a[i]-a[i-1]);
build(1, 1, m);
change(1, 1, m, a[0], f[1]-pre[1]-a[0], 0);
change(1, 1, m, a[0], f[1]-pre[1]+a[0], 1);
for(int i=2;i<=n;i++) {
ll tmp1=query(1, 1, m, 1, a[i], 0), tmp2=query(1, 1, m, a[i], m, 1);
f[i]=min(a[i]+tmp1, tmp2-a[i])+pre[i-1];
change(1, 1, m, a[i-1], f[i]-pre[i]-a[i-1], 0);
change(1, 1, m, a[i-1], f[i]-pre[i]+a[i-1], 1);
}
for(int i=1;i<=n;i++) ans=min(ans, f[i]+pre[n]-pre[i]);
}
int main() {
int A, B;
cin>>m>>n>>A>>B;
for(int i=1;i<=n;i++) a[i]=read();
solve(A, B);
solve(B, A);
cout<<ans;
}

#include<bits/stdc++.h>
using namespace std;
#define N 200010
const int mod=1e9+7;
typedef long long ll;
int n,m,a[N],b[N],tot,by[N],len,dp[N],ans;
struct Point{
int x,y;
friend bool operator == (const Point &a,const Point &b){
return a.x==b.x&&a.y==b.y;
}
}p[N];
class BIT{
int Len;
vector<int> b;
inline int lowbit(int x){
return x&(-x);
}
public:
BIT(int _n):Len(_n){
b.resize(_n+1);
}
inline void Add(int x,int d){
while(x<=Len)b[x]=(b[x]+d)%mod,x+=lowbit(x);
}
inline int Ask(int x){
int ans=0;
while(x)ans=(ans+b[x])%mod,x-=lowbit(x);
return ans;
}
};
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n>>m;
for(int i=1;i<=n;++i){
cin>>a[i];
}
for(int i=1;i<=m;++i){
cin>>b[i];
}
for(int i=1,j=1;i<=n;++i){
while(j<=m&&b[j]<a[i])++j;
if(j>1&&j<=m){
p[++tot]={a[i]-b[j-1],b[j]-a[i]};
}
}
sort(p+1,p+tot+1,[&](Point a,Point b){return a.x==b.x?a.y>b.y:a.x<b.x;});
tot=unique(p+1,p+tot+1)-p-1;
for(int i=1;i<=tot;++i){
by[i]=p[i].y;
}
sort(by+1,by+tot+1);
len=unique(by+1,by+tot+1)-by-1;
for(int i=1;i<=tot;++i){
p[i].y=lower_bound(by+1,by+len+1,p[i].y)-by;
}
BIT B(len);
ans=1;
for(int i=1;i<=tot;++i){
dp[i]=B.Ask(p[i].y-1)+1;
B.Add(p[i].y,dp[i]);
ans=(ans+dp[i])%mod;
}
cout<<ans<<'\n';
return 0;
}



#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL)
#define testcase int T; cin >> T; for (int tc = 1; tc <= T; tc++)
#define MAX 1000000007
#define limit 10000000000000
#define modulo 998244353
#define INF 4000000000000000005
#define vi vector<int>
#define vl vector<long long>
#define pi pair<int,int>
#define pl pair<long long,long long>
#define PI 2*acos(0.0)
#define pb push_back
#define mkp make_pair

void ha()
{
cout<<"YES"<<endl;
}
void na()
{
cout<<"NO"<<endl;
}

ll power(ll a,ll b)
{
ll c,d;

if(b==0)
{
return 1%MAX;
}
else if(b==1)
{
return a%MAX;
}
else if(b%2==0)
{
c=power(a,b/2);
return (c*c)%MAX;
}
else
{
c=power(a,b/2);
d=(c*c)%MAX;
d=(d*a)%MAX;
return d;
}
}

ll plainPower(ll a,ll b)
{
ll sum=1,i;
for(i=1; i<=b; i++)
{
sum*=a;
}
return sum;
}

int absolute(int a)
{
if(a>=0)
{
return a;
}
else
{
return (a*(-1));
}
}
ll absolute(ll a)
{
if(a>=0)
{
return a;
}
else
{
return (a*(-1));
}
}

bool isPrime(int a)
{
for(int i=2; i*i<=a; i++)
{
if(a%i==0)
{
return false;
}
}
return true;
}

bool isTriangle(ll x1,ll y1,ll x2,ll y2,ll x3,ll y3)
{
ll area = (x1*(y2-y3)) + (x2*(y3-y1)) + (x3*(y1-y2));
if(area)
{
return true;
}
else
{
return false;
}
}

ll findRangeSum(ll hi,ll lo)
{
ll j = (hi*(hi+1))/2;
ll k= (lo*(lo+1))/2;
return j-k;
}

bool present(vi &a,int n,int target)
{
int lo=0,hi=n-1,mid;
while(lo<=hi)
{
mid=lo+((hi-lo)/2);
if(a[mid]==target)
{
return true;
}
else if(a[mid]>target)
{
hi=mid-1;
}
else
{
lo=mid+1;
}
}
return false;
}

int Left_bound(vi &a,int n,int target)
{
int lo=0,hi=n-1,mid,ans=0;

while(lo<=hi)
{
mid=lo+((hi-lo)/2);

if(a[mid]<=target)
{
ans=mid;
lo=mid+1;
}
else
{
hi=mid-1;
}
}
return a[ans];
}
int Right_bound(vi &a,int n,int target)
{
int lo=0,hi=n-1,mid,ans=n-1;

while(lo<=hi)
{
mid=lo+((hi-lo)/2);

if(a[mid]>=target)
{
ans=mid;
hi=mid-1;
}
else
{
lo=mid+1;
}
}
return a[ans];
}
void printArray(vi &a)
{
for(int i=0; i<a.size(); i++)
{
cout<<a[i]<<" ";
}
cout<<endl;
}
int Right_bound(vector<pi>&a,int n,int target)
{
int lo=0,hi=n-1,mid,ans=0;
while(lo<=hi)
{
mid=lo+((hi-lo)/2);
if(a[mid].first>=target)
{
ans=a[mid].second;
lo=mid+1;
}
else
{
hi=mid-1;
}
}
return ans;
}

int prefA[100002][2];
int prefB[100002][2];


int main()
{
fastio;
int i,j,k,l;

string a;
cin>>a;
int n=a.length();
string b;
cin>>b;
int m=b.length();



for(i=0; i<n; i++)
{
prefA[i+1][0]=prefA[i][0];
prefA[i+1][1]=prefA[i][1];

prefA[i+1][(a[i]-'A')]++;
}

for(i=0; i<m; i++)
{
prefB[i+1][0]=prefB[i][0];
prefB[i+1][1]=prefB[i][1];

prefB[i+1][(b[i]-'A')]++;

}

int t,t1,t2;cin>>t;
while(t--)
{
cin>>i>>j>>k>>l;

t1 = ((prefA[j][0]-prefA[i-1][0])*2)+((prefA[j][1]-prefA[i-1][1])*1);
t2 = ((prefB[l][0]-prefB[k-1][0])*2)+((prefB[l][1]-prefB[k-1][1])*1);

if((t1%3)==(t2%3))
{
ha();
}
else
{
na();
}
}


return 0;
}

// Exported by Exporter.exe

// Included from D.cpp
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define F first
#define S second
#define MP make_pair
#define MTP make_tuple
#define R Read
#define RD Read_Digit
#define RP Read_P
#define RS Read_String
#define RL Read_Loop
#define RLD Read_Loop_Digit
#define RLP Read_Loop_P
#define RLS Read_Loop_String
#ifdef ONLINE_JUDGE
#define Debug(...) ;
#define Debug_Array(n,x) ;
#define Debugln_Array(n,x) ;
#define NL ;
#else
#define Debug(...) {printf("(%s) = ",(#__VA_ARGS__)),_print(__VA_ARGS__),printf("\n");}
#define Debug_Array(n,x) {printf("%s :",(#x));for(int i=1;i<=n;i++)printf(" "),_print(x[i]);printf("\n");}
#define Debugln_Array(n,x) {for(int i=1;i<=n;i++){printf("%s",(#x));printf("[%d] = ", i);_print(x[i]);printf("\n");}}
#define NL {printf("\n");}
#endif
typedef long long int ll;
typedef unsigned long long int ull;

constexpr int kN = int(1E5 + 10);
// constexpr int kMod = 998244353;
// constexpr int kMod = int(1E9 + 7);
// constexpr int kInf = 0x3f3f3f3f;
// constexpr ll kInf = 0x3f3f3f3f3f3f3f3f;
// constexpr double kPi = acos(-1);
// constexpr double kEps = 1E-9;
// constexpr int dx[4] = {0, 0, 1, -1};
// constexpr int dy[4] = {1, -1, 0, 0};
// constexpr int dx[8] = {0, 0, 1, -1, 1, -1, 1, -1};
// constexpr int dy[8] = {1, -1, 1, -1, -1, 1, 0, 0};


// Included from C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp
bool Fast_IO_activated = false;
bool IOS_activated = false;
// --- Get ---
static inline char Get_Raw_Char() {
static bool pre = Fast_IO_activated = true;
static char buf[1 << 16], *p = buf, *end = buf;
if (p == end) {
if ((end = buf + fread(buf, 1, 1 << 16, stdin)) == buf) return '\0';
p = buf;
}
return *p++;
}

// --- Read ---
template <typename T> static inline void Read_P(T &n) {
static_assert(is_integral<T>::value, "Read_P requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
return ;
}

template <typename T> static inline void Read(T &n) {
static_assert(is_integral<T>::value, "Read requires an integral type");
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
if (neg) n = -n;
return ;
}

template <typename T> static inline void Read_Digit(T &n) {
static_assert(is_integral<T>::value, "Read_Digit requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
return ;
}

static inline void Read_String(string &s) {
s.clear();
char c = Get_Raw_Char();
while (c == ' ' or c == '\n') c = Get_Raw_Char();
while (c != ' ' and c != '\n') {
s += c;
c = Get_Raw_Char();
}
return ;
}

// --- Read multiple ---
template <typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read(n); return Read(Fargs...);}
template <typename T, typename... Targs> static inline void Read_Digit(T &n, Targs&... Fargs) {Read_Digit(n); return Read_Digit(Fargs...);}
template <typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P(n); return Read_P(Fargs...);}
template <typename... Targs> static inline void Read_String(string &s, Targs&... Fargs) {Read_String(s); return Read_String(Fargs...);}

// --- Read Loop ---
template <typename T> static inline void Read_Loop_i(int i, T *a) {return Read(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_i(int i, T *a, Targs*... Fargs) {Read(a[i]); return Read_Loop_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_Digit_i(int i, T *a) {return Read_Digit(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_Digit_i(int i, T *a, Targs*... Fargs) {Read_Digit(a[i]); return Read_Loop_Digit_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_Digit(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_Digit_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_P_i(int i, T *a) {return Read_P(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_P_i(int i, T *a, Targs*... Fargs) {Read_P(a[i]); return Read_Loop_P_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_P(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_P_i(i, Fargs...);}

static inline void Read_Loop_String_i(int i, string *a) {return Read_String(a[i]);}
template <typename... Targs> static inline void Read_Loop_String_i(int i, string *a, Targs*... Fargs) {Read_String(a[i]); return Read_Loop_String_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_String(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_String_i(i, Fargs...);}

// --- Float ---
template <int mul, typename T> static inline void Read(T &n) {
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;

if (neg) n = -n;
return ;
}

template <int mul, typename T> static inline void Read_P(T &n) {
char c;
while (!isdigit(c = Get_Raw_Char())) ;

n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;
return ;
}

template <int mul, typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read<mul>(n); return Read<mul>(Fargs...);}
template <int mul, typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P<mul>(n); return Read_P<mul>(Fargs...);}

// --- init ---
inline void IOS() {
IOS_activated = true;
ios::sync_with_stdio(false); cin.tie(0);
}
inline void Freopen(const char *in, const char *out) {freopen(in, "r", stdin); freopen(out, "w", stdout); return ;}

// --- Output ---
#if defined(__SIZEOF_INT128__)
void Print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
} 
#endif
// End of C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp
template <typename T, typename T1> void make_vector_inner(vector<T>& vec, T1 c) {return vec.push_back(T(c));}
template <typename T, typename T1, typename... Targs> void make_vector_inner(vector<T> &vec, T1 c, Targs... targs) {
vec.push_back(T(c));
return make_vector_inner(vec, targs...);
}
template <typename T, typename... Targs> vector<T> make_vector(Targs... targs) {
vector<T> vec;
make_vector_inner(vec, targs...);
return vec;
}

template <typename T> inline void sort(vector<T> &v) {return sort(v.begin(), v.end());}
template <typename T> inline void sort_r(vector<T> &v) {return sort(v.begin(), v.end(), greater<T>());}
inline void sort(string &s) {return sort(s.begin(), s.end());}
inline void sort_r(string &s) {return sort(s.begin(), s.end(), greater<char>());}

template <typename T> inline void reverse(vector<T> &v) {return reverse(v.begin(), v.end());}
inline void reverse(string &s) {return reverse(s.begin(), s.end());}

template <typename T> inline void Merge(vector<T> &a, vector<T> &b, vector<T> &c) {
if (c.size() < a.size() + b.size()) c.resize(a.size() + b.size());
merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());
return ;
}
template <typename T> inline void Concatanate(vector<T> &a, vector<T> &b, vector<T> &c) {
int a_size = int(a.size()), b_size = int(b.size());
c.resize(a_size + b_size);
for (int i = 0; i < a_size; i++) c[i] = a[i];
for (int i = 0; i < b_size; i++) c[i + a_size] = b[i];
return ;
}
template <typename T> inline void Append(vector<T> &lhs, vector<T> rhs) {
int lsz = int(lhs.size()), rsz = int(rhs.size());
lhs.reserve(lsz + rsz);
for (int i = 0; i < rsz; i++) lhs.push_back(rhs[i]);
return ;
}

template <typename T> inline void Erase(vector<T> &vec, T x) {
int sz = int(vec.size());
for (int i = 0; i < sz; i++) if (vec[i] == x) {
swap(vec[i], vec.back());
vec.pop_back();
break;
}
return ;
}

template <typename T> inline void Discrete(vector<T> &v) {sort(v); v.resize(unique(v.begin(), v.end()) - v.begin()); return ;}
template <typename T> inline int Discrete_Id(vector<T> &v, T x) {return lower_bound(v.begin(), v.end(), x) - v.begin();}

template <typename T> using PQ = priority_queue<T>;
template <typename T> using PQ_R = priority_queue<T, vector<T>, greater<T>>;

template <typename T> inline T ABS(T n) {return n >= 0 ? n : -n;}
template <typename T> __attribute__((target("bmi"))) inline T gcd(T a, T b) {
if (a < 0) a = -a;
if (b < 0) b = -b;
if (a == 0 || b == 0) return a + b;
int n = __builtin_ctzll(a);
int m = __builtin_ctzll(b);
a >>= n;
b >>= m;
while (a != b) {
int m = __builtin_ctzll(a - b);
bool f = a > b;
T c = f ? a : b;
b = f ? b : a;
a = (c - b) >> m;
}
return a << min(n, m);
}
template <typename T> inline T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <typename T, typename... Targs> inline T gcd(T a, T b, T c, Targs... args) {return gcd(a, gcd(b, c, args...));}
template <typename T, typename... Targs> inline T lcm(T a, T b, T c, Targs... args) {return lcm(a, lcm(b, c, args...));}
template <typename T, typename... Targs> inline T min(T a, T b, T c, Targs... args) {return min(a, min(b, c, args...));}
template <typename T, typename... Targs> inline T max(T a, T b, T c, Targs... args) {return max(a, max(b, c, args...));}
template <typename T, typename... Targs> inline void chmin(T &a, T b, Targs... args) {a = min(a, b, args...); return ;}
template <typename T, typename... Targs> inline void chmax(T &a, T b, Targs... args) {a = max(a, b, args...); return ;}

vector<int> Primes(int n) {
if (n == 1) return {};
// 2 ~ n
vector<int> primes;
vector<bool> isPrime(n + 1, true);

primes.reserve(n / __lg(n));

for (int i = 2; i <= n; i++) {
if (isPrime[i]) primes.push_back(i);
for (int j : primes) {
if (i * j > n) break;
isPrime[i * j] = false;
if (i % j == 0) break;
}
}
return primes;
}

template <typename T> vector<T> factors(T x) {
// maybe use factorize would be faster?
vector<T> ans;
for (T i = 1; i * i <= x; i++) if (x % i == 0) ans.push_back(i);

int id = int(ans.size()) - 1;
if (ans[id] * ans[id] == x) id--;
for (int i = id; i >= 0; i--) ans.push_back(x / ans[i]);

return ans;
}

int mex(vector<int> vec) {
int n = int(vec.size());
vector<bool> have(n, false);
for (int i : vec) if (i < n) have[i] = true;
for (int i = 0; i < n; i++) if (!have[i]) return i;
return n;
}

template <typename T> T SQ(T x) {return x * x;}

// Euclidean distance
template <typename T> T Dist2(pair<T, T> lhs, pair<T, T> rhs) {return SQ(lhs.F - rhs.F) + SQ(lhs.S - rhs.S);}
template <typename T> T Dist2(T x1, T y1, T x2, T y2) {return SQ(x1 - x2) + SQ(y1 - y2);}

// Manhattan distance
template <typename T> T Mdist(pair<T, T> lhs, pair<T, T> rhs) {return ABS(lhs.first - rhs.first) + ABS(lhs.second - rhs.second);}
template <typename T> T Mdist(T x1, T y1, T x2, T y2) {return ABS(x1 - x2) + ABS(y1 - y2);}

template <typename T> bool Adj(pair<T, T> lhs, pair<T, T> rhs) {return Mdist(lhs, rhs) == 1;}

template <typename T> T LUBound(T LB, T val, T UB) {return min(max(LB, val), UB);}

template <typename T, typename Comp> T Binary_Search(T L, T R, Comp f) {
// L good R bad
static_assert(is_integral<T>::value, "Binary_Search requires an integral type");
while (R - L > 1) {
T mid = (L + R) >> 1;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename Comp> double Binary_Search(double L, double R, Comp f, int loop = 30) {
for (int i = 1; i <= loop; i++) {
double mid = (L + R) / 2;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename T> T nearest_dist(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin() - val;
else if (val >= *prev(se.end())) return val - *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);
return min(*u - val, val - *v);
}
}

template <typename T> T nearest_elem(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin();
else if (val >= *prev(se.end())) return *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);

if (*u - val > val - *v) return *v;
else return *u;
}
}

namespace MR32 {
using ull = unsigned long long int;
using uint = unsigned int;
ull PowMod(ull a, ull b, ull kMod) {
ull ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(uint x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 3, a[3] = {2, 7, 61};
if (x < 8) return low[x];

uint t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
ull tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}

#ifdef __SIZEOF_INT128__
namespace MR64 {
using uint128 = unsigned __int128;
using ull = unsigned long long int;
using uint = unsigned int;
uint128 PowMod(uint128 a, uint128 b, uint128 kMod) {
uint128 ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(ull x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 7, a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
if (x < 8) return low[x];
ull t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
uint128 tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}
#endif

bool IsPrime(unsigned long long int x) {
#ifdef __SIZEOF_INT128__
if ((x >> 32) == 0) return MR32::IsPrime(x);
else return MR64::IsPrime(x);
#endif
return MR32::IsPrime(x);
}

#ifdef __SIZEOF_INT128__
uint64_t PollardRho(uint64_t x) {
static mt19937 rng;
if (!(x & 1)) return 2;
if (IsPrime(x)) return x;
int64_t a = rng() % (x - 2) + 2, b = a;
uint64_t c = rng() % (x - 1) + 1, d = 1;
while (d == 1) {
a = (__int128(a) * a + c) % x;
b = (__int128(b) * b + c) % x;
b = (__int128(b) * b + c) % x;
d = gcd(uint64_t(abs(a - b)), x);
if (d == x) return PollardRho(x);
}
return d;
}

template <typename T> vector<T> factorize(T x) {
if (x <= 1) return vector<T>();
T p = PollardRho(x);
if (p == x) return vector<T>(1, x);
vector<T> ans, lhs = factorize(p), rhs = factorize(x / p);
Merge(lhs, rhs, ans);
return ans;
}
#endif

// vec must be sorted
template <typename T> vector<pair<T, int>> Compress(vector<T> vec) {
if (vec.empty()) return {};

vector<pair<T, int>> ans;
int cnt = 1, sz = int(vec.size());
T lst = vec[0];
for (int i = 1; i < sz; i++) {
if (lst != vec[i]) {
ans.push_back(make_pair(lst, cnt));
lst = vec[i];
cnt = 1;
}
else cnt++;
}
ans.push_back(make_pair(lst, cnt));
return ans;
}

template <typename T> int Divisors(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

int ans = 1;
for (pair<T, int> i : fac) ans *= i.second + 1;

return ans;
}

template <typename T> T phi(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

T ans = 1;
for (pair<T, int> i : fac) {
ans *= i.first - 1;
for (int j = 1; j < i.second; j++) ans *= i.first;
}

return ans;
}
// End of C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp
template <typename T> void _print(vector<T> v) ;
void _print(bool x) {printf("%s", x ? "True" : "False");}
void _print(char x) {printf("%c", x);}
void _print(short x) {printf("%hd", x);}
void _print(unsigned short x) {printf("%hu", x);}
void _print(int x) {printf("%d", x);}
void _print(unsigned int x) {printf("%u", x);}
void _print(long int x) {printf("%ld", x);}
void _print(unsigned long int x) {printf("%lu", x);}
void _print(long long int x) {printf("%lld", x);}
void _print(unsigned long long int x) {printf("%llu", x);}
void _print(float x) {printf("%f", x);}
void _print(double x) {printf("%lf", x);}
void _print(long double x) {printf("%Lf", x);}
void _print(const char* c) {int n = strlen(c); for (int i = 0; i < n; i++) printf("%c", c[i]);}
void _print(string s) {for (char c : s) printf("%c", c);}
template <size_t _size> void _print(bitset<_size> bs) {for (int i = 0; i < _size; i++) printf("%d", bs[i] ? 1 : 0);}
#ifdef __SIZEOF_INT128__
void _print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
void _print(unsigned __int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
#endif
template <typename T1, typename T2> void _print(pair<T1, T2> x) {printf("("); _print(x.first); printf(", "); _print(x.second); printf(")");}
template <typename T1, typename T2, typename T3> void _print(tuple<T1, T2, T3> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(")");}
template <typename T1, typename T2, typename T3, typename T4> void _print(tuple<T1, T2, T3, T4> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(", "); _print(get<3>(x)); printf(")");}
template <typename T> void _print(vector<T> v) {
if (v.empty()) printf(" empty");
else {
bool first = true;
for (T i : v) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(set<T> s) {
if (s.empty()) printf(" empty");
else {
bool first = true;
for (T i : s) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(stack<T> s) {
if (s.empty()) printf(" empty");
else {
_print(s.top()); s.pop();
while (!s.empty()) {printf(", "); _print(s.top()); s.pop();}
}
}
template <typename T> void _print(queue<T> q) {
if (q.empty()) printf(" empty");
else {
_print(q.front()); q.pop();
while (!q.empty()) {printf(", "); _print(q.front()); q.pop();}
}
}
template <typename T> void _print(deque<T> dq) {
if (dq.empty()) printf(" empty");
else {
_print(dq.front()); dq.pop_front();
while (!dq.empty()) {printf(", "); _print(dq.front()); dq.pop_front();}
}
}
template <typename T1, typename T2, typename T3> void _print(priority_queue<T1, T2, T3> pq) {
if (pq.empty()) printf(" empty");
else {
_print(pq.top()); pq.pop();
while (!pq.empty()) {printf(", "); _print(pq.top()); pq.pop();}
}
}
template <typename T1, typename T2> void _print(map<T1, T2> m) {
if (m.empty()) printf(" empty");
else {
bool first = true;
for (pair<T1, T2> i : m) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}

template <typename T> void _print(T& x) {return x.out();}
template <typename T, typename... Targs> void _print(T x, Targs... Fargs) {_print(x); printf(", "); _print(Fargs...);}
// End of C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp

int a[kN], b[kN];
int dis[kN], dis1[kN], disn[kN];
vector<int> graph[kN];

void Dfs(int cur, int from) {
dis[cur] = dis[from] + 1;
for (int i : graph[cur]) if (i != from) Dfs(i, cur);
return ;
}

int main() {
int n; RP(n);
RLP(n - 1, a, b);

for (int i = 1; i < n; i++) {
graph[a[i]].PB(b[i]);
graph[b[i]].PB(a[i]);
}

Dfs(1, 1);
memcpy(dis1, dis, sizeof(dis));
memset(dis, 0, sizeof(dis));
Dfs(n, n);
memcpy(disn, dis, sizeof(dis));

int l = 0, r = 0;
for (int i = 1; i <= n; i++) {
if (dis1[i] <= disn[i]) l++;
else r++;
}

Debug_Array(n, dis1);
Debug_Array(n, disn);

Debug(l, r);

if (l > r) printf("Fennec\n");
else printf("Snuke\n");
}
// End of D.cpp

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int xy=2e5+10;
int a[xy];
int main(){
int N;cin>>N;
int sum2=0,sum1=0,sum4=0,sum;
for(int i=0;i<N;++i){
int x;scanf("%d",&x);
if(x%2==0){
if(x%4==0) sum4++;
else sum2++;
}
}
sum1=N-sum2-sum4;
if(sum1<=sum4+1&&sum2==0||sum2==N||sum1<sum4+1&&sum2!=0) cout<<"Yes"<<endl;
else cout<<"No"<<endl;
// cout<<"sum1="<<sum1<<"  sum2="<<sum2<<"  sum4="<<sum4<<"  sum="<<sum;
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef long double ld;
typedef std::pair<int, int> pii;
typedef std::pair<int, ll> pil;
typedef std::pair<ll, int> pli;
typedef std::pair<ll, ll> pll;
typedef std::pair<int, ld> pid;
typedef std::pair<ll, ld> pld;
typedef std::pair<int, std::string> pis;
typedef std::pair<ll, std::string> pls;
typedef std::vector<int> vi;
typedef std::vector<vi> vvi;
typedef std::vector<vvi> vvvi;
typedef std::vector<vvvi> vvvvi;
typedef std::vector<ll> vl;
typedef std::vector<vl> vvl;
typedef std::vector<vvl> vvvl;
typedef std::vector<vvvl> vvvvl;
typedef std::vector<ld> vd;
typedef std::vector<vd> vvd;
typedef std::vector<std::string> vs;
#define sz(a) (int)(a).size()
#define rep(i,n) for(auto i=0; i<n; ++i)
#define repm(i,s,n) for(auto i=s; i<n; ++i)
#define repd(i,n) for(auto i=n-1; i>=0; --i)
#define repdm(i,e,n) for(auto i=n-1; i>=e; --i)
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()

constexpr int INF = std::numeric_limits<int>::max() >> 1;
constexpr long long INF_LL = std::numeric_limits<long long>::max() >> 1LL;
constexpr long long MOD1 = 1000000007;
constexpr long long MOD9 = 998244353;
using mint1 = atcoder::modint1000000007;
using mint9 = atcoder::modint998244353;
using vm1 = std::vector<mint1>;
using vvm1 = std::vector<vm1>;
using vvvm1 = std::vector<vvm1>;
using vvvvm1 = std::vector<vvvm1>;
using vm9 = std::vector<mint9>;
using vvm9 = std::vector<vm9>;
using vvvm9 = std::vector<vvm9>;
using vvvvm9 = std::vector<vvvm9>;

template <class T> inline bool chmax(T& a, T b, int eq = 0) { if (a < b || (a == b && eq)) { a = b; return 1; } return 0; }
template <class T> inline bool chmin(T& a, T b, int eq = 0) { if (a > b || (a == b && eq)) { a = b; return 1; } return 0; }

template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::istream& operator>>(std::istream& is, mint& x) noexcept {long long v = 0; std::cin >> v; x = v; return is;}
template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::ostream& operator<<(std::ostream& os, const mint& x) noexcept {os << x.val(); return os;}
inline void __n() { std::cout << "\n"; }
template <class T> inline void __(const T a) { std::cout << a; }
template <class T> inline void __l(const T a) { __(a); __n(); }
template <class T> inline void __s(const T a) { __(a); __(' '); }
template <class T1, class T2> inline void __l(const std::pair<T1, T2> a) { __s(a.first); __l(a.second); }
template <class T1, class T2> inline void __s(const std::pair<T1, T2> a) { __s(a.first); __s(a.second); }
template <class T> inline void __v(const std::vector<T> v) { for(auto a : v) __(a); }
template <class T> inline void __vl(const std::vector<T> v) { for(auto a : v) __l(a); }
template <class T> inline void __vs(const std::vector<T> v) { for(auto a : v) __s(a); __n(); }
template <class T> inline void __vvl(const std::vector<std::vector<T>> v) { for(auto a : v) { __v(a); __n(); } }
template <class T> inline void __vvs(const std::vector<std::vector<T>> v) { for(auto a : v) { __vs(a); } }
inline void __ynl(const bool b) {__l(b ? "yes" : "no");}
inline void __yns(const bool b) {__l(b ? "Yes" : "No");}
inline void __ynu(const bool b) {__l(b ? "YES" : "NO");}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

void solve() {


const int N = 66;
int A, B; cin >> A >> B; A--; B--;

vvi ans(N, vi(N));
rep(i, N/2) rep(j, N) ans[i][j] = 1;

int h = 0, w = 0;
while(A > 0) {
if (w >= N) w = 2 * (++h % 2);
ans[h][w] = 0; w += 4;
A--;
}

h = N-1; w = 2;
while (B > 0) {
if (w >= N) w = 2 * (--h % 2);
ans[h][w] = 1; w += 4;
B--;
}

__s(N); __l(N);
rep(i, N) {
rep(j, N) __(ans[i][j] ? '#' : '.');
__n();
}







}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

int main() {

std::ifstream in("input.txt");
std::cin.rdbuf(in.rdbuf());

std::cin.tie(nullptr);
std::cout.tie(nullptr);
std::ios::sync_with_stdio(false);

solve();
std::cout << std::flush;

return 0;
}

#include <algorithm>
#include <iostream>
#include <numeric>
#include <cstring>
#include <iomanip>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <cmath>
#include <set>
#include <map>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

int32_t main()
{
ios::sync_with_stdio(false);
cin.tie(0);
int n, k; cin >> n >> k;
if(k % 2 == 1)
{
ll x = n/k;
ll ans = x*x*x;
cout << ans << endl;
}
else
{
if(n < k/2)
{
cout << 0 << endl;
return 0;
}
ll x = n/k;
ll ans = x*x*x;
ll y = (n-k/2) / k + 1;
ans += y*y*y;
cout << ans << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
#define all(v) v.begin(), v.end()
#define rep(i, begin, end) for(auto i = (begin); i < (end); i++)
#define rrep(i, end, begin) for(auto i = (end) - 1; i >= (begin); i--)
template<class T> inline bool chmin(T& a, T b){ if (a > b){ a = b; return true; } return false; }
template<class T> inline bool chmax(T& a, T b){ if (a < b){ a = b; return true; } return false; }
template<class T> inline T roundup(T a, T b){ return (a + b - 1) / b; }
constexpr int dy[] = {0, 1, 0, -1, 1, 1, -1, -1, 0};
constexpr int dx[] = {1, 0, -1, 0, 1, -1, 1, -1, 0};
using ll = long long;
constexpr ll INF = 1e9;
/* #include <atcoder/all>
using namespace atcoder;
using mint = modint1000000007;
ostream& operator<<(ostream& os, const mint& n){ os << n.val(); return os; }
istream& operator>>(istream& is, mint& n){ ll m; is >> m; n = m; return is; } */
struct Edge{ int to; ll cost; Edge(int to, ll cost) : to(to), cost(cost) {} };
using Graph = vector<vector<int>>;

int main(){
cin.tie(nullptr);
ios::sync_with_stdio(false);

int h, w, n;
cin >> h >> w >> n;
vector<int> a(n);
for(auto&& e : a) cin >> e;

vector c(h, vector(w, -1));
int idx = 0;
rep(i, 0, h){
if(i % 2 == 0){
rep(j, 0, w){
while(a[idx] <= 0) idx++;
if(a[idx] > 0) c[i][j] = idx, a[idx]--;
}
}else{
rrep(j, w, 0){
while(a[idx] <= 0) idx++;
if(a[idx] > 0) c[i][j] = idx, a[idx]--;
}
}
}
rep(i, 0, h){
rep(j, 0, w) cout << c[i][j] + 1 << " ";
cout << endl;
}
}

#include <cstdio>
#include <vector>
#include <queue>

using namespace std;

const int MAXN = 1e5 + 10, MAXM = 2e5 + 10, MAXC = 1e6 + 10, INF = 2e9;

int n, m;
vector <pair <int, int> > cor[MAXC];
vector <int> e[MAXN + MAXM];

int fa[MAXN], sz[MAXN], id[MAXN], tot;
bool vis[MAXN + MAXM];

void Init(int k) {fa[k] = k, sz[k] = 1, id[k] = -1, vis[k] = 0;}
int Find(int k) {return (k == fa[k] ? k : fa[k] = Find(fa[k]));}
void Union(int u, int v)
{
u = Find(u), v = Find(v);
if (u == v) return;
if (sz[u] < sz[v]) fa[u] = v;
else fa[v] = u;
}

int dis[MAXN + MAXM];
queue <int> q;
void SPFA()
{
for (int i = 1; i <= tot; i++) dis[i] = INF, vis[i] = 0;
dis[1] = 0, vis[1] = 1;
q.push(1);
while (!q.empty())
{
int u = q.front(); q.pop();
vis[u] = 0;
for (auto v : e[u])
if (dis[v] > dis[u] + 1)
{
dis[v] = dis[u] + 1;
if (!vis[v]) q.push(v), vis[v] = 1;
}
}
}

int main()
{
scanf("%d%d", &n, &m);
for (int i = 1; i <= m; i++)
{
int u, v, w;
scanf("%d%d%d", &u, &v, &w);
cor[w].push_back(make_pair(u, v));
}
tot = n;
for (int i = 1; i <= 1e6; i++)
if (!cor[i].empty())
{
for (auto x : cor[i]) Init(x.first), Init(x.second);
for (auto x : cor[i]) Union(x.first, x.second);
for (auto x : cor[i])
{
if (!vis[x.first])
{
int t = Find(x.first);
if (id[t] == -1) id[t] = ++tot;
e[x.first].push_back(id[t]), e[id[t]].push_back(x.first);
vis[x.first] = 1;
}
if (!vis[x.second])
{
int t = Find(x.second);
if (id[t] == -1) id[t] = ++tot;
e[x.second].push_back(id[t]), e[id[t]].push_back(x.second);
vis[x.second] = 1;
}
}
}
SPFA();
printf("%d\n", (dis[n] != INF ? dis[n] / 2 : -1));
return 0;
}

// Problem: AT2396 [ARC071D] Infinite Sequence
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT2396
// Memory Limit: 250 MB
// Time Limit: 2000 ms

/*
* Author: chenkaifeng @BDFZ
*/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pf push_front
#define rep(i, s, t) for (int i = s; i <= t; ++i)
#define per(i, s, t) for (int i = t; i >= s; --i)

namespace nqio{const unsigned R=4e5,W=4e5;char*a,*b,i[R],o[W],*c=o,*d=o+W,h[40],*p=h,y;bool s;struct q{void r(char&x){x=a==b&&(b=(a=i)+fread(i,1,R,stdin),a==b)?-1:*a++;}void f(){fwrite(o,1,c-o,stdout);c=o;}~q(){f();}void w(char x){*c=x;if(++c==d)f();}q&operator>>(char&x){do r(x);while(x<=32);return*this;}q&operator>>(char*x){do r(*x);while(*x<=32);while(*x>32)r(*++x);*x=0;return*this;}template<typename t>q&operator>>(t&x){for(r(y),s=0;!isdigit(y);r(y))s|=y==45;if(s)for(x=0;isdigit(y);r(y))x=x*10-(y^48);else for(x=0;isdigit(y);r(y))x=x*10+(y^48);return*this;}q&operator<<(char x){w(x);return*this;}q&operator<<(char*x){while(*x)w(*x++);return*this;}q&operator<<(const char*x){while(*x)w(*x++);return*this;}template<typename t>q&operator<<(t x){if(!x)w(48);else if(x<0)for(w(45);x;x/=10)*p++=48|-(x%10);else for(;x;x/=10)*p++=48|x%10;while(p!=h)w(*--p);return*this;}}qio;}using nqio::qio;

#define OK debug("OK!\n")
#ifndef ONLINE_JUDGE
namespace debuger{void debug(const char *s) {cerr << s;}template<typename T1,typename... T2>void debug(const char*s, const T1 x, T2...ls) { int p=0; while(*(s + p)!='\0') {if(*(s+p)=='{'&&*(s+p+1)=='}'){cerr << x;debug(s + p + 2, ls...);return;}cerr << *(s + p++);}}}using debuger::debug;
#else
#define debug(...) void(0)
#endif

const int mod = 1e9 + 7;
// const int mod = 998244353;

int qpow(int x, ll p) {
int res = 1, base = x;
while(p) {
if(p & 1) res = 1ll * res * base % mod;
base = 1ll * base * base % mod;
p >>= 1;
}
return res;
}

template<typename T> inline void upd(T& x, const T& y) {	x += y;	if(x >= mod) x -= mod; }
template<typename T> inline void upd(T& x, const T& y, const T& z) { x = y + z; if(x >= mod) x -= mod; }

/* template ends here */

const int N = 1e6 + 5;

int f[N], suf[N<<1], n;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr), cout.tie(nullptr);
cout << fixed << setprecision(15); 
cerr << fixed << setprecision(15);

cin >> n;
suf[n] = n, f[n] = n;
int v = 1ll*(n-1)*(n-1)%mod;
per(i, 1, n-1) {
f[i] = (1ll*f[i+1]+suf[i+3]+(i+1)-(i+2>n)+v)%mod;
suf[i] = (suf[i+1] + f[i])%mod;
}

cout << f[1] << "\n";

return 0;
}

#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
typedef long double D;

const int maxn = 3e5 + 5;
const LL INF = 1e18;
int N; LL T[maxn], pT[maxn], f[maxn], g[maxn], h[maxn];

inline D slope(LL x1, LL y1, LL x2, LL y2) {
return 1.0 * (y2 - y1) / (x2 - x1);
}
inline LL fx(LL x) { return x; }
inline LL fy(LL x) { return f[x] + pT[x] + x * (x + 1) / 2; }
inline D fslope(LL a, LL b) { return slope(fx(a), fy(a), fx(b), fy(b)); }

inline LL gx(LL x) { return x; }
inline LL gy(LL x) { return g[x] + pT[x] + x * (x + 1) / 2; }
inline D gslope(LL a, LL b) { return slope(gx(a), gy(a), gx(b), gy(b)); }

int q[maxn], ql, qr;
void calc_f(LL* f, D (*fslope)(LL, LL)) {
q[ql = qr = 1] = pT[0] = 0;
for (int i = 1; i <= N + 1; i++) {
pT[i] = pT[i - 1] + T[i];
while (ql < qr && fslope(q[qr - 1], q[qr]) <= i) qr--;
f[i] = f[q[qr]] - (pT[i - 1] - pT[q[qr]]) + 1ll * (i - q[qr]) * (i - q[qr] - 1) / 2;
f[i] = max(f[i], f[i - 1]);
while (ql < qr && fslope(q[qr - 1], q[qr]) <= fslope(q[qr], i)) qr--;
q[++qr] = i;
}
}
void calc_g() {
reverse(T + 1, T + 1 + N);
calc_f(g, gslope);
reverse(g + 1, g + 1 + N), reverse(T + 1, T + 1 + N);
swap(g[0], g[N + 1]);
}

LL t[maxn];
inline LL hy_p(int x) { return f[x] + pT[x] + (x * x - x) / 2; }
inline D hslope_p(int x, int y) { return 1.0 * (hy_p(x) - hy_p(y)) / (x - y); }
inline LL hy_s(int x) { return g[x] + pT[x] + (x * x - x) / 2; }
inline D hslope_s(int x, int y) { return 1.0 * (hy_s(x) - hy_s(y)) / (x - y); }
void calc_h(int l, int r) {
if (l == r) {
h[l] = max(h[l], f[l - 1] + g[l + 1] - T[l] + 1);
return ;
}
int mid = (l + r) >> 1;
calc_h(l, mid), calc_h(mid + 1, r);
pT[l - 1] = pT[r + 1] = qr = 0;
for (int i = l; i <= r; i++) q[i - l + 1] = 0, t[i] = -INF, pT[i] = pT[i - 1] + T[i];
for (int i = l - 1; i <= mid; i++) {
while (qr > 1 && fslope(q[qr - 1], q[qr]) <= fslope(i, q[qr])) qr--;
q[++qr] = i;
}
LL mx = -INF;
for (int i = mid + 1; i <= r; i++) {
while (qr > 1 && hslope_p(q[qr - 1], q[qr]) <= i) qr--;
t[i] = f[q[qr]] - (pT[i] - pT[q[qr]]) + 1ll * (i - q[qr]) * (i - q[qr] + 1) / 2 + g[i + 1];
}
for (int i = r; i > mid; i--)
mx = max(mx, t[i]), h[i] = max(mx, h[i]);
qr = 0;
for (int i = r; i >= l; i--) q[i - l + 1] = 0, t[i] = -INF, pT[i] = pT[i + 1] + T[i];
for (int i = r + 1; i > mid; i--) {
while (qr > 1 && gslope(q[qr - 1], q[qr]) >= gslope(i, q[qr])) qr--;
q[++qr] = i;
}
for (int i = mid; i >= l; i--) {
while (qr > 1 && hslope_s(q[qr - 1], q[qr]) >= i) qr--;
t[i] = g[q[qr]] - (pT[i] - pT[q[qr]]) + 1ll * (q[qr] - i) * (q[qr] - i + 1) / 2 + f[i - 1];
}
mx = -INF;
for (int i = l; i <= mid; i++)
mx = max(mx, t[i]), h[i] = max(h[i], mx);
}


int main() {
// freopen("test.in", "r", stdin);
// freopen("test.out", "w", stdout);
scanf("%d", &N);
for (int i = 1; i <= N; i++) scanf("%lld", &T[i]), h[i] = -INF;
calc_f(f, fslope), calc_g(), calc_h(1, N);
int m; scanf("%d", &m);
while (m--) {
int x; LL y; scanf("%d%lld", &x, &y);
printf("%lld\n", max(f[x] + g[x], h[x] + T[x] - y));
}
return 0;
}
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define rrep(i,a,b) for(int i=a;i>=b;i--)
#define fore(i,a) for(auto &i:a)
#define all(x) (x).begin(),(x).end()
#pragma GCC optimize ("-O3")
using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }
//---------------------------------------------------------------------------------------------------
/*---------------------------------------------------------------------------------------------------
∧＿∧  
∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!
（ ´_ゝ`）　/　 ⌒i     
／　　　＼　 　  |　|     
/　　 /￣￣￣￣/　　|  
＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  
＼/＿＿＿＿/　（u　⊃  
---------------------------------------------------------------------------------------------------*/









ll N, M;
//---------------------------------------------------------------------------------------------------
void _main() {
cin >> N >> M;
if (N > M) swap(N, M);

ll ans;
if (N == 1) {
if (M == 1) ans = 1;
else ans = M - 2;
} else {
ans = (N - 2) * (M - 2);
}
cout << ans << endl;
}
#include <bits/stdc++.h>
//#include<boost/multiprecision/cpp_int.hpp>
//#include <atcoder/all>
using namespace std;
//using namespace boost::multiprecision;
//using namespace atcoder;
#define rep(i,n) for(int i=0;i<(n);++i)
#define rrep(i,a,n) for(int i=a;i<(n);i++)
#define lep(i,n) for(long long i=0;i<(n);++i)
#define all(x) (x).begin(),(x).end()
#define rall(x) (x).rbegin(),(x).rend()
#define equals(a,b) (fabs((a)-(b))<eps)
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define sz(x) (int)(x).size()
using ll=long long;
template<typename T> using vc = vector<T>;
template<typename T,typename U> using pp=pair<T,U>;
template<typename T> using pq=priority_queue<T>;
template<typename T> using PQ = priority_queue<T,vc<T>,greater<T>>;
using vi=vc<int> ;
using vvi=vc<vi>;
using vvvi=vc<vvi>;
using vl=vc<ll>;
using vvl=vc<vl>;
using vvvl=vc<vvl>;
using pi=pp<int,int>;
using pd=pp<double,double>;
using pl=pp<ll,ll>;
using pip=pp<int,pi>;
using vpi=vc<pi>;
using vvpi=vc<vpi>;
using vs=vc<string>;
using vss=vc<vs>;
using vst=vc<set<int>>;
const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};
const int inf=1001001001;
const ll infl=100100100100100100;
const double eps=(1e-10);
const ll mod=1000000007;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }
template<typename T>
void rprint(T &a) {printf("%.10f\n",a);}
template<typename T>
void coutarray(vc<T>& v) { rep(i, sz(v)) {if(i)cout << " "; cout << v[i];} cout << endl; }
template<typename T>
void coutmatrix(vc<vc<T>>& v) { rep(i,sz(v)) { rep(j, sz(v[i])) {cout << " "; cout << v[i][j]; } cout << "\n";} };
template<class Abel> struct UnionFind {
vector<int> par;
vector<int> rank;
vector<Abel> diff_weight;

UnionFind(int n = 1, Abel SUM_UNITY = 0) {
init(n, SUM_UNITY);
}

void init(int n = 1, Abel SUM_UNITY = 0) {
par.resize(n); rank.resize(n); diff_weight.resize(n);
for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;
}

int root(int x) {
if (par[x] == x) {
return x;
}
else {
int r = root(par[x]);
diff_weight[x] += diff_weight[par[x]];
return par[x] = r;
}
}

Abel weight(int x) {
root(x);
return diff_weight[x];
}

bool issame(int x, int y) {
return root(x) == root(y);
}

bool merge(int x, int y, Abel w) {
w += weight(x); w -= weight(y);
x = root(x); y = root(y);
if (x == y) return false;
if (rank[x] < rank[y]) swap(x, y), w = -w;
if (rank[x] == rank[y]) ++rank[x];
par[y] = x;
diff_weight[y] = w;
return true;
}

Abel diff(int x, int y) {
return weight(y) - weight(x);
}
};

int main(){
int n,m;
cin>>n>>m;
UnionFind<int>  d(n);
rep(i,m){
int a,b,c;
cin>>a>>b>>c;
a--;
b--;
if(d.issame(a,b)){
if(d.diff(a,b)!=c){
cout<<"No"<<endl;
return 0;
}
}
else d.merge(a,b,c);
}
cout<<"Yes"<<endl;
return 0;
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

ld dijkstra(int n) {
for (int i = 0; i < n; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], idx = j;
}
visited[idx] = true;
for(int j = 0; j < n; j++) {
if(visited[j]) continue;
dist[j] = min(dist[j], dist[idx] + weight[idx][j]);
}
}
return dist[n-1];
}

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
for (int j = 0; j < i; j++) {
adjList[i].insert(j);
adjList[j].insert(i);
weight[i][j] = weight[j][i] = calcDist(i, j);
}
}
for (int i = 0; i < n+1; i++) {
adjList[i].insert(n+1);
adjList[n+1].insert(i);
weight[i][n+1] = weight[n+1][i] = calcDist(i, n+1);
}

printf("%.9Lf\n", dijkstra(n+2));
}
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=1e5+10;

ll a[maxn];

int main(){
int n;
int T;
scanf("%d%d",&n,&T);
for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
ll minn=a[1],maxx=0;
ll cnt=0;
for (int i=2;i<=n;i++){
if(a[i]-minn>0){
if(a[i]-minn>maxx){
maxx=a[i]-minn;
cnt=1;
}else if(a[i]-minn==maxx){
cnt++;
}
}
minn=min(a[i],minn);
}
printf("%lld\n",cnt);
return 0;
}
#include <bits/stdc++.h>
#include <algorithm>
#include <functional>
#include <cmath>
#include<string>
//#include <atcoder/all>
#define _GLIBCXX_DEBUG
#define all(v) v.begin(),v.end()
#define emp " "
#define rep(i,l,n) for(ll i = l; i < (ll)(n); i++)
using namespace std;
//using namespace atcoder;
using ll = long long;
using vs = vector<string>;
using vi = vector<ll>;
using mii = map<ll,ll>;
using vb = vector<bool>;
using Graph = vector<vector<int>>;
ll mod = 1000000007;

struct num {
ll x;
ll y;

num(ll a,ll b) {
x = a;
y = b;
}
};


int main() {
cout << fixed << setprecision(10);

ll n;
cin >> n;

vi b;

ll cnt = 0;

rep(i,0,n) {

cnt++;
ll a;
cin >> a;


if(cnt % 2) {
b.push_back(a);
}
else {
b.insert(b.begin(),a);
}


/*	for(auto x : b) {
cout << x << emp;
}
cout << endl;*/

}


if(cnt % 2) {
reverse(b.begin(),b.end());
}

rep(i,0,b.size()) {
if(i + 1 == b.size()) {
cout << b[i] << endl;
}
else {
cout << b[i] << emp;
}
}

return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, cc = 1e8;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(6);

int n; cin >> n;
vector <int> a(2 * n), c(2 * n);
vector <vector <int>> id(2, vector <int>(n));
for (int i = 0; i < 2 * n; ++i) {
char C; cin >> C >> a[i];
c[i] = (C == 'B' ? 0 : 1);
id[c[i]][a[i] - 1] = i;
}

vector <vector <int>> qs(2 * n, vector <int>(n + 1));
for (int i = 0; i < 2 * n; ++i) {
int cnt = 0;
vector <int> oth;
for (int j = 0; j < i; ++j) {
cnt += (c[j] == c[i] and a[j] > a[i]);
if (c[j] != c[i])
oth.push_back(a[j]);
}
sort(oth.begin(), oth.end());
for (int j = 0; j <= n; ++j) {
qs[i][j] = cnt + (oth.end() - 
upper_bound(oth.begin(), oth.end(), j));
}
}

vector <vector <int>> dp(n + 1, vector <int>(n + 1, mod));
dp[0][0] = 0;
for (int i = 0; i <= n; ++i) {
for (int j = 0; j <= n; ++j) {
if (i) {
dp[i][j] = min(dp[i][j],
dp[i - 1][j] + qs[id[0][i - 1]][j]);
} 
if (j) {
dp[i][j] = min(dp[i][j],
dp[i][j - 1] + qs[id[1][j - 1]][i]);
}
}
}
cout << dp[n][n] << '\n';
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MOD = 998244353;
int main()
{
int n;
string s;
cin >> n >> s;
vector<int> pos[3][3];
for (char& c : s) {
c -= 'A';
}
for (int i = 0; i < 3 * n; ++i) {
pos[i / n][s[i]].push_back(i);
}
string ans(3 * n, '0');
int label = 1;
vector<int> order = { 0,1,2 };
do {
while (pos[0][order[0]].size() > 0 && pos[1][order[1]].size() > 0 && pos[2][order[2]].size() > 0) {
int a = pos[0][order[0]].back();
int b = pos[1][order[1]].back();
int c = pos[2][order[2]].back();
pos[0][order[0]].pop_back();
pos[1][order[1]].pop_back();
pos[2][order[2]].pop_back();
ans[a] = label +'0';
ans[b] = label +'0';
ans[c] = label +'0';
}
++label;
} while (next_permutation(order.begin(), order.end()));
cout << ans << '\n';
}

#include <bits/stdc++.h>

using namespace std;

#define FOR(i,a,b) for(int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(int i=(a),i##i=(b);i>=i##i;i--)

template<typename T> inline void cmin(T &x, T y) {x = (x < y ? x : y);}
template<typename T> inline void cmax(T &x, T y) {x = (x > y ? x : y);}
template<typename T> inline void clr(vector<T> &x) {vector<T>().swap(x);}

using ll = long long;
using db = double;
using poly = vector<int>;
using pii = pair<int, int>;
#define mp make_pair
#define fi first
#define se second

#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
char buf[100000], *p1(buf), *p2(buf);
#define rd read()
inline int read() {
int x = 0;
bool f = true;
char ch = gc;
while(!isdigit(ch)) {
if(ch == '-') f = false;
ch = gc;
}
while(isdigit(ch)) {
x = (x << 1) + (x << 3) + (ch ^ 48);
ch = gc;
}
return f ? x : -x;
}

const int N = 1e3 + 10;
const int M = 2e5 + 10;

int n, m;
vector<pair<int, int> > E;
vector<int> g[N], G[N];
char ans[2][6] = {"diff\n", "same\n"};

inline void input() {
n = rd, m = rd;
//    E.push_back({0, 0});
FOR(i, 0, m - 1) {
int u = rd, v = rd;
E.push_back({u, v});
g[u].push_back(v);
G[v].push_back(u);
}
}

vector<int> st;
bool vis[N];
void dfs1(int u) {
vis[u] = true;
for(int v : g[u]) if(!vis[v]) dfs1(v);
st.push_back(u);
return ;
}

int sz = 0;
int comp[N];
void dfs2(int u) {
comp[u] = sz;
vis[u] = true;
for(int v : G[u]) if(!vis[v]) dfs2(v);
return ;
}

void dfs3(int u) {
vis[u] = true;
for(int v : g[u]) if(!vis[v]) dfs3(v);
return ;
}

inline void work() {
FOR(i, 1, n) if(!vis[i]) dfs1(i);
reverse(st.begin(), st.end());
for(int v : st) vis[v] = false;
for(int v : st) if(!vis[v]) sz++, dfs2(v);
map<pair<int, int>, int> as;
FOR(i, 1, n) {
FOR(j, 1, n) vis[j] = false;
vis[i] = true;
for(int v : g[i]) {
if(vis[v]) as[{i, v}] = 1;
dfs3(v);
}
reverse(g[i].begin(), g[i].end());
FOR(j, 1, n) vis[j] = false;
vis[i] = true;
for(int v : g[i]) {
if(vis[v]) as[{i, v}] = 1;
dfs3(v);
}
}
for(auto c : E) {
if(comp[c.fi] != comp[c.se]) as[c] ^= 1;
cout << ans[as[c]];
}
return ;
}

inline void solve() {
input();
work();
return ;
}

#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)

int main() {
solve();
#ifdef LOCAL
fprintf(stderr, "%lf\n", (double) clock() / CLOCKS_PER_SEC);
#endif
return 0;
}



#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
long long n,k,s,hs,a[200010],ans;
int main()
{
scanf("%lld%lld",&n,&k);
cout<<(n-1)/(k-1)+((n-1)%(k-1)?1:0);
return 0;
}
// time-limit: 2000
// problem-url: https://atcoder.jp/contests/arc132/tasks/arc132_b
//#include <bits/stdc++.h>
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
//#include <ext/pb_ds/assoc_container.hpp>
//using namespace __gnu_pbds;
using namespace std;

#define show(x) cerr << #x" = " << (x) << "\n"
#define pb push_back
#define pp pop_back
#define mp make_pair
#define fst first
#define snd second
#define FOR(var, from, to) for(int var = from; var < int(to); ++var)
#define all(x) x.begin(), x.end()
#define rev(x) x.rbegin(), x.rend()
#define sz(x) int(x.size())
#define vec(x) vector<x>
#define INF 2000000000

typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;
// use unique second element of pair to work as multiset
//typedef tree<pii,null_type,less<pii>,rb_tree_tag,tree_order_statistics_node_update> ordered_multiset;
const ll mod = 1e9 + 7;

template<typename T, typename U> ostream &operator<<(ostream &os, pair<T,U> p){os << "(" << p.fst << "," << p.snd << ")"; return os;}
template<typename T, typename U> istream &operator>>(istream &is, pair<T,U> &p){is >> p.fst >> p.snd; return is;}
template<typename T> istream &operator>>(istream &is, vector<T> &v){FOR(i, 0, v.size()) is >> v[i]; return is;}
template<typename T> ostream &operator<<(ostream &os, vector<T> v){for(T x : v) os << x << " "; return os;}
template<typename T> ostream &operator<<(ostream &os, set<T> s){for(T x : s) os << x << " "; return os;} 
//ostream &operator<<(ostream &os, ordered_set s){for(int x : s) os << x << " "; return os;} 
//ostream &operator<<(ostream &os, ordered_multiset s){for(pii x : s) os << x.fst << " "; return os;} 
template<typename T> ostream &operator<<(ostream &os, multiset<T> s){for(T x : s) os << x << " "; return os;} 
template<typename T, typename U> ostream &operator<<(ostream &os, map<T,U> m){for(auto x : m) os << x << " "; return os;} 
template<typename T> T sum(vector<T> v){T summ = 0; FOR(i, 0, sz(v)) summ += v[i]; return summ;}
ll mod_pow(ll a, ll b){ ll sol = 1; while(b){ if(b&1){ sol = (sol*a)%mod; b--; }else{ a = (a*a)%mod; b/=2; } } return sol;}
ll rem(ll a, ll b){ ll res = a%b; return res < 0 ? res+b : res; }

int cost(vec(int) &p){
int n = sz(p);
vec(int) aux;
int cnt = INF;
int pos = find(all(p), 1) - p.begin();
aux.insert(aux.end(), p.begin()+pos, p.end());
aux.insert(aux.end(), p.begin(), p.begin()+pos);
if(is_sorted(all(aux))) cnt = min(cnt, pos);
aux.clear();
pos = find(all(p), n) - p.begin();
aux.insert(aux.end(), p.begin()+pos, p.end());
aux.insert(aux.end(), p.begin(), p.begin()+pos);
reverse(all(aux));
if(is_sorted(all(aux))) cnt = min(cnt, pos + 1);
return cnt;
}

void test_case(){
int n; cin >> n;
vec(int) p(n); cin >> p;
vec(int) pr(rev(p));
cout << min(cost(p), cost(pr) + 1) << "\n";
}

int main(){
#ifndef DEBUG
ios_base::sync_with_stdio(false);
cin.tie(NULL);
#endif

int t = 1;
FOR(i, 0, t) test_case();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=305,maxm=100005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m;
modint dp[maxn][maxn][maxn];
vector<pii> vec[maxn];

void orzck(){
cin >> n >> m;
rep(m){
int l,r,x;
cin >> l >> r >> x;
if(r-l+1<x){
print(0);
return;
}
vec[r].pb({l,x});
}
dp[1][0][0]=dp[0][1][0]=dp[0][0][1]=1;
rep2(i,1,n+1){
rep1(j,i) rep1(k,i){
bool flag=1;
for(auto& [l,x]: vec[i]){
int cnt=1+(j>=l)+(k>=l);
if(x!=cnt) flag=0;
}
if(!flag){
dp[i][j][k]=dp[j][i][k]=dp[j][k][i]=0;
continue;
}
if(i==n) continue;
dp[i+1][j][k]+=dp[i][j][k];
dp[i][i+1][k]+=dp[i][j][k];
dp[i][j][i+1]+=dp[i][j][k];

dp[i+1][i][k]+=dp[j][i][k];
dp[j][i+1][k]+=dp[j][i][k];
dp[j][i][i+1]+=dp[j][i][k];

dp[i+1][k][i]+=dp[j][k][i];
dp[j][i+1][i]+=dp[j][k][i];
dp[j][k][i+1]+=dp[j][k][i];
//if(!(dp[i][j][k]==0)) bug(i,j,k,dp[i][j][k]);
}
}
modint res=0;
rep(n) rep1(j,n) res+=dp[n][i][j]+dp[i][n][j]+dp[i][j][n];
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
using ll = long long;
constexpr ll mod = 1e9 + 7;
constexpr ll INF = 1LL << 60;

#define REP(i, init, n) for(int i = (int)(init); i < (int)(n); i++)

#define vi vector<int>
#define vl vector<long>
#define vvi vector<vector<int>>
#define vvl vector<vector<long>>
#define pint pair<int, int>
#define plong pair<long, long>

int N, K;
vl A;

void solve() {
REP(i, 0, N) A[i] -= K;
vl cum_A(N + 1, 0);
REP(i, 0, N) {
cum_A[i + 1] = cum_A[i] + A[i];
}
// REP(i, 0, N + 1) cout << cum_A[i] << " ";
vl sorted_cum_A = cum_A;
sort(sorted_cum_A.begin(), sorted_cum_A.end());
vi comp_cum_A(N + 1, 0);
fenwick_tree<int> T(200020);
REP(i, 0, N + 1) {
comp_cum_A[i] = lower_bound(sorted_cum_A.begin(), sorted_cum_A.end(), cum_A[i]) - sorted_cum_A.begin();
}
// REP(i, 0, N + 1) cout << comp_cum_A[i] << " ";
long ans = 0;
T.add(comp_cum_A[N], 1);
for(int i = N - 1; i >= 0; i--) {
int l = comp_cum_A[i], r = 200010;
ans += T.sum(l, r);
T.add(comp_cum_A[i], 1);
// cout << l << " " << r << " " << ans << endl;
}
cout << ans << endl;
}

int main() {
cin >> N >> K;
A.resize(N);
REP(i, 0, N) cin >> A[i];
solve();
}
#include <iostream>
#include<vector>
using namespace std;
using ll = long long;

int main(){
ll N, T; cin >> N >> T;
vector<ll>t(N);
for (ll i = 0; i < N; i++)cin >> t[i];

ll x = 0;
for (ll i = 0; i < N-1; i++) {
x += min(T, t[i + 1] - t[i]);
}
//最後に押したときの時間を足す
x += T;

cout << x << endl;

}
//Champion qkm will not run!
#include <map>
#include <set>
#include <queue>
#include <ctime>
#include <stack>
#include <cmath>
#include <cstdio>
#include <complex>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define pii pair<int, int>
#define mp(x, y) make_pair(x, y)
#define pb push_back
#define fi first
#define se second
#define int long long
using namespace std;

inline int read() {
int x = 0, w = 1;char ch = getchar();
while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
return x * w;
}
inline void write(int x) {
if (x < 0) putchar('-'), x = -x;
if (x > 9) write(x / 10);
putchar(x % 10 + '0');
}

const int MN = 2e5 + 5, MM = 1e5, Mod = 998244353, Inf = 1ll << 60;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

int N, rt1, rt2, vis[MN], deg[MN], stk[MN], tp, p[MN], q[MN], fa[MN], dep[MN];
vector <int> G[MN];

inline int DFS(int u, int pr) {
int res = u, son;
dep[u] = dep[pr] + 1, fa[u] = pr;
for (int v : G[u]) {
if (v != pr) {
son = DFS(v, u);
if (dep[son] > dep[res]) res = son;
}
}
return res;
}

signed main(void) {
N = read();
for (int i = 1, u, v; i < N; i++) {
u = read(), v = read(), G[u].pb(v), G[v].pb(u);
}
rt1 = DFS(1, 0), fa[rt1] = dep[rt1] = 0;
rt2 = DFS(rt1, 0);
while (rt2) stk[++tp] = rt2, vis[rt2] = 1, rt2 = fa[rt2];
// for (int i = 1; i <= tp; i++) printf("%lld%c", stk[i], " \n"[i == tp]);
for (int i = 1; i <= N; i++) {
if (!vis[i]) {
int fl = 0;
for (int j : G[i]) {
if (vis[j]) deg[j]++, fl = 1;
}
if (!fl) return puts("-1"), 0;
}
}
int c = 0;
for (int i = 1; i <= tp; i++) {
for (int j = 1; j <= deg[stk[i]]; j++) {
p[c + j] = c + j + 1;
}
p[c + deg[stk[i]] + 1] = c + 1, c += deg[stk[i]] + 1;
}
c = 0;
for (int i = tp; i >= 1; i--) {
for (int j = 1; j <= deg[stk[i]]; j++) {
q[c + j] = c + j + 1;
}
q[c + deg[stk[i]] + 1] = c + 1, c += deg[stk[i]] + 1;
}
for (int i = 1; i <= N; i++) {
if (p[i] != q[i]) {
if (p[i] < q[i]) {
for (int j = 1; j <= N; j++) printf("%lld%c", p[j], " \n"[j == N]);
return 0;
} else {
for (int j = 1; j <= N; j++) printf("%lld%c", q[j], " \n"[j == N]);
return 0;
}
}
}
for (int i = 1; i <= N; i++) printf("%lld%c", p[i], " \n"[i == N]);
return 0;       
}
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int _=300003;
int n,m;
int c[_];
void add(int x,int v){for(int i=x;i<=m;i+=(i&-i)) c[i]+=v;}
int qry(int x){int r=0;for(int i=x;i;i-=(i&-i)) r+=c[i];return r;}
int read(){
char c=getchar();int x=0;
while (c<48||c>57) c=getchar();
do x=(x<<1)+(x<<3)+(c^48),c=getchar();
while (c>=48&&c<=57);
return x;
}
vector< pair<int,int> > a[_];
int main(){
n=read(); m=read();
for(int i=1;i<=n;++i){
int l=read(),r=read();
a[r-l+1].push_back(make_pair(l,r));
}
int cnt=n;
for(int i=1;i<=m;++i){
int r=cnt;
for(int o=i;o<=m;o+=i) r+=qry(o);
printf("%d\n",r);
for(pair<int,int> o:a[i]){
add(o.first,1);
add(o.second+1,-1);
}
cnt-=a[i].size();
}
return 0;
}

#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int N = 1e5 + 5;
vector<int> edges[N];

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

//~ freopen("15.txt", "r", stdin);
int n; cin>>n;
for(int i=1;i<n;i++){
int a, b; cin>>a>>b;
edges[a].push_back(b), 
edges[b].push_back(a);
}

int l = 1, r = n;

auto check = [&](int m){
vector<int> cnt(n + 1), d(n + 1);

function<void(int, int)> dfs = [&](int u, int p){
set<ar<int, 2>> ss;
for(auto x : edges[u]){
if(x == p) continue;
dfs(x, u); d[x]++;
cnt[u] += cnt[x];
if(d[x] == m) cnt[u]++;
else ss.insert({d[x], x});
}

vector<int> rem;
while((int)ss.size() > 1){
int x = (*--ss.end())[1];
auto it = ss.lower_bound({m - d[x] + 1, 0});
if(it == ss.begin()) { 
rem.push_back(x);
ss.erase(--ss.end());
continue; 
}
ss.erase(--it); 
ss.erase(--ss.end());
cnt[u]++;
}
for(auto x : ss) rem.push_back(x[1]);
sort(rem.begin(), rem.end(), [&](int i, int j) { return (d[i] < d[j]); });
for(int i=0;i<(int)rem.size();i++){
if(!i) d[u] = d[rem[i]];
cnt[u] += (i > 0);
}
};

dfs(1, 1);
return cnt[1] + (d[1] > 0);
};

int A = check(n);
//~ cout<<A<<endl;

while(l < r){
int m = (l + r) >> 1;
if(check(m) <= A) r = m;
else l = m + 1;
}

cout<<A<<" "<<l<<"\n";
}

#include<bits/stdc++.h>
using namespace std;
#define N 25010
#define M 404
typedef long long ll;
const int mod=1e9+7;
int n,K,m,a[N],inv[N],all;
int qpow(int a,int b){
int ans=1;
while(b){
if(b&1)ans=1LL*ans*a%mod;
a=1LL*a*a%mod;
b>>=1;
}
return ans;
}
void init(int n){
inv[1]=1;
for(int i=2;i<=n;++i){
inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;
}
}
void Solve_1(){
static int dp[N][M],g[N][M];
dp[0][0]=1;
for(int i=1;i<=n;++i){
static int s0[M],s1[M];
s0[0]=dp[i-1][0],s1[0]=g[i-1][0];
for(int j=1;j<=K;++j){
s0[j]=(s0[j-1]+dp[i-1][j])%mod;
s1[j]=(s1[j-1]+g[i-1][j])%mod;
}
for(int j=1;j<K;++j){
dp[i][j]=(1LL*dp[i-1][j-1]*(K-j+1)%mod+s0[K]-s0[j-1]+mod)%mod;
g[i][j]=(1LL*g[i-1][j-1]*(K-j+1)%mod+s1[K]-s1[j-1]+mod)%mod;
if(j>=m){
g[i][j]=(g[i][j]+dp[i][j])%mod;
}
}
}
int ans=0;
for(int i=0;i<K;++i)ans=(ans+g[n][i])%mod;
for(int i=K;i>=K-m+1;--i)ans=1LL*ans*inv[i]%mod;
cout<<(all+mod-ans)%mod<<'\n';
}
void Get(int *ans,int jb){
static int dp[N][M];
memset(dp,0,sizeof(dp));
dp[0][jb]=1;
ans[0]=1;
for(int i=1;i<=n;++i){
static int s0[M];
s0[0]=dp[i-1][0];
for(int j=1;j<=K;++j){
s0[j]=(s0[j-1]+dp[i-1][j])%mod;
}
for(int j=1;j<K;++j){
dp[i][j]=(1LL*dp[i-1][j-1]*(K-j+1)%mod+s0[K]-s0[j-1]+mod)%mod;
ans[i]=(ans[i]+dp[i][j])%mod;
}
}
}
int Find(int *a){
vector<bool> vis(K+1);
for(int i=1;i<=m;++i){
if(vis[a[i]])return i-1;
vis[a[i]]=1;
}
return m;
}
void Solve_2(){
int L=Find(a);
reverse(a+1,a+m+1);
int R=Find(a);
static int dp0[N],dp1[N];
Get(dp0,L),Get(dp1,R);
int ans=0;
for(int i=0;i<=n-m;++i){
ans=(ans+1LL*dp0[i]*dp1[n-m-i])%mod;
}
cout<<(all+mod-ans)%mod<<'\n';
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cin>>n>>K>>m;
if(K>n){
cout<<0<<'\n';
return 0;
}
all=1LL*(n-m+1)*qpow(K,n-m)%mod;
init(n);
for(int i=1;i<=m;++i){
cin>>a[i];
}
int zz=0;
for(int i=1;i<=m;++i){
static int las[N];
zz=max(zz,las[a[i]]);
las[a[i]]=i;
if(i-zz==K){
cout<<all<<'\n';
return 0;
}
}
if(!zz){
Solve_1();
}
else{
Solve_2();
}
return 0;
}



#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int X,K,Q,r[100005];
int main(){
scanf("%d%d",&X,&K);
rep(i,1,K)scanf("%d",&r[i]);
int i=1;
scanf("%d",&Q);
int low=0,high=X,o=-1,b=0; // f(t,a)=o*(t-t')+a a in [l',r']
while(Q--){
int t,a;
scanf("%d%d",&t,&a);
while(i<=K&&r[i]<=t){
low=min(X,max(0,low+o*(r[i]-r[i-1])));
high=min(X,max(0,high+o*(r[i]-r[i-1])));
b+=o*(r[i]-r[i-1]);
o=-o;
++i;
}
int low_=min(X,max(0,low+o*(t-r[i-1])));
int high_=min(X,max(0,high+o*(t-r[i-1])));
printf("%d\n",min(high_,max(low_,b+(t-r[i-1])*o+a)));
}
return 0;
}
#include <bits/stdc++.h>
//#include <atcoder/all>
using namespace std;
#define rep(i,n) for(ll i=0; i<n; i++)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rrep(i,n) for(ll i=n-1; i>=0; i--)
#define fi first
#define se second
#define pcnt __builtin_popcountll
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int,int> Pii;
typedef pair<ll,ll> Pll;
typedef pair<ll,Pll> PlP;
template<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }
template<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}cout << "\n";}
template<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}
string zero_padding(int val, int nf){ ostringstream sout;sout << setfill('0') << setw(nf) << val; return sout.str();};
const ld eps = 1e-10;
ull mo = 1000000007;
ld PI=asin(1)*2;
//using namespace atcoder;

int main(){
ll N;
cin >> N;
vector<ll> P(N);
rep(i,N){
cin >> P[i];
P[i]--;
}
ll ans = 0;
rep(i,N-1){
if(i == P[i]){
swap(P[i], P[i+1]);
ans++;
}
}
if(P[N-1] == N-1)ans++;
cout << ans << endl;
}

#include<iostream>
#include<cstdio>
#define N 25000
#define MAXN 200000
#define K 400
#define mod 1000000007
using namespace std;
int read()
{
char c=0;
int sum=0;
while (c<'0'||c>'9') c=getchar();
while ('0'<=c&&c<='9') sum=sum*10+c-'0',c=getchar();
return sum;
}
int n,k,m,a[N+1],f[N+1],g[N+1],dp[N+1],DP[N+1][2],sf[N+1],sg[N+1],sdp[N+1],SDP[N+1][2],fac[MAXN+1],invfac[MAXN+1],ans;
bool used[K+1],F[N+1],G[N+1];
int fast_pow(int a,int b)
{
int res=1,mul=a;
while (b)
{
if (b&1) res=1ll*res*mul%mod;
mul=1ll*mul*mul%mod,b>>=1;
}
return res;
}
int A(int x,int y)
{
if (x<y) return 0;
return 1ll*fac[x]*invfac[x-y]%mod;
}
int C(int x,int y)
{
if (x<y) return 0;
return 1ll*fac[x]*invfac[y]%mod*invfac[x-y]%mod;
}
void Add(int &x,int d)
{
x=(x+d)%mod;
return;
}
int main()
{
//freopen("sequence.in","r",stdin);
//freopen("sequence.out","w",stdout);
bool op=0;
n=read(),k=read(),m=read(),fac[0]=1;
for (int i=1;i<=m;++i) a[i]=read(),op|=used[a[i]],used[a[i]]=1;
for (int i=1;i<=MAXN;++i) fac[i]=1ll*fac[i-1]*i%mod;
invfac[MAXN]=fast_pow(fac[MAXN],mod-2);
for (int i=MAXN-1;i>=0;--i) invfac[i]=1ll*invfac[i+1]*(i+1)%mod;
if (k>n) puts("0");
else if (op)
{
if (m>=k)
{
for (int i=1;i<=m-k+1;++i)
{
op=1;
for (int j=1;j<=k;++j) used[j]=0;
for (int j=i;j<=i+k-1;++j) used[a[j]]=1;
for (int j=1;j<=k;++j) op&=used[j];
if (op)
{
printf("%lld\n",1ll*fast_pow(k,n-m)*(n-m+1)%mod);
return 0;
}
}
}
op=0;
for (int i=1;i<=k;++i) used[i]=0;
for (int i=1;i<=m;++i) op|=used[a[i]],F[i]=!op,used[a[i]]=1;
op=0;
for (int i=1;i<=k;++i) used[i]=0;
for (int i=m;i>=1;--i) op|=used[a[i]],G[m-i+1]=!op,used[a[i]]=1;
f[0]=sf[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k||F[k-i])
{
for (int j=max(i-k+1,0);j<i;++j) Add(f[i],-1ll*f[j]*fac[i-j]%mod);
if (i>=k) Add(f[i],-1ll*sf[i-k]*fac[k]%mod);
}
sf[i]=(f[i]+1ll*sf[i-1]*k%mod)%mod;
}
g[0]=sg[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k||G[k-i])
{
for (int j=max(i-k+1,0);j<i;++j) Add(g[i],-1ll*g[j]*fac[i-j]%mod);
if (i>=k) Add(g[i],-1ll*sg[i-k]*fac[k]%mod);
}
sg[i]=(g[i]+1ll*sg[i-1]*k%mod)%mod;
}
for (int i=0;i<=n-m;++i) ans=(ans-1ll*sf[i]*sg[n-m-i]%mod)%mod;
printf("%lld\n",((ans+1ll*fast_pow(k,n-m)*(n-m+1)%mod)%mod+mod)%mod);
}
else
{
dp[0]=sdp[0]=1;
for (int i=1;i<=n;++i)
{
if (i>=k-m+1)
{
for (int j=max(i-k+1,0);j<i;++j) Add(dp[i],-1ll*dp[j]*fac[i-j]%mod);
if (i>=k) Add(dp[i],-1ll*sdp[i-k]*fac[k]%mod);
}
sdp[i]=(dp[i]+1ll*sdp[i-1]*k%mod)%mod;
}
for (int i=0;i<=n-m;++i) ans=(ans-1ll*sdp[i]*sdp[n-m-i]%mod)%mod;
DP[0][0]=SDP[0][0]=-1;
for (int i=1;i<=n;++i)
{
if (i>=k)
{
for (int j=max(i-k+1,0);j<i;++j)
{
Add(DP[i][0],-1ll*DP[j][0]*fac[i-j]%mod);
Add(DP[i][1],-1ll*DP[j][1]*fac[i-j]%mod);
Add(DP[i][1],-1ll*DP[j][0]*fac[i-j]%mod*min(i-j,k-m+1)%mod);
}
Add(DP[i][0],-1ll*SDP[i-k][0]*fac[k]%mod);
Add(DP[i][1],-1ll*SDP[i-k][1]*fac[k]%mod);
Add(DP[i][1],-1ll*SDP[i-k][0]*fac[k]%mod*(k-m+1)%mod);
}
SDP[i][0]=(DP[i][0]+1ll*SDP[i-1][0]*k%mod)%mod,SDP[i][1]=(DP[i][1]+1ll*SDP[i-1][1]*k%mod)%mod;
}
printf("%lld\n",(((ans+1ll*SDP[n][1]*fast_pow(A(k,m),mod-2)%mod)%mod+1ll*fast_pow(k,n-m)*(n-m+1)%mod)%mod+mod)%mod);
}
return 0;
}

#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

const int N = 1e5 + 5;
vector<int> edges[N];

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

int n; cin>>n;
for(int i=1;i<n;i++){
int a, b; cin>>a>>b;
edges[a].push_back(b), 
edges[b].push_back(a);
}

int l = 1, r = n;

auto check = [&](int m){
vector<int> cnt(n + 1), d(n + 1);

function<void(int, int)> dfs = [&](int u, int p){
set<ar<int, 2>> ss;
for(auto x : edges[u]){
if(x == p) continue;
dfs(x, u); d[x]++;
cnt[u] += cnt[x];
if(d[x] == m) cnt[u]++;
else ss.insert({d[x], x});
}

vector<ar<int, 2>> rem;
while((int)ss.size() > 1){
int x = (*--ss.end())[1];
auto it = ss.lower_bound({m - d[x] + 1, 0});
if(it == ss.begin()) { 
rem.push_back({d[x], x});
ss.erase(--ss.end());
continue; 
}
ss.erase(--it); 
ss.erase(--ss.end());
cnt[u]++;
}
for(auto x : rem) ss.insert(x);
int in = 0;
for(auto x : ss){
if(!in){
d[u] = x[0];
in++;
} else {
cnt[u]++;
}
}
};

dfs(1, 1);
return cnt[1] + (d[1] > 0);
};

int A = check(n);
//~ cout<<A<<endl;

while(l < r){
int m = (l + r) >> 1;
if(check(m) <= A) r = m;
else l = m + 1;
}

cout<<A<<" "<<l<<"\n";
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
int main(){
ll n;
cin>>n;
ll ans=n/11*2;
ll b=n%11;
if(b==0) cout<<ans<<endl;
else if(b<=6){
cout<<ans+1<<endl;
}else cout<<ans+2<<endl;
return 0;
}
//#include<bits/extc++.h>
#include<bits/stdc++.h>
//#define clock chrono1:steady_clock::now().time_since_epoch().count()
//#define x() real()
//#define y() imag()
//#define int long long
//#define double long double

using namespace std;

using pii = pair<int, int>;
using pll = pair<long long, long long>;
//using orderedSet = __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>,
//  __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;

int h, w; 
string S[12];
int to[12];
int cnt = 0;
int used = 0;
bool ok = false;
void recur() {
if (__builtin_popcount(used) == w) {
multiset<string> se;
for(int i = 0; i < h; i++) {
string tmp;
for(int j = 0; j < w; j++)
tmp += ' ';
for(int j = 0; j < w; j++) {
if (to[j] == -1)
tmp[j] = S[i][j];
else
tmp[j] = S[i][to[j]];
}
if (se.find(tmp) != se.end())
se.erase(se.find(tmp));
else
se.insert(S[i]);
}
if (se.size() == 1) {
string str = *(se.begin());
string rev = str;
for(int i = 0; i < w; i++) {
if (to[i] == -1)
rev[i] = str[i];
else
rev[i] = str[to[i]];
}
if (str == rev)
se.erase(se.find(str));
}
if (se.empty())
ok = true;
}

int fir = 0;
while(used & (1 << fir))
fir++;
used |= (1 << fir);
for(int i = fir + 1; i < w; i++) {
if (!(used & (1 << i))) {
used ^= (1 << i);
to[fir] = i;
to[i] = fir;
recur();
used ^= (1 << i);
to[fir] = -1;
to[i] = -1;
}
}
used ^= (1 << fir);
}

signed main() {
ios::sync_with_stdio(false), cin.tie(NULL);

for(int i = 0; i < 12; i++)
to[i] = -1;

cin >> h >> w;
for(int i = 0; i < h; i++)
cin >> S[i];

if (w & 1) {
for(int i = 0; i < w; i++) {
used ^= (1 << i);
recur();
used ^= (1 << i);
}
} else {
recur();
}

cout << ((ok) ? "YES\n" : "NO\n");

return 0;
}

#include<bits/stdc++.h>
using namespace std;

long long a[1000001],c[1000001];
long long o[1000001];
long long ans;
void bg(long long x,long long y){
if(x==y) return;
long long mid=(x+y)/2;
bg(x,mid);
bg(mid+1,y);
long long i=x,j=mid+1,k=x;
while(i<=mid&&j<=y) {
if(a[i]<=a[j]) {
c[k++]=a[i++];
ans+=y-j+1;
}
else c[k++]=a[j++];
}
while(i<=mid) c[k++]=a[i++];
while(j<=y) c[k++]=a[j++];
for(long long q=x;q<=y;q++) 
a[q]=c[q];
}
int main(){
long long n,q;
cin>>n>>q;
n++;
for(long long i=2;i<=n;i++) {
cin>>a[i];
o[i]=a[i]+o[i-1];
a[i]=o[i]-(i-1)*q;
}
bg(1,n);
cout<<ans;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=100005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn*3],res[maxn*3];
priority_queue<int> pq2;
priority_queue<int,vector<int>,greater<int>> pq1;

void orzck(){
cin >> n;
rep(n*3) cin >> a[i];
int cur=0;
rep(n) pq1.push(a[i]),cur+=a[i];
res[n]+=cur;
rep2(i,n,2*n){
pq1.push(a[i]),cur+=a[i];
cur-=pq1.top(),pq1.pop();
res[i+1]+=cur;
}
cur=0;
rep3(i,3*n-1,2*n) pq2.push(a[i]),cur+=a[i];
res[2*n]-=cur;
rep3(i,2*n-1,n){
pq2.push(a[i]),cur+=a[i];
cur-=pq2.top(),pq2.pop();
res[i]-=cur;
}
print(*max_element(res+n,res+2*n+1));
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
int64_t N, T;
cin >> N >> T;
int64_t INF = 100000000000000;
vector<int64_t> t(N);
for (int i = 0; i < N; i++)cin >> t.at(i);
t.push_back(INF);
int64_t Tbegin = 0, Tend = T, now = 0, ans = 0;

for (int i = 0; now!=INF; i++) {
auto iter=prev(lower_bound(t.begin(), t.end(), Tend));
int ti = *iter;
if (ti!=now) {
now = ti;
Tend = ti + T;
}
else {
ans += Tend - Tbegin;
now = *(++iter);
Tbegin = now;
Tend = now + T;
}
}
cout << ans << endl;
return 0;
}
// Problem: A - Permutation Grid
// Contest: AtCoder - AtCoder Regular Contest 132
// URL: https://atcoder.jp/contests/arc132/tasks/arc132_a
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)


#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define mod 1000000009
#define rep(i,n) for (ll i = 0; i < n; i++)
#define  pb push_back
#define mp make_pair
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()
#define ins insert
#define ysno(ok) if(ok){cout<<"YES"<<endl;}else{cout<<"NO"<<endl;}
#define testloop ll t;cin>>t;while(t--)
//
//extra_functions 
ll MOD = 1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
ll add(ll a,ll b){return ((a%MOD)+(b%MOD))%MOD;}
ll mul(ll a,ll b){return ((a%MOD)*(b%MOD))%MOD;}
ll sub(ll a,ll b){return ((a%MOD)-(b%MOD)+MOD)%MOD;}
ll binpow(ll x, ll y){ll z = 1;while(y){if(y & 1) z = mul(z, x);x = mul(x, x);y >>= 1;}return z;}
int dx[] = {1,0,-1,0,-1,1,1,-1,0,2,0,-2,1,-2,1,2,-1,-2,-1,2};
int dy[] = {0,1,0,-1,-1,1,-1,1,2,0,-2,0,-2,1,2,1,-2,-1,2,-1};
// 
// my code starts here
//--------------------------------------------

int main(){
ios::sync_with_stdio(false);
cin.tie(0);
int n;
cin>>n;
vector <int> row(n+1);
vector <int> col(n+1);

for(int i = 0; i < n; i+=1){
int x;
cin>>x;
row[i+1] = x;
}

for(int i = 0; i < n; i+=1){
int x;
cin>>x;
col[i+1] = x;
}

int q;
cin>>q;

for(int i = 0; i < q; i+=1){
int x,y;
cin>>x>>y;
x = row[x];
y = col[y];
x += y;
string ans = ".";
if(x >= n+1){
ans = "#";
}
cout<<ans;
}



}
//
//my code ends here
//--------------------------------------------

#include<cstdio>
#include<iostream>
using namespace std;int n,k,x;void Solve_Test(){scanf("%d%d",&n,&k),cout<<(n+k-3)/(k-1);}
const bool BASE=0;int T=1;int main(){if(BASE)cin>>T;while(T--)Solve_Test();return 0;}
#include<bits/stdc++.h>
using namespace std;
typedef bitset<1010> bs;
int n,m,id[1010][1010],dfn[1010],low[1010],col[1010],c,tot,X[200100],Y[200100];
bs g[1010];
vector<int>v[1010];
stack<int>s;
bool ok[200100];
void Tarjan(int x){
dfn[x]=low[x]=tot++,s.push(x);
for(auto y:v[x]){
if(dfn[y]==-1)Tarjan(y),low[x]=min(low[x],low[y]);
else if(col[y]==-1)low[x]=min(low[x],dfn[y]);
}
if(low[x]!=dfn[x])return;
while(s.top()!=x)col[s.top()]=c,s.pop();
col[s.top()]=c,s.pop();
c++;
}
bs S;
queue<int>q;
void bfs(){
while(!q.empty()){
int x=q.front();q.pop();
bs T=S&g[x];
for(int i=T._Find_first();i!=T.size();i=T._Find_next(i))S.reset(i),q.push(i);
}
}
void func(int x){
S.set(),S.reset(x);
for(int y=0;y<n;y++){
if(!id[x][y])continue;
if(!S.test(y)){ok[id[x][y]]=true;continue;}
S.reset(y),q.push(y);bfs();
}
S.set(),S.reset(x);
for(int y=n-1;y>=0;y--){
if(!id[x][y])continue;
if(!S.test(y)){ok[id[x][y]]=true;continue;}
S.reset(y),q.push(y);bfs();
}
}
int main(){
scanf("%d%d",&n,&m),memset(dfn,-1,sizeof(dfn)),memset(low,-1,sizeof(low)),memset(col,-1,sizeof(col));
for(int i=1,x,y;i<=m;i++)scanf("%d%d",&x,&y),x--,y--,id[x][y]=i,g[x].set(y),v[x].push_back(y),X[i]=x,Y[i]=y;
for(int i=0;i<n;i++)if(dfn[i]==-1)Tarjan(i);
for(int i=0;i<n;i++)func(i);
for(int i=1;i<=m;i++)puts((col[X[i]]==col[Y[i]])^ok[i]?"diff":"same");
return 0;
}
#include<bits/stdc++.h>
using namespace std;
const int mxn=405;
int n,m,i,j,t,k,s,yh[mxn][mxn],mod,jc[mxn],ijc[mxn],ans[mxn][22];
int dp[2][22][402][22][22],sus,b;

inline int Pow(int x,int y,int mod)
{
int ret=1;
while (y)
{
if (y&1) ret=1ll*x*ret%mod;
x=1ll*x*x%mod;y>>=1;
}return ret;
}
inline void add(int &x,int y){x=(x+y)%mod;}

int main()
{
scanf("%d%d%d",&n,&m,&mod);
for (i=0;i<mxn;++i)
{
yh[i][0]=yh[i][i]=1;
for (j=1;j<i;++j) yh[i][j]=(yh[i-1][j-1]+yh[i-1][j])%mod;
}
jc[0]=ijc[0]=jc[1]=ijc[1]=1;
for (i=2;i<mxn;++i) jc[i]=1ll*jc[i-1]*i%mod;
ijc[mxn-1]=Pow(jc[mxn-1],mod-2,mod);//printf("%d\n",jc[100]);
for (i=mxn-2;i>1;--i) ijc[i]=ijc[i+1]*1ll*(i+1)%mod;
//for (i=0;i<=10;++i) printf("%d jc:%d ijc:%d\n",i,jc[i],ijc[i]);
for (i=1;i<=m;++i) dp[0][0][0][i][0]=1;
for (i=0;i<m;++i)
for (j=0;j<=n;++j)
for (k=j;k<=i*j;++k)
for (t=1;t<=m;++t)
for (sus=0;sus<=i;++sus)
{
int nw=dp[i&1][j][k][t][sus],lim=n-(t==i+1);
if (nw)
for (s=j;s<=lim;++s)
{
if ((i+1)^t)
{
int ad=nw*1ll*ijc[s]%mod*ijc[n-s]%mod;
if (s==j) add(dp[(i&1)^1][s][k+s][t][sus+1],ad);
else add(dp[(i&1)^1][s][k+s][t][1],ad*1ll*ijc[sus]%mod);
}
else
{
int ad=nw*1ll*ijc[s]%mod*ijc[n-s-1]%mod;
if (s==j) add(dp[(i&1)^1][s][k+s][t][sus+1],ad);
else add(dp[(i&1)^1][s][k+s][t][1],ad*1ll*ijc[sus]%mod);
}
}
dp[i&1][j][k][t][sus]=0;
}
for (j=0;j<=n;++j)
for (k=j;k<m*n;++k)
for (t=1;t<=m;++t)
for (sus=0;sus<=m;++sus) if (dp[m&1][j][k][t][sus])
{
add(ans[n*m-k][t],dp[m&1][j][k][t][sus]*1ll*jc[k]%mod*jc[n*m-k-1]%mod*jc[m]%mod*ijc[sus]%mod);
//printf("dp %d %d %d %d %d\n",m,j,k,t,dp[m&1][j][k][t]);
}
for (i=1;i<=n*m;++i)
for (j=1;j<=m;++j) printf("%d%c",ans[i][j],(j==m?'\n':' '));
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/dsu>
using namespace atcoder;

int main()
{
int N, M;
cin >> N >> M;
vector<int> p( N );
for( int i = 0; i < N; i++ ) {
cin >> p[i];
p[i]--;
}
dsu ds( N );
for( int i = 0; i < M; i++ ) {
int x, y;
cin >> x >> y;
x--;
y--;
ds.merge( x, y );
}
int ans = 0;
for( int i = 0; i < N; i++ ) {
if( ds.same( p[i], i ) ) ans++;
}

cout << ans << endl;
}

#include <bits/stdc++.h>
#include <algorithm>
#include <functional>
#include <cmath>
#include<string>
//#include <atcoder/all>
#define _GLIBCXX_DEBUG
#define all(v) v.begin(),v.end()
#define emp " "
#define rep(i,l,n) for(ll i = l; i < (ll)(n); i++)
using namespace std;
//using namespace atcoder;
using ll = long long;
using vs = vector<string>;
using vi = vector<ll>;
using mii = map<ll,ll>;
using vb = vector<bool>;
using Graph = vector<vector<int>>;
ll mod = 1000000007;

struct num {
ll x;
ll y;

num(ll a,ll b) {
x = a;
y = b;
}
};


int main() {
cout << fixed << setprecision(10);

ll n;
cin >> n;

vi b;

ll cnt = 0;

rep(i,0,n) {

cnt++;
ll a;
cin >> a;


if(cnt % 2) {
b.push_back(a);
}
else {
b.insert(b.begin(),a);
}


/*	for(auto x : b) {
cout << x << emp;
}
cout << endl;*/

}


if(cnt % 2) {
reverse(b.begin(),b.end());
}

rep(i,0,b.size()) {
if(i + 1 == b.size()) {
cout << b[i] << endl;
}
else {
cout << b[i] << emp;
}
}

return 0;
}

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_set<int> adjList[2005];
ld weight[2005][2005];
bool visited[2005];
ld dist[2005];

tuple<int, int, int> circles[2005];

ld calcDist(int planet1, int planet2) {
ll x1 = get<0>(circles[planet1]);
ll y1 = get<1>(circles[planet1]);
ll r1 = get<2>(circles[planet1]);
ll x2 = get<0>(circles[planet2]);
ll y2 = get<1>(circles[planet2]);
ll r2 = get<2>(circles[planet2]);
ld distBetweenCenters = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
if (distBetweenCenters <= (r1 + r2)) {
return 0;
} else {
return distBetweenCenters - r1 - r2;
}
}

int main() {
int xs, ys, xt, yt;
cin >> xs >> ys >> xt >> yt;

int n;
cin >> n;

circles[0] = make_tuple(xs, ys, 0);
circles[n+1] = make_tuple(xt, yt, 0);
for(int i = 1; i <= n; i++) {
int x, y, r;
cin >> x >> y >> r;
circles[i] = make_tuple(x, y, r);
// dist[i] = calcDist(0, i);
for (int j = 0; j < i; j++) {
adjList[i].insert(j);
adjList[j].insert(i);
weight[i][j] = weight[j][i] = calcDist(i, j);
}
}
for (int i = 0; i < n+1; i++) {
adjList[i].insert(n+1);
adjList[n+1].insert(i);
weight[i][n+1] = weight[n+1][i] = calcDist(i, n+1);
}
for (int i = 0; i < n+2; i++) {
dist[i] = LDBL_MAX;
}
dist[0] = 0;
for(int i = 0; i < n+2; i++) {
ld mn = 1e18;
int idx;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
if(mn > dist[j]) mn = dist[j], idx = j;
}
visited[idx] = true;
for(int j = 0; j < n+2; j++) {
if(visited[j]) continue;
dist[j] = min(dist[j], dist[idx] + weight[idx][j]);
}
}

printf("%.9Lf\n", dist[n+1]);
}
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e5+10;

char s[maxn];

int getans(int len){
int ans=0;
char p=s[0];
for (int i=1;i<len;i++){
if(p!=s[i]) {ans++;p=s[i];}
}
return ans;
}

int main(){
scanf("%s",s);
int ans=1e9;
int len=strlen(s);
ans=min(ans,getans(len));
reverse(s,s+len);
ans=min(ans,getans(len));
printf("%d\n",ans);
return 0;
}
#include <bits/stdc++.h>
//#include<boost/multiprecision/cpp_int.hpp>
//#include <atcoder/all>
using namespace std;
//using namespace boost::multiprecision;
//using namespace atcoder;
#define rep(i,n) for(int i=0;i<(n);++i)
#define rrep(i,a,n) for(int i=a;i<(n);i++)
#define lep(i,n) for(long long i=0;i<(n);++i)
#define all(x) (x).begin(),(x).end()
#define rall(x) (x).rbegin(),(x).rend()
#define equals(a,b) (fabs((a)-(b))<eps)
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define sz(x) (int)(x).size()
using ll=long long;
template<typename T> using vc = vector<T>;
template<typename T,typename U> using pp=pair<T,U>;
template<typename T> using pq=priority_queue<T>;
template<typename T> using PQ = priority_queue<T,vc<T>,greater<T>>;
using vi=vc<int> ;
using vvi=vc<vi>;
using vvvi=vc<vvi>;
using vl=vc<ll>;
using vvl=vc<vl>;
using vvvl=vc<vvl>;
using pi=pp<int,int>;
using pd=pp<double,double>;
using pl=pp<ll,ll>;
using pip=pp<int,pi>;
using vpi=vc<pi>;
using vvpi=vc<vpi>;
using vs=vc<string>;
using vss=vc<vs>;
using vst=vc<set<int>>;
const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};
const int inf=1001001001;
const ll infl=100100100100100100;
const double eps=(1e-10);
const ll mod=1000000007;
template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }
template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }
template<typename T>
void rprint(T &a) {printf("%.10f\n",a);}
template<typename T>
void coutarray(vc<T>& v) { rep(i, sz(v)) {if(i)cout << " "; cout << v[i];} cout << endl; }
template<typename T>
void coutmatrix(vc<vc<T>>& v) { rep(i,sz(v)) { rep(j, sz(v[i])) {cout << " "; cout << v[i][j]; } cout << "\n";} };
template <typename T = int>
struct PotentialUnionFind {
vector<int> par;
vector<T> diff_weight;
PotentialUnionFind(int n,T SUM_=0):par(n, -1), diff_weight(n,SUM_) { }
int root(int x) {
if(par[x] < 0) return x;
int r = root(par[x]);
diff_weight[x] += diff_weight[par[x]];
return par[x] = r;
}
bool unite(int x, int y, T w){
w += weight(x); w -= weight(y);
x = root(x); y = root(y);
if(x == y) return false;
if(par[x] > par[y]){ swap(x,y); w = -w; }
par[x] += par[y];
par[y] = x;
diff_weight[y] = w;
return true;
}
T weight(int x){root(x); return diff_weight[x];}
T diff(int x, int y){return weight(y)-weight(x);}
bool same(int x, int y){return root(x)==root(y);}
int size(int x){return -par[root(x)];}
};

int main(){
int n,m;
cin>>n>>m;
PotentialUnionFind  d(n);
rep(i,m){
int a,b,c;
cin>>a>>b>>c;
a--;
b--;
if(d.same(a,b)){
if(d.diff(a,b)!=c){
cout<<"No"<<endl;
return 0;
}
}
else d.unite(a,b,c);
}
cout<<"Yes"<<endl;
return 0;
}
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define sc second
#define pb push_back
#define ll long long
#define trav(v,x) for(auto v:x)
#define all(x) (x).begin(), (x).end()
#define VI vector<int>
#define VLL vector<ll>
#define pll pair<ll, ll>
#define double long double
//#define int long long
using namespace std;
const int N = 1e6 + 100;
const int inf = 1e9;
//const ll inf = 1e18;
const ll mod = 998244353;//1e9 + 7;

#ifdef LOCAL
void debug_out(){cerr << endl;}
template<typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{
cerr << " " << to_string(H);
debug_out(T...);
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

void sol()
{
int n;
cin >> n;
VI a(n);
for(int i = 0; i < n; i++)
cin >> a[i];
ll ans = 1e18;
for(int i = -100; i <= 100; i++)
{
ll nw = 0;
for(int j = 0; j < n; j++)
nw += (a[j] - i) * (a[j] - i);
ans = min(ans, nw);
}
cout << ans << '\n';
}

signed main()
{
ios::sync_with_stdio(0);
cin.tie(0);
//	int tt;
//	cin >> tt;
//	while(tt--)
sol();
}


#include "bits/stdc++.h"
using namespace std;
#define reps(i, a, b) for(long long (i) = (a); (i) < (b); ++(i))
#define rep(i, n) for(long long (i) = 0; (i) < (n); ++(i))
#define repr(i, b, a) for(long long (i) = (b); (i) >= (a); --(i))
using ll = long long;
using vl = vector<long long>;
using vvl = vector<vector<long long> >;
using pl = pair<long long, long long>;
using tl = tuple<long long, long long, long long>;
using graph = vector<vector<int> >;
struct Edge{
int to;
long long cost;
Edge(int t, long long c) : to(t), cost(c) {}
bool operator<(const Edge &a) const{return cost < a.cost;}
bool operator>(const Edge &a) const{return cost > a.cost;}
};
using wgraph = vector<vector<Edge> >;
constexpr long long INF = numeric_limits<long long>::max() / 8;
constexpr long long dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};
constexpr long long dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T, typename U> inline bool chmax(T &a, const U& b) {if(a<b){a=b;return true;}return false;}
template<typename T, typename U> inline bool chmin(T &a, const U& b) {if(a>b){a=b;return true;}return false;}
template<typename T, typename U> inline T POW(T x, U n) {T ret=1;while(n>0){if(n&1){ret=ret*x;}if(n>>=1){x=x*x;}}return ret;}
template<typename T, typename U> inline T MOD(T n, U m) {if(n >= 0) {return n % m;} else return (n%m + m)%m;}
template<typename T, typename U, typename V> inline T POWMOD(T x, U n, V m){T ret=1;x%=m;while(n>0){if(n&1)ret=ret*x%m;if(n>>=1){x=x*x%m;}}return ret%m;}
template<typename T, typename U> inline T div_ceil(T a, U b){return (a + b - 1) / b;}
template<typename T> inline long long KETA(T n, long long base = 10){long long ret = 0;while(n){ret++; n /= base;} return ret;}
template<typename T> inline long long popcount(T a){return __builtin_popcount(a);}
template<typename T> inline bool contains(T S, T i){return (S & (T(1) << i)) != 0;}
template<typename T> inline void fin(T a){cout << a << '\n'; exit(0);}
template<typename T> inline T SUM(const vector<T> &v){return accumulate(v.begin(), v.end(), (T)0);}
template<typename T> inline T MIN(const vector<T> &v){return *min_element(v.begin(), v.end());}
template<typename T> inline T MAX(const vector<T> &v){return *max_element(v.begin(), v.end());}
template<typename T> inline void decr(vector<T> &v, T d = T(1)){for(auto &c : v){c -= d;}}

template<typename T,typename S> ostream&operator<<(ostream&os,const pair<T,S>&p){os<<"("<<p.first<<", "<<p.second<<")";return os;}
template<typename T,typename S> ostream&operator<<(ostream&os,const map<T,S>&ma){for(auto [a,b]:ma){os<<"("<<a<<", "<<b<<")"<<" ";}return os;}
template<typename T> ostream &operator<<(ostream&os,const set<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const multiset<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const vector<T>&v){os<<"[";for(int i=0;i<v.size();i++){os<<v[i]<<(i==v.size()-1?"":" ");}os<<"]";return os;}

void dump_func() {cerr << endl;}
template<class Head, class... Tail>
void dump_func(Head&& head, Tail&&... tail){
cerr << head;
if(sizeof...(Tail) == 0) cerr << " ";
else cerr << ", ";
dump_func(std::move(tail)...);
}



//#define ONLINE_JUDGE
#ifdef ONLINE_JUDGE
#define dump(...) true
#else
#define dump(...) cerr << __LINE__ << " : (" << #__VA_ARGS__ << ") = "; \
dump_func(__VA_ARGS__)
#endif




void solve(){
ll n, a, b; cin >> n >> a >> b;
if(a * b < n or a + b > n + 1){
cout << -1 << '\n';
return;
}
vector<vector<ll> > chain(b);
ll now = n;
rep(i, a){
chain[0].emplace_back(n - i);
now--;
}
if(b == 1){
reverse(chain[0].begin(), chain[0].end());
for(auto t : chain[0]){
cout << t << ' ';
}
cout << '\n';
return;
}
//残りn - a個
ll k = (n - a) - (n - a) / (b - 1) * (b - 1);
reps(i, 1, k + 1){
rep(j, div_ceil((n - a), (b - 1))){
chain[i].emplace_back(now);
now--;
}
}
reps(i, k + 1, b){
rep(j, (n - a) / (b - 1)){
chain[i].emplace_back(now);
now--;
}
dump(i);
dump(chain);
}
//    assert(chain[0].size() >= chain.back().size());
for(auto &v : chain){
reverse(v.begin(), v.end());
for(auto t : v){
cout << t << ' ';
}
}
cout << '\n';
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout << std::fixed << std::setprecision(15);

solve();

return 0;
}

#include <bits/stdc++.h>
#define ll long long
using namespace std;
#define Mod 1000000007

int main() {
string str;
cin>>str;
ll n=stoll(str);
ll ans=0;
ll t=0;
for (int i = 0; i < pow(2,str.length()-1); ++i) {
t=n;
for (int j = (int)str.length()-1; j>0; j--) {
if(i&1<<(j-1)){
ans+=t/(int)pow(10,j);
t%=(int)pow(10,j);
}
}
ans+=t;
//cout<<i<<ans<<endl;
}
cout<<ans<<endl;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define cerr cerr << "DEBUG "

constexpr int N = 1e5 + 10;

int a[N], n;

int main() {
ios_base::sync_with_stdio(false);
cin.tie(nullptr);

cin >> n;
long long ans = 0;
for (int i = 0; i < n; ++i) {
int x = 1;
if (i != 0) {
char c;
cin >> c;
if (c == '-') {
x = -1;
}
}
cin >> a[i];
a[i] *= x;
ans += a[i];
}

long long sum = ans, shit = 0;
for (int i = n - 1; i >= 0; --i) {
//cerr << sum << '\n';
if (a[i] < 0) {
ans = max(ans, sum - shit * 2ll);
shit = 0;
sum -= 2ll * a[i];
} else {
shit += a[i];
}
}

cout << ans;
}
// Problem: AT2396 [ARC071D] Infinite Sequence
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/AT2396
// Memory Limit: 250 MB
// Time Limit: 2000 ms

/*
* Author: chenkaifeng @BDFZ
*/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pf push_front
#define rep(i, s, t) for (int i = s; i <= t; ++i)
#define per(i, s, t) for (int i = t; i >= s; --i)

namespace nqio{const unsigned R=4e5,W=4e5;char*a,*b,i[R],o[W],*c=o,*d=o+W,h[40],*p=h,y;bool s;struct q{void r(char&x){x=a==b&&(b=(a=i)+fread(i,1,R,stdin),a==b)?-1:*a++;}void f(){fwrite(o,1,c-o,stdout);c=o;}~q(){f();}void w(char x){*c=x;if(++c==d)f();}q&operator>>(char&x){do r(x);while(x<=32);return*this;}q&operator>>(char*x){do r(*x);while(*x<=32);while(*x>32)r(*++x);*x=0;return*this;}template<typename t>q&operator>>(t&x){for(r(y),s=0;!isdigit(y);r(y))s|=y==45;if(s)for(x=0;isdigit(y);r(y))x=x*10-(y^48);else for(x=0;isdigit(y);r(y))x=x*10+(y^48);return*this;}q&operator<<(char x){w(x);return*this;}q&operator<<(char*x){while(*x)w(*x++);return*this;}q&operator<<(const char*x){while(*x)w(*x++);return*this;}template<typename t>q&operator<<(t x){if(!x)w(48);else if(x<0)for(w(45);x;x/=10)*p++=48|-(x%10);else for(;x;x/=10)*p++=48|x%10;while(p!=h)w(*--p);return*this;}}qio;}using nqio::qio;

#define OK debug("OK!\n")
#ifndef ONLINE_JUDGE
namespace debuger{void debug(const char *s) {cerr << s;}template<typename T1,typename... T2>void debug(const char*s, const T1 x, T2...ls) { int p=0; while(*(s + p)!='\0') {if(*(s+p)=='{'&&*(s+p+1)=='}'){cerr << x;debug(s + p + 2, ls...);return;}cerr << *(s + p++);}}}using debuger::debug;
#else
#define debug(...) void(0)
#endif

const int mod = 1e9 + 7;
// const int mod = 998244353;

int qpow(int x, ll p) {
int res = 1, base = x;
while(p) {
if(p & 1) res = 1ll * res * base % mod;
base = 1ll * base * base % mod;
p >>= 1;
}
return res;
}

template<typename T> inline void upd(T& x, const T& y) {	x += y;	if(x >= mod) x -= mod; }
template<typename T> inline void upd(T& x, const T& y, const T& z) { x = y + z; if(x >= mod) x -= mod; }

/* template ends here */

std::mt19937 mtrnd(std::chrono::system_clock::now().time_since_epoch().count());

const int N = 1e6 + 5;

int f[N], suf[N<<1], n;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr), cout.tie(nullptr);
cout << fixed << setprecision(15); 
cerr << fixed << setprecision(15);

cin >> n;
suf[n] = n, f[n] = n;
int v = 1ll*(n-1)*(n-1)%mod;
per(i, 1, n-1) {
f[i] = (1ll*f[i+1]+suf[i+3]+(i+1)-(i+2>n)+v)%mod;
suf[i] = (suf[i+1] + f[i])%mod;
}

cout << f[1] << "\n";

return 0;
}

#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a),i##END=(b);i<=i##END;i++)
#define Rof(i,b,a) for(int i=(b),i##END=(a);i>=i##END;i--)
#define go(u) for(int i=head[u];i;i=nxt[i])
using namespace std;
inline int read(){
int x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
return x*f;
}
const int N=1e6+10,M=1e7+10;
int pr[M],pcnt;bool st[M],d[M],ispr[M];
void init(int n=M-10){
For(i,2,n){
if(!st[i])pr[++pcnt]=i;
for(int j=1;j<=pcnt&&i*pr[j]<=n;j++){
st[i*pr[j]]=1;
if(i%pr[j]==0)break;
}
}
}
int n,a[N],b[N],m,c[N],ans;
int used[N],tag,pre[N];
int head[N],to[N],nxt[N],cnt;
void add(int u,int v){to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;}
bool find(int u){
go(u){
int v=to[i];
if(used[v]!=tag){
used[v]=tag;
if(!pre[v]||find(pre[v]))return pre[v]=u,1;
}
}return 0;
}
void TLE(){while(1)puts("OKOK");}
signed main(){
init();For(i,1,pcnt)ispr[pr[i]]=1;
For(i,1,n=read())d[read()]=1;
For(i,1,M-1)if(d[i]^d[i-1])b[++m]=i;
For(i,2,m)For(j,1,i-1)if(b[i]-b[j]>2&&ispr[b[i]-b[j]])add(i,j),add(j,i);
for(tag=1;tag<=m;tag++)if(b[tag]&1)find(tag);For(i,1,m)
if(pre[i])assert(!c[pre[i]]&&!c[i]),c[pre[i]]=c[i]=1,ans++;
For(i,2,m)For(j,1,i-1)if(!c[i]&&!c[j]&&!(b[i]-b[j]&1))ans+=2,c[i]=c[j]=2;
int tot=0;For(i,1,m)if(!c[i])c[i]=3,tot++;if(tot)ans+=3;printf("%d\n",ans);
return 0;
}
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
//#pragma GCC target("avx2,fma")
#define rep(i,l,r) for (int i = l; i < r; i++)
#define repr(i,r,l) for (int i = r; i >= l; i--)
#define X first
#define Y second
#define pb push_back
#define endl '\n'
#define debug(x) cerr << #x << " : " << x << endl;
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pll;
const long long int N = 7e5+20,mod = 1e9+7,inf = 1e18,sq = 500;
inline int mkay(int a,int b){
if (a+b >= mod) return a+b-mod;
return a+b;
}
inline int poww(int a,int k){
int z = 1;
while (k){
if (k&1) z = 1ll*z*a%mod;
a = 1ll*a*a%mod;
k >>= 1;
}
return z;
}
int main(){
ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
vector<pair<pll,int>> ans;
int l;
cin >> l;
if (l == 2){
cout << 2 << ' ' << 2 << endl;
cout << 1 << ' ' << 2 << ' ' << 0 << endl;
cout << 1 << ' ' << 2 << ' ' << 1 << endl;
return 0;
}
int sum = 0;
int mx = 0;
int z = 1;
rep(i,1,l+1){
ans.pb({{i,i+1},0});
ans.pb({{i,i+1},z});
ans.pb({{i,i+1},2*z});
mx = i;
sum += 2*z;
z *= 3;
if (sum+2*z > l-1) break;
}
int s = l-1;
repr(i,mx+1,1){
int x = poww(3,i-1);
if (x-1 <= s){
ans.pb({{i,mx+2},s-x+1});
s -= x;
}
if (x-1 <= s){
ans.pb({{i,mx+2},s-x+1});
s -= x;
}
}
cout << mx+2 << ' ' << ans.size() << endl;
for (auto u : ans) cout << u.X.X << ' ' << u.X.Y << ' ' << u.Y << endl;

}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <charconv>
#include <cmath>
#include <iomanip>
#include <limits>
#include <functional>
using namespace std;

#define rep(i, n) for (long i = 0; i < (long)(n); i++)
using ll = long long;



int main() {
ll n;
cin>>n;
vector<ll>a(n+2);
vector<ll>dist(n+1);
vector<ll>b(n);
a[0]=0;
a[n+1]=0;
ll ans=0;

for(ll i=1;i<=n;i++){
cin>>a[i];
ll x=abs(a[i]-a[i-1]);
dist[i-1]=x;
ans+=x;
if(i>=2)
b[i-2]=abs(a[i]-a[i-2]);
}
ans+=abs(a[n+1]-a[n]);
b[n-1]=abs(a[n+1]-a[n-1]);
dist[n]=abs(a[n+1]-a[n]);

for(ll i=1;i<=n;i++){
cout<<ans+b[i-1]-dist[i-1]-dist[i]<<endl;
}
}




#include <bits/stdc++.h>
using ll=long long;
using namespace std;
#define REP(i,n) for(int i=0; i<(n); i++)
#define REP2(i,x,n) for(int i=x; i<(n); i++)
#define cin_int(i) int i;cin>>i
#define cin_long(i) ll i;cin>>i
#define cin_arrayint(i,k)vector<int>i; for(int t=0; t<k; t++){int x; cin>>x;i.push_back(x);} 
#define cin_arraydouble(i,k)vector<double>i; for(int t=0; t<k; t++){double x; cin>>x;i.push_back(x);} 
#define foreach(i,t) for(auto i:t)
int main()
{
cin_int(n);
cin_arrayint(a,n);
int x=0;
int y=0;
foreach(i,a)
{
if(i%4==0)
{
x++;
continue;
}
if(i%2!=0)
y++;
}
bool ans=false;
if(x>=y)
ans=true;
if(x+y==n&&y==x+1)
ans=true;
if(ans)
cout<<"Yes"<<endl;
else
cout<<"No"<<endl;
system("pause");
return 0;
}


// Exported by Exporter.exe

// Included from F.cpp
#include <bits/stdc++.h>
using namespace std;
#define PB push_back
#define F first
#define S second
#define MP make_pair
#define MTP make_tuple
#define R Read
#define RD Read_Digit
#define RP Read_P
#define RS Read_String
#define RL Read_Loop
#define RLD Read_Loop_Digit
#define RLP Read_Loop_P
#define RLS Read_Loop_String
#ifdef ONLINE_JUDGE
#define Debug(...) ;
#define Debug_Array(n,x) ;
#define Debugln_Array(n,x) ;
#define NL ;
#else
#define Debug(...) {printf("(%s) = ",(#__VA_ARGS__)),_print(__VA_ARGS__),printf("\n");}
#define Debug_Array(n,x) {printf("%s :",(#x));for(int i=1;i<=n;i++)printf(" "),_print(x[i]);printf("\n");}
#define Debugln_Array(n,x) {for(int i=1;i<=n;i++){printf("%s",(#x));printf("[%d] = ", i);_print(x[i]);printf("\n");}}
#define NL {printf("\n");}
#endif
typedef long long int ll;
typedef unsigned long long int ull;

constexpr int kN = 15;
constexpr int kM = kN * kN;
// constexpr int kMod = 998244353;
// constexpr int kMod = int(1E9 + 7);
// constexpr int kInf = 0x3f3f3f3f;
// constexpr ll kInf = 0x3f3f3f3f3f3f3f3f;
// constexpr double kPi = acos(-1);
// constexpr double kEps = 1E-9;
// constexpr int dx[4] = {0, 0, 1, -1};
// constexpr int dy[4] = {1, -1, 0, 0};
// constexpr int dx[8] = {0, 0, 1, -1, 1, -1, 1, -1};
// constexpr int dy[8] = {1, -1, 1, -1, -1, 1, 0, 0};


// Included from C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp
bool Fast_IO_activated = false;
bool IOS_activated = false;
// --- Get ---
static inline char Get_Raw_Char() {
static bool pre = Fast_IO_activated = true;
static char buf[1 << 16], *p = buf, *end = buf;
if (p == end) {
if ((end = buf + fread(buf, 1, 1 << 16, stdin)) == buf) return '\0';
p = buf;
}
return *p++;
}

// --- Read ---
template <typename T> static inline void Read_P(T &n) {
static_assert(is_integral<T>::value, "Read_P requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
return ;
}

template <typename T> static inline void Read(T &n) {
static_assert(is_integral<T>::value, "Read requires an integral type");
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');
if (neg) n = -n;
return ;
}

template <typename T> static inline void Read_Digit(T &n) {
static_assert(is_integral<T>::value, "Read_Digit requires an integral type");
char c;
while (!isdigit(c = Get_Raw_Char())) ;
n = int(c - '0');
return ;
}

static inline void Read_String(string &s) {
s.clear();
char c = Get_Raw_Char();
while (c == ' ' or c == '\n') c = Get_Raw_Char();
while (c != ' ' and c != '\n') {
s += c;
c = Get_Raw_Char();
}
return ;
}

// --- Read multiple ---
template <typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read(n); return Read(Fargs...);}
template <typename T, typename... Targs> static inline void Read_Digit(T &n, Targs&... Fargs) {Read_Digit(n); return Read_Digit(Fargs...);}
template <typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P(n); return Read_P(Fargs...);}
template <typename... Targs> static inline void Read_String(string &s, Targs&... Fargs) {Read_String(s); return Read_String(Fargs...);}

// --- Read Loop ---
template <typename T> static inline void Read_Loop_i(int i, T *a) {return Read(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_i(int i, T *a, Targs*... Fargs) {Read(a[i]); return Read_Loop_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_Digit_i(int i, T *a) {return Read_Digit(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_Digit_i(int i, T *a, Targs*... Fargs) {Read_Digit(a[i]); return Read_Loop_Digit_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_Digit(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_Digit_i(i, Fargs...);}

template <typename T> static inline void Read_Loop_P_i(int i, T *a) {return Read_P(a[i]);}
template <typename T, typename... Targs> static inline void Read_Loop_P_i(int i, T *a, Targs*... Fargs) {Read_P(a[i]); return Read_Loop_P_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_P(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_P_i(i, Fargs...);}

static inline void Read_Loop_String_i(int i, string *a) {return Read_String(a[i]);}
template <typename... Targs> static inline void Read_Loop_String_i(int i, string *a, Targs*... Fargs) {Read_String(a[i]); return Read_Loop_String_i(i, Fargs...);}
template <typename... Targs> static inline void Read_Loop_String(int n, Targs*... Fargs) {for (int i = 1; i <= n; i++) Read_Loop_String_i(i, Fargs...);}

// --- Float ---
template <int mul, typename T> static inline void Read(T &n) {
char c;
bool neg = false;
while (!isdigit(c = Get_Raw_Char())) if (c == '-') neg = true;
n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;

if (neg) n = -n;
return ;
}

template <int mul, typename T> static inline void Read_P(T &n) {
char c;
while (!isdigit(c = Get_Raw_Char())) ;

n = int(c - '0');
while (isdigit(c = Get_Raw_Char())) n = n * 10 + int(c - '0');

int cnt = 0;

if (c == '.') {
while (isdigit(c = Get_Raw_Char())) {
n = n * 10 + int(c - '0');
cnt++;
}
}

while (cnt++ < mul) n = n * 10;
return ;
}

template <int mul, typename T, typename... Targs> static inline void Read(T &n, Targs&... Fargs) {Read<mul>(n); return Read<mul>(Fargs...);}
template <int mul, typename T, typename... Targs> static inline void Read_P(T &n, Targs&... Fargs) {Read_P<mul>(n); return Read_P<mul>(Fargs...);}

// --- init ---
inline void IOS() {
IOS_activated = true;
ios::sync_with_stdio(false); cin.tie(0);
}
inline void Freopen(const char *in, const char *out) {freopen(in, "r", stdin); freopen(out, "w", stdout); return ;}

// --- Output ---
#if defined(__SIZEOF_INT128__)
void Print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
} 
#endif
// End of C:\Users\ianli\Desktop\CP\template\Various\Fast_IO\Fast_IO.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp
template <typename T, typename T1> void make_vector_inner(vector<T>& vec, T1 c) {return vec.push_back(T(c));}
template <typename T, typename T1, typename... Targs> void make_vector_inner(vector<T> &vec, T1 c, Targs... targs) {
vec.push_back(T(c));
return make_vector_inner(vec, targs...);
}
template <typename T, typename... Targs> vector<T> make_vector(Targs... targs) {
vector<T> vec;
make_vector_inner(vec, targs...);
return vec;
}

template <typename T> inline void sort(vector<T> &v) {return sort(v.begin(), v.end());}
template <typename T> inline void sort_r(vector<T> &v) {return sort(v.begin(), v.end(), greater<T>());}
inline void sort(string &s) {return sort(s.begin(), s.end());}
inline void sort_r(string &s) {return sort(s.begin(), s.end(), greater<char>());}

template <typename T> inline void reverse(vector<T> &v) {return reverse(v.begin(), v.end());}
inline void reverse(string &s) {return reverse(s.begin(), s.end());}

template <typename T> inline void Merge(vector<T> &a, vector<T> &b, vector<T> &c) {
if (c.size() < a.size() + b.size()) c.resize(a.size() + b.size());
merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());
return ;
}
template <typename T> inline void Concatanate(vector<T> &a, vector<T> &b, vector<T> &c) {
int a_size = int(a.size()), b_size = int(b.size());
c.resize(a_size + b_size);
for (int i = 0; i < a_size; i++) c[i] = a[i];
for (int i = 0; i < b_size; i++) c[i + a_size] = b[i];
return ;
}
template <typename T> inline void Append(vector<T> &lhs, vector<T> rhs) {
int lsz = int(lhs.size()), rsz = int(rhs.size());
lhs.reserve(lsz + rsz);
for (int i = 0; i < rsz; i++) lhs.push_back(rhs[i]);
return ;
}

template <typename T> inline void Erase(vector<T> &vec, T x) {
int sz = int(vec.size());
for (int i = 0; i < sz; i++) if (vec[i] == x) {
swap(vec[i], vec.back());
vec.pop_back();
break;
}
return ;
}

template <typename T> inline void Discrete(vector<T> &v) {sort(v); v.resize(unique(v.begin(), v.end()) - v.begin()); return ;}
template <typename T> inline int Discrete_Id(vector<T> &v, T x) {return lower_bound(v.begin(), v.end(), x) - v.begin();}

template <typename T> using PQ = priority_queue<T>;
template <typename T> using PQ_R = priority_queue<T, vector<T>, greater<T>>;

template <typename T> inline T ABS(T n) {return n >= 0 ? n : -n;}
template <typename T> __attribute__((target("bmi"))) inline T gcd(T a, T b) {
if (a < 0) a = -a;
if (b < 0) b = -b;
if (a == 0 || b == 0) return a + b;
int n = __builtin_ctzll(a);
int m = __builtin_ctzll(b);
a >>= n;
b >>= m;
while (a != b) {
int m = __builtin_ctzll(a - b);
bool f = a > b;
T c = f ? a : b;
b = f ? b : a;
a = (c - b) >> m;
}
return a << min(n, m);
}
template <typename T> inline T lcm(T a, T b) {return a * (b / gcd(a, b));}
template <typename T, typename... Targs> inline T gcd(T a, T b, T c, Targs... args) {return gcd(a, gcd(b, c, args...));}
template <typename T, typename... Targs> inline T lcm(T a, T b, T c, Targs... args) {return lcm(a, lcm(b, c, args...));}
template <typename T, typename... Targs> inline T min(T a, T b, T c, Targs... args) {return min(a, min(b, c, args...));}
template <typename T, typename... Targs> inline T max(T a, T b, T c, Targs... args) {return max(a, max(b, c, args...));}
template <typename T, typename... Targs> inline void chmin(T &a, T b, Targs... args) {a = min(a, b, args...); return ;}
template <typename T, typename... Targs> inline void chmax(T &a, T b, Targs... args) {a = max(a, b, args...); return ;}

vector<int> Primes(int n) {
if (n == 1) return {};
// 2 ~ n
vector<int> primes;
vector<bool> isPrime(n + 1, true);

primes.reserve(n / __lg(n));

for (int i = 2; i <= n; i++) {
if (isPrime[i]) primes.push_back(i);
for (int j : primes) {
if (i * j > n) break;
isPrime[i * j] = false;
if (i % j == 0) break;
}
}
return primes;
}

template <typename T> vector<T> factors(T x) {
// maybe use factorize would be faster?
vector<T> ans;
for (T i = 1; i * i <= x; i++) if (x % i == 0) ans.push_back(i);

int id = int(ans.size()) - 1;
if (ans[id] * ans[id] == x) id--;
for (int i = id; i >= 0; i--) ans.push_back(x / ans[i]);

return ans;
}

int mex(vector<int> vec) {
int n = int(vec.size());
vector<bool> have(n, false);
for (int i : vec) if (i < n) have[i] = true;
for (int i = 0; i < n; i++) if (!have[i]) return i;
return n;
}

template <typename T> T SQ(T x) {return x * x;}

// Euclidean distance
template <typename T> T Dist2(pair<T, T> lhs, pair<T, T> rhs) {return SQ(lhs.F - rhs.F) + SQ(lhs.S - rhs.S);}
template <typename T> T Dist2(T x1, T y1, T x2, T y2) {return SQ(x1 - x2) + SQ(y1 - y2);}

// Manhattan distance
template <typename T> T Mdist(pair<T, T> lhs, pair<T, T> rhs) {return ABS(lhs.first - rhs.first) + ABS(lhs.second - rhs.second);}
template <typename T> T Mdist(T x1, T y1, T x2, T y2) {return ABS(x1 - x2) + ABS(y1 - y2);}

template <typename T> bool Adj(pair<T, T> lhs, pair<T, T> rhs) {return Mdist(lhs, rhs) == 1;}

template <typename T> T LUBound(T LB, T val, T UB) {return min(max(LB, val), UB);}

template <typename T, typename Comp> T Binary_Search(T L, T R, Comp f) {
// L good R bad
static_assert(is_integral<T>::value, "Binary_Search requires an integral type");
while (R - L > 1) {
T mid = (L + R) >> 1;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename Comp> double Binary_Search(double L, double R, Comp f, int loop = 30) {
for (int i = 1; i <= loop; i++) {
double mid = (L + R) / 2;
if (f(mid)) L = mid;
else R = mid;
}
return L;
}

template <typename T> T nearest_dist(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin() - val;
else if (val >= *prev(se.end())) return val - *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);
return min(*u - val, val - *v);
}
}

template <typename T> T nearest_elem(set<T> &se, T val) {
static constexpr T kInf = numeric_limits<T>::max() / 2 - 10;

if (se.empty()) return kInf;
else if (val <= *se.begin()) return *se.begin();
else if (val >= *prev(se.end())) return *prev(se.end());
else {
auto u = se.lower_bound(val);
auto v = prev(u);

if (*u - val > val - *v) return *v;
else return *u;
}
}

namespace MR32 {
using ull = unsigned long long int;
using uint = unsigned int;
ull PowMod(ull a, ull b, ull kMod) {
ull ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(uint x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 3, a[3] = {2, 7, 61};
if (x < 8) return low[x];

uint t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
ull tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}

#ifdef __SIZEOF_INT128__
namespace MR64 {
using uint128 = unsigned __int128;
using ull = unsigned long long int;
using uint = unsigned int;
uint128 PowMod(uint128 a, uint128 b, uint128 kMod) {
uint128 ans = 1;
for (; b; b >>= 1, a = a * a % kMod) if (b & 1) ans = ans * a % kMod;
return ans;
}

bool IsPrime(ull x) {
static constexpr bool low[8] = {false, false, true, true, false, true, false, true};
static constexpr uint as = 7, a[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
if (x < 8) return low[x];
ull t = x - 1;
int r = 0;
while ((t & 1) == 0) {
t >>= 1;
r++;
}
for (uint i = 0; i < as; i++) if (a[i] <= x - 2) {
bool ok = false;
uint128 tt = PowMod(a[i], t, x);
if (tt == 1) continue;
for (int j = 0; j < r; j++, tt = tt * tt % x) if (tt == x - 1) {
ok = true;
break;
}
if (!ok) return false;
}
return true;
}
}
#endif

bool IsPrime(unsigned long long int x) {
#ifdef __SIZEOF_INT128__
if ((x >> 32) == 0) return MR32::IsPrime(x);
else return MR64::IsPrime(x);
#endif
return MR32::IsPrime(x);
}

#ifdef __SIZEOF_INT128__
uint64_t PollardRho(uint64_t x) {
static mt19937 rng;
if (!(x & 1)) return 2;
if (IsPrime(x)) return x;
int64_t a = rng() % (x - 2) + 2, b = a;
uint64_t c = rng() % (x - 1) + 1, d = 1;
while (d == 1) {
a = (__int128(a) * a + c) % x;
b = (__int128(b) * b + c) % x;
b = (__int128(b) * b + c) % x;
d = gcd(uint64_t(abs(a - b)), x);
if (d == x) return PollardRho(x);
}
return d;
}

template <typename T> vector<T> factorize(T x) {
if (x <= 1) return vector<T>();
T p = PollardRho(x);
if (p == x) return vector<T>(1, x);
vector<T> ans, lhs = factorize(p), rhs = factorize(x / p);
Merge(lhs, rhs, ans);
return ans;
}
#endif

// vec must be sorted
template <typename T> vector<pair<T, int>> Compress(vector<T> vec) {
if (vec.empty()) return {};

vector<pair<T, int>> ans;
int cnt = 1, sz = int(vec.size());
T lst = vec[0];
for (int i = 1; i < sz; i++) {
if (lst != vec[i]) {
ans.push_back(make_pair(lst, cnt));
lst = vec[i];
cnt = 1;
}
else cnt++;
}
ans.push_back(make_pair(lst, cnt));
return ans;
}

template <typename T> int Divisors(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

int ans = 1;
for (pair<T, int> i : fac) ans *= i.second + 1;

return ans;
}

template <typename T> T phi(T x) {
vector<pair<T, int>> fac = Compress(factorize(x));

T ans = 1;
for (pair<T, int> i : fac) {
ans *= i.first - 1;
for (int j = 1; j < i.second; j++) ans *= i.first;
}

return ans;
}
// End of C:\Users\ianli\Desktop\CP\template\Various\Useful_Functions\Useful_Functions.cpp

// Included from C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp
template <typename T> void _print(vector<T> v) ;
void _print(bool x) {printf("%s", x ? "True" : "False");}
void _print(char x) {printf("%c", x);}
void _print(short x) {printf("%hd", x);}
void _print(unsigned short x) {printf("%hu", x);}
void _print(int x) {printf("%d", x);}
void _print(unsigned int x) {printf("%u", x);}
void _print(long int x) {printf("%ld", x);}
void _print(unsigned long int x) {printf("%lu", x);}
void _print(long long int x) {printf("%lld", x);}
void _print(unsigned long long int x) {printf("%llu", x);}
void _print(float x) {printf("%f", x);}
void _print(double x) {printf("%lf", x);}
void _print(long double x) {printf("%Lf", x);}
void _print(const char* c) {int n = strlen(c); for (int i = 0; i < n; i++) printf("%c", c[i]);}
void _print(string s) {for (char c : s) printf("%c", c);}
template <size_t _size> void _print(bitset<_size> bs) {for (int i = 0; i < _size; i++) printf("%d", bs[i] ? 1 : 0);}
#ifdef __SIZEOF_INT128__
void _print(__int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
void _print(unsigned __int128 x) {
if (x < 0) {
printf("-");
x = -x;
}
if (x == 0) printf("0");
else {
static int val[100];
int idx = -1;
while (x) {
val[++idx] = x % 10;
x /= 10;
}
while (idx >= 0) printf("%d", val[idx--]);
}
}
#endif
template <typename T1, typename T2> void _print(pair<T1, T2> x) {printf("("); _print(x.first); printf(", "); _print(x.second); printf(")");}
template <typename T1, typename T2, typename T3> void _print(tuple<T1, T2, T3> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(")");}
template <typename T1, typename T2, typename T3, typename T4> void _print(tuple<T1, T2, T3, T4> x) {printf("("); _print(get<0>(x)); printf(", "); _print(get<1>(x)); printf(", "); _print(get<2>(x)); printf(", "); _print(get<3>(x)); printf(")");}
template <typename T> void _print(vector<T> v) {
if (v.empty()) printf(" empty");
else {
bool first = true;
for (T i : v) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(set<T> s) {
if (s.empty()) printf(" empty");
else {
bool first = true;
for (T i : s) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}
template <typename T> void _print(stack<T> s) {
if (s.empty()) printf(" empty");
else {
_print(s.top()); s.pop();
while (!s.empty()) {printf(", "); _print(s.top()); s.pop();}
}
}
template <typename T> void _print(queue<T> q) {
if (q.empty()) printf(" empty");
else {
_print(q.front()); q.pop();
while (!q.empty()) {printf(", "); _print(q.front()); q.pop();}
}
}
template <typename T> void _print(deque<T> dq) {
if (dq.empty()) printf(" empty");
else {
_print(dq.front()); dq.pop_front();
while (!dq.empty()) {printf(", "); _print(dq.front()); dq.pop_front();}
}
}
template <typename T1, typename T2, typename T3> void _print(priority_queue<T1, T2, T3> pq) {
if (pq.empty()) printf(" empty");
else {
_print(pq.top()); pq.pop();
while (!pq.empty()) {printf(", "); _print(pq.top()); pq.pop();}
}
}
template <typename T1, typename T2> void _print(map<T1, T2> m) {
if (m.empty()) printf(" empty");
else {
bool first = true;
for (pair<T1, T2> i : m) {
if (first) first = false;
else printf(", ");
_print(i);
}
}
}

template <typename T> void _print(T& x) {return x.out();}
template <typename T, typename... Targs> void _print(T x, Targs... Fargs) {_print(x); printf(", "); _print(Fargs...);}
// End of C:\Users\ianli\Desktop\CP\template\Various\Debug\Debug.cpp

int a[kM], b[kM], c[kM];
int block[1 << kN];
int dp[kN][1 << kN];
int edge[kN][kN];

int main() {
int n, m; RP(n, m);
RLP(m, a, b, c);

for (int i = 1; i <= m; i++) a[i]--;
for (int i = 1; i <= m; i++) b[i]--;
for (int i = 1; i <= m; i++) edge[a[i]][b[i]] = edge[b[i]][a[i]] = c[i];

int tot = 1 << n;

for (int i = 1; i <= m; i++) {
int remain = (tot - 1) ^ (1 << a[i]);

// b      || a
// remain || tot - remain

for (int mask = remain; mask > 0; mask = (mask - 1) & remain) if (mask >> b[i] & 1) {
block[mask] += c[i];
block[(tot - 1) ^ mask] += c[i];
}
}

//for (int mask = 0; mask < tot; mask++) {
//	Debug(mask, block[mask]);
//}

memset(dp, 0x3f, sizeof(dp));

for (int mask = 1; mask < tot; mask++) if (mask & 1) {
for (int i = 0; i < n; i++) if (mask >> i & 1) {
if (i == 0) dp[i][mask] = block[mask];

int remain = mask ^ (1 << i);

// j       || i
// submask || mask - submask

for (int submask = remain; submask > 0; submask = (submask - 1) & remain) if (submask & 1) {
for (int j = 0; j < n; j++) if ((submask >> j & 1) and edge[j][i]) {
int val = dp[j][submask] + block[mask ^ submask] - (edge[j][i] << 1);


chmin(dp[i][mask], val);
}
}

}
}


int ans = dp[n - 1][tot - 1] >> 1;

printf("%d\n", ans);
}
// End of F.cpp

///****In the name of ALLAH, most Gracious, most Compassionate****//

#pragma GCC target ("avx2")
#pragma GCC optimization ("O3")
#pragma GCC optimization ("unroll-loops")

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair <int, int> pii;

#define ALL(a) a.begin(), a.end()
#define FastIO ios::sync_with_stdio(false); cin.tie(0);cout.tie(0)
#define IN freopen("input.txt","r+",stdin)
#define OUT freopen("output.txt","w+",stdout)

#define DBG(a) cerr<< "line "<<__LINE__ <<" : "<< #a <<" --> "<<(a)<<endl
#define NL cout<<endl

template < class T1,class T2>
ostream &operator <<(ostream &os,const pair < T1,T2 > &p)
{
os<<"{"<<p.first<<","<<p.second<<"}";
return os;
}

const int N=3e5+5;
const int oo=1e9+7;

int cnt[2][N][2];

void init(int i,string &s)
{
for(int j=0;j<s.size();j++)
{
cnt[i][j+1][0]=cnt[i][j][0];
cnt[i][j+1][1]=cnt[i][j][1];
cnt[i][j+1][s[j]-'A']++;
}
}

string gt(int i,int l,int r)
{
int a = cnt[i][r][0]-cnt[i][l-1][0];
int b = cnt[i][r][1]-cnt[i][l-1][1];
int mn =min(a,b);
int mx = max(a,b);
int an = mx-mn;

if(an%3 == 0)
{
return "";
}
else if(an%3 == 1)
return a==mx?"A":"B";
else 
return a==mx?"B":"A";

}

int32_t main()
{
FastIO;
string s,t;
cin>>s>>t;

init(0,s);
init(1,t);
int q;
cin>>q;

while(q--)
{
int a,b,c,d;
cin>>a>>b>>c>>d;
cout<<(gt(0,a,b)==gt(1,c,d)?"YES":"NO")<<"\n";
}

return 0;
}

// Author: wlzhouzhuan
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,l,r) for(int i=(l);i>=(r);i--)
#define pb push_back
#define fir first
#define sec second
#define SZ(x) ((int)x.size())
#define pii pair<int,int>
template<class T1,class T2>void ckmin(T1&x,T2 y){if(x>y)x=y;}
template<class T1,class T2>void ckmax(T1&x,T2 y){if(x<y)x=y;}
inline ll read(){
ll x=0,f=0;char ch=getchar();
while(!isdigit(ch))f|=ch=='-',ch=getchar();
while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
return f?-x:x;
}
template<class T>void print(T x){
if(x<0)putchar('-'),x=-x;
if(x>=10)print(x/10);
putchar(x%10+'0');
}
template<class T>void print(T x,char let){print(x),putchar(let);}

const int N=200005;
const int mod=1e9+7;

inline void uad(int &x,int y){
if((x+=y)>=mod)x-=mod;    
}

struct Info{
int a,b;
friend bool operator < (const Info&a,const Info&b){
if(a.a!=b.a)return a.a<b.a;
else return a.b>b.b;
}
}item[N];
int n,m,a[N],b[N],tmp[N],len;

struct fen{
int c[N];
void add(int x,int dlt){
while(x<=len)uad(c[x],dlt),x+=x&-x;
}
int qry(int x){
int ret=0;
while(x)uad(ret,c[x]),x^=x&-x;
return ret;
}
}tr;

int f[N];

int main(){
n=read(),m=read();
rep(i,1,n)a[i]=read();rep(i,1,m)b[i]=read();
int _n=0;
rep(i,1,n)if(a[i]>b[1]&&a[i]<b[m])a[++_n]=a[i];
n=_n;
rep(i,1,n){
int t=lower_bound(b+1,b+m+1,a[i])-b;
item[i].b=b[t]-a[i];
item[i].a=a[i]-b[t-1];
tmp[++len]=item[i].b;
}


tmp[++len]=0;
sort(item+1,item+n+1),sort(tmp+1,tmp+len+1),len=unique(tmp+1,tmp+len+1)-tmp-1;
/*  
rep(i,1,n){
printf("item[%d] = (%2d,%2d)\n",i,item[i].a,item[i].b);
}
*/
int ans=1;
tr.add(1,1);
rep(i,1,n){
if(item[i].a==item[i-1].a&&item[i].b==item[i-1].b)continue;
int real_b=lower_bound(tmp+1,tmp+len+1,item[i].b)-tmp;
f[i]=tr.qry(real_b-1);
//        printf("f[%d]=%d\n",i,f[i]);
tr.add(real_b,f[i]);
uad(ans,f[i]);
}
print(ans,'\n');
return 0;
} 
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;

const int N=2e5+5;
int n,q,a,b,lst;
ll ans,minn;

struct Tree
{
ll sum1[N<<2],sum2[N<<2],tag[N<<2];

void Add(int k,ll val)
{
tag[k]+=val;
sum1[k]+=val;sum2[k]+=val;
}

void pushdown(int k)
{
Add(k<<1,tag[k]);Add(k<<1|1,tag[k]);
tag[k]=0;
}

void build(int k,int l,int r)
{
sum1[k]=1e17;sum2[k]=1e17;
if(l==r) return ;
int mid=(l+r)>>1;
build(k<<1,l,mid);build(k<<1|1,mid+1,r);
}

void update(int k,int l,int r,int x,ll val,int type)
{
if(l==r)
{
sum1[k]=val;sum2[k]=val+type*l;
return ;
}
if(tag[k]) pushdown(k);
int mid=(l+r)>>1;
if(x<=mid) update(k<<1,l,mid,x,val,type);
else update(k<<1|1,mid+1,r,x,val,type);
sum1[k]=min(sum1[k<<1],sum1[k<<1|1]);
sum2[k]=min(sum2[k<<1],sum2[k<<1|1]);
}

ll query1(int k,int l,int r,int x,int y)
{
if(x<=l&&r<=y) return sum1[k];
if(l>y||r<x) return 1e14;
if(tag[k]) pushdown(k);
int mid=(l+r)>>1;
return min(query1(k<<1,l,mid,x,y),query1(k<<1|1,mid+1,r,x,y));
}

ll query2(int k,int l,int r,int x,int y)
{
if(x<=l&&r<=y) return sum2[k];
if(l>y||r<x) return 1e14;
if(tag[k]) pushdown(k);
int mid=(l+r)>>1;
return min(query2(k<<1,l,mid,x,y),query2(k<<1|1,mid+1,r,x,y));
}

}t1,t2;

int main()
{
int x,dis;
scanf("%d%d%d%d",&n,&q,&a,&b);
t1.build(1,1,n);t2.build(1,1,n);
t1.update(1,1,n,b,0,-1);t2.update(1,1,n,b,0,1);
lst=a;
for(int i=1;i<=q;i++)
{
scanf("%d",&x);
dis=x>lst ? x-lst:lst-x;
//		printf("%lld %lld\n",t1.query2(1,1,n,1,x)+x,t2.query2(1,1,n,x,n)-x);
ans=min(t1.query1(1,1,n,1,n)+dis,minn=min(t1.query2(1,1,n,1,x)+x,t2.query2(1,1,n,x,n)-x));
t1.Add(1,dis);t2.Add(1,dis);
t1.update(1,1,n,lst,minn,-1);t2.update(1,1,n,lst,minn,1);
lst=x;
}
printf("%lld",ans);
return 0;
}
/*
8 3 1 8
3 5 1
*/
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll, ll>;
using tll = tuple<ll, ll, ll>;
#define rep(i,n) for (ll i=0; i<n; ++i)
#define all(c) begin(c),end(c)
#define PI acos(-1)
#define oo 2e18
constexpr const ll MOD = 998244353;
void cincout(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); }
template<typename T1, typename T2>
bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}
template<typename T1, typename T2>
bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}
ld dist(ld x1,ld x2,ld y1,ld y2){return (sqrtl((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));}
// https://atcoder.jp/contests/abc228/editorial/2932
// M^(K^N)%MODを求める場合、 K^N%(MOD-1)
ll modpow(ll a, ll n, ll mod){ a %= mod; if (a==0) return 0; if (n==0) return 1; if (n%2==1) return (a * modpow(a, n - 1, mod)) % mod; else { ll t = modpow(a, n / 2, mod) % mod;       return (t * t) % mod; }}
ll modinv(ll n, ll mod){ return modpow(n, mod-2, mod); }
// 逆元（modが素数以外）https://atcoder.jp/contests/abc186/tasks/abc186_e
ll modinv2(ll a, ll m) { // ret = inv(a) mod m
ll b=m, u=1, v=0; while (b){ ll t=a/b; a-=t*b; swap(a, b); u-=t*v; swap(u, v); } u%=m; if (u<0) u+=m; return u; }
// 座標圧縮
template<typename T>
ll comp(vector<T> &A){ map<T, ll> mp; for(auto p: A) mp[p] = 0; ll sz = 0; for(auto &p: mp) p.second = ++sz; for(auto &a: A) a = mp[a]; return sz; }
ll dx[] = {0, 1, 0, -1};
ll dy[] = {-1, 0, 1, 0};  
bool is_pop(ll hash, ll d){ return (hash>>d)&1; }
//priority_queue<ll, vector<ll>, greater<ll>> Q;

//    size_t = 18446744073709551615 (1.8*10^19)
// LLONG_MAX = 9223372036854775807 (9.2*10^18)
//   INT_MAX = 2147483647 (2.1*10^9)

/*
3
3 5 -1

12
*/

ll N;
ll A[100010];
int main(){
cincout();

ll N;
cin >> N;
rep(i, N) cin >> A[i+1];
ll sum = 0;
rep(i, N+1){
sum += abs(A[i] - A[i+1]);
}
rep(i, N){
ll pre = abs(A[i] - A[i+1]) + abs(A[i+1] - A[i+2]);
ll nx = abs(A[i] - A[i+2]);
cout << sum - pre + nx << endl;
}
}
// Problem: F - Many Fucks
// Contest: AtCoder - AtCoder Regular Contest 073
// URL: https://atcoder.jp/contests/arc073/tasks/arc073_d
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstring>
#include <cstdio>
#include <cctype>
#define int long long
using namespace std;

const int INF  = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 2e5 + 5;
int inline read(){
int x = 0, f = 0; char ch = getchar();
while(!isdigit(ch)) f ^= (ch == '-'), ch = getchar();
while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
return f ? -x : x;
}

int n, q, x[MAXN], a, b;
int f[MAXN];

struct segtree{
struct segtree_node{
int val, lz;
}segt[MAXN << 2];
#define ls (k << 1)
#define rs (k << 1 | 1)
void pushdown(int k) {
segt[ls].lz += segt[k].lz;
segt[ls].val += segt[k].lz;
segt[rs].lz += segt[k].lz;
segt[rs].val += segt[k].lz;
segt[k].lz = 0;
}
void pushup(int k) { segt[k].val = min(segt[ls].val, segt[rs].val); }
void build(int k, int l, int r){
segt[k].val = INF; segt[k].lz = 0;
if(l == r) return;
int mid = (l + r) >> 1;
build(ls, l, mid); build(rs, mid + 1, r);
pushup(k);
}
void add(int k, int l, int r, int x, int y, int v) { 
if(x <= l && r <= y) {
segt[k].val += v;
segt[k].lz  += v;
return;
}
if(r < x || y < l) return;
int mid = (l + r) >> 1;
pushdown(k);
add(ls, l, mid, x, y, v);
add(rs, mid + 1, r, x, y, v);
pushup(k);
}
void setmin(int k, int l, int r, int pos, int v) {
if(l == r) { segt[k].val = min(segt[k].val, v); segt[k].lz = 0; return; }
int mid = (l + r) >> 1; pushdown(k);
if(pos <= mid) setmin(ls, l, mid, pos, v);
else setmin(rs, mid + 1, r, pos, v);
pushup(k);
}
int query(int k, int l, int r, int x, int y) {
if(x <= l && r <= y) return segt[k].val;
if(r <  x || y <  l) return INF;
int mid = (l + r) >> 1;	pushdown(k);
return min(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));
}
}A, B;	

int solve(int a, int b) {
memset(f, 0x3f, sizeof(f)); f[b] = abs(a - x[1]);
A.build(1, 1, n); B.build(1, 1, n);
A.setmin(1, 1, n, b, abs(a - x[1]) - b);
B.setmin(1, 1, n, b, abs(a - x[1]) + b);
f[b] = f[0]; f[1] = abs(a - x[1]);
for(int i = 2; i <= q; ++i) {
int ret = INF;
ret = min(ret, A.query(1, 1, n, 1, x[i]) + x[i]);
ret = min(ret, B.query(1, 1, n, x[i], n) - x[i]);
A.add(1, 1, n, 1, n, abs(x[i] - x[i - 1]));
B.add(1, 1, n, 1, n, abs(x[i - 1] - x[i]));
A.setmin(1, 1, n, x[i - 1], ret - x[i - 1]);
B.setmin(1, 1, n, x[i - 1], ret + x[i - 1]);
ret = min(ret, f[i - 1] + abs(x[i] - x[i - 1]));
f[i] = ret;
// fprintf(stderr, "%lld \n", ret);
}
return f[q];
}

signed main(){
n = read(); q = read(); a = read(); b = read();
for(int i = 1; i <= q; ++i) x[i] = read();
printf("%lld\n", min(solve(a, b), solve(b, a)));
}
// Sky's the limit :)
#include <bits/stdc++.h>
using namespace std;
#define int long long

/*

*/

const int N = 3e5 + 9;

struct DSU {
vector<int> par, rnk, sz;
int c;
DSU(int n) : par(n + 1), rnk(n + 1, 0), sz(n + 1, 1), c(n) {
for (int i = 1; i <= n; ++i) par[i] = i;
}
int find(int i) {
return (par[i] == i ? i : (par[i] = find(par[i])));
}
bool same(int i, int j) {
return find(i) == find(j);
}
int get_size(int i) {
return sz[find(i)];
}
int count() {
return c;    //connected components
}
int merge(int i, int j) {
if ((i = find(i)) == (j = find(j))) return -1;
else --c;
if (rnk[i] > rnk[j]) swap(i, j);
par[i] = j;
sz[j] += sz[i];
if (rnk[i] == rnk[j]) rnk[j]++;
return j;
}
};

void run_case() {
int n;
cin >> n;
vector<pair<int, int>> x(n), y(n);
for (int i = 0; i < n; i++) {
cin >> x[i].first >> y[i].first;
x[i].second = y[i].second = i;
}

sort(x.begin(), x.end());
sort(y.begin(), y.end());

vector<array<int, 3>> edges;
for (int i = 0; i < n - 1; i++) {
edges.push_back({x[i + 1].first - x[i].first, x[i].second, x[i + 1].second});
edges.push_back({y[i + 1].first - y[i].first, y[i].second, y[i + 1].second});
}
sort(edges.begin(), edges.end());

int res = 0;
DSU d(n);
for (auto e : edges) {
int u = e[1], v = e[2], w = e[0];
if (!d.same(u, v)) {
res += w;
d.merge(u, v);
}
}
cout << res << '\n';
}

signed main() {
ios_base::sync_with_stdio(false); cin.tie(nullptr);

int T = 1;
// cin >> T;
for (int t = 1; t <= T; t++) {
// cout << "Case #" << t << ": ";
run_case();
}

return 0;
}
#include <bits/stdc++.h>

using namespace std;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
int n;
cin >> n;
int x[n];
for (int i = 0; i < n; i++) {
cin >> x[i];
}
int L, q;
cin >> L >> q;

vector<vector<int>> RIGHT(n, vector<int>(21, -1));

for (int i = 0; i < n; i++) {
int l = i + 1, r = n - 1;
while (l < r) {
int m = (l + r + 1) >> 1;
if (x[i] + L >= x[m])
l = m;
else
r = m - 1;	
}
if (l < n) RIGHT[i][0] = l;
}

for (int j = 1; j <= 20; j++) {
for (int i = 0; i < n; i++) {
if (RIGHT[i][j-1] != -1)
RIGHT[i][j] = RIGHT[RIGHT[i][j-1]][j-1];
}
}
// for (int i = 0; i < n; i++) {
// 	for (int j = 0; j <= 20; j++) {
// 		cout << RIGHT[i][j] << ' ';
// 	}
// 	cout << '\n';
// }

while (q --) {
int x, y;
cin >> x >> y;
x--; y--;
if (x > y) swap(x, y);
int ans = 0;
for (int k = 20; k >= 0; k--) {
if (RIGHT[x][k] == -1) continue;
if (RIGHT[x][k] >= y) continue;
x = RIGHT[x][k];
ans += (1 << k);
}
cout << 1 + ans << '\n';
}
return 0;
}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<long long> VL;
typedef vector<vector<long long>> VVL;
typedef pair<int,int> Pair;
typedef tuple<int,int,int> tpl;

#define ALL(a)  (a).begin(),(a).end()
#define SORT(c) sort((c).begin(),(c).end())
#define REVERSE(c) reverse((c).begin(),(c).end())
#define EXIST(m,v) (m).find((v)) != (m).end()
#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()
#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)
#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)
#define RREP(i,n) RFOR(i,n,0)

#define en "\n"

constexpr double EPS = 1e-9;
constexpr double PI  = 3.1415926535897932;
constexpr int INF = 2147483647;
constexpr long long LINF = 1LL<<60;
constexpr long long MOD =  998244353; // 1000000007;

template<class T> inline bool chmax(T& a, T b){if(a<b){a=b;return true;}return false;}
template<class T> inline bool chmin(T& a, T b){if(a>b){a=b;return true;}return false;}

#include<atcoder/modint>
using mint = atcoder::modint1000000007;

void Main(){
int n; cin >> n;
mint n2 = mint(n-1)*(n-1);
vector<mint> dp(n+2); dp[0] = 1;
REP(i,n-1){
dp[i+1] += dp[i];
dp[i+2] -= dp[i];
if(i+3 < n){
dp[i+3] += dp[i];
dp[n] -= dp[i];
}
int mn = max(1,n-i-2), mx = n;
dp[n] += dp[i] * (mx-mn);
dp[n+1] -= dp[i] * (mx-mn);
dp[i+2] += dp[i+1];
}
dp[n] += dp[n-1];
dp[n+1] -= dp[n-1];
dp[n+1] += dp[n];

mint ans;
REP(i,n-1) ans += dp[i] * n2;
ans += dp[n-1] * (n-1);
ans += dp[n];
cout << ans.val() << en;
return;
}

int main(void){
cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);
int t=1; //cin>>t;
while(t--) Main();
return 0;
};
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<20>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod1000000007 = 1000000007;
const int mod998244353 = 998244353;

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
ll L;
cin >> L;
int n = 0;
ll x = 1;
while(x <= L) x*=2, ++n;

vector<tuple<int, int, ll>> ans;
rep(i, n-1) {
ans.emplace_back(n-i-1, n-i, 1ll<<i);
ans.emplace_back(n-i-1, n-i, 0);

if(L & 1<<i) {
ll cst = L;
cst >>= i+1;
cst <<= i+1;
ans.emplace_back(1, n-i, cst);
}
}
sort(ALL(ans));

cout << n << " " << SZ(ans) << endl;
for(auto x : ans) cout << get<0>(x) << " " << get<1>(x) << " " << get<2>(x) << endl;
}
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define INF 0x3f3f3f
using namespace std;
const int N=2e6+5;
int dis[6000],mp[6000][6000],vis[N],a[N];
void solve(){
int n,even=0,odd=0,fo=0;cin>>n;
for(int i=1;i<=n;i++)cin>>a[i];
for(int i=1;i<=n;i++){
if(a[i]%2==0){
even++;
if(a[i]%4==0){
fo++;
}
}
else odd++;
}
if(odd+fo==n){
if(n%2==1){
if(odd<=fo+1){
cout<<"Yes\n";
}
else cout<<"No\n";
}
else{
if(odd<=fo){
cout<<"Yes\n";
}
else cout<<"No\n";
}
}
else {
if(odd<=fo){
cout<<"Yes\n";
}
else cout<<"No\n";
}
}
signed main(){
solve();
return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
using ll  = long long;
using ull = unsigned long long;
template<class t>
using vec = vector<t>;
template<class t, size_t s>
using arr = array<t, s>;
template<class t>
using priority_queueRe = priority_queue<t, vec<t>, greater<t>>;
#define LL_INF (INT64_MAX >> 2)
#define F_ZERO (1e-5)
#define PI (3.1415926535897932)
#define PI2 (6.2831853071795864)
#define MOD_1 (1000000007)
#define MOD_2 (998244353)
#define is_zero(val) (abs(val)<F_ZERO)
#define deg_rad(d) (PI*(d)/180.0)
#define rad_deg(r) (180.0*(r)/PI)
#define div_upper(a,b) (((a)+(b)-1)/(b))
#define rep(i,t,n)     for(int i=(int)(t)  ;i< (int)(n);i++)
#define repR(i,t,n)    for(int i=(int)(n)-1;i>=(int)(t);i--)
#define rep2(i,t,n)    for(int i=(int)(t)  ;i<=(int)(n);i++)
#define rep2R(i,t,n)   for(int i=(int)(n)  ;i>=(int)(t);i--)
#define repP(i,t,n,p)  for(ll  i=(ll) (t)  ;i< (ll) (n);i+=(ll)(p))
#define rep2P(i,t,n,p) for(ll  i=(ll) (t)  ;i<=(ll) (n);i+=(ll)(p))
#define Vrep(e,v)      for(auto&e:(v))
#define Vrep2(i,b,e)   for(auto i=b;i!=e;i++)
#define PB push_back
#define PO pop_back
#define EB emplace_back
#define EP emplace
#define CL clear
#define EM empty
#define RS resize
#define SI size
#define FI first
#define SE second
#define Vres(i,v) fill((i).begin(),(i).end(),v)
#define Vcop(a,b) copy((b).begin(),(b).end(),(a).begin())
#define Vrev(v) reverse((v).begin(),(v).end())
#define Vsort(v) sort((v).begin(),(v).end())
#define VsortR(v) Vsort(v),Vrev(v)
#define Vlob(v,t) lower_bound((v).begin(),(v).end(),(t))
#define Vupb(v,t) upper_bound((v).begin(),(v).end(),(t))
#define Qget(i,q) auto i=q.top();q.pop()
template<class t>
struct FastMathTools
{
vec<t>fac;
t operator[](int n)const{return fac[n];}
FastMathTools(ll n){assert(1<=n);fac.RS(n+1);fac[0]=1;rep(a,1,n)fac[a]=fac[a-1]*a;}
ll gcd(ll a,ll b){if(a<b)return gcd(b,a);if(b==0)return a;return gcd(b,a%b);}
ll lcm(ll a,ll b){if(a<b)return lcm(b,a);return a/gcd(a,b)*b;}
t  pow(t  a,ll b){if(a==0)return 0;t r=1;while(b){if(b&1)r=(r*a);a=(a*a);b>>=1;}return r;}
t  con(ll a,ll b){if(fac.SI()<=a)return con2(a,b);if(b<0||a<b)return 0;return fac[a]/(fac[b]*fac[a-b]);}
vec<ll>divisor(ll x){vec<ll>r;set<ll>s;ll rt=sqrt(x);rep2(i,1,rt)if(x%i==0)s.EP(i),s.EP(x/i);Vrep(a,s)r.EB(a);return r;}
private:
t  con2(ll a,ll b){assert(b<=100000000LL);t r=1;rep(i,0,b)r*=a-i;if(b<fac.SI())r/=fac[b];else rep2(i,1,b)r/=i;return r;}
};
template<class t>
using FMT = FastMathTools<t>;
template<class t>
t Vsum(vec<t>&v){t r=0;Vrep(a,v)r+=a;return r;}
template<class t, size_t s>
t Vsum(arr<t, s>&v){t r=0;Vrep(a,v)r+=a;return r;}
template<class t>
void Vcin(vec<t>& v,ll n){v.RS(n);rep(a,0,n)cin>>v[a];}
template<class t>
void Vcin(vec<pair<t,t>>& v,ll n){v.RS(n);rep(a,0,n)cin>>v[a].FI>>v[a].SE;}
template<class t, size_t s>
void Vcin(arr<t, s>& v,ll n){assert(n<=(ll)s);rep(a,0,n)cin>>v[a];}
template<class t, size_t s>
void Vcin(arr<pair<t,t>,s>& v,ll n){assert(n<=(ll)s);rep(a,0,n)cin>>v[a].FI>>v[a].SE;}
template<class t, size_t s1, size_t s2>
void Vcin(arr<arr<t,s2>,s1>&v,ll n1,ll n2){assert(n1<=(ll)s1);assert(n2<=(ll)s2);rep(a,0,n1)rep(b,0,n2)cin>>v[a][b];}
template<class t>
void Vcin2(vec<t>& v,ll n){v.RS(n+1);rep2(a,1,n)cin>>v[a];}
template<class t, size_t s>
void Vcin2(arr<t,s>&v,ll n){assert(n<(ll)s);rep2(a,1,n)cin>>v[a];}
template<class t, size_t s1, size_t s2>
void Vcin2(arr<arr<t,s2>,s1>&v,ll n1,ll n2){assert(n1<(ll)s1);assert(n2<(ll)s2);rep2(a,1,n1)rep2(b,1,n2)cin>>v[a][b];}
template<class t, size_t s1, size_t s2>
void Vcout(arr<arr<t,s2>,s1>&v,ll n1,ll n2,string bt){assert(n1<=(ll)s1);assert(n2<=(ll)s2);rep(a,0,n1){rep(b,0,n2)cout<<v[a][b]<<bt;cout<<endl;}}
void cmin(ll&a,ll b){a=min(a,b);}
void cmax(ll&a,ll b){a=max(a,b);}
bool is_inside(ll x,ll y,ll lx,ll ly){if(0<=x&&x<lx&&0<=y&&y<ly)return true;return false;}
template<size_t s>
void get_prime(arr<bool,s>&v){assert(2<=s);ll r=sqrt(s);Vrep(a,v)a=true;v[0]=v[1]=false;rep2(p,2,r)if(v[p])rep2P(i,2*p,s,p)v[i]=false;}
pair<ll,ll>Vget(pair<ll,ll>p1,pair<ll,ll>p2){return{p2.first-p1.first,p2.second-p1.second};}
ll Vcross(pair<ll,ll>v1,pair<ll,ll>v2){return v1.first*v2.second-v1.second*v2.first;}
ll mat_mat(vec<vec<ll>>& m1, vec<vec<ll>>& m2, ll mod = LL_INF)
{
vec<vec<ll>>r(m1);
rep(i, 0, r.SI()) rep(j, 0, r.SI()) r[i][j] = 0;
rep(i, 0, m1.SI()) rep(j, 0, m1.SI()) rep(k, 0, m1.SI()) r[i][j] = (r[i][j] + m1[i][k] * m2[k][j]) % mod;
rep(i, 0, m1.SI()) rep(j, 0, m1.SI()) m1[i][j] = r[i][j];
return 0;
}
ll vec_mat(vec<vec<ll>>& m, vec<ll>& v, ll mod = LL_INF)
{
vec<ll> r(v); Vres(r, 0);
rep(i, 0, r.SI()) rep(j, 0, m[i].SI()) r[i] = (r[i] + v[j] * m[i][j]) % mod;
v = r;
return 0;
}
ll pow_mat(vec<vec<ll>>& m, ll n, ll mod = LL_INF)
{
vec<vec<ll>> a(m);
rep(i, 0, m.SI()) rep(j, 0, m.SI()) m[i][j] = (i == j ? 1 : 0);
while (n) {
if (n & 1) mat_mat(m, a, mod);
mat_mat(a, a, mod);
n >>= 1;
}
return 0;
}
const int dx[8]={1,0,-1,0,1,1,-1,-1};const int dy[8]={0,1,0,-1,1,-1,-1,1};
ll A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0, O = 0, P = 0, Q = 0, R = 0, S = 0, T = 0, U = 0, V = 0, W = 0, X = 0, Y = 0, Z = 0;
ull uA = 0, uB = 0, uC = 0, uD = 0, uE = 0, uF = 0, uG = 0, uH = 0, uI = 0, uJ = 0, uK = 0, uL = 0, uM = 0, uN = 0, uO = 0, uP = 0, uQ = 0, uR = 0, uS = 0, uT = 0, uU = 0, uV = 0, uW = 0, uX = 0, uY = 0, uZ = 0;
// 辺
struct Edge
{
Edge(int i, int f, int t, ll le = 1, ll ca = -1, ll co = -1, int re = -1, ll fl = 0) { index = i; from = f; to = t; len = le; cap = ca; cost = co; rev = re; flow = fl; }
int index, from, to, rev;
ll len, cap, cost, flow;
bool enabled = true;
bool operator< (const Edge& obj) const { return make_tuple(index, from, to, len, cap, cost, rev, flow) < make_tuple(obj.index, obj.from, obj.to, obj.len, obj.cap, obj.cost, obj.rev, obj.flow); }
};
// グラフ
struct Graph
{
vec<set<int>> Gr;
vec<Edge> Ed;
Edge&operator[](int n)     {return Ed[n];}
Edge operator[](int n)const{return Ed[n];}
Graph(void)=default;
Graph(ll n){reset(n);}
ll reset(ll n){Gr.CL();Gr.RS(n);Ed.CL();return 0;}
//辺操作
int AE    (int f,int t,ll le=1,ll ca=-1,ll co=-1){Gr[f].EP(Ed.SI());Ed.EB(Ed.SI(),f,t,le,ca,co          );return(int)Ed.SI()-1;}
int AE_len(int f,int t,ll le                    ){Gr[f].EP(Ed.SI());Ed.EB(Ed.SI(),f,t,le                );return(int)Ed.SI()-1;}
int AE_cc (int f,int t,        ll ca,   ll co   ){Gr[f].EP(Ed.SI());Ed.EB(Ed.SI(),f,t,1 ,ca,co          );return(int)Ed.SI()-1;}
int AE_re (int f,int t,ll le=1,ll ca=-1,ll co=-1){Gr[f].EP(Ed.SI());Ed.EB(Ed.SI(),f,t,le,ca,co,Ed.SI()+1);Gr[t].EP(Ed.SI());Ed.EB(Ed.SI(),t,f,le,ca,co,Ed.SI()-1);return(int)Ed.SI()-2;}
ll E_rev (int m){auto&e=Ed[m];Gr[e.from].erase(m);Gr[e.to].emplace(m);swap(e.from,e.to);return 0;}
bool is_enable(int m)const{return Ed[m].enabled;}
ll   disableE (int m)     {Ed[m].enabled=false;return m;}
ll   enableE  (int m)     {Ed[m].enabled=true; return m;}
//頂点操作
ll addV(int n){Gr.RS(Gr.SI()+n);return(ll)Gr.SI();}
ll disableV(int v){Vrep(e,Gr[v])disableE(e);return 0;}
//グラフ作成
ll grid (int h,int w){reset(h*w);rep(a,0,h)rep(b,0,w){if(is_inside(a,b+1,h,w))AE_re(w*a+b,w*a+(b+1));if(is_inside(a+1,b,h,w))AE_re(w*a+b,w*(a+1)+b);}return h*w;}
ll grid2(int h,int w){reset(h*w);rep(a,0,h)rep(b,0,w){if(is_inside(a,b+1,h,w))AE   (w*a+b,w*a+(b+1));if(is_inside(a+1,b,h,w))AE   (w*a+b,w*(a+1)+b);}return h*w;}
//グラフ計算
ll DSU(vec<vec<int>>&f)const{dsu ds((int)Gr.SI());Vrep(e,Ed)ds.merge(e.from,e.to);f=ds.groups();return(ll)f[0].SI();}
ll SCC(vec<vec<int>>&f)const{scc_graph gr((int)Gr.SI());Vrep(e,Ed)gr.add_edge(e.from,e.to);f=gr.scc();return(ll)f.SI();}
bool connected(int a,int b)const{dsu ds((int)Gr.SI());Vrep(e,Ed)if(is_enable(e.index))ds.merge(e.from,e.to);return ds.same(a,b);}
vec<ll>          distanceN          (int s          )        const{vec<ll>d(Gr.SI(),LL_INF);d[s]=0;priority_queueRe<pair<ll,ll>>pq;pq.EP(0,s);while(pq.SI()){Qget(v,pq);if(d[v.SE]<v.FI)continue;Vrep(e,Gr[v.SE])if(is_enable(Ed[e].index)&&d[Ed[e].to]>v.FI+Ed[e].len){d[Ed[e].to]=v.FI+Ed[e].len;pq.EP(v.FI+Ed[e].len,Ed[e].to);}}return d;}
vec<pair<ll,int>>distanceNpre       (int s          )        const{vec<pair<ll,int>>d(Gr.SI(),make_pair(LL_INF,-1));d[s]=make_pair(0,-1);priority_queueRe<pair<ll,ll>>pq;pq.EP(0,s);while(pq.SI()){Qget(v,pq);if(d[v.SE].FI<v.FI)continue;Vrep(e,Gr[v.SE])if(is_enable(Ed[e].index)&&d[Ed[e].to].FI>v.FI+Ed[e].len){d[Ed[e].to].FI=v.FI+Ed[e].len;d[Ed[e].to].SE=e;pq.EP(v.FI+Ed[e].len,Ed[e].to);}}return d;}
bool             distance           (int s,vec<ll>&d)        const{d.CL();d.RS(Gr.SI(),LL_INF);d[s]=0;rep(n,0,d.SI())Vrep(e,Ed)if(is_enable(e.index)&&d[e.from]!=LL_INF)cmin(d[e.to],d[e.from]+e.len);Vrep(e,Ed)if(is_enable(e.index)&&d[e.to]>d[e.from]+e.len)return true;return false;}
ll               distanceN          (int s,int t)            const{auto d=distanceN(s);return d[t];}
ll               distance           (int s,int t)            const{vec<ll>d;distance(s,d);return d[t];}
vec<int>         path               (int s,int t)            const{auto d=distanceNpre(s);if(d[t].SE==-1)return vec<int>();vec<int>r;while(t!=s){r.EB(t);t=Ed[d[t].SE].from;}r.EB(s);Vrev(r);return r;}
ll               max_flow           (int s,int t,ll f=LL_INF)     {mf_graph <ll>   gr((int)Gr.SI());Vrep(e,Ed)gr.add_edge(e.from,e.to,e.cap       );auto r=gr.flow (s,t,f);int a=0;Vrep(e,Ed)e.flow=gr.get_edge(a++).flow;return r;}
pair<ll,ll>      min_cost_flow      (int s,int t,ll f=LL_INF)     {mcf_graph<ll,ll>gr((int)Gr.SI());Vrep(e,Ed)gr.add_edge(e.from,e.to,e.cap,e.cost);auto r=gr.flow (s,t,f);int a=0;Vrep(e,Ed)e.flow=gr.get_edge(a++).flow;return r;}
vec<pair<ll,ll>> min_cost_flow_slope(int s,int t,ll f=LL_INF)     {mcf_graph<ll,ll>gr((int)Gr.SI());Vrep(e,Ed)gr.add_edge(e.from,e.to,e.cap,e.cost);auto r=gr.slope(s,t,f);int a=0;Vrep(e,Ed)e.flow=gr.get_edge(a++).flow;return r;}
ll               min_spanning       (void)                   const{dsu uf((int)Gr.SI());ll r=0;priority_queueRe<pair<ll,ll>>pq;Vrep(e,Ed)pq.EP(e.cap,e.index);while(!pq.EM()){Qget(e,pq);if(!uf.same(Ed[e.SE].from,Ed[e.SE].to)){uf.merge(Ed[e.SE].from,Ed[e.SE].to);r+=Ed[e.SE].cap;}}if((ll)uf.SI(0)!=(ll)Gr.SI())return-1;return r;}
};
// BinaryIndexed木
struct BIT
{
vec<ll>tree;
ll size;
BIT(ll s,ll i=0){reset(s,i);}
ll reset(ll s,ll i=0){size=s+1;tree.RS(s+2,i);return 0;}
ll add(ll i,ll v){i++;while(i<=size){tree[i]+=v;i+=(i&-i);}return v;}
ll sum(ll i){i++;ll r=0;while(i){r+=tree[i];i-=(i&-i);}return r;}
ll sum(ll l,ll r){return sum(r-1)-sum(l-1);}
ll all(void){return sum(size-2);}
};
// 最長増加部分列
struct LIS
{
vec<ll>dp;
ll add(ll a){auto i=Vlob(dp,a);if(i==dp.end())dp.EB(a);else*i=a;return dp.SI();}
};
// 二次元累積和&区間和
struct Sum2D
{
vec<vec<ll>> date;
Sum2D(void)=default;
Sum2D(ll w,ll h){reset(w,h);}
ll reset(ll w,ll h){date.RS(w+1,vec<ll>(h+1,0));return 0;}
ll&at(ll w,ll h){return date[w+1][h+1];}
ll cal(void){ll w=date.SI();ll h=date.front().SI();rep(y,0,h)rep(x,1,w)date[x][y]+=date[x-1][y];rep(y,1,h)rep(x,0,w)date[x][y]+=date[x][y-1];return date.back().back();}
ll sum(ll x1,ll y1,ll x2,ll y2){return date[x2][y2]-date[x1][y2]-date[x2][y1]+date[x1][y1];}
};
// 直線の集合の最大値 傾き,代入値が単調増加限定
struct LinesMax
{
deque<pair<ll,ll>>dq;
void add_line(ll a,ll b){dq.EB(a,b);while(true){if(dq.SI()<=2)return;array<pair<ll,ll>,3>lines;auto q=dq.rbegin();rep(i,0,3)lines[i]=*q++;if((lines[1].second-lines[0].second)*(lines[1].first-lines[2].first)>(lines[2].second-lines[1].second)*(lines[0].first-lines[1].first))break;auto tem=dq.back();dq.pop_back();dq.pop_back();dq.EB(tem);}return;}
ll lines_max(ll x){if(dq.SI()==0)return LL_INF;while(true){if(dq.SI()==1)return dq.front().first*x+dq.front().second;array<pair<ll,ll>,2>lines;auto q=dq.begin();rep(i,0,2)lines[i]=*q++;if(lines[0].first*x+lines[0].second>lines[1].first*x+lines[1].second)return lines[0].first*x+lines[0].second;dq.pop_front();}return LL_INF;}
};
// 多項式
struct Poly
{
using mint=modint998244353;
vec<mint>date;
Poly(void)=default;
Poly(ll n){date.RS(n);}
Poly(vec<ll>&vec){Vrep(i,vec)this->date.EB(i);}
Poly(vec<mint>&vec){date=vec;}
Poly operator*(const Poly&obj)const{Poly r;r.date=convolution(this->date,obj.date);return r;}
Poly operator*(const ll obj)const{Poly r(*this);Vrep(x,r.date)x*=obj;return r;}
Poly operator/(const Poly&obj)const{ll s=this->size()-obj.size()+1;if(s<=0)return Poly();Poly r=(*this).rev()*obj.rev().inv(s);r.resize(s);return r.rev();}
Poly operator+(const Poly&obj)const{Poly r(*this);r.resize(max(r.size(),obj.size()));rep(i,0,obj.size())r[i]+=obj[i];return r;}
Poly operator-(const Poly&obj)const{Poly r(*this);r.resize(max(r.size(),obj.size()));rep(i,0,obj.size())r[i]-=obj[i];return r;}
mint&operator[](int n){return date[n];}
ll operator[](int n)const{return date[n].val();}
void resize(ll n){date.RS(n);}
ll size(void)const{return date.SI();}
Poly inv(ll n)const{Poly g(1);ll s=1;g[0]=this->date[0].inv();while(g.size()<n){s*=2;g=g*2-g*g*(*this);g.resize(s);}g.resize(n);return g;}
Poly rev(void)const{Poly r(*this);Vrev(r.date);return r;}
ll shrink(void){while(date.SI()&&date.back()==0)date.pop_back();return date.SI();}
Poly Yflip(){Poly r(this->date);rep(i,0,r.SI())if(i%2==1)r[i]*=-1;return r;}
};
// p(x)/q(x)のx^nの係数
ll mori(ll n,Poly& p,Poly& q){if(n==0)return p[0].val();Poly u=p*q.Yflip(),v=q*q.Yflip();rep(i,0,(v.size()+1)/2)v[i]=v[2*i];v.resize((v.size()+1)/2);rep(i,0,u.size()/2)u[i]=u[2*i+(n%2)];u.resize((u.size()+1-(n%2))/2);return mori(n/2,u,v);}
// n項目の値 k+1項間漸化式 初期状態d:a0～ak 漸化式c:an = c0*an-1 + c1*an-2 + ... + ck-1*an-k
ll zenka(ll n,vec<ll> d,vec<ll>c){vec<ll>qv(c.size()+1);qv[0]=1;rep(i,0,c.size())qv[i+1]=-c[i];Poly p(d),q(qv);p=q*p;p.resize(c.size());return mori(n,p,q);}
// n項目までの値 k+1項間漸化式 初期状態d:a0 = 1,a1～ak 漸化式c:an = c0*an-1 + c1*an-2 + ... + ck-1*an-k
vec<ll>zenka_all(ll n,vec<ll> d,vec<ll>c){vec<ll>rv,qv(c.size()+1);qv[0]=1;rep(i,0,c.size())qv[i+1]=-c[i];Poly p(d),q(qv),r;p=q*p;p.resize(c.size());p.resize(n+2);p=p.rev();q=q.rev();r=(p/q).rev();Vrep(i,r.date)rv.EB(i.val());return rv;}
// 転倒数
ll inversion_num(vec<ll> v, ll max)
{
BIT bit(max + 1);
ll r = 0;
Vrev(v);
Vrep(i, v){bit.add(i, 1);r+=bit.sum(i - 1);}
return r;
}
typedef struct UFTree
{
vec<ll> par;
UFTree(ll n){reset(n);}
ll reset(ll n){par.RS(n);rep(i,0,n)par[i]=i;return 0;}
ll leader(ll x){return par[x]=(par[x]==x?x:leader(par[x]));}
ll same(ll x,ll y){return (leader(x)==leader(y)?1:0);}
ll merge(ll x,ll y){ll xl=leader(x),yl=leader(y);if(xl==yl)return 0;par[xl]=yl;return 1;}
} UFT;
typedef struct UndoUFTree
{
vec<ll> par, size;
vec<pair<ll, ll>> history;
ll now = 0;
UndoUFTree(ll n){reset(n);}
ll reset(ll n){size.RS(n,1);par.RS(n);rep(i,0,n)par[i]=i;return 0;}
ll leader(ll x){return(par[x]==x?x:leader(par[x]));}
ll same(ll x,ll y){return (leader(x)==leader(y)?1:0);}
ll merge(ll x,ll y){ll xl=leader(x),yl=leader(y);if(xl==yl)return now;if(size[xl]>size[yl])swap(xl,yl);par[xl]=yl;ll s=0;if(size[xl]==size[yl])s=1;history.EB(xl,s);size[yl]+=s;return++now;}
ll undo(ll t){while(t<now){auto b=history.back();size[par[b.FI]]-=b.SE;par[b.FI]=b.FI;history.pop_back();now--;}return now;}
} UUFT;

using mint1 = modint1000000007;
using mint2 = modint998244353;
FMT<mint1> mt(1000005);
string s, t;



vec<ll>dat;
set<ll>tem;
ll ans = 0;

int solve(void)
{
cin >> N;
Vcin(dat, N);
Vsort(dat);
Vrep(a, dat)tem.EP(a);
if (tem.size() % 2) {
cout << tem.size();
}
else {
cout << tem.size() - 1;
}
return 0;
}


int main(void)
{
ios_base::sync_with_stdio(false);
rep(i, 0, 1) solve();
return 0;
}
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define f first
#define s second
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()

const int inf = 1e9;
const ll infll = 1e18;
const int M = 1000000007;
const int N = 1e6;

int nimber(int x, int k){
while(x % k){
// cout << x << endl;
int d = x / k + 1, r = x % k;
int times = (r + d - 1)/d;
x -= d * times;
}
// cout << x << endl;
return x / k;
}
int main(){
int n;
scanf("%d", &n);
int ans = 0;
for(int i = 0,x,k; i < n; ++i){
scanf("%d%d", &x, &k);
ans ^= nimber(x, k);
} 

puts(ans == 0? "Aoki" : "Takahashi");
}	
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
int n, m; cin>>n>>m;
int sum = 0, ans, xsum = 0, ysum = 0;
for(int i=0; i<n; i++){
int x; cin>>x;
xsum = (xsum + ((i*x%MOD+MOD)%MOD - sum + MOD)%MOD)%MOD;
sum = ((sum + x)%MOD + MOD)%MOD;
}
sum = 0;
for(int i=0; i<m; i++){
int y; cin>>y;
ysum = (ysum + ((i*y%MOD+MOD)%MOD - sum + MOD)%MOD)%MOD;
sum = ((sum + y)%MOD + MOD)%MOD;
}
ans = xsum*ysum%MOD;
cout<<ans<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e5 + 10;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f3f3f3f3f;
int n,T=1,m,k;
int a[N];
int fnc[1000010];
void init(){
fnc[0] = 1;
for(int i = 1; i < 1000000; i++){
fnc[i] = fnc[i - 1]*i%mod;
}
}
int qpow(int x,int y){
int ans = 1;
for(;y;y/=2,x=x*x%mod){
if(y&1)ans=ans*x%mod;
}
return ans;
}
int C(int x,int y){
return fnc[y]*qpow(fnc[x],mod - 2)%mod*qpow(fnc[y - x],mod - 2)%mod;
}
signed main(){
//	scanf("%lld",&T);
init();
while(T--){
scanf("%lld%lld%lld",&n,&m,&k);
int sum = 0;
//		for(int i = 0; i <= m; i++)
//		{
//			for(int j = 0; j <= k; j++)
//			{
//				sum += C(n - 1,n + i + j - 1)*C(i,i + j)%mod*qpow(3,m + k - i - j)%mod;
//				sum %= mod;
//			}
//		}
if(m > k)swap(m,k);
int cnt = qpow(2,m);
int kk = 1;
for(int i = 0; i <= m; i++){
sum += C(n - 1,n + i - 1)*qpow(2,i)%mod*qpow(3,m + k - i)%mod;
sum %= mod;
}
//printf("%lld\n",sum);
for(int i = m + 1; i <= k; i++){
cnt = (cnt * 2 % mod + mod - kk)%mod;
kk = kk * i%mod * qpow(i - m,mod - 2)%mod;
//printf("%lld\n",cnt);
sum += C(n - 1,n + i - 1)*cnt%mod*qpow(3,m + k - i)%mod;
sum %= mod;
}
//printf("%lld\n",sum);
int cnt2 = qpow(2,k);
int kkk = 1;
for(int i = k + 1; i <= m + k; i++){
cnt = (cnt * 2 % mod + mod - kk)%mod;
kk = kk * i%mod * qpow(i - m,mod - 2)%mod;
cnt2 = (cnt2 * 2 % mod + mod - kkk)%mod;
kkk = kkk * i%mod * qpow(i - k,mod - 2)%mod;
int p =(mod + (cnt - (qpow(2,i) - cnt2) + mod)%mod)%mod;
//printf("%lld\n",cnt);
sum += C(n - 1,n + i - 1)*p%mod*qpow(3,m + k - i)%mod;
sum %= mod;
}
printf("%lld\n",sum);
}
}	
#include<bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
long long ans,n;

long long kasumi(long long a,long long b)
{
long long ans=1;
while(b)
{
if(b&1) ans=ans*a%mod;
a=a*a%mod;
b>>=1;
}
return ans;
}

int main()
{
scanf("%lld",&n);
long long l=1,r=1,t=1,len1=1,p=10,len2=1,q=10;
do
{
while(t<n)
{
++r;
if(r==p) p*=10,++len1;
t+=len1;
}
if(t==n) ++ans;
++l;
t-=len2;
if(l==q) q*=10,++len2;
}while(l<10000000);
for(long long l=1,r;l<=n-1;l=r+1)
{
r=(n-1)/((n-1)/l);
ans=(ans+(r-l+1)*((n-1)/l))%mod;
}
for(long long l=1,r;l<=n;l=r+1)
{
r=n/(n/l);
ans=(ans-(r-l+1)*(n/l)%mod+mod)%mod;
}
for(int i=1;i<=7;i++) ans=(ans-(n-1)/i+n/i)%mod;
ans=(ans+n/8)%mod;
for(long long i=1;i*i<=n;++i)
{
if(n%i==0)
{
if(i>7) ans+=(9ll*kasumi(10,i-1)-n/i+1)%mod;
if(i*i!=n&&n/i>7) ans+=(9ll*kasumi(10,n/i-1)-i+1)%mod;
}
}
printf("%lld",(ans+mod)%mod);
}
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long 
#define ri int
#define pii pair<int,int>
const ll mod=998244353;
ll add(ll x,ll y){return (x+=y)<mod?x:x-mod;}
ll dec(ll x,ll y){return (x-=y)<0?x+mod:x;}
ll ksm(ll d,ll t,ll res=1){for(;t;t>>=1,d=d*d%mod) if(t&1) res=res*d%mod;return res;}
const int MAXN=2e3+7;
int f[2][MAXN],n;
int a[MAXN],b[MAXN],suma[MAXN][MAXN<<1],sumb[MAXN][MAXN<<1];
int main(){
scanf("%d",&n);
for(ri i=1;i<=n*2;++i){
char op[8];int w;
scanf("%s%d",op,&w);
if(op[0]=='W') a[w]=i;
else b[w]=i;
}
for(ri i=1;i<=n;++i) suma[i][a[i]]++,sumb[i][b[i]]++;
for(ri i=1;i<=n;++i) for(ri j=(n<<1);j;--j) suma[i][j]+=suma[i][j+1],sumb[i][j]+=sumb[i][j+1];
for(ri j=1;j<=(n<<1);++j) for(ri i=1;i<=n;++i) suma[i][j]+=suma[i-1][j],sumb[i][j]+=sumb[i-1][j];
memset(f,0x3f,sizeof(f));
int o=1;
f[0][0]=0;
for(ri i=0;i<=n;++i){
o^=1;if(i) memset(f[o],0x3f,sizeof(f[o]));
for(ri j=0;j<=n;++j){
if(i) f[o][j]=min(f[o][j],f[o^1][j]+suma[i-1][a[i]]+sumb[j][a[i]]);
if(j) f[o][j]=min(f[o][j],f[o][j-1]+suma[i][b[j]]+sumb[j-1][b[j]]);
}
// for(ri j=0;j<=n;++j) printf("%d ",f[o][j]);puts("");
}
printf("%d\n",f[o][n]);
}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 5000500;
ll n, l[N], r[N], p[N], t[N];
ll buc[N];
ll lowbit (ll x) {return x & (-x);}
ll que (ll x) {
ll ret = 0;
while (x) {
ret += t[x];
x -= lowbit (x);
}
return ret;
}
void add (ll x, ll v) {
while (x <= n) {
t[x] += v;
x += lowbit (x); 
}
}
int main () {
//	freopen ("myin.in", "r", stdin);
cin >> n;
for (ll i=1;i<=n;i++) {
cin >> l[i] >> r[i];
}
for (ll i=1;i<=n;i++) {
if (i == n || l[i] != l[i + 1]) {
if (p[i] && p[i] != l[i]) {
puts ("-1");
return 0;
}
p[i] = l[i];
}
if (i == 1 || r[i] != r[i - 1]) {
if (p[i] && p[i] != r[i]) {
puts ("-1");
return 0;
}
p[i] = r[i];
}
}
for (int i=1;i<=n;i++) {
if (! p[i]) continue ;
if (buc[p[i]]) {
puts ("-1");
return 0;
} else {
buc[p[i]] = 1;
}
}
for (ll i=1,ps=1;i<=n;i++) {
if (! p[i]) {
while (buc[ps]) ps ++;
buc[p[i] = ps] = 1;
}
}
//	for (int i=1;i<=n;i++) cout << p[i] << " "; puts ("");
for (ll i=n,t=N;i>=1;i--) {
t = min (t, p[i]);
if (t != l[i]) {
puts ("-1");
return 0;
}
}
for (ll i=1,t=0;i<=n;i++) {
t = max (t, p[i]);
if (t != r[i]) {
puts ("-1");
return 0;
}
}
ll Ans = 0;
for (ll i=1;i<=n;i++) {
Ans += i - que (p[i]) - 1;
add (p[i], 1);
}
cout << Ans << endl;
}
#include<cstdio>
#include<queue>
using namespace std;
int k,v[100005];
struct node{int x,y;}a;
deque<node> q;
int main(){
scanf("%d",&k);
q.push_back({1,1});
while(1){
a=q.front();
q.pop_front();
if(v[a.y]) continue;
v[a.y]=1;
if(!a.y){
printf("%d\n",a.x);
return 0;
}
q.push_front({a.x,a.y*10%k});
q.push_back({a.x+1,(a.y+1)%k});
}
return 0;
}
//Author:Fczhao
//Language:cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 7;
struct node{
int id, val;
bool operator < (const node &a) const {
return a.val < val;
}
};
vector<int> e[maxn]; 
int a[maxn];
bool vis[maxn];
priority_queue<node> Q;
signed main(){
#ifdef FCZHAO
freopen("1.in", "r", stdin);
freopen("1.out", "w", stdout);
#endif
ios::sync_with_stdio(false);
bool f = true;
int n; cin >> n;
for(int i = 1; i < n; i++) {
int u, v; cin >> u >> v;
e[u].push_back(v);
e[v].push_back(u);
}
int k; cin >> k;
for(int i = 0; i < k; i++) {
int v, p; cin >> v >> p;
a[v] = p;
vis[v] = true;
Q.push({v, p});
}
while(!Q.empty()) {
node tmp = Q.top();
int it = tmp.id; Q.pop();
for(int x : e[it]) {
if(!vis[x]) {
vis[x] = true;
Q.push({x, a[it] + 1});
a[x] = tmp.val + 1;
}
else { 
if(abs(a[x] - a[it]) != 1) f = false;
}
}
}
if(!f) cout << "No" << endl;
else {
cout << "Yes" << endl;
for(int i = 1; i <= n; i++) cout << a[i] << endl;
}
return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ld,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

ll n;
struct edge{ll to; ld cost;};
using Graph=vector<vector<edge>>;
ld INF=1e12;
Graph G;
ld dis[1005];

void dijkstra(ll s){
fill(dis,dis+n,INF);
priority_queue<pii,vector<pii>,greater<pii>> que;
dis[s]=0;
que.emplace(dis[s],s);

while(!que.empty()){
pii p=que.top(); que.pop();
ll v=p.second;
if(dis[v]<p.first) continue;
for(auto &e:G[v]){
if(dis[e.to]>dis[v]+e.cost){
dis[e.to]=dis[v]+e.cost;
que.emplace(dis[e.to],e.to);
}
}
}
}

int main(){
ll xs,ys,xt,yt;
cin>>xs>>ys>>xt>>yt>>n;
vi x(n+2),y(n+2),r(n+2);
x[0]=xs,y[0]=ys,r[0]=0;
x[1]=xt,y[1]=yt,r[1]=0;
rep(i,n){
cin>>x[i+2]>>y[i+2]>>r[i+2];
}
n+=2;
G.resize(n);
rep(i,n-1) rep(j,i+1,n){
ld dist=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
dist=max(dist-r[i]-r[j],(ld)0);
G[i].push_back({j,dist});
G[j].push_back({i,dist});
}
dijkstra(0);
cout<<fixed<<setprecision(12)<<dis[1]<<endl;
}
#include    <bits/stdc++.h>
#include    <stdio.h>
#include    <ext/pb_ds/assoc_container.hpp>// For pbds.Don't use tree as variable name.
#include    <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define pb          push_back
#define eb          emplace_back
#define mem(x,i)    memset(x,i,sizeof(x))
#define ff          first
#define ss          second
#define all(x)      x.begin(),x.end()
#define Q           int t; scanf("%d", &t); for(int q=1; q<=t; q++)

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;//%Lf
typedef pair<ll, ll> pi;

template <typename T>  using orderedSet = tree<T, null_type, less<T>,rb_tree_tag, tree_order_statistics_node_update>;
//order_of_key(k) - number of element strictly less than k.
//find_by_order(k) - k'th element in set.(0 indexed)(iterator)

/* Debug Tools */
#define error(args...) \
{ \
string _s = #args; replace(_s.begin(), _s.end(), ',', ' ');\
stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args);\
}
void err(istream_iterator<string> it) {}
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
cerr<< *it << " = " << a <<",\n"[++it==istream_iterator<string>()];
err(it, args...);
}

const int MOD = 1e9+7 ; //For big mod
template<typename T>inline T gcd(T a, T b){T c;while (b){c = b;b = a % b;a = c;}return a;} // better than __gcd
template<typename T>inline T lcm(T a, T b){return (a/gcd(a, b))*b;}
ll powmod(ll a,ll b){ll res=1;a%=MOD;if(b<0) return 0;for(; b; b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}

const int xx[] = {+1, -1, +0, +0};//, +1, +1, -1, -1};// exclude last four when side adjacent
const int yy[] = {+0, +0, +1, -1};//, +1, -1, +1, -1};
const int INF    = 0x3f3f3f3f;// useful for memset
const ll LL_INF  = 0x3f3f3f3f3f3f3f3f;
const double PI  = acos(-1.0);
const double eps = 1e-9;
const int mxn     = 1e5+5; //CHECK here for every problem
const int mod    = 1e9+7;

ll fac[mxn];

ll C(int n, int r){
ll up = fac[n];
ll down = (fac[n-r]*fac[r])%mod;
down = powmod(down, mod-2);
return (up*down)%mod;
}

int main()
{
fac[0] = 1;
for(ll i=1; i<mxn; i++){
fac[i] = (fac[i-1]*i)%mod;
}
int n;
cin >> n;
vector<int> pos(n+2, -1);
int l, r;
for(int i=0; i<=n; i++){
int x;
cin >> x;
if(pos[x] != -1){
l = pos[x];
r = n-i;
}
pos[x] = i;
}
// error(l+r)
for(int i=1; i<=n+1; i++){
ll ans = C(n+1, i);
if(l+r >= i-1){
ans = ((ans-C(l+r, i-1))%mod+mod+mod)%mod;
}
cout << ans << '\n';
}
}

#include<iostream>
#include<algorithm>
using namespace std;

int n;
#define maxn 200011
int a[maxn],b[maxn],na[maxn],nb[maxn];
int main()
{
scanf("%d",&n); for (int i=1;i<=n;i++) scanf("%d",&a[i]); for (int i=1;i<=n;i++) scanf("%d",&b[i]);
int ans=0;
for (int i=0;i<=28;i++)
{
for (int j=1;j<=n;j++) na[j]=a[j]&((1<<(i+1))-1),nb[j]=b[j]&((1<<(i+1))-1);
sort(nb+1,nb+1+n); int t1=1<<i,t2=2*t1,t3=3*t1,t4=4*t1;
int now=0;
for (int j=1;j<=n;j++)
{
now^=(lower_bound(nb+1,nb+1+n,t2-na[j])-lower_bound(nb+1,nb+1+n,t1-na[j]))&1;
now^=(lower_bound(nb+1,nb+1+n,t4-na[j])-lower_bound(nb+1,nb+1+n,t3-na[j]))&1;
}
ans|=now<<i;
}
printf("%d\n",ans);
return 0;
}
#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
#define yn(joken) cout<<((joken) ? "Yes" : "No")<<endl
#define YN(joken) cout<<((joken) ? "YES" : "NO")<<endl
using namespace std;
using ll = long long;
using vi = vector<int>;
using vl = vector<ll>;
using vs = vector<string>;
using vc = vector<char>;
using vd = vector<double>;
using vvi = vector<vector<int>>;
using vvl = vector<vector<ll>>;
const int INF = 1e9;
const ll LINF = 1e18;
template <class T>
bool chmax(T& a, const T& b) {
if (a < b) {
a = b;
return 1;
}
return 0;
}
template <class T>
bool chmin(T& a, const T& b) {
if (b < a) {
a = b;
return 1;
}
return 0;
}
template <class T>
vector<T> make_vec(size_t a) {
return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
is >> v[i];
}
return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
for (int i = 0; i < int(v.size()); i++) {
os << v[i];
if (i < int(v.size()) - 1) os << ' ';
}
return os;
}

int main(){
cin.tie(nullptr);
ios::sync_with_stdio(false);

ll K;
cin>>K;
vl V(50,K/50+49);
rep(i,K%50){
rep(j,50){
if(j==i) V[j]+=50;
else V[j]--;
}
}
cout<<50<<endl;
cout<<V<<endl;
}
#include<bits/stdc++.h>
using namespace std;
int p;
inline int qow(int a,int n){
int ans=1;
for(;n;n>>=1){
if(n&1) ans=(1ll*ans*a)%p;
a=(1ll*a*a)%p;
}
return ans;
}
inline int inverse(int a){
return qow(a,p-2);
}
int fac[1000];
int infac[1000];
int dp1[500][30][30]={};
int dp2[500][30][30]={};
int ans[500][30]={}; 
int kk[500];
int kkk[500][500];
int main(){
int n,k;
scanf("%d%d%d",&n,&k,&p);
fac[0]=1;
for(int i=1;i<=900;i++) fac[i]=(1ll*i*fac[i-1])%p;
for(int i=0;i<=900;i++) infac[i]=inverse(fac[i]);
for(int i=0;i<=n;i++) kk[i]=(1ll*infac[i]*infac[n-i])%p;
for(int i=0;i<=n;i++){
for(int j=0;j<=k;j++) kkk[i][j]=qow(kk[i],j);
}
for(int i=0;i<=k;i++) dp1[0][i][0]=(1ll*qow(infac[n],i)*infac[i])%p;
for(int i=1;i<=n;i++){
for(int j=0;j<=k;j++){
for(int u=0;u<=(i-1)*j;u++){
for(int v=0;v<=k-j;v++) dp1[u+i*v][j+v][i]=(dp1[u+i*v][j+v][i]+1ll*((1ll*infac[v]*dp1[u][j][i-1])%p)*kkk[i][v])%p;
}
}
}
for(int i=0;i<=k;i++) dp2[n*i][i][n]=(1ll*kkk[0][i]*infac[i])%p;
for(int i=n-1;i>=0;i--){
for(int j=0;j<=k;j++){
for(int u=(i+1)*j;u<=n*j;u++){
for(int v=0;v<=k-j;v++) dp2[u+i*v][j+v][i]=(dp2[u+i*v][j+v][i]+1ll*((1ll*infac[v]*dp2[u][j][i+1])%p)*kkk[i][v])%p;
}
}
}
for(int pos=1;pos<=n*k;pos++){
for(int val=1;val<=k;val++){
int anss=0;
for(int o=val;o<=k;o++){
anss=(anss+1ll*((1ll*dp2[n*k-pos][k-o][1]*infac[o])%p)*kkk[0][o])%p;
}
ans[pos][val]=(1ll*anss*n)%p;
}
}
for(int pos=1;pos<=n*k;pos++){
int qq=n*k-pos;
for(int j=1;j<=n-1;j++){
int anss=0;
for(int val=1;val<=k;val++){
for(int o=1;o<=k-(val-1);o++){
int uu=min((val-1)*(j-1),n*k-pos-j*o);
for(int y=0;y<=uu;y++)
anss=(anss+1ll*dp1[y][val-1][j-1]*((1ll*((1ll*infac[o]*dp2[qq-j*o-y][k-o-(val-1)][j+1])%p)*kkk[j][o])%p))%p;
} 
for(int i=0;i<val-1;i++){
int o=val-1-i;
int uu=min(i*(j-1),n*k-pos-j*o);
for(int y=0;y<=uu;y++){
int w=(1ll*dp1[y][i][j-1]*((1ll*((1ll*infac[o]*dp2[qq-j*o-y][k-o-i][j+1])%p)*kkk[j][o])%p))%p;
anss=anss-w;
if(anss<0) anss+=p;
}
}
ans[pos][val]=(ans[pos][val]+1ll*anss*(n-j))%p;
}
}
}
for(int pos=1;pos<=n*k;pos++){
for(int val=1;val<=k;val++){
ans[pos][val]=(1ll*((1ll*ans[pos][val]*fac[n*k-pos])%p)*fac[pos-1])%p;
printf("%lld ",(1ll*ans[pos][val]*fac[k])%p);
}
printf("\n");
} 
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, LOG = 301;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);
int n; cin >> n;
vector <int> a(n);
for (auto& x : a) cin >> x;

sort(a.begin(), a.end());
int ans = a[0];
for (int i = 0; i < n; ++i) {
if (abs(2 * a[i] - a[n - 1]) < abs(2 * ans - a[n - 1])) {
ans = a[i];
}
}
cout << a[n - 1] << ' ' << ans << '\n';
return 0;
}

// Problem: B - Shift and Reverse
// Contest: AtCoder - AtCoder Regular Contest 132
// URL: https://atcoder.jp/contests/arc132/tasks/arc132_b
// Memory Limit: 1024 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)


#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define mod 1000000009
#define rep(i,n) for (ll i = 0; i < n; i++)
#define  pb push_back
#define mp make_pair
#define f first
#define s second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()
#define ins insert
#define ysno(ok) if(ok){cout<<"YES"<<endl;}else{cout<<"NO"<<endl;}
#define testloop ll t;cin>>t;while(t--)
//
//extra_functions 
ll MOD = 1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
ll add(ll a,ll b){return ((a%MOD)+(b%MOD))%MOD;}
ll mul(ll a,ll b){return ((a%MOD)*(b%MOD))%MOD;}
ll sub(ll a,ll b){return ((a%MOD)-(b%MOD)+MOD)%MOD;}
ll binpow(ll x, ll y){ll z = 1;while(y){if(y & 1) z = mul(z, x);x = mul(x, x);y >>= 1;}return z;}
int dx[] = {1,0,-1,0,-1,1,1,-1,0,2,0,-2,1,-2,1,2,-1,-2,-1,2};
int dy[] = {0,1,0,-1,-1,1,-1,1,2,0,-2,0,-2,1,2,1,-2,-1,2,-1};
// 
// my code starts here
//--------------------------------------------

bool prblm(vector <int> a, int in){
int x = a.size()-in;
if(x < 3){return false;}
x += in;
int diff = a[in]-a[in+1];
//cout<<diff<<" "<<in<<endl;
for(int i = in+1; i <x-1; i+=1){

if(diff != (a[i]-a[i+1])){
//cout<<diff<<" "<<in<<" "<<(a[i]-a[i+1])<<endl;
return true;
}
}
return false;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(0);
int n;
cin>>n;
vector <int> a(n);
vector <int> b(n);
rep(i,n){cin>>a[i];}
b = a;
reverse(all(b));
int ans = INT_MAX;
if(prblm(a,0)){

int seek = 1;
//	int i = 0;
for(int i = 1; i < n; i+=1){
if(a[i] == 1 ){
if(!prblm(a,i)){

break;
}
else{
seek+=1;
}
}
else if(a[i] == n){
if(!prblm(a,i)){
seek+=1;
break;
}
else{
seek+=1;
}
}
else{
seek+=1;
}
}
//cout<<"NOl"<<" "<<seek<<endl;
ans = min(ans,seek);

}
else{
if(a[0] == n){
ans = min(ans,1);
}
else{
ans = 0;
}

}
if(prblm(b,0)){
//	cout<<"ok";
int seek = 2;
//	int i = 0;
for(int i = 1; i < n; i+=1){
if(b[i] == 1 ){
if(!prblm(b,i)){
break;
}
else{
seek+=1;
}
}
else if(b[i] == n){
if(!prblm(b,i)){
seek+=1;
break;
}
else{
seek+=1;
}
}
else{
seek+=1;
}
}
ans = min(ans,seek);
}
else{
if(a[0] == n){
ans = min(ans,2);
}
else{
ans = min(ans,1);
}
}

cout<<ans<<endl;


}
//
//my code ends here
//--------------------------------------------

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

#define ls (id << 1)
#define rs (id << 1 | 1)
#define mid (l + r >> 1)

def(N, int, 2e5 + 5)

int n, q, a, b;
int x[N];
ll ml[N << 2], mr[N << 2], lz[N << 2];

void pushup(int id) {
ml[id] = min(ml[ls], ml[rs]);
mr[id] = min(mr[ls], mr[rs]);
}

void pushdown(int id) {
if(lz[id]) {
ml[ls] += lz[id], mr[ls] += lz[id], lz[ls] += lz[id];
ml[rs] += lz[id], mr[rs] += lz[id], lz[rs] += lz[id];
lz[id] = 0;
}
}

void modify(int id, int l, int r, int x, ll v) {
if(l == r) {
To_min(ml[id], v - l);
To_min(mr[id], v + l);
return ;
}
pushdown(id);
if(mid >= x) modify(ls, l, mid, x, v);
else modify(rs, mid + 1, r, x, v);
pushup(id);
}

ll queryl(int id, int l, int r, int x, int y) {
if(x <= l && r <= y) return ml[id];
pushdown(id);
ll ret = 1e18;
if(mid >= x) To_min(ret, queryl(ls, l, mid, x, y));
if(mid < y) To_min(ret, queryl(rs, mid + 1, r, x, y));
return ret;
}

ll queryr(int id, int l, int r, int x, int y) {
if(x <= l && r <= y) return mr[id];
pushdown(id);
ll ret = 1e18;
if(mid >= x) To_min(ret, queryr(ls, l, mid, x, y));
if(mid < y) To_min(ret, queryr(rs, mid + 1, r, x, y));
return ret;
}

ll query(int id, int l, int r) {
if(l == r) return ml[id] + l;
pushdown(id);
return min(query(ls, l, mid), query(rs, mid + 1, r));
}

int main() {
qread(n, q, a, b);
rep(i, 1, q) qread(x[i]);
memset(ml, 0x3f, sizeof ml);
memset(mr, 0x3f, sizeof mr);
modify(1, 1, n, a, abs(b - x[1]));
modify(1, 1, n, b, abs(a - x[1]));
rep(i, 2, q) {
ll nw = min(queryl(1, 1, n, 1, x[i]) + x[i], queryr(1, 1, n, x[i], n) - x[i]);
ll np = abs(x[i] - x[i - 1]);
ml[1] += np, mr[1] += np, lz[1] += np;
modify(1, 1, n, x[i - 1], nw);
}
cout << query(1, 1, n) << endl;
return 0;
}
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
//---------------------------------------------------------------------------------------------------
/*---------------------------------------------------------------------------------------------------
∧＿∧  
∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!
（ ´_ゝ`）　/　 ⌒i     
／　　　＼　 　  |　|     
/　　 /￣￣￣￣/　　|  
＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  
＼/＿＿＿＿/　（u　⊃  
---------------------------------------------------------------------------------------------------*/



int N, A[101010];
int dp[101][10101];
//---------------------------------------------------------------------------------------------------
void _main() {
cin >> N;
rep(i, 0, N) cin >> A[i];

dp[0][0] = 1;
rep(i, 0, N) rep(j, 0, 10001) if(dp[i][j]) {
dp[i + 1][j] = 1;
dp[i + 1][j + A[i]] = 1;
}

int ans = 0;
rep(j, 0, 10001) if (j % 10 && dp[N][j]) ans = max(ans, j);
cout << ans << endl;
}
#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

int x, y; cin>>x>>y;
int res = 0;
while(x <= y){
x <<= 1;
res++;
}

cout<<res<<"\n";
}

#ifdef __LOCAL
#define _GLIBCXX_DEBUG

#endif
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using P = pair<int,int>;
using PIL = pair<int,ll>;
using PLI = pair<ll,int>;
using PLL = pair<ll,ll>;
#define all(x) (x).begin(),(x).end()
#define unique_delete(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
using mint = modint1000000007;

template<class T> bool chmin(T &a, T b) {if(a>b){a=b;return 1;}return 0;}
template<class T> bool chmax(T &a, T b) {if(a<b){a=b;return 1;}return 0;}
template<class T> void show_vec(T v) {for (int i=0;i<v.size();i++) cout<<v[i]<<" ";}
template<class T> void show_pair(T p) {cout<<p.first<<" "<<p.second<<endl;}
template<class T> bool judge_digit(T bit,T i) {return (((bit&(1LL<<i))!=0)?1:0);}
#define REP(i,n) for(int i=0;i<int(n);i++)
#define ROUNDUP(a,b) (((a)+(b)-1)/(b))
#define YESNO(T) cout<<(T?"YES":"NO")<<endl
#define yesno(T) cout<<(T?"yes":"no")<<endl
#define YesNo(T) cout<<(T?"Yes":"No")<<endl

const int INFint = 1 << 29;
const ll INF = 1LL << 60;
const ll MOD = 1000000007LL;
const double pi = 3.14159265358979;
const vector<int> h_idx4 = {-1, 0,0,1};
const vector<int> w_idx4 = { 0,-1,1,0};
const vector<int> h_idx8 = {-1,-1,-1, 0,0, 1,1,1};
const vector<int> w_idx8 = {-1, 0, 1,-1,1,-1,0,1};


int main(){
ios::sync_with_stdio(false);
cin.tie(0);
//cout << fixed << setprecision(15);//小数の桁数指定
//COMinit();//二項係数使うときにコメントアウトを外すこと。

ll N;
cin>>N;
vector<ll>A(N);
REP(i,N){cin>>A[i];}
REP(i,N){A[i]=A[i]-i-1;}
sort(all(A));
ll med;
if(N%2){
med=N/2;
}
else{med=N/2;}
ll median=A[med];
ll answer=0;
REP(i,N){
answer+=abs(A[i]-median);
}
cout<<answer<<endl;



}
#pragma GCC optimize ("O3")
#pragma GCC target ("avx")
//#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i = 0; i < (n); i++)
#define rep1(i, n) for(int i = 1; i <= (n); i++)
#define co(x) cout << (x) << "\n"
#define cosp(x) cout << (x) << " "
#define ce(x) cerr << (x) << "\n"
#define cesp(x) cerr << (x) << " "
#define pb push_back
#define mp make_pair
#define chmin(x, y) x = min(x, y)
#define chmax(x, y) x = max(x, y)
#define Would
#define you
#define please

const int cm = 1 << 17;
char cn[cm], * ci = cn + cm, ct;
inline char getcha() {
if (ci - cn == cm) { fread_unlocked(cn, 1, cm, stdin); ci = cn; }
return *ci++;
}
inline int getint() {
int A = 0;
if (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';
else while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';
return A;
}

const int dm = 1 << 20;
char dn[dm], * di = dn;
inline void putint(int X) {
if (X == 0) {
*di++ = '0';
*di++ = '\n';
return;
}
int keta = 0;
char C[10];
while (X) {
*(C + keta) = '0' + X % 10;
X /= 10;
keta++;
}
for (int i = keta - 1; i >= 0; i--)* di++ = (*(C + i));
*di++ = '\n';
}

int main() {
//cin.tie(0);
//ios::sync_with_stdio(false);


int X = getint(), K = getint();
int r[100002];
rep1(i, K) r[i] = getint();
r[0] = 0;
r[K + 1] = 2e9;

int L = 0;
int R = X;
int takasa = 0;
int katamuki = -1;
int *ri = r;

int Q = getint();
rep(i, Q) {
int t = getint(), a = getint();

while (t > *(ri + 1)) {
takasa += katamuki * (*(ri + 1) - *ri);
if (katamuki < 0) {
L -= min(0, takasa + L);
R -= min(0, takasa + R);
}
else {
L -= max(0, takasa + L - X);
R -= max(0, takasa + R - X);
}
ri++;
katamuki *= -1;
}
chmax(a, L);
chmin(a, R);
a += takasa + katamuki * (t - *ri);
chmax(a, 0);
chmin(a, X);
putint(a);
}
fwrite(dn, 1, di - dn, stdout);
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}









vector<int>dat;
int lowbit(int x){
return x&-x;
}
void add(int i,int c){
while(i<dat.size()){
dat[i]+=c;
i+= lowbit(i);
}
}
int sum(int i){
int res=0;
while(i){
res+=dat[i];
i-= lowbit(i);
}
return res;
}
using PII=pair<int,int>;
int main(){
int n,m;
cin>>n>>m;
dat=vector<int>(m+50);
vector<PII>sove(n);
for(int i=0;i<n;i++) cin>>sove[i].first>>sove[i].second;
sort(sove.begin(),sove.end(),[&](auto a,auto b)->bool {
return a.second-a.first<b.second-b.first;
});
int cnt=0,index=0;
for(int i=1;i<=m;i++){
while(index<n&&sove[index].second-sove[index].first+1<i){
cnt++;
add(sove[index].first,1),add(sove[index].second+1,-1);
index++;
}
int ans=n-cnt;
for(int j=0;j<=m;j+=i){
ans+=sum(j);
}
cout<<ans<<endl;
}
return 0;
}

#include <bits/stdc++.h>

using namespace std;

// long longの省略
typedef long long ll;

// rep(先頭にRで逆からループ、末尾にSで「1～n」となる)
#define rep(i, a, n) for(int i = a; i < n; i++)
#define reps(i, a, n) for(int i = a; i <= n; i++)
#define rrep(i, a, n) for(int i = n - 1; i >= a; i--)
#define rreps(i, a, n) for(int i = n; i >= a; i--)

// ソートなどに対象を入れる場合
#define all(x) (x).begin(),(x).end()

// ソートされた配列から重複を削除して詰めなおす
#define UNIQUE(x) x.erase( unique(x.begin(), x.end()), x.end() );

// bfs等で4方向調べるときの配列(上下左右の順番)
int d[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

// 余りを答えとして出す時の割る値(デフォルト値)
int MOD = 1e9 + 7;

// ユークリッド互除法
int __gcd(int a, int b){
int c;

while((c = a % b) != 0){
a = b;
b = c;
}

return b;
}

// 「number」の「n」ビット目が「1」であるか「0」か
// ビット目の数え方は配列の添え字と同じ
bool __bit(int number, int n){
if(number & (1 << n))
return true;

return false;
}

// aよりもbが大きいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmax(T &a, const T& b) {
if (a < b) {
a = b;  // aをbで更新
return true;
}

return false;
}
// aよりもbが小さいならばaをbで更新する
// (更新されたならばtrueを返す)
template <typename T>
bool chmin(T &a, const T& b) {
if (a > b) {
a = b;  // aをbで更新
return true;
}

return false;
}

// 累乗をmodで計算
ll mod_pow(ll a, ll n, ll mod) {
ll res = 1;
while (n > 0) {
if (n & 1) res = res * a % mod;
a = a * a % mod;
n >>= 1;
}
return res;
}

// nCrをmodで計算
// COMinit(取りうるnの最大値)を実行してから、COM(n, r)を使用すること)
vector<ll> fac, finv, inv;

void COMinit(int MAX) {
fac.resize(MAX); finv.resize(MAX); inv.resize(MAX);

fac[0] = fac[1] = 1;
finv[0] = finv[1] = 1;
inv[1] = 1;
for (int i = 2; i < MAX; i++){
fac[i] = fac[i - 1] * i % MOD;
inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
finv[i] = finv[i - 1] * inv[i] % MOD;
}
}

long long COM(int n, int k){
if (n < k) return 0;
if (n < 0 || k < 0) return 0;
return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
}

int main(){
ll x; cin >> x;


if(x % 11){
ll ans = (x / 11) * 2 + 1;

if(x % 11 > 6) ans++;

cout << ans << endl;

return 0;
}

cout << x / 11 * 2 << endl;

return 0;
}
#pragma GCC optimize ("O3")
#pragma GCC target ("avx")
//#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
#define rep(i, n) for(int i = 0; i < (n); i++)
#define rep1(i, n) for(int i = 1; i <= (n); i++)
#define co(x) cout << (x) << "\n"
#define cosp(x) cout << (x) << " "
#define ce(x) cerr << (x) << "\n"
#define cesp(x) cerr << (x) << " "
#define pb push_back
#define mp make_pair
#define chmin(x, y) x = min(x, y)
#define chmax(x, y) x = max(x, y)
#define Would
#define you
#define please

const int cm = 1 << 17;
char cn[cm], * ci = cn + cm, ct;
inline char getcha() {
if (ci - cn == cm) { fread_unlocked(cn, 1, cm, stdin); ci = cn; }
return *ci++;
}
inline int getint() {
int A = 0;
if (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';
else while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';
return A;
}

const int dm = 1 << 20;
char dn[dm], * di = dn;
inline void putint(int X) {
if (X == 0) {
*di++ = '0';
*di++ = '\n';
return;
}
int keta = 0;
char C[10];
while (X) {
*(C + keta) = '0' + X % 10;
X /= 10;
keta++;
}
for (int i = keta - 1; i >= 0; i--)* di++ = (*(C + i));
*di++ = '\n';
}

int main() {
//cin.tie(0);
//ios::sync_with_stdio(false);


int X = getint(), K = getint();
int r[100002];
rep1(i, K) r[i] = getint();
r[0] = 0;
r[K + 1] = 2e9;

int L = 0;
int R = X;
int takasa = 0;
int katamuki = -1;
int *ri = r;

int Q = getint();
rep(i, Q) {
int t = getint(), a = getint();

while (t > *(ri + 1)) {
takasa += katamuki * (*(ri + 1) - *ri);
if (katamuki < 0) {
L -= min(0, takasa + L);
R -= min(0, takasa + R);
}
else {
L -= max(0, takasa + L - X);
R -= max(0, takasa + R - X);
}
ri++;
katamuki *= -1;
}
chmax(a, L);
chmin(a, R);
a += takasa + katamuki * (t - *ri);
chmax(a, 0);
chmin(a, X);
putint(a);
}

fwrite(dn, 1, di - dn, stdout);

Would you please return 0;
}
#ifndef HIDDEN_IN_VISUAL_STUDIO // 折りたたみ用

// 警告の抑制
#define _CRT_SECURE_NO_WARNINGS

// ライブラリの読み込み
#include <bits/stdc++.h>
using namespace std;

// 型名の短縮
using ll = long long; // -2^63 ～ 2^63 = 9 * 10^18（int は -2^31 ～ 2^31 = 2 * 10^9）
using pii = pair<int, int>;	using pll = pair<ll, ll>;	using pil = pair<int, ll>;	using pli = pair<ll, int>;
using vi = vector<int>;		using vvi = vector<vi>;		using vvvi = vector<vvi>;
using vl = vector<ll>;		using vvl = vector<vl>;		using vvvl = vector<vvl>;
using vb = vector<bool>;	using vvb = vector<vb>;		using vvvb = vector<vvb>;
using vc = vector<char>;	using vvc = vector<vc>;		using vvvc = vector<vvc>;
using vd = vector<double>;	using vvd = vector<vd>;		using vvvd = vector<vvd>;
template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
using Graph = vvi;

// 定数の定義
const double PI = 3.14159265359;
const double DEG = PI / 180.; // θ [deg] = θ * DEG [rad]
const vi dx4 = { 1, 0, -1, 0 }; // 4 近傍（下，右，上，左）
const vi dy4 = { 0, 1, 0, -1 };
const vi dx8 = { 1, 1, 0, -1, -1, -1, 0, 1 }; // 8 近傍
const vi dy8 = { 0, 1, 1, 1, 0, -1, -1, -1 };
const int INF = 1001001001; const ll INFL = 2002002002002002002LL;
const double EPS = 1e-10; // 許容誤差に応じて調整

// 入出力高速化
struct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } fastIOtmp;

// 汎用マクロの定義
#define all(a) (a).begin(), (a).end()
#define sz(x) ((int)(x).size())
#define distance (int)distance
#define Yes(b) {cout << ((b) ? "Yes" : "No") << endl;}
#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 から n-1 まで昇順
#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s から t まで昇順
#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s から t まで降順
#define repe(v, a) for(const auto& v : (a)) // a の全要素（変更不可能）
#define repea(v, a) for(auto& v : (a)) // a の全要素（変更可能）
#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d ビット全探索（昇順）
#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a の順列全て（昇順）
#define repit(it, a) for(auto it = (a).begin(); it != (a).end(); ++it) // イテレータを回す（昇順）
#define repitr(it, a) for(auto it = (a).rbegin(); it != (a).rend(); ++it) // イテレータを回す（降順）
#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod
#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // 重複除去

// 汎用関数の定義
template <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }
template <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // 最大値を更新（更新されたら true を返す）
template <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // 最小値を更新（更新されたら true を返す）

// 演算子オーバーロード
template <class T, class U> inline istream& operator>> (istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template <class T, class U> inline ostream& operator<< (ostream& os, const pair<T, U>& p) { os << "(" << p.first << "," << p.second << ")"; return os; }
template <class T, class U, class V> inline istream& operator>> (istream& is, tuple<T, U, V>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t); return is; }
template <class T, class U, class V> inline ostream& operator<< (ostream& os, const tuple<T, U, V>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << ")"; return os; }
template <class T, class U, class V, class W> inline istream& operator>> (istream& is, tuple<T, U, V, W>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t); return is; }
template <class T, class U, class V, class W> inline ostream& operator<< (ostream& os, const tuple<T, U, V, W>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << "," << get<3>(t) << ")"; return os; }
template <class T> inline istream& operator>> (istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }
template <class T> inline ostream& operator<< (ostream& os, const vector<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const list<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T, greater<T>>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const unordered_set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const unordered_map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, stack<T> s) { while (!s.empty()) { os << s.top() << " "; s.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, queue<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, deque<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop_front(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue_rev<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline vector<T>& operator--(vector<T>& v) { rep(_i_, sz(v)) --v[_i_]; return v; }
template <class T> inline vector<T>& operator++(vector<T>& v) { rep(_i_, sz(v)) ++v[_i_]; return v; }

// 手元環境（Visual Studio）
#ifdef _MSC_VER
#define popcount (int)__popcnt // 全ビット中の 1 の個数
#define popcountll (int)__popcnt64
inline int lsb(unsigned int n) { unsigned long i; _BitScanForward(&i, n); return i; } // 最下位ビットの位置（0-indexed）
inline int lsbll(unsigned long long n) { unsigned long i; _BitScanForward64(&i, n); return i; }
inline int msb(unsigned int n) { unsigned long i; _BitScanReverse(&i, n); return i; } // 最上位ビットの位置（0-indexed）
inline int msbll(unsigned long long n) { unsigned long i; _BitScanReverse64(&i, n); return i; }
template <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
#define dump(x) cout << "\033[1;36m" << (x) << "\033[0m" << endl;
#define dumps(x) cout << "\033[1;36m" << (x) << "\033[0m ";
#define dumpel(a) { int _i_ = -1; cout << "\033[1;36m"; repe(x, a) {cout << ++_i_ << ": " << x << endl;} cout << "\033[0m"; }
#define input_from_file(f) ifstream isTMP(f); cin.rdbuf(isTMP.rdbuf());
#define output_to_file(f) ofstream osTMP(f); cout.rdbuf(osTMP.rdbuf());
// 提出用（gcc）
#else
#define popcount (int)__builtin_popcount
#define popcountll (int)__builtin_popcountll
#define lsb __builtin_ctz
#define lsbll __builtin_ctzll
#define msb(n) (31 - __builtin_clz(n))
#define msbll(n) (63 - __builtin_clzll(n))
#define gcd __gcd
#define dump(x)
#define dumps(x)
#define dumpel(v)
#define input_from_file(f)
#define output_to_file(f)
#endif

#endif // 折りたたみ用


//-----------------AtCoder 専用-----------------
#include <atcoder/all>
using namespace atcoder;

//using mint = modint1000000007;
using mint = modint998244353;
//using mint = modint; // mint::set_mod(m);

istream& operator>> (istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }
ostream& operator<< (ostream& os, const mint& x) { os << x.val(); return os; }
using vm = vector<mint>;	using vvm = vector<vm>;		using vvvm = vector<vvm>;

template <class S, S(*op)(S, S), S(*e)()>ostream& operator<<(ostream& os, segtree<S, op, e> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
template <class S, S(*op)(S, S), S(*e)(), class F, S(*mp)(F, S), F(*cp)(F, F), F(*id)()>ostream& operator<<(ostream& os, lazy_segtree<S, op, e, F, mp, cp, id> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
ostream& operator<<(ostream& os, dsu d) { repe(g, d.groups()) { repe(v, g) { os << v << " "; } os << endl; } return os; };
//----------------------------------------------


void uso() {
int n;
cin >> n;

vl a(n);
cin >> a;

vl acc(n + 1);
rep(i, n) acc[i + 1] = acc[i] + a[i];

mt19937 mt;
mt.seed((int)time(NULL));
uniform_int_distribution<> rnd(1, n - 1);

ll res = INFL;

rep(hoge, 800) {
vi j(3);
j[0] = rnd(mt);
do { j[1] = rnd(mt); } while (j[0] == j[1]);
do { j[2] = rnd(mt); } while (j[0] == j[2] || j[1] == j[2]);
sort(all(j));

ll p = acc[j[0]];
ll q = acc[j[1]] - acc[j[0]];
ll r = acc[j[2]] - acc[j[1]];
ll s = acc[n] - acc[j[2]];
ll dif = max({ p, q, r, s }) - min({ p, q, r, s });

while (true) {
bool change_flag = false;

if (j[0] > 1) {
ll np = p - a[j[0] - 1];
ll nq = q + a[j[0] - 1];
ll ndif = max({ np, nq, r, s }) - min({ np, nq, r, s });
if (dif > ndif) {
p = np;
q = nq;
dif = ndif;
j[0]--;
change_flag = true;
}
}

if (j[0] < j[1] - 1) {
ll np = p + a[j[0]];
ll nq = q - a[j[0]];
ll ndif = max({ np, nq, r, s }) - min({ np, nq, r, s });
if (dif > ndif) {
p = np;
q = nq;
dif = ndif;
j[0]++;
change_flag = true;
}
}

if (j[1] > j[0] + 1) {
ll nq = q - a[j[1] - 1];
ll nr = r + a[j[1] - 1];
ll ndif = max({ p, nq, nr, s }) - min({ p, nq, nr, s });
if (dif > ndif) {
q = nq;
r = nr;
dif = ndif;
j[1]--;
change_flag = true;
}
}

if (j[1] < j[2] - 1) {
ll nq = q + a[j[1]];
ll nr = r - a[j[1]];
ll ndif = max({ p, nq, nr, s }) - min({ p, nq, nr, s });
if (dif > ndif) {
q = nq;
r = nr;
dif = ndif;
j[1]++;
change_flag = true;
}
}

if (j[2] > j[1] + 1) {
ll nr = r - a[j[2] - 1];
ll ns = s + a[j[2] - 1];
ll ndif = max({ p, q, nr, ns }) - min({ p, q, nr, ns });
if (dif > ndif) {
r = nr;
s = ns;
dif = ndif;
j[2]--;
change_flag = true;
}
}

if (j[2] < n - 1) {
ll nr = r + a[j[2]];
ll ns = s - a[j[2]];
ll ndif = max({ p, q, nr, ns }) - min({ p, q, nr, ns });
if (dif > ndif) {
r = nr;
s = ns;
dif = ndif;
j[2]++;
change_flag = true;
}
}

if (!change_flag) break;
}

chmin(res, dif);
}

cout << res << endl;
}


int main() {
//	input_from_file("input.txt");
//	output_to_file("output.txt");

int n;
cin >> n;

vl a(n);
cin >> a;

vl acc(n + 1);
rep(i, n) acc[i + 1] = acc[i] + a[i];

ll res = INFL;

// BC = a[0..i2) と DE = a[i2..n) に分ける．
repi(i2, 2, n - 2) {
ll pq = acc[i2];
ll sr = acc[n] - acc[i2];

int i1c = distance(acc.begin(), lower_bound(all(acc), pq / 2));
int i3c = distance(acc.begin(), lower_bound(all(acc), acc[i2] + sr / 2));

// B = a[0..i1) と C = a[i1..i2) に分ける．
repi(i1, i1c - 1, i1c + 1) {
// D = a[i2..i3) と E = a[i3..n) に分ける．
repi(i3, i3c - 1, i3c + 1) {
if (i1 <= 0) continue;
if (i2 - i1 <= 0) continue;
if (i3 - i2 <= 0) continue;
if (n - i3 <= 0) continue;

ll p = acc[i1];
ll q = acc[i2] - acc[i1];
ll r = acc[i3] - acc[i2];
ll s = acc[n] - acc[i3];

ll dif = max({ p, q, r, s }) - min({ p, q, r, s });
chmin(res, dif);
}
}
}

cout << res << endl;
}

#include "bits/stdc++.h"
using namespace std;

#define ar array
#define int long long

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

string s; cin>>s;
int n = (int)s.size();
int mn = n;
for(int i=1;i<(int)s.size();i++){
if(s[i] != s[i-1]){
mn = min(mn, max(i, n - i));
}
}

cout<<mn<<"\n";
}

#include <bits/stdc++.h>

#define fi first
#define se second
#define il inline
#define Ld double
#define pc putchar
#define rg register
#define ll long long
#define lll __int128
#define pb push_back
#define mp make_pair
#define It ::iterator
#define W(p) while(p--)
#define pll pair<ll, ll>
#define pli pair<ll, int>
#define pil pair<int, ll>
#define pii pair<int, int>
#define ull unsigned long long
#define all(x) x.begin(), x.end()
#define def(N, K, b) const K N = b;
#define FOR(i, b, s) for(int i = (b); i < (s); ++i) 
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define FOR_(i, b, s) for(int i = (b); i > (s); --i) 
#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)

namespace IO {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;
inline char gc() {
return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);
} 
inline void qread() {}
template<class T1, class ...T2>
inline void qread(T1 &IEE, T2&... ls) {
register T1 __ = 0, ___ = 1;
register char ch;
while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;
do {
__ = (__ << 1) + (__ << 3) + (ch ^ 48);
}while(isdigit(ch = gc()));
__ *= ___;
IEE = __;
qread(ls...);
return ;
}
template<class T>
inline void QreadArr(T Begin, T End) {
while(Begin != End) {
qread(*Begin);
++Begin;
}
}
inline void flush() {
fwrite(obuf, 1, oS - obuf, stdout);
oS = obuf;
return ;
}
inline void putc_(char _x) {
*oS++ = _x;
if(oS == oT) flush();
}
inline void qwrite() {}
template<class T1, class ...T2>
inline void qwrite(T1 IEE, T2... ls) {
if(!IEE) putc_('0');
if(IEE < 0) putc_('-'), IEE = -IEE;
while(IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;
while(_qr) putc_(_st[_qr--]);
qwrite(ls...);
return ;
}
template<class T>
inline void WriteArr(T Begin, T End) {
const char Kg = ' ', Edl = '\n';
while(Begin != End) {
qwrite(*Begin);
++Begin;
putc_(Kg);
}
putc_(Edl);
}
struct Flusher_{ ~Flusher_() { flush(); } } io_flusher;
}

using namespace IO;
using namespace std;

il ll qpow(ll n, ll base, ll mod = 1e18) {
ll ret = 1;
while(n) {
if(n & 1) ret = ret * base % mod;
base = base * base % mod;
n >>= 1;
}
return ret % mod;
}

namespace strHash {
def(SIZ, int, 1e6 + 5);
def(bs, int, 131);
def(p, int, 1e9 + 7);

int n;
ll hp[SIZ];
ll pw[SIZ];

void init(const string &s) {
n = s.size() - 1;
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
} 

void Init(const char s[]) {
n = strlen(s + 1);
pw[0] = 1;
rep(i, 1, n) pw[i] = pw[i - 1] * bs % p, hp[i] = (hp[i - 1] * bs % p + s[i] - 'a' + 1) % p;	
}

ll get(int l, int r) {
ll ret = hp[r];
ret = (ret - hp[l - 1] * pw[r - l + 1] % p + p) % p;
return ret;
}
}

namespace Comb {
def(SIZ, int, 1e6 + 5);
int p;

ll inv[SIZ], fac[SIZ], Inv[SIZ];

void init(int mod) {
p = mod;
inv[0] = fac[0] = Inv[0] = inv[1] = fac[1] = Inv[1] = 1;
rep(i, 2, SIZ - 1) {
fac[i] = fac[i - 1] * i % p;
inv[i] = p - (p / i) * inv[p % i] % p;
Inv[i] = Inv[i - 1] * inv[i] % p;
}
}

ll C(int n, int m) {
if(n < m || m < 0) return 0;
return ((fac[n] * Inv[n - m]) % p) * Inv[m] % p;
}
} using Comb::C;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
ll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }

template<class T1, class T2>
T1 Min(const T1 x, const T2 y) { return x > y ? y : x; }
template<class T1, class T2>
T1 Max(const T1 x, const T2 y) { return x > y ? x : y; }

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }
template<class T1, class T2>
void To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }

il ll qmul(ll x, ll y, ll p) {
ll l = x * (y >> 25) % p * (1 << 25) % p;
ll r = x * (y & ((1 << 25) - 1)) % p;
return (l + r) % p;
}

il ll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }
il ll lcm(ll x, ll y) { return x / gcd(x, y) * y; } 

void InitHash(ull &base, int &prime, ull &mod) { base = 131, prime = 233317, mod = 212370440130137957ll; } 
//header

#define ls (id << 1)
#define rs (id << 1 | 1)
#define mid (l + r >> 1)

def(N, int, 2e5 + 5)

int n, q, a, b;
int x[N];
ll ml[N << 2], mr[N << 2], lz[N << 2];

void pushup(int id) {
ml[id] = min(ml[ls], ml[rs]);
mr[id] = min(mr[ls], mr[rs]);
}

void pushdown(int id) {
if(lz[id]) {
ml[ls] += lz[id], mr[ls] += lz[id], lz[ls] += lz[id];
ml[rs] += lz[id], mr[rs] += lz[id], lz[rs] += lz[id];
lz[id] = 0;
}
}

void modify(int id, int l, int r, int x, ll v) {
if(l == r) {
To_min(ml[id], v - l);
To_min(mr[id], v + l);
return ;
}
pushdown(id);
if(mid >= x) modify(ls, l, mid, x, v);
else modify(rs, mid + 1, r, x, v);
pushup(id);
}

ll queryl(int id, int l, int r, int x, int y) {
if(x <= l && r <= y) return ml[id];
pushdown(id);
ll ret = 1e18;
if(mid >= x) To_min(ret, queryl(ls, l, mid, x, y));
if(mid < y) To_min(ret, queryl(rs, mid + 1, r, x, y));
return ret;
}

ll queryr(int id, int l, int r, int x, int y) {
if(x <= l && r <= y) return mr[id];
pushdown(id);
ll ret = 1e18;
if(mid >= x) To_min(ret, queryr(ls, l, mid, x, y));
if(mid < y) To_min(ret, queryr(rs, mid + 1, r, x, y));
return ret;
}

ll query(int id, int l, int r) {
if(l == r) return ml[id] + l;
pushdown(id);
return min(query(ls, l, mid), query(rs, mid + 1, r));
}

int main() {
qread(n, q, a, b);
rep(i, 1, q) qread(x[i]);
memset(ml, 0x3f, sizeof ml);
memset(mr, 0x3f, sizeof mr);
modify(1, 1, n, a, abs(b - x[1]));
modify(1, 1, n, b, abs(a - x[1]));
rep(i, 2, q) {
ll nw = min(queryl(1, 1, n, 1, x[i]) + x[i], queryr(1, 1, n, x[i], n) - x[i]);
ll np = abs(x[i] - x[i - 1]);
ml[1] += np, mr[1] += np, lz[1] += np;
modify(1, 1, n, x[i - 1], nw);
}
cout << query(1, 1, n) << endl;
return 0;
}
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<queue>
#include<stack>
#include<map>
#include<vector>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
const int maxn=2e5+10;
const int maxm=1e6+10;
const int mod=1e8+7;
const int base=1e4;
const ull base1=233;
const ull base2=19260817;
const int maxxn=0x7fffffff;
const int minxn=-0x7fffffff;
const db inf=1e13;
const db eps=1e-8;
inline ll read(){
ll x=0,w=1;char c=getchar();
while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
while(c<='9'&&c>='0'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
return x*w;
}
int n;
ll ans;
ll a[maxm],b[maxm],p;
inline void msort(int l,int r){
if(l==r) return;
int mid=(l+r)>>1;
msort(l,mid);
msort(mid+1,r);
int i=l,j=mid+1,k=i;
while(i<=mid&&j<=r){
if(a[i]>a[j]){
b[k++]=a[i++];
}
else{
b[k++]=a[j++];
ans+=mid-i+1;
}
}
while(i<=mid){
b[k++]=a[i++];
}
while(j<=r){
b[k++]=a[j++];
}
for(i=l;i<=r;i++){
a[i]=b[i];
}
}
int main(){
n=read(),p=read();
for(int i=1;i<=n;i++){
a[i]=read();
}
for(int i=1;i<=n;i++){
a[i]+=a[i-1]-p;
}
msort(0,n);
printf("%lld\n",ans);
return 0;
}
#include <bits/stdc++.h>
using namespace std;

int main() {
cin.tie(0)->sync_with_stdio(0);

int n;
cin >> n;

vector<int> r(n), c(n);
for (auto& ri : r) {
cin >> ri;
}
for (auto& ci : c) {
cin >> ci;
}

vector<int> ir(n + 1), ic(n + 1);
for (int i = 0; i < n; ++i) {
ir[r[i]] = i;
ic[c[i]] = i;
}

vector<vector<int>> rq(n), cq(n);
int q;
cin >> q;
for (int i = 0; i < q; ++i) {
int ri, ci;
cin >> ri >> ci;
--ri, --ci;
rq[ri].push_back(i);
cq[ci].push_back(i);
}

string ans(q, '?');

bool black = true;
int i = n;

for (int j = 0; j < n; ++j) {
for (auto k : rq[ir[i]]) {
if (ans[k] == '?') {
if (black) {
ans[k] = '#';
} else {
ans[k] = '.';
}
}
}

for (auto k : cq[ic[i]]) {
if (ans[k] == '?') {
if (black) {
ans[k] = '#';
} else {
ans[k] = '.';
}
}
}

black = !black;
i = n - i;
if (i < n - i) {
++i;
}
}

cout << ans << "\n";

return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <string>
#include <cmath>
#include <set>
#include <stack>
#include <map>
#include <queue>
#include <iterator>
#include <sstream>
#include <cassert>
#include <locale>
#include <numeric>

#define ld long double
#define debug(x) cout << #x << " is " << x << '\n';
#define int long long

using namespace std;
const int mod = 1e9 + 7, LOG = 301;

signed main() {
ios_base::sync_with_stdio(false);
cin.tie(0);
cout << fixed << setprecision(8);
int n; cin >> n;
vector <int> a(n), sorted;
for (auto& x : a) cin >> x;

sorted = a;
sort(sorted.begin(), sorted.end());

for (int i = 0; i < n; ++i) {
cout << sorted[n / 2 - (a[i] >= sorted[n / 2])] << '\n';
}
cout << '\n';

return 0;
}

#include <bits/stdc++.h>
//#define int long long

namespace IO {
std::ostream& fmtbase(std::ostream& out, const char* format) {
for (; *format; format++) {
if (*format == '{' && *(format + 1) == '}') {
std::cerr << "\nError Number of Parameters!\n";
assert(0);
}

out << *format;
}

return out;
}

template <class Fst, class ... Nxt>
std::ostream& fmtbase(std::ostream& out, const char* format, Fst value, Nxt ... nxt) {
for (; *format; format++) {
if (*format == '{' && *(format + 1) == '}') {
out << value;
return fmtbase(out, format + 2, nxt...);
}
else {
std::cout << *format;
}
}

std::cerr << "\nError Number of Parameters!\n";
assert(0);
return out;
}

template <class ... Ps>
std::ostream& fmtout(const char* format, Ps ... ps) {
return fmtbase(std::cout, format, ps...);
}

template <class ... Ps>
std::ostream& fmterr(const char* format, Ps ... ps) {
return fmtbase(std::cerr, format, ps...);
}

template <class ... Ps>
std::ostream& fmtoutln(const char* format, Ps ... ps) {
return fmtout(format, ps...) << '\n';
}

template <class ... Ps>
std::ostream& fmterrln(const char* format, Ps ... ps) {
return fmtbase(std::cerr, format, ps...) << '\n';
}

std::istream& allin() {
return std::cin;
}

template <class Fst, class ... Nxt>
std::istream& allin(Fst& fst, Nxt& ... nxt) {
std::cin >> fst;
return allin(nxt...);
}

template <class Iter>
std::istream& rangin(Iter begin, Iter end) {
while (begin != end) {
std::cin >> *begin;
begin++;
}

return std::cin;
}
}

namespace Solve {
using namespace IO;

using Long = long long;
using Double = long double;

int const INF = std::numeric_limits<signed>::max();
int const NINF = std::numeric_limits<signed>::min();
Long const LINF = std::numeric_limits<Long>::max();
Long const LNINF = std::numeric_limits<Long>::min();
Double const EPS = 1e-12l;

int const N = 5e5 + 10;

std::string s, t;
int n;

void main() {
allin(n, s, t);

auto form = [&](std::string s) {
std::vector<int> res;

for (int i = 0; i < (int) s.size(); i++) {
int cur = ((s[i] - 'A' - i) % 3 + 3) % 3;
res.push_back(cur);

//				fmterr("({}, {}) ", s[i], cur);

if (res.size() >= 3) {
bool check = true;
for (int i = 2; i <= 3; i++) {
int t = (int) res.size() - i;
if (res[t] != res.back()) {
check = false;
}
}

if (check) {
for (int i = 1; i <= 3; i++) {
res.pop_back();
}
}
}
}

//			fmterr("\n");

return res;	
};

if (form(s) == form(t)) {
fmtout("YES\n");
}
else {
fmtout("NO\n");
}
}

void init() {

}

void clear() {

}
}

signed main() {
//	freopen("d.in", "r", stdin);
//	freopen("d.out", "w", stdout);

std::ios::sync_with_stdio(false);
std::cin.tie(0);
std::cout.tie(0);

//	double start = clock();

int t = 1;
//	std::cin >> t;

Solve::init();

for (; t; t--) {
Solve::main();
Solve::clear();
}

//	std::cerr << "\nTIME: " << (clock() - start) / CLOCKS_PER_SEC << '\n';

return 0;
}
#include <atcoder/all>
using namespace atcoder;
#include <bits/stdc++.h>
#define all(a) (a.begin()),(a.end())
#define rall(a) (a.rbegin()),(a.rend())
using namespace std;
using ll=long long;
using ld=long double;
using pll=pair<ll,ll>;
template<class T>bool chmax(T &a, const T &b) {if(a<b) {a=b; return 1;} return 0;}
template<class T>bool chmin(T &a, const T &b) {if(b<a) {a=b; return 1;} return 0;}
istream& operator >> (istream& is, modint1000000007& x) { unsigned int t; is >> t; x=t; return is; }
istream& operator >> (istream& is, modint998244353& x) { unsigned int t; is >> t; x=t; return is; }
istream& operator >> (istream& is, modint& x) { unsigned int t; is >> t; x=t; return is; }
ostream& operator << (ostream& os, const modint1000000007& x) { os << x.val(); return os; }
ostream& operator << (ostream& os, const modint998244353& x) { os << x.val(); return os; }
ostream& operator << (ostream& os, const modint& x) { os << x.val(); return os; }
template<class T1, class T2>istream& operator >> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }
template<class T1, class T2>ostream& operator << (ostream& os, const pair<T1,T2>& p) { os << p.first << " " << p.second; return os;}
template<class T>istream& operator >> (istream& is, vector<T>& v) { for(T& x:v) is >> x; return is; }
template<class T>ostream& operator << (ostream& os, const vector<T>& v) {for(int i=0;i<(int)v.size();i++) {os << v[i] << (i+1 == v.size() ? "":" ");} return os;}
template<class... A> void pt()      { std::cout << "\n"; }
template<class... A> void pt_rest() { std::cout << "\n"; }
template<class T, class... A> void pt_rest(const T& first, const A&... rest) { std::cout << " " << first; pt_rest(rest...); }
template<class T, class... A> void pt(const T& first, const A&... rest)      { std::cout << first; pt_rest(rest...); }
template<typename V, typename H> void resize(vector<V>& vec, const H head){ vec.resize(head); }
template<typename V, typename H, typename ... T> void resize(vector<V>& vec, const H& head, const T ... tail){ vec.resize(head); for(auto& v: vec) resize(v, tail...); }
template<typename V, typename T> void fill(V& x, const T& val){ x = val; }
template<typename V, typename T> void fill(vector<V>& vec, const T& val){ for(auto& v: vec) fill(v, val); }
template<typename H> void vin(istream& is, const int idx, vector<H>& head){ is >> head[idx]; }
template<typename H, typename ... T> void vin(istream& is, const int idx, vector<H>& head, T& ... tail){ vin(is >> head[idx], idx, tail...); }
template<typename H, typename ... T> void vin(istream& is, vector<H>& head, T& ... tail){ for(int i=0; i<(int)head.size(); i++) vin(is, i, head, tail...); }
template<typename H, typename ... T> void vin(vector<H>& head, T& ... tail){ vin(cin, head, tail...); }
map<ll,ll>divisor(ll n){map<ll,ll>res;for(ll i=1;i*i<=n;i++)if(n%i==0){res[i]++;res[n/i]++;}return res;}
map<ll,ll>factrization(ll n){map<ll,ll>res;for(ll i=2;i*i<=n;i++)while(n%i==0){res[i]++;n/=i;}if(n>1)res[n]++;return res;}
static const ll inf=1e18+7;
static const ld pi=acos(-1);
static const ld eps=1e-10;
using v1=vector<ll>;
using v2=vector<v1>;
using v3=vector<v2>;
using v4=vector<v3>;
using S=ll;
S op(S a,S b){return a+b;}
S e(){return 0;}

int main(void) {
cin.tie(nullptr);
ios::sync_with_stdio(false);

ll N;cin>>N;
v1 a(N);cin>>a;

ll ans=0;
while(1){
ll f=1;
for(ll i=0;i<N;i++){if(a[i]>N-1)f=0;}
if(f)break;

ll t=0;
v1 b(N);
for(ll i=0;i<N;i++)b[i]=a[i]/N,t+=b[i];
for(ll i=0;i<N;i++)a[i]+=t-b[i],a[i]-=b[i]*N;
ans+=t;
}
pt(ans);



}



#include <bits/stdc++.h>
using namespace std;
#include <atcoder/maxflow>
using namespace atcoder;

int main()
{
int N;
cin >> N;
vector<int> a( N ), b( N ), c( N ), d( N );
for( int i = 0; i < N; i++ ) cin >> a[i] >> b[i];
for( int i = 0; i < N; i++ ) cin >> c[i] >> d[i];

mf_graph<int> g( N * 2 + 2 );
int s = N * 2, t = N * 2 + 1;
for( int i = 0; i < N; i++ ) {
g.add_edge( s, i, 1 );
}
for( int i = 0; i < N; i++ ) {
for( int j = 0; j < N; j++ ) {
if( a[i] < c[j] && b[i] < d[j] ) {
g.add_edge( i, j + N, 1 );
}
}
}
for( int i = 0; i < N; i++ ) {
g.add_edge( i + N, t, 1 );
}
int ans = g.flow( s, t );

cout << ans << endl;
}

#include    <bits/stdc++.h>
#include    <stdio.h>
#include    <ext/pb_ds/assoc_container.hpp>// For pbds.Don't use tree as variable name.
#include    <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define pb          push_back
#define eb          emplace_back
#define mem(x,i)    memset(x,i,sizeof(x))
#define ff          first
#define ss          second
#define all(x)      x.begin(),x.end()
#define Q           int t; scanf("%d", &t); for(int q=1; q<=t; q++)

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;//%Lf
typedef pair<ll, ll> pi;

template <typename T>  using orderedSet = tree<T, null_type, less<T>,rb_tree_tag, tree_order_statistics_node_update>;
//order_of_key(k) - number of element strictly less than k.
//find_by_order(k) - k'th element in set.(0 indexed)(iterator)

/* Debug Tools */
#define error(args...) \
{ \
string _s = #args; replace(_s.begin(), _s.end(), ',', ' ');\
stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args);\
}
void err(istream_iterator<string> it) {}
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
cerr<< *it << " = " << a <<",\n"[++it==istream_iterator<string>()];
err(it, args...);
}

const int MOD = 1e9+7 ; //For big mod
template<typename T>inline T gcd(T a, T b){T c;while (b){c = b;b = a % b;a = c;}return a;} // better than __gcd
template<typename T>inline T lcm(T a, T b){return (a/gcd(a, b))*b;}
ll powmod(ll a,ll b){ll res=1;a%=MOD;if(b<0) return 0;for(; b; b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}

const int xx[] = {+1, -1, +0, +0};//, +1, +1, -1, -1};// exclude last four when side adjacent
const int yy[] = {+0, +0, +1, -1};//, +1, -1, +1, -1};
const int INF    = 0x3f3f3f3f;// useful for memset
const ll LL_INF  = 0x3f3f3f3f3f3f3f3f;
const double PI  = acos(-1.0);
const double eps = 1e-9;
const int mxn     = 1e5+5; //CHECK here for every problem
const int mod    = 1e9+7;

ll fac[mxn];

ll C(int n, int r){
ll up = fac[n];
ll down = (fac[n-r]*fac[r])%mod;
down = powmod(down, mod-2);
return (up*down)%mod;
}

int main()
{
fac[0] = 1;
for(ll i=1; i<mxn; i++){
fac[i] = (fac[i-1]*i)%mod;
}
int n;
cin >> n;
vector<int> pos(n+2, -1);
int l, r;
for(int i=0; i<=n; i++){
int x;
cin >> x;
if(pos[x] != -1){
l = pos[x];
r = n-i;
}
pos[x] = i;
}
// error(l+r)
for(int i=1; i<=n+1; i++){
ll ans = C(n+1, i);
if(l+r >= i-1){
ans = ((ans-C(l+r, i-1))%mod+mod+mod)%mod;
}
cout << ans << '\n';
}
}

#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 100010;
int a[maxn];
int n, t;

int main() {
cin >> n >> t;
for (int i = 0; i < n; i++)
cin >> a[i];
int maxi = a[n - 1];
int max_dif = 0;
for (int i = n - 1; i >= 0; i--) {
maxi = max(maxi, a[i]); //maximum number
max_dif = max(max_dif, maxi - a[i]); //max difference
}
maxi = a[n - 1];
int ans = 0;
for (int i = n - 1; i >= 0; i--) {
maxi = max(maxi, a[i]); //maximum number
if (max_dif == maxi - a[i]) {
++ans;
}
}
cout << ans << endl;
return 0;
}

#include<bits/stdc++.h>
#define int long long
using namespace std;
#define fi first
#define se second
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<pii> vp;

long long read() {
long long res=0, w=1; char c=getchar();
while(!isdigit(c)) {if(c=='-') w=-1; c=getchar();}
while(isdigit(c)) {res=res*10+c-48, c=getchar();}
return res*w;
}

const int mod=1e9+7;
int n,k,f[2009],ans,a[2009],cnt;

int ksm(int x,int y,int res=1) {
for(;y;y>>=1,x=x*x%mod) if(y%2) res=res*x%mod;
return res;
}

signed main() {
n=read(), k=read();
for(int i=1;i*i<=n;i++) if(n%i==0) {
a[++cnt]=i; if(n/i!=i) a[++cnt]=n/i;
}
sort(a+1,a+cnt+1);
rep(i,1,cnt) {
f[i]=ksm(k,(a[i]+1)/2);
rep(j,1,i-1) if(a[i]%a[j]==0) f[i]=(f[i]+mod-f[j])%mod;
ans=(ans+f[i]*(a[i]%2?a[i]:a[i]/2))%mod;
}
printf("%lld\n",ans);
return 0;
}
#include <queue>
#include <cstdio>
#include <cstring>

const int N = 1e5 + 5;

int n, e[N][2], dis[N], vis[N];
std :: deque <int> q;

int main() {
scanf("%d", &n);
memset(dis, 0x3f, sizeof(dis));
for(int i = 1; i <= n; i++) e[i][0] = (i * 10) % n, e[i][1] = (i + 1) % n;
q.push_back(1), dis[1] = 1;
while(!q.empty()) {
int x = q.front();
q.pop_front();
if(vis[x]) continue;
vis[x] = 1;
if(dis[e[x][0]] > dis[x]) {
dis[e[x][0]] = dis[x], q.push_front(e[x][0]);
}
if(dis[e[x][1]] > dis[x] + 1) {
dis[e[x][1]] = dis[x] + 1, q.push_back(e[x][1]);
}
}
printf("%d", dis[0]);
return 0;
}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 5000500;
ll n, l[N], r[N], p[N], t[N];
ll buc[N];
ll lowbit (ll x) {return x & (-x);}
ll que (ll x) {
ll ret = 0;
while (x) {
ret += t[x];
x -= lowbit (x);
}
return ret;
}
void add (ll x, ll v) {
while (x <= n) {
t[x] += v;
x += lowbit (x); 
}
}
int main () {
//	freopen ("myin.in", "r", stdin);
cin >> n;
for (ll i=1;i<=n;i++) {
cin >> l[i] >> r[i];
}
for (ll i=1;i<=n;i++) {
if (i == n || l[i] != l[i + 1]) {
if (p[i] && p[i] != l[i]) {
puts ("-1");
return 0;
}
p[i] = l[i];
}
if (i == 1 || r[i] != r[i - 1]) {
if (p[i] && p[i] != r[i]) {
puts ("-1");
return 0;
}
p[i] = r[i];
}
}
for (int i=1;i<=n;i++) {
if (! p[i]) continue ;
if (buc[p[i]]) {
puts ("-1");
return 0;
} else {
buc[p[i]] = 1;
}
}
for (ll i=1,ps=1;i<=n;i++) {
if (! p[i]) {
while (buc[ps]) ps ++;
buc[p[i] = ps] = 1;
}
}
//	for (int i=1;i<=n;i++) cout << p[i] << " "; puts ("");
for (ll i=n,t=N;i>=1;i--) {
t = min (t, p[i]);
if (t != l[i]) {
puts ("-1");
return 0;
}
}
for (ll i=1,t=0;i<=n;i++) {
t = max (t, p[i]);
if (t != r[i]) {
puts ("-1");
return 0;
}
}
ll Ans = 0;
for (ll i=1;i<=n;i++) {
Ans += i - que (p[i]) - 1;
add (p[i], 1);
}
cout << Ans << endl;
}
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long 
#define ri int
#define pii pair<int,int>
const ll mod=998244353;
ll add(ll x,ll y){return (x+=y)<mod?x:x-mod;}
ll dec(ll x,ll y){return (x-=y)<0?x+mod:x;}
ll ksm(ll d,ll t,ll res=1){for(;t;t>>=1,d=d*d%mod) if(t&1) res=res*d%mod;return res;}
const int MAXN=2e3+7;
int f[2][MAXN],n;
int a[MAXN],b[MAXN],suma[MAXN][MAXN<<1],sumb[MAXN][MAXN<<1];
int main(){
scanf("%d",&n);
for(ri i=1;i<=n*2;++i){
char op[8];int w;
scanf("%s%d",op,&w);
if(op[0]=='W') a[w]=i;
else b[w]=i;
}
for(ri i=1;i<=n;++i) suma[i][a[i]]++,sumb[i][b[i]]++;
for(ri i=1;i<=n;++i) for(ri j=(n<<1);j;--j) suma[i][j]+=suma[i][j+1],sumb[i][j]+=sumb[i][j+1];
for(ri j=1;j<=(n<<1);++j) for(ri i=1;i<=n;++i) suma[i][j]+=suma[i-1][j],sumb[i][j]+=sumb[i-1][j];
memset(f,0x3f,sizeof(f));
int o=1;
f[0][0]=0;
for(ri i=0;i<=n;++i){
o^=1;if(i) memset(f[o],0x3f,sizeof(f[o]));
for(ri j=0;j<=n;++j){
if(i) f[o][j]=min(f[o][j],f[o^1][j]+suma[i-1][a[i]]+sumb[j][a[i]]);
if(j) f[o][j]=min(f[o][j],f[o][j-1]+suma[i][b[j]]+sumb[j-1][b[j]]);
}
// for(ri j=0;j<=n;++j) printf("%d ",f[o][j]);puts("");
}
printf("%d\n",f[o][n]);
}
#include<bits/stdc++.h>
using namespace std;

int n,m;
vector<pair<int,int>> g[100010];
int d[100010],fa[100010];

int find(int x)
{
if(fa[x]==x) return x;
int tmp=fa[x];
fa[x]=find(fa[x]);
d[x]+=d[tmp];
return fa[x];
}

int main() {
scanf("%d%d",&n,&m);
int to,from,dd;
for(int i=1;i<=n;i++) fa[i]=i;
for(int i=1;i<=m;i++)
{
scanf("%d%d%d",&to,&from,&dd);
int fx=find(to),fy=find(from);
if(fx==fy)
{
if(d[from]-d[to]!=dd)
{
puts("No");
return 0;
}
}
else
{
d[fy]=d[to]-d[from]+dd;
fa[fy]=fx;
}
}
puts("Yes");
return 0;
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
//#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
void solve(){ 
string s, t; cin>>s>>t;
vi pfs(sz(s) + 1, 0), pfs2(sz(t) + 1, 0);
for(int i=1; i<=sz(s); i++){
pfs[i] = (s[i-1] == 'A');
pfs[i] += pfs[i-1];
}
for(int i=1; i<=sz(t); i++){
pfs2[i] = (t[i-1] == 'A');
pfs2[i] += pfs2[i-1];
}
int q; cin>>q;
while(q--){
int a,b,c,d; cin>>a>>b>>c>>d;
int x1 = (b-a)%3 - 2*(pfs[b] - pfs[a-1])%3;
int x2 = (d-c)%3 - 2*(pfs2[d] - pfs2[c-1])%3;
x1 %= 3; x2 %= 3; x1 += 3; x2 += 3; x1 %= 3; x2 %=3;
if(x1 == x2)
cout<<"YES\n";
else cout<<"NO\n";
}
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <bits/stdc++.h>

using namespace std;

const int maxn=1e5+10;
const int inf=0x3f3f3f3f;

struct Edge{
int u,v,w;
}e[4*maxn];

int n,m;
int cnt,h[maxn],d[maxn],vis[maxn];
int x,y,z;

void addedge(int u,int v,int w){
e[++cnt].u=v;
e[cnt].w=w;
e[cnt].v=h[u];
h[u]=cnt;
}

priority_queue<pair<int,int > > q;
set<int> c[maxn];

void dij(){
memset(d,inf,sizeof(d));
d[1]=0;
q.push(make_pair(d[1],1));
while(q.size()){
int t1=q.top().second;
q.pop();
if(vis[t1]) continue;
vis[t1]=1;
for(int i=h[t1];i;i=e[i].v){
int t2;
if(c[t1].count(e[i].w)) t2=0;
else t2=1;
if(d[t1]+t2<d[e[i].u]){
d[e[i].u]=d[t1]+t2;
c[e[i].u].clear();
c[e[i].u].insert(e[i].w);
q.push(make_pair(-d[e[i].u],e[i].u));
}
else if(d[t1]+t2==d[e[i].u]){
c[e[i].u].insert(e[i].w);
}
}
}
}

int main() {
cin>>n>>m;
for(int i=0;i<m;i++){
cin>>x>>y>>z;
addedge(x,y,z);
addedge(y,x,z);
}
dij();
if(d[n]==inf) cout<<"-1"<<endl;
else cout<<d[n]<<endl;
return 0;
}

#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstring>
#include <iostream>
#include <sstream>
#include <numeric>
#include <map>
#include <set>
#include <queue>
#include <vector>

using namespace std;

vector<int> solve(int N, int A, int B) {
if (A + B > N + 1) {
return {};
}
vector<int> ans(N);
for (int i = 0; i <= A; ++i) {
if (i + (N - i + B - 1) / B == A) {
int r = N - ((N - i) % B);
for (int j = 0; j < N; ++j) {
if (j < i) {
ans[j] = j;
} else if (j < r) {
ans[j] = i + B - 1 + (j - i) / B * B - ((j - i) % B);
} else {
ans[j] = N - 1 - j + r;


}
}
return ans;
}
}
return {};
}

int main() {
int N, A, B;
std::cin >> N >> A >> B;
vector<int> ans = solve(N, A, B);
if (ans.empty()) {
cout << "-1" << endl;
} else {
for (size_t i = 0; i < ans.size(); ++i) {
if (i) cout << " ";
cout << (ans[i] + 1);
}
cout << endl;
}
return 0;
}

#include <bits/stdc++.h>
#define rep(i, b, s) for(int i = (b); i <= (s); ++i)
#define per(i, b, s) for(int i = (b); i >= (s); --i)
#define ll long long
#define ios ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define fi first
#define se second
#define mp make_pair
#define Ld long double
#define pii pair<int, int>
#define pb push_back

using namespace std;

const int N = 5e5 + 5;
const int M = 1e5 + 5;

int n, m;
pii w[N];
int t[M];

int lbt(int x) { return x & (-x); }

void upd(int x, int v) {
while(x <= m) t[x] += v, x += lbt(x);
}

int qry(int x) {
int ret = 0;
while(x) ret += t[x], x -= lbt(x);
return ret;
}

inline int len(pii x) { return x.se - x.fi; }

bool cmp(pii x, pii y) {
return len(x) < len(y);
}

int main() {
ios;
cin >> n >> m;
rep(i, 1, n) cin >> w[i].fi >> w[i].se;
sort(w + 1, w + n + 1, cmp);
int nw = 1;
rep(i, 1, m) {
while(nw <= n && len(w[nw]) < i) {
upd(w[nw].fi, 1);
upd(w[nw].se + 1, -1);
++nw;
}
int sum = 0;
for(int j = i; j <= m; j += i) sum += qry(j);
cout << n - nw + 1 + sum << endl;
}
return 0;
}
#include<iostream>
#include<string>
#include<vector>
#include<queue>
#include<algorithm>
#define int long long
using namespace std;

signed main()
{
int n;
string ans = "No";
int cnt_j = 0, cnt_2 = 0, cnt_4 = 0;
cin >> n;
for (int i = 1; i <= n; i++)
{
int x; cin >> x;
if (x & 1)
{
cnt_j++;
}
else
{
if (x % 4 == 0)
cnt_4++;

cnt_2++;
}
}
if (cnt_2 == cnt_4)
{
if (cnt_j <= cnt_4 + 1)
ans = "Yes";
}
else if (cnt_j <= cnt_4)
{
cnt_2 -= cnt_j - 1;
if (cnt_2 > 1)
{
ans = "Yes";
}
}
cout << ans << endl;
}
#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<20>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod1000000007 = 1000000007;
const int mod998244353 = 998244353;

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
int L;
cin >> L;
int n = 0;
int x = 1;
while(x <= L) x*=2, ++n;

vector<tuple<int, int, int>> ans;
rep(i, n-1) {
ans.emplace_back(n-i-1, n-i, 1<<i);
ans.emplace_back(n-i-1, n-i, 0);
}
rep(i, n-1) {
if(L & 1<<i) {
int cst = L;
cst >>= i+1;
cst <<= i+1;
ans.emplace_back(1, n-i, cst);
}
}

sort(ALL(ans));

cout << n << " " << SZ(ans) << endl;
for(auto x : ans) cout << get<0>(x) << " " << get<1>(x) << " " << get<2>(x) << endl;
}
#include <bits/stdc++.h>

using namespace std;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
long long n, s;
cin >> n >> s;
if (n < s) return cout << "-1\n", 0;
if (n == s) return cout << n + 1 << '\n', 0;
auto check = [&](long long b) ->bool {
long long x = n, ans = 0;
while (x) {
ans += x % b;
x /= b;
}
return (ans == s);
};
long long res = LLONG_MAX;
for (int i = 1; i * 1LL * i <= n; i++) {
if ((n - s) % i == 0) {
if (i + 1 != 1 && check(i + 1))
res = min(res, i + 1LL);
if ((n - s) / i + 1 != 1 && check((n - s) / i + 1))
res = min(res, (n - s) / i + 1);
}
}
if (res == LLONG_MAX) res = -1;
cout << res << '\n';
return 0;
}
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

// typedefs...
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll, ll> pll;
typedef trie<string,null_type,trie_string_access_traits<>,pat_trie_tag,trie_prefix_search_node_update>pref_trie;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;

// constants...
const double PI = acos(-1);
const ll mod =998244353 ; // 1000000007
const int MXS = 2e5+5;
const ll MXI = 1e9+5;
const ll MXL = 1e18+5;
const ll INF = 1e9+5;
const ll INFLL = 1e18+5;
const ll EPS = 1e-9;

// defines...
#define MP        make_pair
#define PB        push_back
#define fi         first
#define se         second
#define sz(x)      (int)x.size()
#define all(x)      begin(x), end(x)
#define si(a)       scanf("%d", &a)
#define sii(a, b)    scanf("%d%d", &a, &b)
#define ordered_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>
#define boost_      ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define iter_(i,n)    for (int i = 0; i < int(n); i++)
#define for_n(i, n)  for (int i = 1; i <= int(n); i++)
#define print_array(a) for(int i=0;i<n;i++)  cout<<a[i]<<" ";
#define rev(i,n)     for(int i=n;i>=0;i--)
#define itr          ::iterator
#define s_sort(s)    sort(s.begin(),s.end())
#define n_sort(a, n)    sort(a,a+n)
#define precise_impact cout<<setprecision(10)<<fixed;
#define endl         "\n"
// functions...
ll gcd(ll a, ll b){ while (b){ a %= b; swap(a, b);} return a;}
ll lcm(ll a, ll b){ return (a/gcd(a, b)*b);}
ll ncr(ll a, ll b){ ll x = max(a-b, b), ans=1; for(ll K=a, L=1; K>=x+1; K--, L++){ ans = ans * K; ans /= L;} return ans;}
ll bigmod(ll a,ll b){ if(b==0){ return 1;} ll tm=bigmod(a,b/2); tm=(tm*tm)%mod; if(b%2==1) tm=(tm*a)%mod; return tm;}
ll egcd(ll a,ll b,ll &x,ll &y){ if(a==0){ x=0; y=1; return b;} ll x1,y1; ll d=egcd(b%a,a,x1,y1); x=y1-(b/a)*x1; y=x1; return d;}
ll modpow(ll a,ll p) {ll ans=1;while(p){if(p%2)ans=(ans*a)%mod;a=(a*a)%mod;p/=2;} return ans;}
ll inverse_mod(ll n) {return modpow(n,mod-2);}
//ll fact[200005];
//ll ncr_mod(ll n,ll r) {return (((fact[n]*inverse_mod(fact[r]))%mod)*inverse_mod(fact[n-r]))%mod;}
class point 
{
public:
ll x,y,pos;
};
class edge
{
public:
ll x,y,dis;
edge(ll x,ll y,ll dis)
{
this->x=x;this->y=y;this->dis=dis;
}
};
bool cmp1(point a,point b)
{
return a.x<b.x;
}
bool cmp2(point a,point b)
{
return a.y<b.y;
}
bool cmp3(edge a,edge b)
{
return a.dis<b.dis;
}
int pre[100005];
int dsu(int x)
{
if(pre[x]==x) return x;
return pre[x]=dsu(pre[x]);
}
void solve()
{
int n;
cin>>n;
point a[n+5];
for(int i=1;i<=n;i++) 
{
cin>>a[i].x>>a[i].y;
a[i].pos=i;
}
sort(a+1,a+1+n,cmp1); 
vector<edge> v;
for(int i=2;i<=n;i++)
{
edge temp(a[i].pos,a[i-1].pos,a[i].x-a[i-1].x);
v.PB(temp);
}
sort(a+1,a+1+n,cmp2); 
for(int i=2;i<=n;i++)
{
edge temp(a[i].pos,a[i-1].pos,a[i].y-a[i-1].y);
v.PB(temp);
}
sort(v.begin(),v.end(),cmp3);
for(int i=0;i<=n;i++) pre[i]=i;
ll ans=0;
for(int i=0;i<v.size();i++)
{
int t1=v[i].x,t2=v[i].y;
t1=dsu(t1),t2=dsu(t2);//cout<<t1<<t2<<endl;
if(t1==t2) continue;
pre[t1]=t2;
ans+=v[i].dis;
}
cout<<ans<<endl;
} 
int main()
{

int t=1;
//cin>>t; 
for(int i=1;i<=t;i++)
{
// cout<<"Case "<<i<<": ";
solve();
}
}
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace std;

typedef long long ll;

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

string s, t;
cin >> s >> t;

vector<int> a(sz(s), 0);
vector<int> b(sz(t), 0);

for (int i = 0; i < sz(s); i++) {
a[i] = (i ? a[i - 1] : 0) + (s[i] == 'A' ? 2 : 1);
}

for (int i = 0; i < sz(t); i++) {
b[i] = (i ? b[i - 1] : 0) + (t[i] == 'A' ? 2 : 1);
}

a.insert(a.begin(), 0);
b.insert(b.begin(), 0);

int q;
cin >> q;

for (int i = 1; i <= q; i++) {
int l1, r1, l2, r2;
cin >> l1 >> r1 >> l2 >> r2;
int x = a[r1] - a[l1 - 1];
int y = b[r2] - b[l2 - 1];

if ((x - y) % 3 == 0) {
cout << "YES\n";
}
else {
cout << "NO\n";
}
}

return 0;
}

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> pii;
typedef vector<pair<int,int>> vpii;
typedef vector<long long> vl;

int main(){
int N;
ll T;
cin >> N >> T;
vl t(N);
ll sum=0;
for(int i=0; i<N; i++){
cin >> t[i];
}
ll prevt=0;
for(int i=1; i<N; i++){
sum=sum+min(t[i]-prevt,T);
prevt=t[i];
}
cout << sum+T << endl;
}
#include <bits/stdc++.h>

#define ll long long
#define map unordered_map
#define set unordered_set
#define l_l pair<ll, ll>
#define P pair<ll, ll>
#define vll vector<ll>
#define mll map<ll, ll>
#define mp make_pair
#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)
#define reps(i, n) for (int i = 1, i##_len = (n); i <= i##_len; ++i)
#define rev(i, n) for (int i = ((int)(n)-1); i >= 0; --i)
#define revs(i, n) for (int i = ((int)(n)); i > 0; --i)

using namespace std;

const ll MOD = 1000000007LL;
const ll INF = (1LL << 60LL);

// template <class T> void plus_mod(T &a, const T &b) {a = (a + b) % MOD;}

ll grid[100][100];

int main() {
ll H = 100;
ll W = 100;

ll A, B;
scanf("%lld %lld", &A, &B);

rep(y, H / 2) {
rep(x, W) { grid[y][x] = 1; }
}

ll y = 0;
ll x = 0;
rep(i, A - 1) {
grid[y][x] = 0;
x += 2;
if (x >= W) {
y += 2;
x = (y % 2 == 0) ? 0 : 1;
}
}

y = H / 2 + 1;
x = 0;
rep(i, B - 1) {
grid[y][x] = 1;
x += 2;
if (x >= W) {
y += 2;
x = (y % 2 == 0) ? 0 : 1;
}
}

cout << (H) << " " << (W) << endl;

rep(y, H) {
rep(x, W) {
char ch = grid[y][x] == 0 ? '.' : '#';
cout << (ch);
}
cout << ("") << endl;
}
}

#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

typedef long long ll;
typedef long double ld;
typedef std::pair<int, int> pii;
typedef std::pair<int, ll> pil;
typedef std::pair<ll, int> pli;
typedef std::pair<ll, ll> pll;
typedef std::pair<int, ld> pid;
typedef std::pair<ll, ld> pld;
typedef std::pair<int, std::string> pis;
typedef std::pair<ll, std::string> pls;
typedef std::vector<int> vi;
typedef std::vector<vi> vvi;
typedef std::vector<vvi> vvvi;
typedef std::vector<vvvi> vvvvi;
typedef std::vector<ll> vl;
typedef std::vector<vl> vvl;
typedef std::vector<vvl> vvvl;
typedef std::vector<vvvl> vvvvl;
typedef std::vector<ld> vd;
typedef std::vector<vd> vvd;
typedef std::vector<std::string> vs;
#define sz(a) (int)(a).size()
#define rep(i,n) for(auto i=0; i<n; ++i)
#define repm(i,s,n) for(auto i=s; i<n; ++i)
#define repd(i,n) for(auto i=n-1; i>=0; --i)
#define repdm(i,e,n) for(auto i=n-1; i>=e; --i)
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()

constexpr int INF = std::numeric_limits<int>::max() >> 1;
constexpr long long INF_LL = std::numeric_limits<long long>::max() >> 1LL;
constexpr long long MOD1 = 1000000007;
constexpr long long MOD9 = 998244353;
using mint1 = atcoder::modint1000000007;
using mint9 = atcoder::modint998244353;
using vm1 = std::vector<mint1>;
using vvm1 = std::vector<vm1>;
using vvvm1 = std::vector<vvm1>;
using vvvvm1 = std::vector<vvvm1>;
using vm9 = std::vector<mint9>;
using vvm9 = std::vector<vm9>;
using vvvm9 = std::vector<vvm9>;
using vvvvm9 = std::vector<vvvm9>;

template <class T> inline bool chmax(T& a, T b, int eq = 0) { if (a < b || (a == b && eq)) { a = b; return 1; } return 0; }
template <class T> inline bool chmin(T& a, T b, int eq = 0) { if (a > b || (a == b && eq)) { a = b; return 1; } return 0; }

template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::istream& operator>>(std::istream& is, mint& x) noexcept {long long v = 0; std::cin >> v; x = v; return is;}
template <class mint, internal::is_modint_t<mint>* = nullptr> constexpr std::ostream& operator<<(std::ostream& os, const mint& x) noexcept {os << x.val(); return os;}
inline void __n() { std::cout << "\n"; }
template <class T> inline void __(const T a) { std::cout << a; }
template <class T> inline void __l(const T a) { __(a); __n(); }
template <class T> inline void __s(const T a) { __(a); __(' '); }
template <class T1, class T2> inline void __l(const std::pair<T1, T2> a) { __s(a.first); __l(a.second); }
template <class T1, class T2> inline void __s(const std::pair<T1, T2> a) { __s(a.first); __s(a.second); }
template <class T> inline void __v(const std::vector<T> v) { for(auto a : v) __(a); }
template <class T> inline void __vl(const std::vector<T> v) { for(auto a : v) __l(a); }
template <class T> inline void __vs(const std::vector<T> v) { for(auto a : v) __s(a); __n(); }
template <class T> inline void __vvl(const std::vector<std::vector<T>> v) { for(auto a : v) { __v(a); __n(); } }
template <class T> inline void __vvs(const std::vector<std::vector<T>> v) { for(auto a : v) { __vs(a); } }
inline void __ynl(const bool b) {__l(b ? "yes" : "no");}
inline void __yns(const bool b) {__l(b ? "Yes" : "No");}
inline void __ynu(const bool b) {__l(b ? "YES" : "NO");}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

void solve() {


const int N = 100;
int A, B; cin >> A >> B; A--; B--;

vvi ans(N, vi(N));
rep(i, N/2) rep(j, N) ans[i][j] = 1;

int h = 0, w = 0;
while(A > 0) {
if (w >= N) w = 2 * (++h % 2);
ans[h][w] = 0; w += 4;
A--;
}

h = N-1; w = 2;
while (B > 0) {
if (w >= N) w = 2 * (--h % 2);
ans[h][w] = 1; w += 4;
B--;
}

__s(N); __l(N);
rep(i, N) {
rep(j, N) __(ans[i][j] ? '#' : '.');
__n();
}







}

//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *//

int main() {

std::ifstream in("input.txt");
std::cin.rdbuf(in.rdbuf());

std::cin.tie(nullptr);
std::cout.tie(nullptr);
std::ios::sync_with_stdio(false);

solve();
std::cout << std::flush;

return 0;
}

//
// Created by whq on 2022/1/11.
//

#include <bits/stdc++.h>

#define uset unordered_set
#define umap unordered_map
#define debug cout<<"ok"<<endl
#define ll long long
#define endl '\n'
#define ii pair<ll, ll>
#define fi first
#define se second
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvl vector<vector<ll>>
#define vl vector<ll>
#define mod 1000000007
#define inf 0x3f3f3f3f
#define For(i, n) for (int i = 0; i < n; i++)
#define forn(i, a, b) for(int i=a;i<=b;i++)
#define rep(i, n) for(int i=1;i<=n;i++)
#define pb(a) push_back(a)
#define all(a) a.begin(),a.end()
#define lowbit(x) (x&(-x))
#define fr(x) freopen(x,"r",stdin)
#define fw(x) freopen(x,"w",stdout)
using namespace std;

class A {
public:
int solve() {
string s, t;
cin >> s >> t;
int q;
cin >> q;
int n = s.size(), m = t.size();
vl ss(n + 1, 0), tt(m + 1, 0);
for (int i = 1; i <= n; i++) {
ss[i] += ss[i - 1];
if (s[i - 1] == 'A') ss[i] += 1;
else ss[i] -= 1;
}
for (int i = 1; i <= m; i++) {
tt[i] += tt[i - 1];
if (t[i - 1] == 'A') tt[i] += 1;
else tt[i] -= 1;
}
while (q--) {
int a, b, c, d;
cin >> a >> b >> c >> d;
ll cur_s = ss[b] - ss[a - 1], cur_t = tt[d] - tt[c - 1];
cur_s%=3;
cur_t%=3;
if(cur_s<0) cur_s+=3;
if(cur_t<0) cur_t+=3;
//cout<<cur_s<<' '<<cur_t<<endl;
if (abs(cur_s % 3) == abs(cur_t % 3)) cout << "YES" << endl;
else cout << "NO" << endl;
}
return 0;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
A ans;
ans.solve();
return 0;
}
// ====================================================================================================================
// C++ includes used for precompiling -*- C++ -*-

// Copyright (C) 2003-2013 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file stdc++.h
*  This is an implementation file for a precompiled header.
*/

// 17.4.1.2 Headers

// C
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif

// ここより↑は触らない(#include <bits/stdc++.h>の部分)
// ====================================================================================================================
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<int, P> P1;
typedef pair<P, P> P2;
#define pu push
#define pb push_back
#define mp make_pair
#define eps 1e-7
#define INF 1000000000
#define mod 1000000007
#define fi first
#define sc second
#define rep(i,x) for(int i=0;i<x;i++)
#define repn(i,x) for(int i=1;i<=x;i++)
#define SORT(x) sort(x.begin(),x.end())
#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())
#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())
#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())

int main() {
ll N, T;
cin >> N >> T;
vector<ll> lst(N);
for (ll i = 0; i < N; i++) {
cin >> lst.at(i);
}
ll ans = 0;

for (ll i = 0; i < N - 1; i++) {
ans += min(T, lst[i + 1] - lst[i]);
}
ans += T;

cout << ans << endl;

return(0);
}
#include <bits/stdc++.h>
using namespace std; 

typedef long long ll; 
typedef pair <int, int> ii; 

const ll LINF = (ll) 1e18; 
const int INF = (int) 1e9;

ll ans(ll x) {
return x * x * x; 
}

int main() {
ios::sync_with_stdio(0); 
cin.tie(0); 
ll n, k; 
cin >> n >> k; 

// mk + k / 2 <= n 
// m = [n - k / 2] / k

// n / k

ll res = ans(n / k) + (!(k & 1) && n >= k / 2) * ans((n - k / 2) / k + 1); 

cout << res << '\n'; 
}
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a),i##END=(b);i<=i##END;i++)
#define Rof(i,b,a) for(int i=(b),i##END=(a);i>=i##END;i--)
#define go(u) for(int i=head[u];i;i=nxt[i])
using namespace std;
inline int read(){
int x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
return x*f;
}
const int N=1e6+10,M=1e7+10;
int pr[M],pcnt;bool st[M],d[M],ispr[M];
void init(int n=M-10){
For(i,2,n){
if(!st[i])pr[++pcnt]=i;
for(int j=1;j<=pcnt&&i*pr[j]<=n;j++){
st[i*pr[j]]=1;
if(i%pr[j]==0)break;
}
}
}
int n,a[N],b[N],m,c[N],ans;
int used[N],tag,pre[N];
int head[N],to[N],nxt[N],cnt;
void add(int u,int v){to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;}
bool find(int u){
go(u){
int v=to[i];
if(used[v]!=tag){
used[v]=tag;
if(!pre[v]||find(pre[v]))return pre[v]=u,1;
}
}return 0;
}
void TLE(){while(1)puts("OKOK");}
signed main(){
init();For(i,1,pcnt)ispr[pr[i]]=1;
For(i,1,n=read())d[read()]=1;
For(i,1,M-1)if(d[i]^d[i-1])b[++m]=i;
For(i,2,m)For(j,1,i-1)if(b[i]-b[j]>2&&ispr[b[i]-b[j]]){
add(i,j),add(j,i);
if((b[i]-b[j])%2==0)TLE();
}
for(tag=1;tag<=m;tag++)if(b[tag]&1)find(tag);For(i,1,m)
if(pre[i])assert(!c[pre[i]]&&!c[i]),c[pre[i]]=c[i]=1,ans++;
For(i,2,m)For(j,1,i-1)if(!c[i]&&!c[j]&&!(b[i]-b[j]&1))ans+=2,c[i]=c[j]=2;
int tot=0;For(i,1,m)if(!c[i])c[i]=3,tot++;if(tot)ans+=3;printf("%d\n",ans);
return 0;
}
// 大常数 std，这都能过应该没有正解被卡掉吧（
#include <bits/stdc++.h>

namespace MOD {
const int mod = 1000000007;
inline int add(const int &a, const int &b) { int p = a + b; if(p >= mod) p -= mod; return p; }
inline int sub(const int &a, const int &b) { int p = a - b; if(p < 0) p += mod; return p; }
inline int __mul(const int &a, const int &b) { return 1ll * a * b % mod; }
inline int mul(const int &a, const int &b) { int p = __mul(a, b); if(p < 0) p += mod; return p; }
template<typename T> int qpow(int a, T b) {
int ret = 1;
for (; b; b >>= 1, a = mul(a, a))
if (b & 1)
ret = mul(ret, a);
return ret;
}
}
using namespace MOD;

const int N = 100010;
int top, stk[N];

int main() {
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);

int n, k;
std::string s;
int ans = 0;

std::cin >> n >> k >> s;

const int P = 1000;
std::vector<int> fac(P + 1, 1), ifac(P + 1, 1), S(P + 1, 1), iS(P + 1, 1);
for (int i = 1; i <= P; ++i) {
fac[i] = mul(fac[i - 1], i);
S[i] = mul(S[i - 1], fac[i]);
}

iS[P] = qpow(S[P], mod - 2);
for (int i = P; i >= 1; --i) {
ifac[i] = mul(iS[i], S[i - 1]);
iS[i - 1] = mul(iS[i], fac[i]);
}

std::function<int(int, int)> C = [&] (int fir, int sec) {
return mul(fac[fir], mul(ifac[sec], ifac[fir - sec]));
};

const int MAXN = 80;

std::vector<int> cnt(MAXN);
std::function<bool()> check = [&] () {
int R = cnt[0], B = top - R;
std::vector<int> pos(MAXN), val(MAXN);
std::vector<bool> del(MAXN);

for (int i = 0, j = 0; i < k; ++i) {
if (s[i] == 'r' && B != 0) {
--B;
pos[++j] = i;
val[j] = stk[top - j + 1] - 1;
del[i] = true;
}
}

if (B != 0) {
return false;
}

for (int i = 0; i < k; ++i) {
if (B == top - R) {
break;
}
if (del[i]) {
continue;
}
if (s[i] == 'b' && i > pos[B + 1]) {
++B;
pos[B] = i;
del[i] = true;
}
}

if(B != top - R) {
return false;
}

for (int i = 0; i < k; ++i) {
if (R != 0 && s[i] == 'r' && del[i] == false) {
del[i] = true;
--R;
}
}

if (R != 0) {
return false;
}

for (int i = 0, j = 1; i < k; ++i) {
while (j <= B && val[j] == 0) {
++j;
}
if (del[i] || j > B || i < pos[j]) {
continue;
}
--val[j];
}

for (int i = 1; i <= B; ++i) {
if (val[i] > 0) {
return false;
}
}

return true;
};

std::function<void(int)> dfs = [&] (int sum) {
if ((sum + cnt[0]) * 2 - 1 > n) {
return;
}
if (check()) {
int res = fac[top];

for (int i = 1; i <= top; ++i) {
if (i == 1 || stk[i] != stk[i - 1]) {
res = mul(res, ifac[cnt[stk[i]]]);
}
}

ans = add(ans, mul(res, C(
n + 2 * (top - cnt[0]) + 1,
2 * (sum + top)
)));
}
for (int i = stk[top]; i <= n - sum; ++i) {
stk[++top] = i;
++cnt[i];
dfs(sum + i);
--top;
--cnt[i];
}
};

dfs(0);

std::cout << ans << '\n';

return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define int long long int
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define br "\n"

// debugger
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x <<": "; _print(x); cerr << endl;
#define debug2(x, y) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr<<endl;
#define debug3(x, y, z) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr <<" " << #z<<": "; _print(z); cerr<<endl;
#define debug4(x, y, z, a) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr <<" " << #z<<": "; _print(z);  cerr <<" " << #a<<": "; _print(a); cerr<<endl;
#else
#define debug(x)
#define debug2(x, y)
#define debug3(x, y, z)
#define debug4(x, y, z, a)
#endif

void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(double t) {cerr << t;}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V>     void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.first); cerr << ","; _print(p.second); cerr << "}";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}
// debugger ends

void code(int testcaseNumber, int testcases){
/*ummeed hai ki base case ka socha hoga*/
int n, m;
cin>>n>>m;

int totalBoxes = n*m;
int border = 2*n + 2*m - 4;
int down = totalBoxes - border;
cout<<abs(down)<<br;

}

signed main(){
int t=1;

for(int i=0; i<t; i++){
code(i, t-1);
}

return 0;
}



#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, unordered_map<int, int> > mp;
unordered_map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include <bits/stdc++.h>
using namespace std;
const int maxn = 6000000;
const int maxm = 6000000;

struct Edge {
int u, v, w, next;
} e[maxm << 1];

int en = 0, h[maxn];
bool vis[maxn];
int dis[maxn], n, m, s, tot, f[maxn], x[maxn], y[maxn];
map<int, int> mp;
vector<int> vec[maxn], p;

typedef pair<int, int> PII;

priority_queue<PII, vector<PII>, greater<PII> > q;

int find(int x) {
if (f[x] == x) return x;
return f[x] = find(f[x]);
}
void add(int u, int v, int w) {
en++;
e[en].u = u;
e[en].v = v;
e[en].w = w;
e[en].next = h[u];
h[u] = en;
}

signed main() {
cin >> n >> m;
for (int i = 1; i <= m; ++i) {
int w;
scanf("%d %d %d", &x[i], &y[i], &w);
vec[w].push_back(i);
}
tot = n;

for (int i = 1; i <= 1000000; ++i) {
if (vec[i].size() == 0) continue;
p.clear();
for (auto j : vec[i]) {
int u = x[j], v = y[j];
p.push_back(u);
p.push_back(v);
}
int t = p.size();
sort(p.begin(), p.end());

vector<int>::iterator it = unique(p.begin(), p.end());
p.erase(it, p.end());
t = p.size();

for (int j = 0; j < t; ++j) {
f[p[j]] = p[j], mp[p[j]] = 0;
// cout << "p[j]: " << p[j] << endl;
}

for (auto j : vec[i]) {
int u = x[j], v = y[j];
// cout << u << " " << v << endl;
int ru = find(u);
int rv = find(v);
if (ru != rv) f[ru] = rv;
}

for (int j = 0; j < t; ++j) {
int u = p[j];
int ru = find(u);
if (mp[ru] == 0) mp[ru] = ++tot;
add(u, mp[ru], 1);
add(mp[ru], u, 1);
}
}

for (int i = 1; i <= tot; ++i) dis[i] = INT_MAX / 3;

s = 1;
dis[s] = 0;
q.push(make_pair(0, s));

while (!q.empty()) {
int k = q.top().second;
q.pop();

if (!vis[k]) {
vis[k] = true;
for (int i = h[k]; i > 0; i = e[i].next) {
int v = e[i].v;
int w = e[i].w;
if (dis[v] > dis[k] + w) {
dis[v] = dis[k] + w;
q.push(make_pair(dis[v], v));
}
}
}
}

if (dis[n] == INT_MAX / 3) cout << -1;
else
cout << dis[n] / 2;
return 0;
}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<int, int>;

int main() {
string s, t;
int q;
cin >> s >> t >> q;
int n = s.size(), m = t.size();
vector<int> vs(n), vt(m);
for (int i = 0; i < n; i++) vs[i + 1] = s[i] == 'A' ? 1 : -1;
for (int i = 0; i < m; i++) vt[i + 1] = t[i] == 'A' ? 1 : -1;
for (int i = 0; i < n; i++) vs[i + 1] += vs[i];
for (int i = 0; i < m; i++) vt[i + 1] += vt[i];
while(q--) {
int sr, sl, tr, tl;
cin >> sl >> sr >> tl >> tr;
sl--;
tl--;
int a = vs[sr] - vs[sl];
int b = vt[tr] - vt[tl];
a = (a % 3 + 3) % 3;
b = (b % 3 + 3) % 3;
if (a == b) cout << "YES\n";
else cout << "NO\n";
}
}
#include <bits/stdc++.h>
using namespace std;
struct DSU{
vector<int> p;
DSU(){};
void init(int s){p.assign(s + 1, -1);}
DSU(int s){init(s);}
int par(int u){return p[u] < 0 ? u : (p[u] = par(p[u]));}
bool same(int u, int v){return par(u) == par(v);}
int size(int u){return - p[par(u)];}
void merge(int u, int v){
if((u = par(u)) == (v = par(v))) return;
if(p[u] > p[v]) swap(u, v);
p[u] += p[v]; p[v] = u;
}
};
signed main(){
ios::sync_with_stdio(0);
cin.tie(0);
#ifdef DEBUG
freopen("Input.txt", "r", stdin);
#endif
int n, m;
cin >> n >> m;
vector<int> p(n + 1);
for(int i = 1; i <= n; i++){
cin >> p[i];
}
DSU dsu(n);
map<int, set<int>> mp;
for(int i = 0, u, v; i < m; i++){
cin >> u >> v;
dsu.merge(u, v);
}
for(int i = 1; i <= n; i++){
mp[dsu.par(i)].insert(p[i]);
}
int res = 0;
for(int i = 1; i <= n; i++){
set<int> &s = mp[dsu.par(i)];
auto it = s.find(i);
if(it == s.end()){
continue;
} else{
s.erase(it);
res++;
}
}
cout << res;
}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int maxn=1e5+5;
const int mod=1e9+7;
struct edge{
int to,dis,nxt;
}e[maxn<<2];
int head[maxn],cnt=0,n,m;
int ans1[maxn],ans2[maxn];
int vis[maxn],in[maxn];
ll dis1[maxn],dis2[maxn];
queue<int> q;
vector<int> to[maxn];

inline void add(int u,int v,int w){
e[++cnt].to=v;
e[cnt].dis=w;
e[cnt].nxt=head[u];
head[u]=cnt;
}

void spfa(int s,ll *dis){
dis[s]=0;
q.push(s);
vis[s]=1;
while(!q.empty()){
int u=q.front();
q.pop();
vis[u]=0;
for(int i=head[u];i;i=e[i].nxt){
int v=e[i].to,w=e[i].dis;
if(dis[v]>dis[u]+w){
dis[v]=dis[u]+w;
if(!vis[v]){
vis[v]=1;
q.push(v);
}
}
}
}
}

void topo(int s,ll *dis,int *ans){
for(int u=1;u<=n;u++){
to[u].clear();
for(int i=head[u];i;i=e[i].nxt){
int v=e[i].to,w=e[i].dis;
if(dis[v]==dis[u]+w){
to[u].push_back(v);
in[v]++;
}
}
}
ans[s]=1;
q.push(s);
while(!q.empty()){
int u=q.front(),sz=to[u].size();
q.pop();
for(int i=0;i<sz;i++){
if(--in[to[u][i]]==0) q.push(to[u][i]);
ans[to[u][i]]=(ans[to[u][i]]+ans[u])%mod;
}
}
}

int main(){

int s,t;

scanf("%d %d %d %d",&n,&m,&s,&t);
for(int i=1;i<=m;i++){
int u,v,w;
scanf("%d %d %d",&u,&v,&w);
add(u,v,w);
add(v,u,w);
}

memset(dis1,127/3,sizeof(dis1));
spfa(s,dis1);
topo(s,dis1,ans1);
memset(dis2,127/3,sizeof(dis2));
spfa(t,dis2);
topo(t,dis2,ans2);

int ans=1ll*ans1[t]*ans1[t]%mod;

for(int u=1;u<=n;u++){
if(dis1[u]==dis2[u]&&dis2[u]*2==dis1[t]) ans=(ans-1ll*ans1[u]*ans1[u]%mod*ans2[u]%mod*ans2[u]%mod+mod)%mod;
for(int i=head[u];i;i=e[i].nxt){
int v=e[i].to,w=e[i].dis;
if(dis1[u]+w+dis2[v]==dis1[t]&&dis1[u]*2<dis1[t]&&dis2[v]*2<dis1[t]) ans=(ans-1ll*ans1[u]*ans1[u]%mod*ans2[v]%mod*ans2[v]%mod+mod)%mod;
}
}

printf("%d\n",ans);

return 0;
}


#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long 
#define ri int
#define pii pair<int,int>
const ll mod=998244353;
ll add(ll x,ll y){return (x+=y)<mod?x:x-mod;}
ll dec(ll x,ll y){return (x-=y)<0?x+mod:x;}
ll ksm(ll d,ll t,ll res=1){for(;t;t>>=1,d=d*d%mod) if(t&1) res=res*d%mod;return res;}
const int MAXN=1e5+7;
int n,deg[MAXN],del[MAXN],f[MAXN][2],ans;
vector<int> g[MAXN];
char w[MAXN];
int dfs(int u,int fa){
int res=0,cur=(w[u]^(deg[u]&1))*2;
f[u][0]=cur,f[u][1]=0;
for(auto v:g[u]){
if(v==fa||del[v]) continue;
res=max(res,dfs(v,u));
res=max(res,f[u][0]+f[v][1]);
res=max(res,f[u][1]+f[v][0]);
f[u][0]=max(f[u][0],f[v][0]+cur);
f[u][1]=max(f[u][1],f[v][1]+cur);
f[u][1]=max(f[u][1],f[v][0]);
}
res=max(res,f[u][1]);
return res;
}
void prework(){
queue<int> q;
for(ri i=1;i<=n;++i) if(deg[i]==1&&w[i]==0) q.push(i);
while(!q.empty()){
int u=q.front();q.pop();
del[u]=1;
for(auto v:g[u]) if(--deg[v]==1&&w[v]==0) q.push(v);
}
for(ri i=1;i<=n;++i) if(!del[i]){
ans++;
// printf("%d ",i);
}
// puts("");
// printf("%d\n",ans);
ans=ans*2-2;
for(ri i=1;i<=n;++i) if(!del[i]&&(w[i]^(deg[i]&1))) ans++;
int root=0;
for(ri i=1;i<=n;++i) if(!del[i]) root=i;
if(!root) return puts("0"),void();
// printf("%d\n",ans);
printf("%d\n",ans-dfs(root,0));

}
int main(){
// freopen("rand.in","r",stdin);
scanf("%d",&n);
for(ri i=1;i<n;++i){
int u,v;scanf("%d%d",&u,&v);
deg[u]++,deg[v]++;
g[u].push_back(v),g[v].push_back(u);
}
scanf("%s",w+1);for(ri i=1;i<=n;++i) w[i]=(w[i]=='W');
prework();
}
#include <cstdio>

const int maxn  = 2e5 + 10;

int a[maxn];
int main()
{

int n;
scanf("%d", &n);
int blank = n - 1;

for (int i = 0; i < n; i ++) scanf("%d", &a[i]);

for (int i = n - 1; i >= 0; i -= 2) {
printf("%d", a[i]);

if (blank > 0) {
printf(" ");
blank--;
}
}

for (int i = n % 2 ; i < n; i += 2) {
printf("%d", a[i]);

if (blank > 0) {
printf(" ");
blank--;
}
}



return 0;
}

#include <bits/stdc++.h>
#define GRP int T;cin>>T;rep(C,1,T)
#define FAST ios::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rrep(i,a,b) for(int i=a;i>=b;--i)
#define elif else if
#define mem(arr,val) memset(arr,val,sizeof(arr))
typedef long long ll;
typedef unsigned long long ull;

int n,t;
int a[100010];
int mpri,mdel;
int ans;

int main(){
FAST;
cin>>n>>t;
ans=0;
rep(i,1,n){
cin>>a[i];
}
mpri=a[n];
mdel=0;
rrep(i,n-1,1){
mpri=max(mpri,a[i]);
mdel=max(mdel,mpri-a[i]);
}
mpri=a[n];
rrep(i,n-1,1){
mpri=max(mpri,a[i]);
if(mdel==mpri-a[i]){
++ans;
}
}
cout<<ans<<endl;
return 0;
}
#include<iostream>
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
inline int read()
{
int ret,c,f=1;
while (((c=getchar())> '9'||c< '0')&&c!='-');
if (c=='-') f=-1,ret=0;
else ret=c-'0';
while ((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
return ret*f;
}
int n,m,e,dd[1005],ans,head[1005],to[300005],nxt[300005],tot;
void add(int x,int y)
{
to[++tot]=y;
nxt[tot]=head[x];
head[x]=tot;
return;
}
bool book[1005];
bool dfs(int x)
{
for (int i=head[x];i;i=nxt[i])
{
if (book[to[i]]==0)
{
book[to[i]]=1;
if (dd[to[i]]==0)
{
dd[x]=to[i],dd[to[i]]=x;
return 1;
}
else
{
if (dfs(dd[to[i]]))
{
dd[x]=to[i],dd[to[i]]=x;
return 1;
}
}
}
}
return 0;
}
pair<int,int> aa[200],bb[200];
int main()
{
n=read();
for (int i=1;i<=n;i++)
{
aa[i].first=read(),aa[i].second=read();
}
for (int i=1;i<=n;i++)
{
bb[i].first=read(),bb[i].second=read();
for (int j=1;j<=n;j++) if (bb[i].first>aa[j].first&&bb[i].second>aa[j].second) add(i,j+n),add(j+n,i);
}
for (int i=1;i<=n;i++)
{
memset(book,0,sizeof(book));
if (dd[i]==0) ans+=dfs(i);
}
cout<<ans<<endl;
return 0;
}
#include "bits/stdc++.h"
using namespace std;

#define ar array

string f(string s){
vector<char> ss;

auto check = [&](){
int sz = (int)ss.size();
return (ss[sz - 1] == ss[sz - 2] && ss[sz - 2] == ss[sz - 3]);
};

for(int i=0;i<(int)s.size();i++){
while((int)ss.size() >= 3 && check()){
for(int j=0;j<3;j++) ss.pop_back();
}

ss.push_back(s[i]);
}
while((int)ss.size() >= 3 && check()){
for(int j=0;j<3;j++) ss.pop_back();
}

s = "";
for(auto x : ss) s += x;
return s;
}

signed main(){
ios::sync_with_stdio(0); cin.tie(0);

int n; cin>>n;
string s, t; cin>>s>>t;
for(int i=0;i<n;i++){
s[i] -= 'A';
s[i] = (s[i] - i % 3 + 3) % 3;
s[i] += 'A';

t[i] -= 'A';
t[i] = (t[i] - i % 3 + 3) % 3;
t[i] += 'A';
}

//~ cout<<f(s)<<"\n"<<f(t)<<"\n";
if(f(s) == f(t)){
cout<<"YES\n";
} else {
cout<<"NO\n";
}
}


#include "bits/stdc++.h"
using namespace std;
#define int long long int
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define br "\n"

// debugger
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x <<": "; _print(x); cerr << endl;
#define debug2(x, y) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr<<endl;
#define debug3(x, y, z) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr <<" " << #z<<": "; _print(z); cerr<<endl;
#define debug4(x, y, z, a) cerr << #x<<": "; _print(x); cerr <<" " << #y<<": "; _print(y); cerr <<" " << #z<<": "; _print(z);  cerr <<" " << #a<<": "; _print(a); cerr<<endl;
#else
#define debug(x)
#define debug2(x, y)
#define debug3(x, y, z)
#define debug4(x, y, z, a)
#endif

void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(double t) {cerr << t;}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V>     void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.first); cerr << ","; _print(p.second); cerr << "}";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}
// debugger ends

void code(int testcaseNumber, int testcases){
/*ummeed hai ki base case ka socha hoga*/

int n, k;
cin>>n>>k;

map<int, int> mp;
for(int i=0; i<n; i++){
int num;
cin>>num;
mp[num]++;
}

vector<int> cnt;
for(auto &i: mp){
cnt.push_back(i.second);
}


sort(cnt.begin(), cnt.end());
debug(cnt);
int cntSize = cnt.size();

int i = 0, moves = 0;
int newSize = cntSize;
while(newSize > k && i<cntSize){
debug2(newSize, k);
moves += cnt[i];
newSize--;
i++;
}

cout<<moves<<br;


}

signed main(){
int t=1;
for(int i=0; i<t; i++){
code(i, t-1);
}

return 0;
}


//GCC
#pragma G++ optimize(1)
#pragma G++ optimize(2)
#pragma G++ optimize(3)
#pragma G++ optimize("Ofast")
#pragma G++ optimize("inline")
#pragma G++ optimize("-fgcse")
#pragma G++ optimize("-fgcse-lm")
#pragma G++ optimize("-fipa-sra")
#pragma G++ optimize("-ftree-pre")
#pragma G++ optimize("-ftree-vrp")
#pragma G++ optimize("-fpeephole2")
#pragma G++ optimize("-ffast-math")
#pragma G++ optimize("-fsched-spec")
#pragma G++ optimize("unroll-loops")
#pragma G++ optimize("-falign-jumps")
#pragma G++ optimize("-falign-loops")
#pragma G++ optimize("-falign-labels")
#pragma G++ optimize("-fdevirtualize")
#pragma G++ optimize("-fcaller-saves")
#pragma G++ optimize("-fcrossjumping")
#pragma G++ optimize("-fthread-jumps")
#pragma G++ optimize("-funroll-loops")
#pragma G++ optimize("-freorder-blocks")
#pragma G++ optimize("-fschedule-insns")
#pragma G++ optimize("inline-functions")
#pragma G++ optimize("-ftree-tail-merge")
#pragma G++ optimize("-fschedule-insns2")
#pragma G++ optimize("-fstrict-aliasing")
#pragma G++ optimize("-falign-functions")
#pragma G++ optimize("-fcse-follow-jumps")
#pragma G++ optimize("-fsched-interblock")
#pragma G++ optimize("-fpartial-inlining")
#pragma G++ optimize("no-stack-protector")
#pragma G++ optimize("-freorder-functions")
#pragma G++ optimize("-findirect-inlining")
#pragma G++ optimize("-fhoist-adjacent-loads")
#pragma G++ optimize("-frerun-cse-after-loop")
#pragma G++ optimize("inline-small-functions")
#pragma G++ optimize("-finline-small-functions")
#pragma G++ optimize("-ftree-switch-conversion")
#pragma G++ optimize("-foptimize-sibling-calls")
#pragma G++ optimize("-fexpensive-optimizations")
#pragma G++ optimize("inline-functions-called-once")
#pragma G++ optimize("-fdelete-null-pointer-checks")
//Includes
#include<bits/stdc++.h>
using namespace std;
//Defines
#define ten(x) ((x<<1)+(x<<3))
#define Fsize 100000
#if ONLINE_JUDGE
#define getchar() (A==B&&(B=(A=Fin)+fread(Fin,1,Fsize,stdin),A==B)?EOF:*A++)
#define putchar(Ch) (FoutSize<Fsize?Fout[FoutSize++]=Ch:(fwrite(Fout,1,Fsize,stdout),Fout[(FoutSize=0)++]=Ch))
#define inline __inline__ __attribute__((always_inline)) 
#endif
#define register 
//Vars
int Top, FoutSize; char Ch, * A, * B, Fin[Fsize], Fout[Fsize], Stack[Fsize];
//Functions
template<typename T> inline void read(register T& x) { x = 0; while (!isdigit(Ch = getchar())); while (x = ten(x) + (Ch & 15), isdigit(Ch = getchar())); }
inline void read(register char& x) { x = getchar(); }
inline void read(register char* x) { while ((*(x++) = getchar()) != '\n'); *(--x) = '\0'; }
template<typename T, typename... Args>inline void read(register T& x, register Args&... args) { read(x), read(args...); }

template<typename T> inline void write(register T& x) { if (!x)return (void)(putchar('0')); if (x < 0)putchar('-'), x = -x; while (x)Stack[++Top] = (x % 10) ^ 48, x /= 10; while (Top)putchar(Stack[Top--]); }
inline void write(register char& x) { putchar(x); }
inline void write(register char* x) { while (putchar(*(x++)), *x ^ '\0'); }
template<typename T, typename... Args> inline void write(register T x, register Args... args) { write(x), write(args...); }
inline int clear() { fwrite(Fout, 1, FoutSize, stdout); return FoutSize = 0; }

#define Work(p,w,init) \
w[init] = 0;\
q.push(init);\
while (!q.empty()) {\
rint u = q.front();\
q.pop();\
for (auto v : e[u])\
if (w[v] == -1) {\
w[v] = w[u] + 1;\
q.push(v);\
}\
}\
rint p = 0;\
for (rint i = 1; i < n; ++i)\
if (w[p] < w[i])\
p = i;
#define FS(path,w,init,end)\
VI path = init;\
while (path.back() != end) {\
rint u = path.back();\
for (auto v : e[u])\
if (w[v] == w[u] - 1) {\
path.AddPoi(v);\
break;\
}\
}
#define VI vector<int>
#define rint register int
#define All(vi) vi.begin(),vi.end()
#define AddPoi push_back
#define IN(v,e) for(auto v:e)
int main() {
rint n;
read(n);
vector<VI> e(n);
for (rint i = 1,u, v; i < n; ++i)
read(u, v),--u,--v,e[u].AddPoi(v),e[v].AddPoi(u);
queue<rint> q;
VI w1(n, -1), w2(n, -1);
Work(p1, w1, 0);
Work(p2, w2, p1);
FS(path, w2, { p2 }, p1);
auto d = path;
sort(All(d));
VI ans[2];
for (rint k = 0; k < 2; ++k) {
rint c = 0;
IN ( u , path) {
rint c1 = ++c;
IN ( v , e[u])
if (!binary_search(All(d), v))
ans[k].AddPoi(++c);
ans[k].AddPoi(c1);
}
reverse(All(path));
}
VI w = min(ans[0], ans[1]);
if (w.size() != n)
write('-', '1', '\n');
else 
for (auto i : w)
write(i,' ');
return clear();
}
// Author - kasparovian
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
#define frr(i,n) for(int i=0;i<(n);i++)
#define pb push_back
#define eb emplace_back
#define all(v) (v).begin(),(v).end()
#define fr first
#define sc second
#define mk make_pair
#define endl '\n'
#define MOD 1000000007
#define in insert
#define sz(x) (ll)(x).size()
#define mem(a,b) memset(a,b,sizeof(a))
#define int long long
#define runtime() ((double)clock() / CLOCKS_PER_SEC) 
#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
#define TRACE 

#ifdef TRACE 
#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) 
template <typename Arg1> 
void __f(const char* name, Arg1&& arg1){ 
cerr << name << " : " << arg1 << endl; 
} 
template <typename Arg1, typename... Args> 
void __f(const char* names, Arg1&& arg1, Args&&... args){ 
const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << " : " << arg1<<" | ";__f(comma+1, args...); 
} 
#else 
#define trace(...) 
#endif 
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double ld;
typedef pair<ll,ll> pl;
typedef pair<int,int> pi;
typedef pair<int,pi> ppi;
typedef vector<vi> graph;
template<class T> void mxi(T & a, const T & b) { a = max(a, b); }
template<class T> void mni(T & a, const T & b) { a = min(a, b); }
ld EPS=1e-9;
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  
#define SHUF(v) shuffle(all(v), RNG); 
// Use mt19937_64 for 64 bit random numbers. 
bool o(int alp, int n, vi &h, int a, int b){
int sum = 0;
for(int i=0; i<n; i++){
int num = h[i] - alp*b;
if(num <= 0)continue;
sum += (num + a - b - 1)/(a - b);
}
return (sum <= alp);
}
void solve(){ 
int n, a, b; cin>>n>>a>>b;
vector<int> h(n);
for(int i=0; i<n; i++)
cin>>h[i];
int st = 0, ed = 2e9, res, mid;
while(st <= ed){
mid = (st + ed)/2;
if(o(mid, n, h, a, b)){
res = mid; ed = mid - 1;
}
else st = mid + 1;
}
cout<<res<<endl;
}
signed main(){
fast;
int t,tab;
t=1;
tab=t;
while(t--){
//cout<<"Case #"<<(tab-t)<<": ";
solve();
}
cerr<<runtime();
}
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <cmath>
#include <stdio.h>
#include <list>
#include <numeric>
#include <stack>
#include <queue>
#include <tuple>
#include <bitset>
#include <map>
#include <math.h>
//ceil(a/b)   (a + (b - 1))/ b
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); i++)
typedef long long ll;
typedef pair<int, int> P;
const int inf = 1000000007;
const double PI = 3.14159265358979323846;
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};
int ddx[] = {1, -1, 0, 0, 1,1,-1,-1};
int ddy[] = {0, 0, 1, -1, 1,-1,1,-1};

void cans(bool f){
if (f)
cout << "Yes" << endl;
else
cout << "No" << endl;
}

template <typename T>
T gcd(T a, T b) {
if(b == 0) return a;
else return gcd(b,a%b);
}


int sz(string S){
return int(S.size());
}

bool compare1(pair<ll, ll> a, pair<ll, ll> b){
return a.first < b.first;
}

bool compare2(pair<ll, ll> a, pair<ll, ll> b){
return a.second < b.second;
}






int main(){
ll N, T;
cin >> N >> T;
vector<ll> t(N+1);
rep(i,N) {
cin >> t[i];
}
t[N] = 100000000000;
ll ans = 0;
rep(i,N) {
ll diff = t[i+1] - t[i];
ans += min(T,diff);
}
cout << ans << endl;
}

#include<bits/stdc++.h>
using namespace std;
using P=pair<int,int>;
using ll=long long;
template<class T> using heapq = priority_queue<T,vector<T>,greater<T>>;
template<class T> bool chmax(T &a,const T b) {if (a<b) {a=b;return true;} else return false;} 
template<class T> bool chmin(T &a,const T b) {if (a>b) {a=b;return true;} else return false;} 
#define rep(i,n) for(int i=0; i<(n); i++)
#define srep(i,a,b) for(int i=(a); i<(b); i++)
#define rrep(i,n) for(int i=(n)-1;i>=0; i--)
#define srrep(i,a,b) for(int i=(b)-1; i>=(a); i--)
int main(){
int n; cin >> n;
vector<int> R(n),C(n);
rep(i,n) cin >> R[i]; rep(i,n) cin >> C[i];
int q; cin >> q;
char ans[] = ".#";
rep(i,q){
int r,c; cin >> r >> c;
cout << ans[R[r-1]+C[c-1]>=n+1];
}
cout << '\n';
}
#include<bits/stdc++.h>
using namespace std;
const int N=300010;
int n,m,a[N],r[N],mx[N];
int main(){
scanf("%d",&m);int n=(1<<m);
for(int i=0;i<n;i++)scanf("%d",&a[i]);
for(int i=0;i<n;i++)
for(int j=i;j<n;j=(j+1)|i){
r[j]=max(r[j],a[i]+mx[j]);
mx[j]=max(mx[j],a[i]);
}
for(int i=1;i<n;i++)printf("%d\n",r[i]=max(r[i],r[i-1]));
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,x,b[maxn];

void orzck(){
cin >> n;
rep(n){
cin >> x;
b[x]++,b[x+1]++,b[x+2]++;
}
print(*max_element(b,b+maxn));
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=200005,maxm=200005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,m;

void orzck(){
cin >> n >> m;
print(((n-m)*100+m*1900)*pow2(m));
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long

#ifdef NAYAK
#include "D:/dual/c/debug.h"
#else
#define DEBUG(x...);
#endif
#define SPEEDUP ios_base::sync_with_stdio(false);cin.tie(NULL);
#define MOD 1000000007

// int palindrome(int a){

// }
ll pow(ll a,ll b){
ll ans=1;
for(int i=0;i<b;i++){ans*=a;}
return ans;
}
int sum(int a){
int ans=0;
while(a>0){
ans+=a%10;
a/=10;
}
return ans;
}
int fgcd(int a,int b){
if(b>a){int swap=a;a=b;b=swap;}
while(a%b!=0){
int swap=a%b;
a=b;
b=swap;
}
return b;
}
int gcd(int a[],int n){
int ans=a[0];
for(int i=1;i<n;i++)ans=fgcd(ans,a[i]);
return ans;
}
int satisfy(int a){
int fact[1000]={0},len=0,start=2;
while(a>1){
int count=0;
while(a%start==0){
a/=start;
count++;
}
if(count!=0)fact[len++]=count;
start++;
}
// for(int i=0;i<len;i++)cerr<<fact[i]<<" ";cerr<<"\n";
if(gcd(fact,len)!=1)return 1;
else return 0;
}
void sort(vector <string> &a,int n){
int sorted=0;
while(!sorted){
sorted=1;
for(int i=1;i<n;i++){
if(a[i]<a[i-1]){string g=a[i];a[i]=a[i-1];a[i-1]=g;sorted=0;}
}
}
}
int ma(int num){
if(num==0)return -1;
else return 1;
}
char s(int num){
if(num==0)return '-';
return '+';
}
void CLEAN(){
ll x,y;cin>>x>>y;
ll ans=0;
while(x<=y){
ans++;
x*=2;
}
cout<<ans;
}



int32_t main(){

// int T;scanf("%d",&T);while(T--){
CLEAN();
// }

cerr << "-- RUN: " << (float)clock() / CLOCKS_PER_SEC << " s --" << endl;
return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <stack>
#include <math.h>
#include <unordered_map>
#include <unordered_set>
#include <iomanip>
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
template<typename T>T gcd(T a,T b){return b==0?a:gcd(b,a%b);}
template<typename T>T lcm(T a,T b){return a*b/gcd(a,b);}
template<typename T>T max(T a,T b,T c){ return max(a,max(b,c));}
template<typename T>T min(T a,T b,T c){ return min(a,min(b,c));}
template<typename T>
ll quickpow(T a,T b){
ll ans=1;
while(b){
if(b&1) ans=ans*a;
a=a*a,b=b>>1;
}
return ans;
}
template<typename T>
bool is_prime(T x){
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
template<typename T>
int countof1(T n) {
int ret = 0;
while (n) n &= n - 1,ret++;
return ret;
}
template<typename T>
int prime_factor(T n,int x){   //n!(n的阶乘)分解出质因子x的个数
int cnt=0;
while(n){
n=n/x;
cnt+=n;
}
return cnt;
}
template<typename T>
T extgcd(T a,T b,T &x,T &y){     //求解ax+by=gcd(a,b)的x,y
T d=a;                       //当ax+by=k中，k!=gcd(a,b)则x,y无解
if(b!=0){
d= extgcd(b,a%b,y,x);
y-=(a/b)*x;
}else x=1,y=0;
return d;
}
ll qmi(ll a, ll k, int p){
ll res = 1 % p;
while (k) {
if (k & 1) res = res * a % p;
a = a * a % p;
k >>= 1;
}
return res;
}
ll inv(ll a, ll p){  //求a的逆元  除以a等于乘以a的逆元
return qmi(a, p - 2, p);
}
ll C(ll a, ll b, int p){
if (a < b) return 0;
ll x = 1, y = 1;
for (int i = a, j = 1; j <= b; i--, j++) {
x = x * i % p;
y = y * j % p;
}
return x * qmi(y, p - 2, p) % p;
}
ll lucas(ll a, ll b, int p) {
if (a < p && b < p) return C(a, b, p);
return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}






int mod=1e9+7;
int main(){
int n;
cin>>n;
vector<int>cnt(1e5);
for(int i=0;i<n;i++){
int x;
cin>>x;
cnt[--x]++;
}
int ans=0,count=0;
for(int i=0;i<1e5;i++){
if(cnt[i]==0) continue;
ans++;
if(cnt[i]%2==0) count++;
}
if(count%2==1) ans--;
cout<<ans<<endl;
return 0;
}

#ifdef __LOCAL
#define _GLIBCXX_DEBUG

#endif
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using P = pair<int,int>;
using PIL = pair<int,ll>;
using PLI = pair<ll,int>;
using PLL = pair<ll,ll>;
#define all(x) (x).begin(),(x).end()
#define unique_delete(x) (x).erase(unique((x).begin(), (x).end()), (x).end())
using mint = modint1000000007;

template<class T> bool chmin(T &a, T b) {if(a>b){a=b;return 1;}return 0;}
template<class T> bool chmax(T &a, T b) {if(a<b){a=b;return 1;}return 0;}
template<class T> void show_vec(T v) {for (int i=0;i<v.size();i++) cout<<v[i]<<" ";}
template<class T> void show_pair(T p) {cout<<p.first<<" "<<p.second<<endl;}
template<class T> bool judge_digit(T bit,T i) {return (((bit&(1LL<<i))!=0)?1:0);}
#define REP(i,n) for(int i=0;i<int(n);i++)
#define ROUNDUP(a,b) (((a)+(b)-1)/(b))
#define YESNO(T) cout<<(T?"YES":"NO")<<endl
#define yesno(T) cout<<(T?"yes":"no")<<endl
#define YesNo(T) cout<<(T?"Yes":"No")<<endl

const int INFint = 1 << 29;
const ll INF = 1LL << 60;
const ll MOD = 1000000007LL;
const double pi = 3.14159265358979;
const vector<int> h_idx4 = {-1, 0,0,1};
const vector<int> w_idx4 = { 0,-1,1,0};
const vector<int> h_idx8 = {-1,-1,-1, 0,0, 1,1,1};
const vector<int> w_idx8 = {-1, 0, 1,-1,1,-1,0,1};


int main(){
ios::sync_with_stdio(false);
cin.tie(0);
//cout << fixed << setprecision(15);//小数の桁数指定
//COMinit();//二項係数使うときにコメントアウトを外すこと。

ll N;
cin>>N;
vector<ll>A(N);
REP(i,N){cin>>A[i];}
sort(all(A));
unique_delete(A);
ll k=A.size();
if(k%2){
cout<<k<<endl;
}
else{cout<<k-1<<endl;}



}
#include <iostream>
using namespace std;

int main(void)
{
long long X, Y; cin >> X >> Y;

long long cnt = 0;
while (X <= Y) {
X *= 2;
cnt++;
}
cout << cnt;
}
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast,unroll-loops")

#define ll long long
#define int ll
#define ull unsigned ll
#define ld long double
#define rep(a) rep1(i,a)
#define rep1(i,a) rep2(i,0,a)
#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)
#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)
#define chkmin(a,b) (a=min(a,b))
#define chkmax(a,b) (a=max(a,b))
#define all(a) a.begin(),a.end()
#define pii pair<int,int>
#define pb push_back
//#define inf 1010000000
#define inf 4000000000000000000
#define eps 1e-9
#define sz(a) ((int)a.size())
#define pow2(x) (1ll<<(x))
#define ceiling(a,b) (((a)+(b)-1)/(b))
#define print0(a) cout << (a) << ' '
#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())
#ifdef i_am_noob
#define bug(...) cerr << "#" << __LINE__ << ' ' << #__VA_ARGS__ << "- ", _do(__VA_ARGS__)
template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << "\n";}
template<typename T> void _do(T && x) {cerr << x << endl;}
template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << ", "; _do(y...);}
#else
#define bug(...) 777771449
#endif
template<typename T> void print(T && x) {cout << x << "\n";}
template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}

const int Mod=1000000007,Mod2=998244353;
const int MOD=Mod2;
template <int mod>
struct Modint{
int val;
Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}
Modint operator +(const Modint& o) const {
Modint res;
res.val=val+o.val;
if(res.val>=mod) res.val-=mod;
return res;
}
Modint operator +(const int& o) const {return Modint(val+o);}
Modint operator -() const {
Modint res;
res.val=-val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const Modint& o) const {
Modint res;
res.val=val-o.val;
if(res.val<0) res.val+=mod;
return res;
}
Modint operator -(const int& o) const {return Modint(val-o);}
Modint operator *(const Modint& o) const {return Modint(val*o.val);}
Modint operator *(const int& o) const {return Modint(val*(o%mod));}
Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}
Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}
Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}
Modint Pow(int b) const {
Modint tmp(val),ret(1);
while(b){
if(b&1) ret*=tmp;
b>>=1;tmp*=tmp;
}
return ret;
}
Modint Pow(const Modint& a, int b) const {return a.Pow(b);}
inline Modint inv() const {return (*this).Pow(mod-2);}
Modint operator /(const Modint& o) const {return *this*o.inv();}
Modint operator /(const int& o) const {return *this*Modint(o).inv();}
bool operator ==(const Modint& o) const {return val==o.val;}
};
template<int mod>
ostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}
template<int mod>
Modint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}
template<int mod>
Modint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}
template<int mod>
Modint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}
#define modint Modint<MOD>
vector<modint> inv,fac,invfac;
void init_comb(int N){
inv.resize(N),fac.resize(N),invfac.resize(N);
inv[1]=1,fac[0]=1,invfac[0]=1;
rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);
rep2(i,1,N) fac[i]=fac[i-1]*i;
rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];
}
inline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}
inline modint H(int n, int m){return C(n+m-1,n);}
const int maxn=100005,maxm=5005,maxk=7777714;

//i_am_noob
//#define wiwihorz  
int n,a[maxn],res;

void orzck(){
cin >> n;
rep(n) cin >> a[i];
rep(n) a[i]--;
rep(n-1) if(a[i]==i&&a[i+1]==i+1) res++,swap(a[i],a[i+1]);
rep(n) if(a[i]==i) res++;
print(res);
}

signed main(){
ios_base::sync_with_stdio(0),cin.tie(0);
// #ifdef i_am_noob
// freopen("input1.txt","r",stdin);
// freopen("output1.txt","w",stdout);
// freopen("output2.txt","w",stderr);
// #endif
cout << fixed << setprecision(15);
int t;
#ifdef wiwihorz
cin >> t;
#else
t=1;
#endif
while(t--) orzck();
return 0;
}
#ifndef HIDDEN_IN_VISUAL_STUDIO // 折りたたみ用

// 警告の抑制
#define _CRT_SECURE_NO_WARNINGS

// ライブラリの読み込み
#include <bits/stdc++.h>
using namespace std;

// 型名の短縮
using ll = long long; // -2^63 ～ 2^63 = 9 * 10^18（int は -2^31 ～ 2^31 = 2 * 10^9）
using pii = pair<int, int>;	using pll = pair<ll, ll>;	using pil = pair<int, ll>;	using pli = pair<ll, int>;
using vi = vector<int>;		using vvi = vector<vi>;		using vvvi = vector<vvi>;
using vl = vector<ll>;		using vvl = vector<vl>;		using vvvl = vector<vvl>;
using vb = vector<bool>;	using vvb = vector<vb>;		using vvvb = vector<vvb>;
using vc = vector<char>;	using vvc = vector<vc>;		using vvvc = vector<vvc>;
using vd = vector<double>;	using vvd = vector<vd>;		using vvvd = vector<vvd>;
template <class T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;
using Graph = vvi;

// 定数の定義
const double PI = 3.14159265359;
const double DEG = PI / 180.; // θ [deg] = θ * DEG [rad]
const vi dx4 = { 1, 0, -1, 0 }; // 4 近傍（下，右，上，左）
const vi dy4 = { 0, 1, 0, -1 };
const vi dx8 = { 1, 1, 0, -1, -1, -1, 0, 1 }; // 8 近傍
const vi dy8 = { 0, 1, 1, 1, 0, -1, -1, -1 };
const int INF = 1001001001; const ll INFL = 2002002002002002002LL;
const double EPS = 1e-10; // 許容誤差に応じて調整

// 入出力高速化
struct fast_io { fast_io() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } fastIOtmp;

// 汎用マクロの定義
#define all(a) (a).begin(), (a).end()
#define sz(x) ((int)(x).size())
#define distance (int)distance
#define Yes(b) {cout << ((b) ? "Yes" : "No") << endl;}
#define rep(i, n) for(int i = 0, i##_len = int(n); i < i##_len; ++i) // 0 から n-1 まで昇順
#define repi(i, s, t) for(int i = int(s), i##_end = int(t); i <= i##_end; ++i) // s から t まで昇順
#define repir(i, s, t) for(int i = int(s), i##_end = int(t); i >= i##_end; --i) // s から t まで降順
#define repe(v, a) for(const auto& v : (a)) // a の全要素（変更不可能）
#define repea(v, a) for(auto& v : (a)) // a の全要素（変更可能）
#define repb(set, d) for(int set = 0; set < (1 << int(d)); ++set) // d ビット全探索（昇順）
#define repp(a) sort(all(a)); for(bool a##_perm = true; a##_perm; a##_perm = next_permutation(all(a))) // a の順列全て（昇順）
#define repit(it, a) for(auto it = (a).begin(); it != (a).end(); ++it) // イテレータを回す（昇順）
#define repitr(it, a) for(auto it = (a).rbegin(); it != (a).rend(); ++it) // イテレータを回す（降順）
#define smod(n, m) ((((n) % (m)) + (m)) % (m)) // 非負mod
#define uniq(a) {sort(all(a)); (a).erase(unique(all(a)), (a).end());} // 重複除去

// 汎用関数の定義
template <class T> inline ll pow(T n, int k) { ll v = 1; rep(i, k) v *= n; return v; }
template <class T> inline bool chmax(T& M, const T& x) { if (M < x) { M = x; return true; } return false; } // 最大値を更新（更新されたら true を返す）
template <class T> inline bool chmin(T& m, const T& x) { if (m > x) { m = x; return true; } return false; } // 最小値を更新（更新されたら true を返す）

// 演算子オーバーロード
template <class T, class U> inline istream& operator>> (istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }
template <class T, class U> inline ostream& operator<< (ostream& os, const pair<T, U>& p) { os << "(" << p.first << "," << p.second << ")"; return os; }
template <class T, class U, class V> inline istream& operator>> (istream& is, tuple<T, U, V>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t); return is; }
template <class T, class U, class V> inline ostream& operator<< (ostream& os, const tuple<T, U, V>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << ")"; return os; }
template <class T, class U, class V, class W> inline istream& operator>> (istream& is, tuple<T, U, V, W>& t) { is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t); return is; }
template <class T, class U, class V, class W> inline ostream& operator<< (ostream& os, const tuple<T, U, V, W>& t) { os << "(" << get<0>(t) << "," << get<1>(t) << "," << get<2>(t) << "," << get<3>(t) << ")"; return os; }
template <class T> inline istream& operator>> (istream& is, vector<T>& v) { repea(x, v) is >> x; return is; }
template <class T> inline ostream& operator<< (ostream& os, const vector<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const list<T>& v) { repe(x, v) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const set<T, greater<T>>& s) { repe(x, s) os << x << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, const unordered_set<T>& s) { repe(x, s) os << x << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T, class U> inline ostream& operator<< (ostream& os, const unordered_map<T, U>& m) { repe(p, m) os << p << " "; return os; }
template <class T> inline ostream& operator<< (ostream& os, stack<T> s) { while (!s.empty()) { os << s.top() << " "; s.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, queue<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, deque<T> q) { while (!q.empty()) { os << q.front() << " "; q.pop_front(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline ostream& operator<< (ostream& os, priority_queue_rev<T> q) { while (!q.empty()) { os << q.top() << " "; q.pop(); } return os; }
template <class T> inline vector<T>& operator--(vector<T>& v) { rep(_i_, sz(v)) --v[_i_]; return v; }
template <class T> inline vector<T>& operator++(vector<T>& v) { rep(_i_, sz(v)) ++v[_i_]; return v; }

// 手元環境（Visual Studio）
#ifdef _MSC_VER
#define popcount (int)__popcnt // 全ビット中の 1 の個数
#define popcountll (int)__popcnt64
inline int lsb(unsigned int n) { unsigned long i; _BitScanForward(&i, n); return i; } // 最下位ビットの位置（0-indexed）
inline int lsbll(unsigned long long n) { unsigned long i; _BitScanForward64(&i, n); return i; }
inline int msb(unsigned int n) { unsigned long i; _BitScanReverse(&i, n); return i; } // 最上位ビットの位置（0-indexed）
inline int msbll(unsigned long long n) { unsigned long i; _BitScanReverse64(&i, n); return i; }
template <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
#define dump(x) cout << "\033[1;36m" << (x) << "\033[0m" << endl;
#define dumps(x) cout << "\033[1;36m" << (x) << "\033[0m ";
#define dumpel(a) { int _i_ = -1; cout << "\033[1;36m"; repe(x, a) {cout << ++_i_ << ": " << x << endl;} cout << "\033[0m"; }
#define input_from_file(f) ifstream isTMP(f); cin.rdbuf(isTMP.rdbuf());
#define output_to_file(f) ofstream osTMP(f); cout.rdbuf(osTMP.rdbuf());
// 提出用（gcc）
#else
#define popcount (int)__builtin_popcount
#define popcountll (int)__builtin_popcountll
#define lsb __builtin_ctz
#define lsbll __builtin_ctzll
#define msb(n) (31 - __builtin_clz(n))
#define msbll(n) (63 - __builtin_clzll(n))
#define gcd __gcd
#define dump(x)
#define dumps(x)
#define dumpel(v)
#define input_from_file(f)
#define output_to_file(f)
#endif

#endif // 折りたたみ用


//-----------------AtCoder 専用-----------------
#include <atcoder/all>
using namespace atcoder;

//using mint = modint1000000007;
using mint = modint998244353;
//using mint = modint; // mint::set_mod(m);

istream& operator>> (istream& is, mint& x) { ll x_; is >> x_; x = x_; return is; }
ostream& operator<< (ostream& os, const mint& x) { os << x.val(); return os; }
using vm = vector<mint>;	using vvm = vector<vm>;		using vvvm = vector<vvm>;

template <class S, S(*op)(S, S), S(*e)()>ostream& operator<<(ostream& os, segtree<S, op, e> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
template <class S, S(*op)(S, S), S(*e)(), class F, S(*mp)(F, S), F(*cp)(F, F), F(*id)()>ostream& operator<<(ostream& os, lazy_segtree<S, op, e, F, mp, cp, id> seg) { int n = seg.max_right(0, [](S x) {return true; }); rep(i, n) os << seg.get(i) << " "; return os; }
ostream& operator<<(ostream& os, dsu d) { repe(g, d.groups()) { repe(v, g) { os << v << " "; } os << endl; } return os; };
//----------------------------------------------


int main() {
//	input_from_file("input.txt");
//	output_to_file("output.txt");

int n;
cin >> n;

vl a(n);
cin >> a;

vl d(n);
rep(i, n) d[i] = a[i] - (i + 1);

sort(all(d));

ll b = d[n / 2];

ll res = 0;
rep(i, n) {
res += abs(d[i] - b);
}

cout << res << endl;
}

#include <bits/stdc++.h>
#define REP(i,n) for(int i=0;i<n;i++)
using namespace std;
using pii=pair<int,int>;

using Graph = vector<vector<int>>;

template<typename T> class Dinic{
struct edge{
int to;
T cap;
int rev;
};

const T INF = std::numeric_limits<T>::max();
int V;
vector<vector<edge>> network;
vector<int> distance;
vector<int> memo;



void add_edge(int _from, int _to, T _cap){
edge e, e_reverse;
e.to = _to;
e.cap = _cap;
e.rev = network[_to].size();
//network[e.to][e.rev]=eの逆辺
e_reverse.to = _from;
e_reverse.cap = 0;
e_reverse.rev = network[_from].size();
network[_from].push_back(e);
network[_to].push_back(e_reverse);
}

void bfs(int s){
//使える辺を使ってsからの距離をbfs

distance.assign(V, -1);
distance[s] = 0;
queue<int> to_do;
to_do.push(s);
while(!to_do.empty()){
int v = to_do.front();
to_do.pop();
for(auto e : network[v]){
if(e.cap > 0 && distance[e.to] < 0){
distance[e.to] = distance[v] + 1;
to_do.push(e.to);
}
}
}
}

T dfs(int s, int t, T f){
if(s == t) return f;
for(int i = memo[s];i<network[s].size();i++){
memo[s] = i;
//sスタートの頂点はi-1番目までは通れなかったことをメモ
edge e = network[s][i];
if(e.cap>0 && distance[s]<distance[e.to]){
//eが通れるとき
T d = dfs(e.to, t, min(f, e.cap));
//通った辺の流量を更新（e.capを更新してはいけない！network[s][i].capを直接更新せよ．）
if(d > 0){
network[s][i].cap -= d;
network[e.to][e.rev].cap += d;
return d;
}
}
}
return 0;
}



public:

Dinic(vector<vector<pair<int, T>>> &G){
V = G.size();
network.resize(V);
for(int v = 0;v<V;v++){
for(auto p : G[v]){
int _from, _to;
T _cap;
_from = v;
tie(_to, _cap) = p;
add_edge(_from, _to, _cap);
}
}
}

T solve(int s, int t){
T flow = 0;
T f = 0;
//int count = 0;
while(true){
bfs(s);
//cout<<"bfs : "<<count<<endl;
//count++;

//if(count>1000) break;
if(distance[t]<0) return flow;
memo.assign(V, 0);
f = dfs(s, t, INF);
//cout<<f<<endl;
while(f > 0){
flow += f;
f = dfs(s, t, INF);
}
}
return 0;
}

};

int main() {
int N;;
cin>>N;
vector<vector<pair<int, long long>>> G(N+2);
//0がスタート，N+1がゴールの燃やす埋める
long long A;
long long adjustment = 0;
for(int i = 1;i<=N;i++){
cin>>A;
if(A>0){
adjustment += A;
G[0].push_back(make_pair(i, 0));
G[i].push_back(make_pair(N+1, A));
}else{
G[0].push_back(make_pair(i, -A));
G[i].push_back(make_pair(N+1, 0));
}
}

long long INF = std::numeric_limits<long long>::max();
for(int i = 1;i<N;i++){
for(int j = 2;i*j<=N;j++){
G[i].push_back(make_pair(i*j, INF));
}
}

Dinic<long long> Z(G);
cout<<adjustment - Z.solve(0, N+1)<<endl;



return 0;
}
#include<bits/stdc++.h>
using namespace std;
using P=pair<int,int>;
using ll=long long;
template<class T> using heapq = priority_queue<T,vector<T>,greater<T>>;
template<class T> bool chmax(T &a,const T b) {if (a<b) {a=b;return true;} else return false;} 
template<class T> bool chmin(T &a,const T b) {if (a>b) {a=b;return true;} else return false;} 
#define rep(i,n) for(int i=0; i<(n); i++)
#define srep(i,a,b) for(int i=(a); i<(b); i++)
#define rrep(i,n) for(int i=(n)-1;i>=0; i--)
#define srrep(i,a,b) for(int i=(b)-1; i>=(a); i--)
int main(){
int n; cin >> n;
vector<int> R(n),C(n);
rep(i,n) cin >> R[i]; rep(i,n) cin >> C[i];
int q; cin >> q;
string ans(q,'.');
rep(i,q){
int r,c; cin >> r >> c;
if (R[r-1]+C[c-1] >= n+1) ans[i] = '#';
}
cout << ans << endl;
}
#include <bits/stdc++.h>
//#include <atcoder/all>
using namespace std;
#define rep(i,n) for(ll i=0; i<n; i++)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rrep(i,n) for(ll i=n-1; i>=0; i--)
#define fi first
#define se second
#define pcnt __builtin_popcountll
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int,int> Pii;
typedef pair<ll,ll> Pll;
typedef pair<ll,Pll> PlP;
template<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }
template<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}cout << "\n";}
template<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}
string zero_padding(int val, int nf){ ostringstream sout;sout << setfill('0') << setw(nf) << val; return sout.str();};
const ld eps = 1e-10;
ull mo = 1000000007;
ld PI=asin(1)*2;
//using namespace atcoder;

int main(){
ll N;
cin >> N;
vector<ll> s(N);
rep(i,N) cin >> s[i];
vector<vector<ll>> dp(N+1,vector<ll>(10001));
dp[0][0] = 1;
rep(i,N){
ll a = s[i];
rep(j,10001){
if(j+a <= 10000){
dp[i+1][j+a] |= dp[i][j];
}
dp[i+1][j] |= dp[i][j];
}
}
ll ans = 0;
rep(i,10001){
if(i%10 == 0) continue;
if(dp[N][i]) cmax(ans, i);
}
cout << ans << endl;
}

#include <iostream>
using namespace std;
int main(){
int n,t,ans=0,last;
cin>>n>>t>>last;
while(--n){
int tt;
cin>>tt;
ans+=min(tt-last,t);
last=tt;
}
cout<<ans+t;
return 0;
}
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace std;

typedef long long ll;

const int MAXN = (int)1e5 + 5;

vector<int> adj[MAXN], vec;
int ind[MAXN];
bool mark[MAXN];
int n, t, sz;

void dfs(int v, int pr = -1) {
int id = ++sz;

if (adj[v].empty()) {
ind[id] = ++t;
return;
}

int nxt = -1;

for (int to : adj[v]) {
if (to != pr) {
if (mark[to] || nxt == -1) {
nxt = to;
}
}
}

for (int to : adj[v]) {
if (to != pr && to != nxt) {
dfs(to, v);
}
}

ind[id] = ++t;

if (nxt != -1) {
dfs(nxt, v);
}
}

vector<int> get(int v) {
sz = t = 0;
dfs(v);

/*
cout << "start: " << v << endl;
cout << "ind: ";

for (int i = 1; i <= n; i++) {
cout << ind[i] << " \n"[i == n];
}
*/

vector<int> res(n);

for (int i = 1; i <= n; i++) {
res[ind[i] - 1] = i;
}

return res;
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n;

for (int i = 1; i < n; i++) {
int u, v;
cin >> u >> v;
adj[u].pb(v);
adj[v].pb(u);
}

if (n == 2) {
cout << "1 2\n";
return 0;
}

for (int i = 1; i <= n; i++) {
if (sz(adj[i]) > 1) {
mark[i] = 1;
}
}

int A = -1, B = -1;

for (int i = 1; i <= n; i++) {
if (mark[i]) {
int cnt = 0;

for (int to : adj[i]) {
if (mark[to]) {
cnt++;
}
}

if (cnt == 0) {
if (A != -1 || B != -1) {
cout << "-1\n";
return 0;
}

A = B = i;
}

if (cnt == 1) {
if (A == -1) {
A = i;
}
else if (B == -1) {
B = i;
}
else {
cout << "-1\n";
return 0;
}
}
}
}

assert(A != -1 && B != -1);
int stA = A, stB = B;

for (int to : adj[A]) {
if (!mark[to]) {
stA = to;
break;
}
}

for (int to : adj[B]) {
if (!mark[to]) {
stB = to;
break;
}
}

vector<int> ans = min(
get(stA),
get(stB)
);

for (int x : ans) {
cout << x << ' ';
}

return 0;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<int>;
using vvi=vector<vi>;
using pii=pair<int,int>;
const int mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(int i = 0; i < n; i++)
#define rep2(i, a, n)    for(int i = a; i < n; i++)
#define rep3(i, a, n, b) for(int i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
int n;
cin>>n;
pii p={-1,-1};
vi a(n);
rep(i,n){
cin>>a[i];
if(p.first<abs(a[i])) p={abs(a[i]),i};
}
cout<<2*n-1<<endl;
rep(i,n){
if(i==p.second) continue;
cout<<p.second+1<<" "<<i+1<<endl;
}
cout<<p.second+1<<" "<<p.second+1<<endl;
if(a[p.second]>=0) rep(i,n-1) cout<<i+1<<" "<<i+2<<endl;
else for(int i=n-1;i>0;i--) cout<<i+1<<" "<<i<<endl;
}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 5000500;
ll n, l[N], r[N], p[N], t[N];
ll buc[N];
ll lowbit (ll x) {return x & (-x);}
ll que (ll x) {
ll ret = 0;
while (x) {
ret += t[x];
x -= lowbit (x);
}
return ret;
}
void add (ll x, ll v) {
while (x <= n) {
t[x] += v;
x += lowbit (x); 
}
}
int main () {
cin >> n;
for (ll i=1;i<=n;i++) {
cin >> l[i] >> r[i];
}
for (ll i=1;i<=n;i++) {
if (i == n || l[i] != l[i + 1]) {
if (p[i] && p[i] != l[i]) {
puts ("-1");
return 0;
}
p[i] = l[i];
}
if (i == 1 || r[i] != r[i - 1]) {
if (p[i] && p[i] != r[i]) {
puts ("-1");
return 0;
}
p[i] = r[i];
}
}
for (int i=1;i<=n;i++) {
if (! p[i]) continue ;
if (buc[p[i]]) {
puts ("-1");
return 0;
} else {
buc[p[i]] = 1;
}
}
for (ll i=1,ps=1;i<=n;i++) {
if (! p[i]) {
while (buc[ps]) ps ++;
buc[p[i] = ps] = 1;
}
}
for (ll i=n,t=N;i>=1;i--) {
t = min (t, p[i]);
if (t != l[i]) {
puts ("-1");
return 0;
}
}
for (ll i=1,t=0;i<=n;i++) {
t = max (t, p[i]);
if (t != r[i]) {
puts ("-1");
return 0;
}
}
ll Ans = 0;
for (ll i=1;i<=n;i++) {
Ans += i - que (p[i]) - 1;
add (p[i], 1);
}
cout << Ans << endl;
}
#include<set>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define pii pair<int,int>
using namespace std;multiset<int>e;pii a[110],b[110];int n,ans,x;multiset<int>::iterator it;void Solve_Test(){scanf("%d",&n);for(int i=1;i<=n;++i)scanf("%d%d",&a[i].first,&a[i].second);for(int i=1;i<=n;++i)scanf("%d%d",&b[i].first,&b[i].second);sort(a+1,a+n+1),sort(b+1,b+n+1);
for(int i=1,j=1;i<=n||j<=n;)if(i>n||(j<=n&&a[i].first>b[j].first)){if((it=e.lower_bound(x=b[j].second))!=e.begin())e.erase(--it),++ans;++j;}else e.insert(a[i++].second);printf("%d",ans);}const bool BASE=0;int T=1;int main(){if(BASE)cin>>T;while(T--)Solve_Test();return 0;}
#include <bits/stdc++.h>
#define GRP int T;cin>>T;rep(C,1,T)
#define FAST ios::sync_with_stdio(false);cin.tie(0);
using namespace std;
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rrep(i,a,b) for(int i=a;i>=b;--i)
#define elif else if
#define mem(arr,val) memset(arr,val,sizeof(arr))
typedef long long ll;
typedef unsigned long long ull;

char s[100010];
int len,ans;

int main(){
FAST;
cin>>s;
len=strlen(s);
ans=0;
rep(i,1,len-1){
if(s[i-1]!=s[i]){
++ans;
}
}
cout<<ans<<endl;
return 0;
}
#include "bits/stdc++.h"
using namespace std;
#define reps(i, a, b) for(long long (i) = (a); (i) < (b); ++(i))
#define rep(i, n) for(long long (i) = 0; (i) < (n); ++(i))
#define repr(i, b, a) for(long long (i) = (b); (i) >= (a); --(i))
using ll = long long;
using vl = vector<long long>;
using vvl = vector<vector<long long> >;
using pl = pair<long long, long long>;
using tl = tuple<long long, long long, long long>;
using graph = vector<vector<int> >;
struct Edge{
int to;
long long cost;
Edge(int t, long long c) : to(t), cost(c) {}
bool operator<(const Edge &a) const{return cost < a.cost;}
bool operator>(const Edge &a) const{return cost > a.cost;}
};
using wgraph = vector<vector<Edge> >;
constexpr long long INF = numeric_limits<long long>::max() / 8;
constexpr long long dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};
constexpr long long dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T, typename U> inline bool chmax(T &a, const U& b) {if(a<b){a=b;return true;}return false;}
template<typename T, typename U> inline bool chmin(T &a, const U& b) {if(a>b){a=b;return true;}return false;}
template<typename T, typename U> inline T POW(T x, U n) {T ret=1;while(n>0){if(n&1){ret=ret*x;}if(n>>=1){x=x*x;}}return ret;}
template<typename T, typename U> inline T MOD(T n, U m) {if(n >= 0) {return n % m;} else return (n%m + m)%m;}
template<typename T, typename U, typename V> inline T POWMOD(T x, U n, V m){T ret=1;x%=m;while(n>0){if(n&1)ret=ret*x%m;if(n>>=1){x=x*x%m;}}return ret%m;}
template<typename T, typename U> inline T div_ceil(T a, U b){return (a + b - 1) / b;}
template<typename T> inline long long KETA(T n, long long base = 10){long long ret = 0;while(n){ret++; n /= base;} return ret;}
template<typename T> inline long long popcount(T a){return __builtin_popcount(a);}
template<typename T> inline bool contains(T S, T i){return (S & (T(1) << i)) != 0;}
template<typename T> inline void fin(T a){cout << a << '\n'; exit(0);}
template<typename T> inline long long ub_index(vector<T> &v, T a){return upper_bound(v.begin(), v.end(), a) - v.begin();}
template<typename T> inline long long lb_index(vector<T> &v, T a){return lower_bound(v.begin(), v.end(), a) - v.begin();}
template<typename T> inline long long ika_index(vector<T> &v, T a){return upper_bound(v.begin(), v.end(), a) - v.begin() - 1;}
template<typename T> inline long long miman_index(vector<T> &v, T a){return lower_bound(v.begin(), v.end(), a) - v.begin() - 1;}
template<typename T> inline T SUM(const vector<T> &v){return accumulate(v.begin(), v.end(), (T)0);}
template<typename T> inline T MIN(const vector<T> &v){return *min_element(v.begin(), v.end());}
template<typename T> inline T MAX(const vector<T> &v){return *max_element(v.begin(), v.end());}

template<typename T,typename S> ostream&operator<<(ostream&os,const pair<T,S>&p){os<<"("<<p.first<<", "<<p.second<<")";return os;}
template<typename T,typename S> ostream&operator<<(ostream&os,const map<T,S>&ma){for(auto [a,b]:ma){os<<"("<<a<<", "<<b<<")"<<" ";}return os;}
template<typename T> ostream &operator<<(ostream&os,const set<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const multiset<T>&s){os<<"{";for(auto c:s)os<<c<<" ";os<<"}";return os;}
template<typename T> ostream &operator<<(ostream&os,const vector<T>&v){os<<"[";for(int i=0;i<v.size();i++){os<<v[i]<<(i==v.size()-1?"":" ");}os<<"]";return os;}

void dump_func() {cerr << endl;}
template<class Head, class... Tail>
void dump_func(Head&& head, Tail&&... tail){
cerr << head;
if(sizeof...(Tail) == 0) cerr << " ";
else cerr << ", ";
dump_func(std::move(tail)...);
}



//#define ONLINE_JUDGE
#ifdef ONLINE_JUDGE
#define dump(...) true
#else
#define dump(...) cerr << __LINE__ << " : (" << #__VA_ARGS__ << ") = "; \
dump_func(__VA_ARGS__)
#endif

#include "atcoder/lazysegtree"
using namespace atcoder;

namespace arithmetic_add {

const ll LINF = ll(4e18);
const int INF = int(1e9) + 10;

struct S {
ll sum;
int l, r;
};
struct F {
ll a, b;
};
S op(S s, S t) { return {s.sum + t.sum, min(s.l, t.l), max(s.r, t.r)}; }
S e() { return {0, INF, -INF}; }
S mapping(F f, S s) {
return {s.sum + (f.a * (s.l + s.r - 1) + f.b * 2) * (s.r - s.l) / 2, s.l,
s.r};
}
F composition(F f, F g) { return {f.a + g.a, f.b + g.b}; }
F id() { return {0, 0}; }

using lazy_segtype =
atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;

struct lazy_segtree_arithmetic : lazy_segtype {
using lazy_segtype::lazy_segtype;
lazy_segtree_arithmetic(int n) {
vector<S> sv(n);
for (int i = 0; i < n; i++) sv[i] = {0, i, i + 1};
(*this) = lazy_segtree_arithmetic(sv);
}
lazy_segtree_arithmetic(vector<ll> v) {
vector<S> sv(v.size());
for (int i = 0; i < v.size(); i++) sv[i] = {v[i], i, i + 1};
(*this) = lazy_segtree_arithmetic(sv);
}
// f = (a, b)
// [l, r) に b, a+b, 2a+b, ... を加算
void apply(int l, int r, F f) {
lazy_segtype::apply(l, r, {f.a, f.b - f.a * get(l).l});
}
void apply(int p, F f) { apply(p, {f.a, f.b - f.a * get(p).l}); }
};
}  // namespace arithmetic_add

using namespace arithmetic_add;

void solve(){
ll n, m; cin >> n >> m;
vl a(n);
rep(i, n){
cin >> a[i];
a[i]--;
}
ll ans = 0;
lazy_segtree_arithmetic seg(m);
rep(i, n - 1){
if(a[i] < a[i + 1]){
ans += a[i + 1] - a[i];
seg.apply(a[i], a[i + 1], {1, 0});
} else {
ans += m - (a[i] - a[i + 1]);
seg.apply(a[i], m, {1, 0});
seg.apply(0, a[i + 1], {1, m - a[i]});
}
}
ll temp = ans;
rep(i, m){
chmin(ans, temp - seg.get(i).sum);
}
cout << ans << '\n';
}

int main() {
cin.tie(nullptr);
ios::sync_with_stdio(false);
cout << std::fixed << std::setprecision(15);

solve();

return 0;
}

#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
#define ll long long 
#define ri int
#define pii pair<int,int>
const ll mod=998244353;
ll add(ll x,ll y){return (x+=y)<mod?x:x-mod;}
ll dec(ll x,ll y){return (x-=y)<0?x+mod:x;}
ll ksm(ll d,ll t,ll res=1){for(;t;t>>=1,d=d*d%mod) if(t&1) res=res*d%mod;return res;}
const int MAXN=1e5+7;
int n,deg[MAXN],del[MAXN],f[MAXN][2],ans;
vector<int> g[MAXN];
char w[MAXN];
int dfs(int u,int fa){
int res=0,cur=(w[u]^(deg[u]&1))*2;
f[u][0]=cur,f[u][1]=0;
for(auto v:g[u]){
if(v==fa||del[v]) continue;
res=max(res,dfs(v,u));
res=max(res,f[u][0]+f[v][1]);
res=max(res,f[u][1]+f[v][0]);
f[u][0]=max(f[u][0],f[v][0]+cur);
f[u][1]=max(f[u][1],f[v][1]+cur);
f[u][1]=max(f[u][1],f[v][0]);
}
res=max(res,f[u][1]);
return res;
}
void prework(){
queue<int> q;
for(ri i=1;i<=n;++i) if(deg[i]==1&&w[i]==0) q.push(i);
while(!q.empty()){
int u=q.front();q.pop();
del[u]=1;
for(auto v:g[u]) if(--deg[v]==1&&w[v]==0) q.push(v);
}
for(ri i=1;i<=n;++i) if(!del[i]){
ans++;
// printf("%d ",i);
}
// puts("");
// printf("%d\n",ans);
ans=ans*2-2;
for(ri i=1;i<=n;++i) if(!del[i]&&(w[i]^(deg[i]&1))) ans++;
int root=0;
for(ri i=1;i<=n;++i) if(!del[i]) root=i;
if(!root) return puts("0"),void();
// printf("%d\n",ans);
printf("%d\n",ans-dfs(root,0));

}
int main(){
// freopen("rand.in","r",stdin);
scanf("%d",&n);
for(ri i=1;i<n;++i){
int u,v;scanf("%d%d",&u,&v);
deg[u]++,deg[v]++;
g[u].push_back(v),g[v].push_back(u);
}
scanf("%s",w+1);for(ri i=1;i<=n;++i) w[i]=(w[i]=='W');
prework();
}
#include <bits/stdc++.h>
using namespace std;
#define ll long long
struct UF{
UF(ll n):par(n,-1){
}
vector<ll>par;
ll find(ll x){
return (par[x]<0?x:par[x]=find(par[x]));
}
bool unite(ll x,ll y){
x=find(x),y=find(y);
if(x==y)return true;
if(x>y)swap(x,y);
par[x]+=par[y];
par[y]=x;
return false;
}
};
int main(){
ll n,m;cin>>n>>m;ll ans=0;
vector<ll>a(m),b(m),p(n);
for(auto &i:p){cin>>i;i--;}
for(ll i=0;i<m;i++){cin>>a[i]>>b[i];a[i]--,b[i]--;}
UF uf(n);
for(ll i=0;i<m;i++){
uf.unite(a[i],b[i]);
}
//for(auto i:uf.par)cout<<i<<" ";cout<<endl;
for(ll i=0;i<n;i++){
ans+=uf.find(i)==uf.find(p[i]);
}
cout<<ans<<endl;
}

#include <atcoder/modint>
#include <bits/stdc++.h>

#define pb push_back
#define mp make_pair
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

using namespace atcoder;
using namespace std;

typedef long long ll;
typedef modint1000000007 mint;

const int MAXN = (int)2e5 + 5;
const ll LINF = (ll)1e18;

vector<int> adj[MAXN], radj[MAXN], ord;
mint wss[MAXN], we[MAXN];
ll ds[MAXN], de[MAXN];
array<int, 3> e[MAXN];
bool used[MAXN];
int st, en;
int n, m;

void dijkstra(ll dist[], int st) {
fill(dist + 1, dist + n + 1, LINF);
dist[st] = 0;

priority_queue<pair<ll, int>> Q;
Q.push(mp(0, st));

while (!Q.empty()) {
ll cd = -Q.top().first;
int v = Q.top().second;
Q.pop();

if (cd != dist[v]) {
continue;
}

for (int id : adj[v]) {
int to = e[id][0] + e[id][1] - v;
int w = e[id][2];

if (cd + w < dist[to]) {
dist[to] = cd + w;
Q.push(mp(-dist[to], to));
}
}
}
}

void dfs(int v) {
used[v] = 1;

for (int to : adj[v]) {
if (!used[to]) {
dfs(to);
}
}

ord.pb(v);
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);

cin >> n >> m;
cin >> st >> en;

for (int i = 1; i <= m; i++) {
int u, v, d;
cin >> u >> v >> d;
e[i] = {u, v, d};
adj[u].pb(i);
adj[v].pb(i);
}

dijkstra(ds, st);
dijkstra(de, en);
int mm = 0;

for (int i = 1; i <= n; i++) {
adj[i].clear();
}

for (int i = 1; i <= m; i++) {
int u = e[i][0], v = e[i][1], w = e[i][2];

if (ds[u] > ds[v]) {
swap(u, v);
}

if (ds[u] + de[v] + w == ds[en]) {
adj[u].pb(v);
radj[v].pb(u);
e[++mm] = {u, v, w};
}
}

m = mm;

dfs(st);
reverse(all(ord));
wss[st] = 1;

for (int v : ord) {
for (int to : adj[v]) {
wss[to] += wss[v];
}
}

reverse(all(ord));
we[en] = 1;

for (int v : ord) {
for (int to : radj[v]) {
we[to] += we[v];
}
}

mint ans = wss[en] * wss[en];

for (int v = 1; v <= n; v++) {
if (ds[v] == de[v] && ds[v] * 2 == ds[en]) {
ans -= wss[v] * wss[v] * we[v] * we[v];
}
}

for (int i = 1; i <= m; i++) {
int u = e[i][0], v = e[i][1];

if (ds[u] * 2 < ds[en] && de[v] * 2 < de[st]) {
ans -= wss[u] * wss[u] * we[v] * we[v];
}
}

cout << ans.val() << '\n';
return 0;
}

#include <bits/stdc++.h>
using namespace std;
int main(){
string S;
cin >> S;
int N = S.size();
long long ans = 0;
for(int i = 0; i < (1 << (N - 1)); ++i){
string s = {S[0]};
for(int j = 0; j < N - 1; ++j){
if((i >> j) & 1){
ans += stoll(s);
s = S[j + 1];
}else{
s += S[j + 1];
}
}
ans += stoll(s);
}
cout << ans << endl;
}

#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ld=long double;
using vi=vector<ll>;
using vvi=vector<vi>;
using pii=pair<ll,ll>;
const ll mod=1000000007;
const double pi=3.14159265358979;
#define overload4(a, b, c, d, e, ...) e
#define rep1(i, n)       for(ll i = 0; i < n; i++)
#define rep2(i, a, n)    for(ll i = a; i < n; i++)
#define rep3(i, a, n, b) for(ll i = a; i < n; i += b)
#define rep(...) overload4(__VA_ARGS__, rep3, rep2, rep1)(__VA_ARGS__)
#define ALL(a) (a).begin(),(a).end()

int main(){
ll n,m;
cin>>n>>m;
vi x(n),y(m);
rep(i,n) cin>>x[i];
rep(i,m) cin>>y[i];
ll sx=0,sy=0;
rep(i,n-1){
sx+=(x[i+1]-x[i])*(i+1)%mod*(n-i-1)%mod;
sx%=mod;
}
rep(i,m-1){
sy+=(y[i+1]-y[i])*(i+1)%mod*(m-i-1)%mod;
sy%=mod;
}
cout<<sx*sy%mod<<endl;
}
#include <bits/stdc++.h>

using namespace std;

const int N = 410;
typedef long long LL;
unordered_map<LL, map<int, int> > mp;
unordered_map<LL, int> cnt;
int c[N][10], n;
LL a[N][5], b[4] = {1, 1000, 1000 * 1000, 1000 * 1000 * 1000};
vector<int> p;

void del(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] --;
cnt[a[k][i]] --;
}
}

void add(int k) {
for (int i = 1; i <= 4; i ++) {
mp[a[k][i]][k] ++;
cnt[a[k][i]] ++;
}
}

void restore() {
for (unsigned i = 0; i < p.size(); i ++) {
add(p[i]);
}
p.clear();
}

LL solve(int x, int y, int idx, int idy) {
LL res = 1, k;
k = c[x][idx + 1] * b[0] + (c[x][idx + 4] * b[1]) + (c[y][idy + 3] * b[2]) + (c[y][idy + 2] * b[3]);
res = res * cnt[k];
if (res == 0) return 0;
p.push_back(mp[k].begin()->first);
del(p[0]);
k = c[x][idx + 4] * b[0] + (c[x][idx + 3] * b[1]) + (c[y][idy + 4] * b[2]) + (c[y][idy + 3] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[1]);
k = c[x][idx + 3] * b[0] + (c[x][idx + 2] * b[1]) + (c[y][idy + 1] * b[2]) + (c[y][idy + 4] * b[3]);
res = res * cnt[k];
if (res == 0) {
restore();
return 0;
}
p.push_back(mp[k].begin()->first);
del(p[2]);
k = c[x][idx + 2] * b[0] + (c[x][idx + 1] * b[1]) + (c[y][idy + 2] * b[2]) + (c[y][idy + 1] * b[3]);
res = res * cnt[k];
restore();
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
cin >> n;
for (int i = 1; i <= n; i ++) {
for (int j = 1; j <= 4; j ++) {
cin >> c[i][j];
}
for (int j = 1; j <= 4; j ++) {
c[i][j + 4] = c[i][j];
}
for (int j = 1; j <= 4; j ++) {
for (int k = 0; k < 4; k ++) {
a[i][j] += (c[i][j + k] * b[k]);
}
}
add(i);
}
LL ans = 0;
for (int i = 1; i <= n; i ++) {
del(i);
for (int j = 1; j <= n; j ++) {
if (i == j) continue;
del(j);
for (int k = 0; k < 4; k ++) {
ans += solve(i, j, 0, k);
}
add(j);
}
add(i);
}
cout << ans / 6 << endl;
return 0;
}

#include<iostream>
#include<vector>
using namespace std;
using ll = long long;

ll grundy(ll a, int k) {
a -= a % k / (a / k + 1) * (a / k + 1);
if (a < k || a % k == 0) return a / k;
return grundy((ll)a * (k - 1) / k, k);
}

int main() {
int N;
cin >> N;
vector<int> A(N), K(N);
for (int i = 0; i < N; i++) cin >> A[i] >> K[i];

ll xor_ = 0;
for (int i = 0; i < N; i++) {
xor_ ^= grundy(A[i], K[i]);
}

if (xor_ == 0) cout << "Aoki\n";
else cout << "Takahashi\n";
}
#include <bits/stdc++.h>

using namespace std;

const int N = 2e3 + 5;
int n, k;
int f[N][N][2];

inline int calc(int a, int b, int c, int d, int color) {
a = max(a, 1);
b = max(b, 1);
c = min(c, 2 * k);
d = min(d, 2 * k);
if (c < a || d < b) return 0;
return f[c][d][color] - f[c][b - 1][color] - f[a - 1][d][color] + f[a - 1][b - 1][color];
}

int main() {
ios::sync_with_stdio(0);
cin.tie(0);
memset(f, 0, sizeof f);
cin >> n >> k;
int total[2] = {0};
for (int i = 1; i <= n; ++i) {
int x, y;
char c;
cin >> x >> y >> c;
x = x % (2 * k) + 1;
y = y % (2 * k) + 1;
f[x][y][c == 'B']++;
total[c == 'B']++;
}
for (int i = 1; i <= 2 * k; ++i) {
for (int j = 1; j <= 2 * k; ++j) {
for (int c = 0; c < 2; ++c) {
f[i][j][c] += f[i - 1][j][c] + f[i][j - 1][c] - f[i - 1][j - 1][c];
}
}
}
int ans = 0;
for (int i = 1; i <= k; ++i) {
for (int j = 1; j <= k; ++j) {
for (int c = 0; c < 2; ++c) {
int res = 0, rev = c;
for (int u = -1; u <= +1; ++u) {
for (int v = -1; v <= +1; ++v) {
res += calc(i + u * k, j + v * k, i + (u + 1) * k - 1, j + (v + 1) * k - 1, rev);
rev ^= 1;
}
}
ans = max(ans, res);
}
}
}
cout << ans;
return 0;
}

#include<bits/stdc++.h>

using namespace std;

#define intc(n); int n;cin>>n;
#define str_ass(s,t); string s=t;
#define int_ass(n,m); int n=m;
#define strc(s); string s;cin>>s; 

#define qfor(i,n) for(int i=0;i<n;i++)
#define die() for(;;)
#define qw(tc) while(tc--)
#define pb push_back
#define popb pop_back
#define sz(s) s.size()

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pii;
const char X=11;
const char H=101;
const short N=1001;
const int W=10001;
const long double pi=3.141592653589793223846264338327950288419716939937510;
const long double e=2.718281828459045;
const long long inf=99999999999999999;
const short zero=0;

int add(int x,int y){

int g=0;
for(int i=x;i<=y;i++)
g+=i;
return g;

} 

bool prime(long long x){

if(x==0||x==1)
return 0;
else if(x==2)
return 1;
else
for(int i=2;i<x/2;i++)
if(x%1==0)
return 0;
return 1;

}

int main(){

cin.tie(0);
ios::sync_with_stdio(0);

int a[H];
intc(n);
int g=0,ans=0;

qfor(i,n){
cin>>a[i];
g+=a[i];
}

int av=round(double(g)/double(n));
qfor(i,n){
ans+=pow(a[i]-av,2);
}
cout<<ans;

return 0;
}
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a),i##END=(b);i<=i##END;i++)
#define Rof(i,b,a) for(int i=(b),i##END=(a);i>=i##END;i--)
#define go(u) for(int i=head[u];i;i=nxt[i])
using namespace std;
inline int read(){
int x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
return x*f;
}
const int N=1e3+10,M=1e7+10;
int pr[M],pcnt;bool st[M],d[M],ispr[M];
void init(int n=M-10){
For(i,2,n){
if(!st[i])pr[++pcnt]=i;
for(int j=1;j<=pcnt&&i*pr[j]<=n;j++){
st[i*pr[j]]=1;
if(i%pr[j]==0)break;
}
}
}
int n,a[N],b[N],m,c[N],ans;
int used[N],tag,pre[N];
int head[N],to[N*N],nxt[N*N],cnt;
void add(int u,int v){to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;}
bool find(int u){
go(u){
int v=to[i];
if(used[v]!=tag){
used[v]=tag;
if(!pre[v]||find(pre[v]))return pre[v]=u,1;
}
}return 0;
}
void TLE(){while(1)puts("OKOK");}
signed main(){
init();For(i,1,pcnt)ispr[pr[i]]=1;
For(i,1,n=read())d[read()]=1;
For(i,1,M-1)if(d[i]^d[i-1])b[++m]=i;
For(i,2,m)For(j,1,i-1)if(b[i]-b[j]>2&&ispr[b[i]-b[j]])
add(i,j),add(j,i);
for(tag=1;tag<=m;tag++)if(b[tag]&1)find(tag);For(i,1,m)
if(pre[i])assert(!c[pre[i]]&&!c[i]),c[pre[i]]=c[i]=1,ans++;
For(i,2,m)For(j,1,i-1)if(!c[i]&&!c[j]&&!(b[i]-b[j]&1))ans+=2,c[i]=c[j]=2;
int tot=0;For(i,1,m)if(!c[i])c[i]=3,tot++;if(tot)ans+=3;printf("%d\n",ans);
return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>

using namespace std;
using namespace atcoder;

// エイリアス
using  ll = long signed long;
using ull = long unsigned long;
using  ld = long double;
using   P = pair<int, int>;
using llP = pair<ll, ll>;
using DoP = pair<double, double>;
using mint = modint1000000007;
//using mint = modint998244353;

// 汎用マクロ
#define ALL(a) (a).begin(), (a).end()
#define RALL(a) (a).rbegin(), (a).rend()
#define rep(i, n) for (int i = 0; i < n; ++i)
#define FOREACH(i,q) for (auto &i : q)
#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)
#define SZ(x) ((int)(x).size())
#define BIT_COUNT(x) ((int)bitset<20>(x).count())
#define Yes(q) ((q) ? "Yes" : "No")
#define YES(q) ((q) ? "YES" : "NO")
#define Possible(q) ((q) ? "Possible" : "Impossible")
#define POSSIBLE(q) ((q) ? "POSSIBLE" : "IMPOSSIBLE")
template <class T>inline bool chmin(T &a, const T b) {if (a > b) { a = b; return true;} return false;}
template <class T>inline bool chmax(T &a, const T b) {if (a < b) { a = b; return true;} return false;}
template <class T>inline void line_out(const vector<T> vec, int n = 1e9) { rep(i, min(n, (int)vec.size())) { cout << vec[i]; if(i < n-1) cout << " ";} cout << endl;}
const int di[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};
const int mod1000000007 = 1000000007;
const int mod998244353 = 998244353;

/*    スニペット登録済み   */
// sieve エラトステネスの篩（構造体）
// combination 組み合わせ（構造体）
// prime factorization map 素因数分解（関数）
// lcs 最長共通部分文字列（ラムダ式）
// getlin(cin, 変数)で1行入力
// cout << std::fixed << std::setprecision(15) << ans << endl;

int main()
{
int L;
cin >> L;
int n = 1;
int x = 1;
while(x <= L) x*=2, ++n;
--n;

vector<tuple<int, int, int>> ans;
rep(i, n-1) {
ans.emplace_back(n-i-1, n-i, 1<<i);
ans.emplace_back(n-i-1, n-i, 0);
}
rep(i, n-1) {
if(L & 1<<i) {
int cst = L;
cst >>= i+1;
cst <<= i+1;
ans.emplace_back(1, n-i, cst);
}
}

sort(ALL(ans));

cout << n << " " << SZ(ans) << endl;
for(auto x : ans) cout << get<0>(x) << " " << get<1>(x) << " " << get<2>(x) << endl;
}
// ====================================================================================================================
// C++ includes used for precompiling -*- C++ -*-

// Copyright (C) 2003-2013 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file stdc++.h
*  This is an implementation file for a precompiled header.
*/

// 17.4.1.2 Headers

// C
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif

// ここより↑は触らない(#include <bits/stdc++.h>の部分)
// ====================================================================================================================
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<int, P> P1;
typedef pair<P, P> P2;
#define pu push
#define pb push_back
#define mp make_pair
#define eps 1e-7
#define INF 1000000000
#define mod 1000000007
#define fi first
#define sc second
#define rep(i,x) for(int i=0;i<x;i++)
#define repn(i,x) for(int i=1;i<=x;i++)
#define SORT(x) sort(x.begin(),x.end())
#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())
#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())
#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())

int main() {
ll N, T;
cin >> N >> T;
vector<ll> lst(N);
for (ll i = 0; i < N; i++) {
cin >> lst.at(i);
}

ll ans = 0;
ll startT = 0;
ll endT = lst[0] + T;
for (ll i = 1; i < N; i++) {
if (lst[i] < endT) {
ans += lst[i] - startT;
}
else {
ans += T;
}
startT = lst[i];
endT = startT + T;
}
ans += T;

cout << ans << endl;

return(0);
}
#include <bits/stdc++.h>
using namespace std;
#include <atcoder/all>
using namespace atcoder;
using ll = long long;
using vi = vector<int>;
using vvi = vector<vector<int>>;
using pii = pair<int, int>;
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repr(i, n) for (int i = (int)(n - 1); i >= 0; i--)

using mint = modint1000000007;
int main() {
int n;
cin >> n;

vector<mint> dp(n + 1);
dp[0] = 1;
rep(i, n + 1) {
if (i > 1) dp[i] += dp[i - 1];
if (i < n - 2) {
dp[i + 1] += dp[i];
dp[i + 2] -= dp[i];
dp[i + 3] += dp[i];
dp[n] += dp[i] * (i + 1);
dp[n] += dp[i] * (n - 1) * (n - 1);
} else {
if (i == n - 2) dp[n] += dp[i] * n * n;
if (i == n - 1) dp[n] += dp[i] * n;
}
}

cout << dp[n].val() << endl;
return 0;
}

#include <bits/stdc++.h>
#include <atcoder/all>
using namespace std;
using namespace atcoder;
#define NYAN ios::sync_with_stdio(false);cin.tie(nullptr);
typedef long long ll;
typedef long double ld;
#define vb vector<bool>
#define vl vector<long long>
#define pl pair<long long,long long>
#define ALL(x) x.begin(),x.end()
#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)
#define rrep(i, n) for (ll i = n; i >= 0LL; i--)
#define reps(i, s, n) for (ll i = s; i < (ll)(n); i++)
#define sz(x) (ll)x.size()
template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }
long double PI = 3.14159265358979;
#define INF32 2147483647
#define INF64 9223372036854775807
//using mint = modint998244353;
using mint = modint1000000007;
//ll x[]={0,1,0,-1};
//ll y[]={1,0,-1,0};
ll rmax(ll a,ll b){return max(a,b);}
ll rmin(ll a,ll b){return min(a,b);}
ll rzero(){return 0;}
ll rinf(){return INF64;}

signed main(){
NYAN
ll n;
cin>>n;
vl a(n+2);
reps(i,1,n+1)cin>>a[i];
a[0]=0;
a[n+1]=0;
ll sum=0;
rep(i,n+1)sum+=abs(a[i]-a[i+1]);
rep(i,n){
ll ans;
ans=sum-abs(a[i]-a[i+1])-abs(a[i+1]-a[i+2]);
ans+=abs(a[i]-a[i+2]);
cout<<ans<<"\n";
}
return 0;
}

